
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080001c0 <Reset_Handler>:
 80001c0:	b672      	cpsid	i
 80001c2:	4822      	ldr	r0, [pc, #136]	; (800024c <endfiniloop+0x4>)
 80001c4:	f380 8809 	msr	PSP, r0
 80001c8:	2002      	movs	r0, #2
 80001ca:	f380 8814 	msr	CONTROL, r0
 80001ce:	f3bf 8f6f 	isb	sy
 80001d2:	f00b fa05 	bl	800b5e0 <__core_init>
 80001d6:	f005 f8d3 	bl	8005380 <__early_init>
 80001da:	481d      	ldr	r0, [pc, #116]	; (8000250 <endfiniloop+0x8>)
 80001dc:	491d      	ldr	r1, [pc, #116]	; (8000254 <endfiniloop+0xc>)
 80001de:	4a1e      	ldr	r2, [pc, #120]	; (8000258 <endfiniloop+0x10>)

080001e0 <msloop>:
 80001e0:	4291      	cmp	r1, r2
 80001e2:	bf3c      	itt	cc
 80001e4:	f841 0b04 	strcc.w	r0, [r1], #4
 80001e8:	e7fa      	bcc.n	80001e0 <msloop>
 80001ea:	491c      	ldr	r1, [pc, #112]	; (800025c <endfiniloop+0x14>)
 80001ec:	4a17      	ldr	r2, [pc, #92]	; (800024c <endfiniloop+0x4>)

080001ee <psloop>:
 80001ee:	4291      	cmp	r1, r2
 80001f0:	bf3c      	itt	cc
 80001f2:	f841 0b04 	strcc.w	r0, [r1], #4
 80001f6:	e7fa      	bcc.n	80001ee <psloop>
 80001f8:	4919      	ldr	r1, [pc, #100]	; (8000260 <endfiniloop+0x18>)
 80001fa:	4a1a      	ldr	r2, [pc, #104]	; (8000264 <endfiniloop+0x1c>)
 80001fc:	4b1a      	ldr	r3, [pc, #104]	; (8000268 <endfiniloop+0x20>)

080001fe <dloop>:
 80001fe:	429a      	cmp	r2, r3
 8000200:	bf3e      	ittt	cc
 8000202:	f851 0b04 	ldrcc.w	r0, [r1], #4
 8000206:	f842 0b04 	strcc.w	r0, [r2], #4
 800020a:	e7f8      	bcc.n	80001fe <dloop>
 800020c:	2000      	movs	r0, #0
 800020e:	4917      	ldr	r1, [pc, #92]	; (800026c <endfiniloop+0x24>)
 8000210:	4a17      	ldr	r2, [pc, #92]	; (8000270 <endfiniloop+0x28>)

08000212 <bloop>:
 8000212:	4291      	cmp	r1, r2
 8000214:	bf3c      	itt	cc
 8000216:	f841 0b04 	strcc.w	r0, [r1], #4
 800021a:	e7fa      	bcc.n	8000212 <bloop>
 800021c:	f00b f9f8 	bl	800b610 <__init_ram_areas>
 8000220:	f00b f9e6 	bl	800b5f0 <__late_init>
 8000224:	4c13      	ldr	r4, [pc, #76]	; (8000274 <endfiniloop+0x2c>)
 8000226:	4d14      	ldr	r5, [pc, #80]	; (8000278 <endfiniloop+0x30>)

08000228 <initloop>:
 8000228:	42ac      	cmp	r4, r5
 800022a:	da03      	bge.n	8000234 <endinitloop>
 800022c:	f854 1b04 	ldr.w	r1, [r4], #4
 8000230:	4788      	blx	r1
 8000232:	e7f9      	b.n	8000228 <initloop>

08000234 <endinitloop>:
 8000234:	f000 fe04 	bl	8000e40 <main>
 8000238:	4c10      	ldr	r4, [pc, #64]	; (800027c <endfiniloop+0x34>)
 800023a:	4d11      	ldr	r5, [pc, #68]	; (8000280 <endfiniloop+0x38>)

0800023c <finiloop>:
 800023c:	42ac      	cmp	r4, r5
 800023e:	da03      	bge.n	8000248 <endfiniloop>
 8000240:	f854 1b04 	ldr.w	r1, [r4], #4
 8000244:	4788      	blx	r1
 8000246:	e7f9      	b.n	800023c <finiloop>

08000248 <endfiniloop>:
 8000248:	f00b b9da 	b.w	800b600 <__default_exit>
 800024c:	20000800 	.word	0x20000800
 8000250:	55555555 	.word	0x55555555
 8000254:	20000000 	.word	0x20000000
 8000258:	20000400 	.word	0x20000400
 800025c:	20000400 	.word	0x20000400
 8000260:	0800e9c8 	.word	0x0800e9c8
 8000264:	20000800 	.word	0x20000800
 8000268:	20000d2c 	.word	0x20000d2c
 800026c:	20000d30 	.word	0x20000d30
 8000270:	200025d8 	.word	0x200025d8
 8000274:	080001c0 	.word	0x080001c0
 8000278:	080001c0 	.word	0x080001c0
 800027c:	080001c0 	.word	0x080001c0
 8000280:	080001c0 	.word	0x080001c0
	...

08000290 <_port_switch>:
 8000290:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000294:	f8c1 d00c 	str.w	sp, [r1, #12]
 8000298:	68c3      	ldr	r3, [r0, #12]
 800029a:	469d      	mov	sp, r3
 800029c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002a0 <_port_thread_start>:
 80002a0:	f00b fd96 	bl	800bdd0 <_dbg_check_unlock>
 80002a4:	f00a f8d4 	bl	800a450 <_stats_stop_measure_crit_thd>
 80002a8:	2300      	movs	r3, #0
 80002aa:	f383 8811 	msr	BASEPRI, r3
 80002ae:	4628      	mov	r0, r5
 80002b0:	47a0      	blx	r4
 80002b2:	2000      	movs	r0, #0
 80002b4:	f00c fd64 	bl	800cd80 <chThdExit>

080002b8 <_port_switch_from_isr>:
 80002b8:	f00a f8c2 	bl	800a440 <_stats_start_measure_crit_thd>
 80002bc:	f00b fd70 	bl	800bda0 <_dbg_check_lock>
 80002c0:	f00c fa9e 	bl	800c800 <chSchDoReschedule>
 80002c4:	f00b fd84 	bl	800bdd0 <_dbg_check_unlock>
 80002c8:	f00a f8c2 	bl	800a450 <_stats_stop_measure_crit_thd>

080002cc <_port_exit_from_isr>:
 80002cc:	df00      	svc	0
 80002ce:	e7fe      	b.n	80002ce <_port_exit_from_isr+0x2>

080002d0 <bmk13_execute>:
 *
 * <h2>Description</h2>
 * The memory size of the various kernel objects is printed.
 */

static void bmk13_execute(void) {
 80002d0:	b508      	push	{r3, lr}

  test_print("--- System: ");
 80002d2:	482e      	ldr	r0, [pc, #184]	; (800038c <bmk13_execute+0xbc>)
 80002d4:	f005 f98c 	bl	80055f0 <test_print>
  test_printn(sizeof(ch_system_t));
 80002d8:	f44f 60bb 	mov.w	r0, #1496	; 0x5d8
 80002dc:	f005 f940 	bl	8005560 <test_printn>
  test_println(" bytes");
 80002e0:	482b      	ldr	r0, [pc, #172]	; (8000390 <bmk13_execute+0xc0>)
 80002e2:	f005 f9a5 	bl	8005630 <test_println>
  test_print("--- Thread: ");
 80002e6:	482b      	ldr	r0, [pc, #172]	; (8000394 <bmk13_execute+0xc4>)
 80002e8:	f005 f982 	bl	80055f0 <test_print>
  test_printn(sizeof(thread_t));
 80002ec:	2060      	movs	r0, #96	; 0x60
 80002ee:	f005 f937 	bl	8005560 <test_printn>
  test_println(" bytes");
 80002f2:	4827      	ldr	r0, [pc, #156]	; (8000390 <bmk13_execute+0xc0>)
 80002f4:	f005 f99c 	bl	8005630 <test_println>
  test_print("--- Timer : ");
 80002f8:	4827      	ldr	r0, [pc, #156]	; (8000398 <bmk13_execute+0xc8>)
 80002fa:	f005 f979 	bl	80055f0 <test_print>
  test_printn(sizeof(virtual_timer_t));
 80002fe:	2014      	movs	r0, #20
 8000300:	f005 f92e 	bl	8005560 <test_printn>
  test_println(" bytes");
 8000304:	4822      	ldr	r0, [pc, #136]	; (8000390 <bmk13_execute+0xc0>)
 8000306:	f005 f993 	bl	8005630 <test_println>
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
  test_print("--- Semaph: ");
 800030a:	4824      	ldr	r0, [pc, #144]	; (800039c <bmk13_execute+0xcc>)
 800030c:	f005 f970 	bl	80055f0 <test_print>
  test_printn(sizeof(semaphore_t));
 8000310:	200c      	movs	r0, #12
 8000312:	f005 f925 	bl	8005560 <test_printn>
  test_println(" bytes");
 8000316:	481e      	ldr	r0, [pc, #120]	; (8000390 <bmk13_execute+0xc0>)
 8000318:	f005 f98a 	bl	8005630 <test_println>
#endif
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
  test_print("--- EventS: ");
 800031c:	4820      	ldr	r0, [pc, #128]	; (80003a0 <bmk13_execute+0xd0>)
 800031e:	f005 f967 	bl	80055f0 <test_print>
  test_printn(sizeof(event_source_t));
 8000322:	2004      	movs	r0, #4
 8000324:	f005 f91c 	bl	8005560 <test_printn>
  test_println(" bytes");
 8000328:	4819      	ldr	r0, [pc, #100]	; (8000390 <bmk13_execute+0xc0>)
 800032a:	f005 f981 	bl	8005630 <test_println>
  test_print("--- EventL: ");
 800032e:	481d      	ldr	r0, [pc, #116]	; (80003a4 <bmk13_execute+0xd4>)
 8000330:	f005 f95e 	bl	80055f0 <test_print>
  test_printn(sizeof(event_listener_t));
 8000334:	2014      	movs	r0, #20
 8000336:	f005 f913 	bl	8005560 <test_printn>
  test_println(" bytes");
 800033a:	4815      	ldr	r0, [pc, #84]	; (8000390 <bmk13_execute+0xc0>)
 800033c:	f005 f978 	bl	8005630 <test_println>
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  test_print("--- Mutex : ");
 8000340:	4819      	ldr	r0, [pc, #100]	; (80003a8 <bmk13_execute+0xd8>)
 8000342:	f005 f955 	bl	80055f0 <test_print>
  test_printn(sizeof(mutex_t));
 8000346:	2010      	movs	r0, #16
 8000348:	f005 f90a 	bl	8005560 <test_printn>
  test_println(" bytes");
 800034c:	4810      	ldr	r0, [pc, #64]	; (8000390 <bmk13_execute+0xc0>)
 800034e:	f005 f96f 	bl	8005630 <test_println>
#endif
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
  test_print("--- CondV.: ");
 8000352:	4816      	ldr	r0, [pc, #88]	; (80003ac <bmk13_execute+0xdc>)
 8000354:	f005 f94c 	bl	80055f0 <test_print>
  test_printn(sizeof(condition_variable_t));
 8000358:	2008      	movs	r0, #8
 800035a:	f005 f901 	bl	8005560 <test_printn>
  test_println(" bytes");
 800035e:	480c      	ldr	r0, [pc, #48]	; (8000390 <bmk13_execute+0xc0>)
 8000360:	f005 f966 	bl	8005630 <test_println>
#endif
#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)
  test_print("--- Queue : ");
 8000364:	4812      	ldr	r0, [pc, #72]	; (80003b0 <bmk13_execute+0xe0>)
 8000366:	f005 f943 	bl	80055f0 <test_print>
  test_printn(sizeof(io_queue_t));
 800036a:	2024      	movs	r0, #36	; 0x24
 800036c:	f005 f8f8 	bl	8005560 <test_printn>
  test_println(" bytes");
 8000370:	4807      	ldr	r0, [pc, #28]	; (8000390 <bmk13_execute+0xc0>)
 8000372:	f005 f95d 	bl	8005630 <test_println>
#endif
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
  test_print("--- MailB.: ");
 8000376:	480f      	ldr	r0, [pc, #60]	; (80003b4 <bmk13_execute+0xe4>)
 8000378:	f005 f93a 	bl	80055f0 <test_print>
  test_printn(sizeof(mailbox_t));
 800037c:	2028      	movs	r0, #40	; 0x28
 800037e:	f005 f8ef 	bl	8005560 <test_printn>
  test_println(" bytes");
 8000382:	4803      	ldr	r0, [pc, #12]	; (8000390 <bmk13_execute+0xc0>)
 8000384:	f005 f954 	bl	8005630 <test_println>
#endif
}
 8000388:	bd08      	pop	{r3, pc}
 800038a:	bf00      	nop
 800038c:	0800d6d0 	.word	0x0800d6d0
 8000390:	0800d6e0 	.word	0x0800d6e0
 8000394:	0800d6e8 	.word	0x0800d6e8
 8000398:	0800d6f8 	.word	0x0800d6f8
 800039c:	0800d708 	.word	0x0800d708
 80003a0:	0800d718 	.word	0x0800d718
 80003a4:	0800d728 	.word	0x0800d728
 80003a8:	0800d738 	.word	0x0800d738
 80003ac:	0800d748 	.word	0x0800d748
 80003b0:	0800d758 	.word	0x0800d758
 80003b4:	0800d768 	.word	0x0800d768
	...

080003c0 <long_to_string_with_divisor>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 80003c0:	b088      	sub	sp, #32
 80003c2:	9003      	str	r0, [sp, #12]
 80003c4:	9102      	str	r1, [sp, #8]
 80003c6:	9201      	str	r2, [sp, #4]
 80003c8:	9300      	str	r3, [sp, #0]
  int i;
  char *q;
  long l, ll;

  l = num;
 80003ca:	9b02      	ldr	r3, [sp, #8]
 80003cc:	9305      	str	r3, [sp, #20]
  if (divisor == 0) {
 80003ce:	9b00      	ldr	r3, [sp, #0]
 80003d0:	2b00      	cmp	r3, #0
 80003d2:	d102      	bne.n	80003da <long_to_string_with_divisor+0x1a>
    ll = num;
 80003d4:	9b02      	ldr	r3, [sp, #8]
 80003d6:	9304      	str	r3, [sp, #16]
 80003d8:	e001      	b.n	80003de <long_to_string_with_divisor+0x1e>
  } else {
    ll = divisor;
 80003da:	9b00      	ldr	r3, [sp, #0]
 80003dc:	9304      	str	r3, [sp, #16]
  }

  q = p + MAX_FILLER;
 80003de:	9b03      	ldr	r3, [sp, #12]
 80003e0:	330b      	adds	r3, #11
 80003e2:	9306      	str	r3, [sp, #24]
  do {
    i = (int)(l % radix);
 80003e4:	9b05      	ldr	r3, [sp, #20]
 80003e6:	9a01      	ldr	r2, [sp, #4]
 80003e8:	fbb3 f2f2 	udiv	r2, r3, r2
 80003ec:	9901      	ldr	r1, [sp, #4]
 80003ee:	fb01 f202 	mul.w	r2, r1, r2
 80003f2:	1a9b      	subs	r3, r3, r2
 80003f4:	9307      	str	r3, [sp, #28]
    i += '0';
 80003f6:	9b07      	ldr	r3, [sp, #28]
 80003f8:	3330      	adds	r3, #48	; 0x30
 80003fa:	9307      	str	r3, [sp, #28]
    if (i > '9')
 80003fc:	9b07      	ldr	r3, [sp, #28]
 80003fe:	2b39      	cmp	r3, #57	; 0x39
 8000400:	dd02      	ble.n	8000408 <long_to_string_with_divisor+0x48>
      i += 'A' - '0' - 10;
 8000402:	9b07      	ldr	r3, [sp, #28]
 8000404:	3307      	adds	r3, #7
 8000406:	9307      	str	r3, [sp, #28]
    *--q = i;
 8000408:	9b06      	ldr	r3, [sp, #24]
 800040a:	3b01      	subs	r3, #1
 800040c:	9306      	str	r3, [sp, #24]
 800040e:	9b07      	ldr	r3, [sp, #28]
 8000410:	b2da      	uxtb	r2, r3
 8000412:	9b06      	ldr	r3, [sp, #24]
 8000414:	701a      	strb	r2, [r3, #0]
    l /= radix;
 8000416:	9a05      	ldr	r2, [sp, #20]
 8000418:	9b01      	ldr	r3, [sp, #4]
 800041a:	fbb2 f3f3 	udiv	r3, r2, r3
 800041e:	9305      	str	r3, [sp, #20]
  } while ((ll /= radix) != 0);
 8000420:	9a04      	ldr	r2, [sp, #16]
 8000422:	9b01      	ldr	r3, [sp, #4]
 8000424:	fbb2 f3f3 	udiv	r3, r2, r3
 8000428:	9304      	str	r3, [sp, #16]
 800042a:	9b04      	ldr	r3, [sp, #16]
 800042c:	2b00      	cmp	r3, #0
 800042e:	d1d9      	bne.n	80003e4 <long_to_string_with_divisor+0x24>

  i = (int)(p + MAX_FILLER - q);
 8000430:	9b03      	ldr	r3, [sp, #12]
 8000432:	330b      	adds	r3, #11
 8000434:	461a      	mov	r2, r3
 8000436:	9b06      	ldr	r3, [sp, #24]
 8000438:	1ad3      	subs	r3, r2, r3
 800043a:	9307      	str	r3, [sp, #28]
  do
    *p++ = *q++;
 800043c:	9b03      	ldr	r3, [sp, #12]
 800043e:	1c5a      	adds	r2, r3, #1
 8000440:	9203      	str	r2, [sp, #12]
 8000442:	9a06      	ldr	r2, [sp, #24]
 8000444:	1c51      	adds	r1, r2, #1
 8000446:	9106      	str	r1, [sp, #24]
 8000448:	7812      	ldrb	r2, [r2, #0]
 800044a:	701a      	strb	r2, [r3, #0]
  while (--i);
 800044c:	9b07      	ldr	r3, [sp, #28]
 800044e:	3b01      	subs	r3, #1
 8000450:	9307      	str	r3, [sp, #28]
 8000452:	9b07      	ldr	r3, [sp, #28]
 8000454:	2b00      	cmp	r3, #0
 8000456:	d1f1      	bne.n	800043c <long_to_string_with_divisor+0x7c>

  return p;
 8000458:	9b03      	ldr	r3, [sp, #12]
}
 800045a:	4618      	mov	r0, r3
 800045c:	b008      	add	sp, #32
 800045e:	4770      	bx	lr

08000460 <ch_ltoa>:

static char *ch_ltoa(char *p, long num, unsigned radix) {
 8000460:	b500      	push	{lr}
 8000462:	b085      	sub	sp, #20
 8000464:	9003      	str	r0, [sp, #12]
 8000466:	9102      	str	r1, [sp, #8]
 8000468:	9201      	str	r2, [sp, #4]

  return long_to_string_with_divisor(p, num, radix, 0);
 800046a:	9803      	ldr	r0, [sp, #12]
 800046c:	9902      	ldr	r1, [sp, #8]
 800046e:	9a01      	ldr	r2, [sp, #4]
 8000470:	2300      	movs	r3, #0
 8000472:	f7ff ffa5 	bl	80003c0 <long_to_string_with_divisor>
 8000476:	4603      	mov	r3, r0
}
 8000478:	4618      	mov	r0, r3
 800047a:	b005      	add	sp, #20
 800047c:	f85d fb04 	ldr.w	pc, [sp], #4

08000480 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8000480:	b500      	push	{lr}
 8000482:	b091      	sub	sp, #68	; 0x44
 8000484:	9003      	str	r0, [sp, #12]
 8000486:	9102      	str	r1, [sp, #8]
 8000488:	9201      	str	r2, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 800048a:	2300      	movs	r3, #0
 800048c:	9309      	str	r3, [sp, #36]	; 0x24
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 800048e:	9b02      	ldr	r3, [sp, #8]
 8000490:	1c5a      	adds	r2, r3, #1
 8000492:	9202      	str	r2, [sp, #8]
 8000494:	781b      	ldrb	r3, [r3, #0]
 8000496:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    if (c == 0)
 800049a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800049e:	2b00      	cmp	r3, #0
 80004a0:	d101      	bne.n	80004a6 <chvprintf+0x26>
      return n;
 80004a2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80004a4:	e20b      	b.n	80008be <chvprintf+0x43e>
    if (c != '%') {
 80004a6:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80004aa:	2b25      	cmp	r3, #37	; 0x25
 80004ac:	d00b      	beq.n	80004c6 <chvprintf+0x46>
      streamPut(chp, (uint8_t)c);
 80004ae:	9b03      	ldr	r3, [sp, #12]
 80004b0:	681b      	ldr	r3, [r3, #0]
 80004b2:	689b      	ldr	r3, [r3, #8]
 80004b4:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 80004b8:	9803      	ldr	r0, [sp, #12]
 80004ba:	4611      	mov	r1, r2
 80004bc:	4798      	blx	r3
      n++;
 80004be:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80004c0:	3301      	adds	r3, #1
 80004c2:	9309      	str	r3, [sp, #36]	; 0x24
 80004c4:	e7e3      	b.n	800048e <chvprintf+0xe>
      continue;
    }
    p = tmpbuf;
 80004c6:	ab04      	add	r3, sp, #16
 80004c8:	930f      	str	r3, [sp, #60]	; 0x3c
    s = tmpbuf;
 80004ca:	ab04      	add	r3, sp, #16
 80004cc:	930e      	str	r3, [sp, #56]	; 0x38
    left_align = FALSE;
 80004ce:	2300      	movs	r3, #0
 80004d0:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    if (*fmt == '-') {
 80004d4:	9b02      	ldr	r3, [sp, #8]
 80004d6:	781b      	ldrb	r3, [r3, #0]
 80004d8:	2b2d      	cmp	r3, #45	; 0x2d
 80004da:	d105      	bne.n	80004e8 <chvprintf+0x68>
      fmt++;
 80004dc:	9b02      	ldr	r3, [sp, #8]
 80004de:	3301      	adds	r3, #1
 80004e0:	9302      	str	r3, [sp, #8]
      left_align = TRUE;
 80004e2:	2301      	movs	r3, #1
 80004e4:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    }
    filler = ' ';
 80004e8:	2320      	movs	r3, #32
 80004ea:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    if (*fmt == '0') {
 80004ee:	9b02      	ldr	r3, [sp, #8]
 80004f0:	781b      	ldrb	r3, [r3, #0]
 80004f2:	2b30      	cmp	r3, #48	; 0x30
 80004f4:	d105      	bne.n	8000502 <chvprintf+0x82>
      fmt++;
 80004f6:	9b02      	ldr	r3, [sp, #8]
 80004f8:	3301      	adds	r3, #1
 80004fa:	9302      	str	r3, [sp, #8]
      filler = '0';
 80004fc:	2330      	movs	r3, #48	; 0x30
 80004fe:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    }
    width = 0;
 8000502:	2300      	movs	r3, #0
 8000504:	930a      	str	r3, [sp, #40]	; 0x28
    while (TRUE) {
      c = *fmt++;
 8000506:	9b02      	ldr	r3, [sp, #8]
 8000508:	1c5a      	adds	r2, r3, #1
 800050a:	9202      	str	r2, [sp, #8]
 800050c:	781b      	ldrb	r3, [r3, #0]
 800050e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      if (c >= '0' && c <= '9')
 8000512:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000516:	2b2f      	cmp	r3, #47	; 0x2f
 8000518:	d909      	bls.n	800052e <chvprintf+0xae>
 800051a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800051e:	2b39      	cmp	r3, #57	; 0x39
 8000520:	d805      	bhi.n	800052e <chvprintf+0xae>
        c -= '0';
 8000522:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000526:	3b30      	subs	r3, #48	; 0x30
 8000528:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 800052c:	e009      	b.n	8000542 <chvprintf+0xc2>
      else if (c == '*')
 800052e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000532:	2b2a      	cmp	r3, #42	; 0x2a
 8000534:	d110      	bne.n	8000558 <chvprintf+0xd8>
        c = va_arg(ap, int);
 8000536:	9b01      	ldr	r3, [sp, #4]
 8000538:	1d1a      	adds	r2, r3, #4
 800053a:	9201      	str	r2, [sp, #4]
 800053c:	681b      	ldr	r3, [r3, #0]
 800053e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      else
        break;
      width = width * 10 + c;
 8000542:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8000544:	4613      	mov	r3, r2
 8000546:	009b      	lsls	r3, r3, #2
 8000548:	4413      	add	r3, r2
 800054a:	005b      	lsls	r3, r3, #1
 800054c:	461a      	mov	r2, r3
 800054e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000552:	4413      	add	r3, r2
 8000554:	930a      	str	r3, [sp, #40]	; 0x28
 8000556:	e7d6      	b.n	8000506 <chvprintf+0x86>
    }
    precision = 0;
 8000558:	2300      	movs	r3, #0
 800055a:	930b      	str	r3, [sp, #44]	; 0x2c
    if (c == '.') {
 800055c:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000560:	2b2e      	cmp	r3, #46	; 0x2e
 8000562:	d129      	bne.n	80005b8 <chvprintf+0x138>
      while (TRUE) {
        c = *fmt++;
 8000564:	9b02      	ldr	r3, [sp, #8]
 8000566:	1c5a      	adds	r2, r3, #1
 8000568:	9202      	str	r2, [sp, #8]
 800056a:	781b      	ldrb	r3, [r3, #0]
 800056c:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
        if (c >= '0' && c <= '9')
 8000570:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000574:	2b2f      	cmp	r3, #47	; 0x2f
 8000576:	d909      	bls.n	800058c <chvprintf+0x10c>
 8000578:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 800057c:	2b39      	cmp	r3, #57	; 0x39
 800057e:	d805      	bhi.n	800058c <chvprintf+0x10c>
          c -= '0';
 8000580:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000584:	3b30      	subs	r3, #48	; 0x30
 8000586:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 800058a:	e009      	b.n	80005a0 <chvprintf+0x120>
        else if (c == '*')
 800058c:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000590:	2b2a      	cmp	r3, #42	; 0x2a
 8000592:	d111      	bne.n	80005b8 <chvprintf+0x138>
          c = va_arg(ap, int);
 8000594:	9b01      	ldr	r3, [sp, #4]
 8000596:	1d1a      	adds	r2, r3, #4
 8000598:	9201      	str	r2, [sp, #4]
 800059a:	681b      	ldr	r3, [r3, #0]
 800059c:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
        else
          break;
        precision *= 10;
 80005a0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80005a2:	4613      	mov	r3, r2
 80005a4:	009b      	lsls	r3, r3, #2
 80005a6:	4413      	add	r3, r2
 80005a8:	005b      	lsls	r3, r3, #1
 80005aa:	930b      	str	r3, [sp, #44]	; 0x2c
        precision += c;
 80005ac:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80005b0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80005b2:	4413      	add	r3, r2
 80005b4:	930b      	str	r3, [sp, #44]	; 0x2c
 80005b6:	e7d5      	b.n	8000564 <chvprintf+0xe4>
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 80005b8:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80005bc:	2b6c      	cmp	r3, #108	; 0x6c
 80005be:	d003      	beq.n	80005c8 <chvprintf+0x148>
 80005c0:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80005c4:	2b4c      	cmp	r3, #76	; 0x4c
 80005c6:	d10d      	bne.n	80005e4 <chvprintf+0x164>
      is_long = TRUE;
 80005c8:	2301      	movs	r3, #1
 80005ca:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
      if (*fmt)
 80005ce:	9b02      	ldr	r3, [sp, #8]
 80005d0:	781b      	ldrb	r3, [r3, #0]
 80005d2:	2b00      	cmp	r3, #0
 80005d4:	d01a      	beq.n	800060c <chvprintf+0x18c>
        c = *fmt++;
 80005d6:	9b02      	ldr	r3, [sp, #8]
 80005d8:	1c5a      	adds	r2, r3, #1
 80005da:	9202      	str	r2, [sp, #8]
 80005dc:	781b      	ldrb	r3, [r3, #0]
 80005de:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 80005e2:	e014      	b.n	800060e <chvprintf+0x18e>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');
 80005e4:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80005e8:	2b40      	cmp	r3, #64	; 0x40
 80005ea:	d905      	bls.n	80005f8 <chvprintf+0x178>
 80005ec:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80005f0:	2b5a      	cmp	r3, #90	; 0x5a
 80005f2:	d801      	bhi.n	80005f8 <chvprintf+0x178>
 80005f4:	2301      	movs	r3, #1
 80005f6:	e000      	b.n	80005fa <chvprintf+0x17a>
 80005f8:	2300      	movs	r3, #0
 80005fa:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 80005fe:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 8000602:	f003 0301 	and.w	r3, r3, #1
 8000606:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 800060a:	e000      	b.n	800060e <chvprintf+0x18e>
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
 800060c:	bf00      	nop
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 800060e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8000612:	3b44      	subs	r3, #68	; 0x44
 8000614:	2b34      	cmp	r3, #52	; 0x34
 8000616:	f200 80e2 	bhi.w	80007de <chvprintf+0x35e>
 800061a:	a201      	add	r2, pc, #4	; (adr r2, 8000620 <chvprintf+0x1a0>)
 800061c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000620:	08000757 	.word	0x08000757
 8000624:	080007df 	.word	0x080007df
 8000628:	080007df 	.word	0x080007df
 800062c:	080007df 	.word	0x080007df
 8000630:	080007df 	.word	0x080007df
 8000634:	08000757 	.word	0x08000757
 8000638:	080007df 	.word	0x080007df
 800063c:	080007df 	.word	0x080007df
 8000640:	080007df 	.word	0x080007df
 8000644:	080007df 	.word	0x080007df
 8000648:	080007df 	.word	0x080007df
 800064c:	080007a9 	.word	0x080007a9
 8000650:	080007df 	.word	0x080007df
 8000654:	080007df 	.word	0x080007df
 8000658:	080007df 	.word	0x080007df
 800065c:	080007df 	.word	0x080007df
 8000660:	080007df 	.word	0x080007df
 8000664:	080007a1 	.word	0x080007a1
 8000668:	080007df 	.word	0x080007df
 800066c:	080007df 	.word	0x080007df
 8000670:	08000799 	.word	0x08000799
 8000674:	080007df 	.word	0x080007df
 8000678:	080007df 	.word	0x080007df
 800067c:	080007df 	.word	0x080007df
 8000680:	080007df 	.word	0x080007df
 8000684:	080007df 	.word	0x080007df
 8000688:	080007df 	.word	0x080007df
 800068c:	080007df 	.word	0x080007df
 8000690:	080007df 	.word	0x080007df
 8000694:	080007df 	.word	0x080007df
 8000698:	080007df 	.word	0x080007df
 800069c:	080006f5 	.word	0x080006f5
 80006a0:	08000757 	.word	0x08000757
 80006a4:	080007df 	.word	0x080007df
 80006a8:	080007df 	.word	0x080007df
 80006ac:	080007df 	.word	0x080007df
 80006b0:	080007df 	.word	0x080007df
 80006b4:	08000757 	.word	0x08000757
 80006b8:	080007df 	.word	0x080007df
 80006bc:	080007df 	.word	0x080007df
 80006c0:	080007df 	.word	0x080007df
 80006c4:	080007df 	.word	0x080007df
 80006c8:	080007df 	.word	0x080007df
 80006cc:	080007a9 	.word	0x080007a9
 80006d0:	080007df 	.word	0x080007df
 80006d4:	080007df 	.word	0x080007df
 80006d8:	080007df 	.word	0x080007df
 80006dc:	0800070f 	.word	0x0800070f
 80006e0:	080007df 	.word	0x080007df
 80006e4:	080007a1 	.word	0x080007a1
 80006e8:	080007df 	.word	0x080007df
 80006ec:	080007df 	.word	0x080007df
 80006f0:	08000799 	.word	0x08000799
    case 'c':
      filler = ' ';
 80006f4:	2320      	movs	r3, #32
 80006f6:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      *p++ = va_arg(ap, int);
 80006fa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80006fc:	1c5a      	adds	r2, r3, #1
 80006fe:	920f      	str	r2, [sp, #60]	; 0x3c
 8000700:	9a01      	ldr	r2, [sp, #4]
 8000702:	1d11      	adds	r1, r2, #4
 8000704:	9101      	str	r1, [sp, #4]
 8000706:	6812      	ldr	r2, [r2, #0]
 8000708:	b2d2      	uxtb	r2, r2
 800070a:	701a      	strb	r2, [r3, #0]
 800070c:	e06d      	b.n	80007ea <chvprintf+0x36a>
      break;
    case 's':
      filler = ' ';
 800070e:	2320      	movs	r3, #32
 8000710:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      if ((s = va_arg(ap, char *)) == 0)
 8000714:	9b01      	ldr	r3, [sp, #4]
 8000716:	1d1a      	adds	r2, r3, #4
 8000718:	9201      	str	r2, [sp, #4]
 800071a:	681b      	ldr	r3, [r3, #0]
 800071c:	930e      	str	r3, [sp, #56]	; 0x38
 800071e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8000720:	2b00      	cmp	r3, #0
 8000722:	d101      	bne.n	8000728 <chvprintf+0x2a8>
        s = "(null)";
 8000724:	4b68      	ldr	r3, [pc, #416]	; (80008c8 <chvprintf+0x448>)
 8000726:	930e      	str	r3, [sp, #56]	; 0x38
      if (precision == 0)
 8000728:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800072a:	2b00      	cmp	r3, #0
 800072c:	d102      	bne.n	8000734 <chvprintf+0x2b4>
        precision = 32767;
 800072e:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8000732:	930b      	str	r3, [sp, #44]	; 0x2c
      for (p = s; *p && (--precision >= 0); p++)
 8000734:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8000736:	930f      	str	r3, [sp, #60]	; 0x3c
 8000738:	e002      	b.n	8000740 <chvprintf+0x2c0>
 800073a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800073c:	3301      	adds	r3, #1
 800073e:	930f      	str	r3, [sp, #60]	; 0x3c
 8000740:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8000742:	781b      	ldrb	r3, [r3, #0]
 8000744:	2b00      	cmp	r3, #0
 8000746:	d050      	beq.n	80007ea <chvprintf+0x36a>
 8000748:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800074a:	3b01      	subs	r3, #1
 800074c:	930b      	str	r3, [sp, #44]	; 0x2c
 800074e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8000750:	2b00      	cmp	r3, #0
 8000752:	daf2      	bge.n	800073a <chvprintf+0x2ba>
 8000754:	e049      	b.n	80007ea <chvprintf+0x36a>
      break;
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
 8000756:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 800075a:	2b00      	cmp	r3, #0
 800075c:	d005      	beq.n	800076a <chvprintf+0x2ea>
        l = va_arg(ap, long);
 800075e:	9b01      	ldr	r3, [sp, #4]
 8000760:	1d1a      	adds	r2, r3, #4
 8000762:	9201      	str	r2, [sp, #4]
 8000764:	681b      	ldr	r3, [r3, #0]
 8000766:	9307      	str	r3, [sp, #28]
 8000768:	e004      	b.n	8000774 <chvprintf+0x2f4>
      else
        l = va_arg(ap, int);
 800076a:	9b01      	ldr	r3, [sp, #4]
 800076c:	1d1a      	adds	r2, r3, #4
 800076e:	9201      	str	r2, [sp, #4]
 8000770:	681b      	ldr	r3, [r3, #0]
 8000772:	9307      	str	r3, [sp, #28]
      if (l < 0) {
 8000774:	9b07      	ldr	r3, [sp, #28]
 8000776:	2b00      	cmp	r3, #0
 8000778:	da07      	bge.n	800078a <chvprintf+0x30a>
        *p++ = '-';
 800077a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800077c:	1c5a      	adds	r2, r3, #1
 800077e:	920f      	str	r2, [sp, #60]	; 0x3c
 8000780:	222d      	movs	r2, #45	; 0x2d
 8000782:	701a      	strb	r2, [r3, #0]
        l = -l;
 8000784:	9b07      	ldr	r3, [sp, #28]
 8000786:	425b      	negs	r3, r3
 8000788:	9307      	str	r3, [sp, #28]
      }
      p = ch_ltoa(p, l, 10);
 800078a:	980f      	ldr	r0, [sp, #60]	; 0x3c
 800078c:	9907      	ldr	r1, [sp, #28]
 800078e:	220a      	movs	r2, #10
 8000790:	f7ff fe66 	bl	8000460 <ch_ltoa>
 8000794:	900f      	str	r0, [sp, #60]	; 0x3c
 8000796:	e028      	b.n	80007ea <chvprintf+0x36a>
      p = ftoa(p, f, precision);
      break;
#endif
    case 'X':
    case 'x':
      c = 16;
 8000798:	2310      	movs	r3, #16
 800079a:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 800079e:	e006      	b.n	80007ae <chvprintf+0x32e>
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
 80007a0:	230a      	movs	r3, #10
 80007a2:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 80007a6:	e002      	b.n	80007ae <chvprintf+0x32e>
      goto unsigned_common;
    case 'O':
    case 'o':
      c = 8;
 80007a8:	2308      	movs	r3, #8
 80007aa:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
unsigned_common:
      if (is_long)
 80007ae:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 80007b2:	2b00      	cmp	r3, #0
 80007b4:	d005      	beq.n	80007c2 <chvprintf+0x342>
        l = va_arg(ap, unsigned long);
 80007b6:	9b01      	ldr	r3, [sp, #4]
 80007b8:	1d1a      	adds	r2, r3, #4
 80007ba:	9201      	str	r2, [sp, #4]
 80007bc:	681b      	ldr	r3, [r3, #0]
 80007be:	9307      	str	r3, [sp, #28]
 80007c0:	e004      	b.n	80007cc <chvprintf+0x34c>
      else
        l = va_arg(ap, unsigned int);
 80007c2:	9b01      	ldr	r3, [sp, #4]
 80007c4:	1d1a      	adds	r2, r3, #4
 80007c6:	9201      	str	r2, [sp, #4]
 80007c8:	681b      	ldr	r3, [r3, #0]
 80007ca:	9307      	str	r3, [sp, #28]
      p = ch_ltoa(p, l, c);
 80007cc:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80007d0:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80007d2:	9907      	ldr	r1, [sp, #28]
 80007d4:	461a      	mov	r2, r3
 80007d6:	f7ff fe43 	bl	8000460 <ch_ltoa>
 80007da:	900f      	str	r0, [sp, #60]	; 0x3c
 80007dc:	e005      	b.n	80007ea <chvprintf+0x36a>
      break;
    default:
      *p++ = c;
 80007de:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80007e0:	1c5a      	adds	r2, r3, #1
 80007e2:	920f      	str	r2, [sp, #60]	; 0x3c
 80007e4:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 80007e8:	701a      	strb	r2, [r3, #0]
      break;
    }
    i = (int)(p - s);
 80007ea:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80007ec:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80007ee:	1ad3      	subs	r3, r2, r3
 80007f0:	930c      	str	r3, [sp, #48]	; 0x30
    if ((width -= i) < 0)
 80007f2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80007f4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80007f6:	1ad3      	subs	r3, r2, r3
 80007f8:	930a      	str	r3, [sp, #40]	; 0x28
 80007fa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80007fc:	2b00      	cmp	r3, #0
 80007fe:	da01      	bge.n	8000804 <chvprintf+0x384>
      width = 0;
 8000800:	2300      	movs	r3, #0
 8000802:	930a      	str	r3, [sp, #40]	; 0x28
    if (left_align == FALSE)
 8000804:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
 8000808:	f083 0301 	eor.w	r3, r3, #1
 800080c:	b2db      	uxtb	r3, r3
 800080e:	2b00      	cmp	r3, #0
 8000810:	d002      	beq.n	8000818 <chvprintf+0x398>
      width = -width;
 8000812:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000814:	425b      	negs	r3, r3
 8000816:	930a      	str	r3, [sp, #40]	; 0x28
    if (width < 0) {
 8000818:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800081a:	2b00      	cmp	r3, #0
 800081c:	da36      	bge.n	800088c <chvprintf+0x40c>
      if (*s == '-' && filler == '0') {
 800081e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8000820:	781b      	ldrb	r3, [r3, #0]
 8000822:	2b2d      	cmp	r3, #45	; 0x2d
 8000824:	d113      	bne.n	800084e <chvprintf+0x3ce>
 8000826:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
 800082a:	2b30      	cmp	r3, #48	; 0x30
 800082c:	d10f      	bne.n	800084e <chvprintf+0x3ce>
        streamPut(chp, (uint8_t)*s++);
 800082e:	9b03      	ldr	r3, [sp, #12]
 8000830:	681b      	ldr	r3, [r3, #0]
 8000832:	689a      	ldr	r2, [r3, #8]
 8000834:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8000836:	1c59      	adds	r1, r3, #1
 8000838:	910e      	str	r1, [sp, #56]	; 0x38
 800083a:	781b      	ldrb	r3, [r3, #0]
 800083c:	9803      	ldr	r0, [sp, #12]
 800083e:	4619      	mov	r1, r3
 8000840:	4790      	blx	r2
        n++;
 8000842:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000844:	3301      	adds	r3, #1
 8000846:	9309      	str	r3, [sp, #36]	; 0x24
        i--;
 8000848:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800084a:	3b01      	subs	r3, #1
 800084c:	930c      	str	r3, [sp, #48]	; 0x30
      }
      do {
        streamPut(chp, (uint8_t)filler);
 800084e:	9b03      	ldr	r3, [sp, #12]
 8000850:	681b      	ldr	r3, [r3, #0]
 8000852:	689b      	ldr	r3, [r3, #8]
 8000854:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 8000858:	9803      	ldr	r0, [sp, #12]
 800085a:	4611      	mov	r1, r2
 800085c:	4798      	blx	r3
        n++;
 800085e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000860:	3301      	adds	r3, #1
 8000862:	9309      	str	r3, [sp, #36]	; 0x24
      } while (++width != 0);
 8000864:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8000866:	3301      	adds	r3, #1
 8000868:	930a      	str	r3, [sp, #40]	; 0x28
 800086a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800086c:	2b00      	cmp	r3, #0
 800086e:	d1ee      	bne.n	800084e <chvprintf+0x3ce>
 8000870:	e00c      	b.n	800088c <chvprintf+0x40c>
    }
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
 8000872:	9b03      	ldr	r3, [sp, #12]
 8000874:	681b      	ldr	r3, [r3, #0]
 8000876:	689a      	ldr	r2, [r3, #8]
 8000878:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800087a:	1c59      	adds	r1, r3, #1
 800087c:	910e      	str	r1, [sp, #56]	; 0x38
 800087e:	781b      	ldrb	r3, [r3, #0]
 8000880:	9803      	ldr	r0, [sp, #12]
 8000882:	4619      	mov	r1, r3
 8000884:	4790      	blx	r2
      n++;
 8000886:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000888:	3301      	adds	r3, #1
 800088a:	9309      	str	r3, [sp, #36]	; 0x24
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 800088c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800088e:	3b01      	subs	r3, #1
 8000890:	930c      	str	r3, [sp, #48]	; 0x30
 8000892:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8000894:	2b00      	cmp	r3, #0
 8000896:	daec      	bge.n	8000872 <chvprintf+0x3f2>
 8000898:	e00d      	b.n	80008b6 <chvprintf+0x436>
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
      streamPut(chp, (uint8_t)filler);
 800089a:	9b03      	ldr	r3, [sp, #12]
 800089c:	681b      	ldr	r3, [r3, #0]
 800089e:	689b      	ldr	r3, [r3, #8]
 80008a0:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 80008a4:	9803      	ldr	r0, [sp, #12]
 80008a6:	4611      	mov	r1, r2
 80008a8:	4798      	blx	r3
      n++;
 80008aa:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80008ac:	3301      	adds	r3, #1
 80008ae:	9309      	str	r3, [sp, #36]	; 0x24
      width--;
 80008b0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80008b2:	3b01      	subs	r3, #1
 80008b4:	930a      	str	r3, [sp, #40]	; 0x28
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 80008b6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80008b8:	2b00      	cmp	r3, #0
 80008ba:	d1ee      	bne.n	800089a <chvprintf+0x41a>
 80008bc:	e5e7      	b.n	800048e <chvprintf+0xe>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 80008be:	4618      	mov	r0, r3
 80008c0:	b011      	add	sp, #68	; 0x44
 80008c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80008c6:	bf00      	nop
 80008c8:	0800d794 	.word	0x0800d794
 80008cc:	00000000 	.word	0x00000000

080008d0 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80008d0:	b40e      	push	{r1, r2, r3}
 80008d2:	b500      	push	{lr}
 80008d4:	b084      	sub	sp, #16
 80008d6:	9001      	str	r0, [sp, #4]
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80008d8:	ab06      	add	r3, sp, #24
 80008da:	9302      	str	r3, [sp, #8]
  formatted_bytes = chvprintf(chp, fmt, ap);
 80008dc:	9801      	ldr	r0, [sp, #4]
 80008de:	9905      	ldr	r1, [sp, #20]
 80008e0:	9a02      	ldr	r2, [sp, #8]
 80008e2:	f7ff fdcd 	bl	8000480 <chvprintf>
 80008e6:	9003      	str	r0, [sp, #12]
  va_end(ap);

  return formatted_bytes;
 80008e8:	9b03      	ldr	r3, [sp, #12]
}
 80008ea:	4618      	mov	r0, r3
 80008ec:	b004      	add	sp, #16
 80008ee:	f85d eb04 	ldr.w	lr, [sp], #4
 80008f2:	b003      	add	sp, #12
 80008f4:	4770      	bx	lr
 80008f6:	bf00      	nop
	...

08000900 <chIQGet>:
 * @return              A byte value from the queue.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {
 8000900:	b500      	push	{lr}
 8000902:	b083      	sub	sp, #12
 8000904:	9001      	str	r0, [sp, #4]

  return chIQGetTimeout(iqp, TIME_INFINITE);
 8000906:	9801      	ldr	r0, [sp, #4]
 8000908:	f04f 31ff 	mov.w	r1, #4294967295
 800090c:	f009 fc20 	bl	800a150 <chIQGetTimeout>
 8000910:	4603      	mov	r3, r0
}
 8000912:	4618      	mov	r0, r3
 8000914:	b003      	add	sp, #12
 8000916:	f85d fb04 	ldr.w	pc, [sp], #4
 800091a:	bf00      	nop
 800091c:	0000      	movs	r0, r0
	...

08000920 <readreg>:
    systime_t tmo;
    uint32_t pwm_frequency;
    uint8_t pwm_channel;
} PCA9685;
uint8_t readreg(PCA9685 *pca9685, uint8_t reg)
{
 8000920:	b510      	push	{r4, lr}
 8000922:	b086      	sub	sp, #24
 8000924:	9005      	str	r0, [sp, #20]
 8000926:	460b      	mov	r3, r1
 8000928:	f88d 3013 	strb.w	r3, [sp, #19]
  if(reg < 70 || reg > 249)
 800092c:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8000930:	2b45      	cmp	r3, #69	; 0x45
 8000932:	d903      	bls.n	800093c <readreg+0x1c>
 8000934:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8000938:	2bf9      	cmp	r3, #249	; 0xf9
 800093a:	d92b      	bls.n	8000994 <readreg+0x74>
  {
     pca9685->tmo = MS2ST(4);
 800093c:	9b05      	ldr	r3, [sp, #20]
 800093e:	2228      	movs	r2, #40	; 0x28
 8000940:	655a      	str	r2, [r3, #84]	; 0x54
     if(pca9685->acquire)
 8000942:	9b05      	ldr	r3, [sp, #20]
 8000944:	7b1b      	ldrb	r3, [r3, #12]
 8000946:	2b00      	cmp	r3, #0
 8000948:	d004      	beq.n	8000954 <readreg+0x34>
       i2cAcquireBus(pca9685->driver);
 800094a:	9b05      	ldr	r3, [sp, #20]
 800094c:	685b      	ldr	r3, [r3, #4]
 800094e:	4618      	mov	r0, r3
 8000950:	f006 ff86 	bl	8007860 <i2cAcquireBus>
     pca9685->status = i2cMasterTransmitTimeout(pca9685->driver,pca9685->i2caddress, &reg, 1, pca9685->rxbuf, 1, pca9685->tmo);
 8000954:	9b05      	ldr	r3, [sp, #20]
 8000956:	6858      	ldr	r0, [r3, #4]
 8000958:	9b05      	ldr	r3, [sp, #20]
 800095a:	781b      	ldrb	r3, [r3, #0]
 800095c:	b299      	uxth	r1, r3
 800095e:	9b05      	ldr	r3, [sp, #20]
 8000960:	f103 020d 	add.w	r2, r3, #13
 8000964:	9b05      	ldr	r3, [sp, #20]
 8000966:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8000968:	f10d 0413 	add.w	r4, sp, #19
 800096c:	9200      	str	r2, [sp, #0]
 800096e:	2201      	movs	r2, #1
 8000970:	9201      	str	r2, [sp, #4]
 8000972:	9302      	str	r3, [sp, #8]
 8000974:	4622      	mov	r2, r4
 8000976:	2301      	movs	r3, #1
 8000978:	f006 ff1a 	bl	80077b0 <i2cMasterTransmitTimeout>
 800097c:	4602      	mov	r2, r0
 800097e:	9b05      	ldr	r3, [sp, #20]
 8000980:	651a      	str	r2, [r3, #80]	; 0x50
     if(pca9685->acquire)
 8000982:	9b05      	ldr	r3, [sp, #20]
 8000984:	7b1b      	ldrb	r3, [r3, #12]
 8000986:	2b00      	cmp	r3, #0
 8000988:	d004      	beq.n	8000994 <readreg+0x74>
          i2cReleaseBus(pca9685->driver);
 800098a:	9b05      	ldr	r3, [sp, #20]
 800098c:	685b      	ldr	r3, [r3, #4]
 800098e:	4618      	mov	r0, r3
 8000990:	f006 ff7e 	bl	8007890 <i2cReleaseBus>
  }
  return pca9685->rxbuf[0];
 8000994:	9b05      	ldr	r3, [sp, #20]
 8000996:	7b5b      	ldrb	r3, [r3, #13]
}
 8000998:	4618      	mov	r0, r3
 800099a:	b006      	add	sp, #24
 800099c:	bd10      	pop	{r4, pc}
 800099e:	bf00      	nop

080009a0 <writereg>:
void writereg(PCA9685 *pca9685, uint8_t reg, uint8_t data)
{
 80009a0:	b510      	push	{r4, lr}
 80009a2:	b086      	sub	sp, #24
 80009a4:	9005      	str	r0, [sp, #20]
 80009a6:	460b      	mov	r3, r1
 80009a8:	f88d 3013 	strb.w	r3, [sp, #19]
 80009ac:	4613      	mov	r3, r2
 80009ae:	f88d 3012 	strb.w	r3, [sp, #18]
     pca9685->txbuf[0] = reg;//register address
 80009b2:	9b05      	ldr	r3, [sp, #20]
 80009b4:	f89d 2013 	ldrb.w	r2, [sp, #19]
 80009b8:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
     pca9685->txbuf[1] = data;
 80009bc:	9b05      	ldr	r3, [sp, #20]
 80009be:	f89d 2012 	ldrb.w	r2, [sp, #18]
 80009c2:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
     pca9685->tmo = MS2ST(4);
 80009c6:	9b05      	ldr	r3, [sp, #20]
 80009c8:	2228      	movs	r2, #40	; 0x28
 80009ca:	655a      	str	r2, [r3, #84]	; 0x54
     if(pca9685->acquire)
 80009cc:	9b05      	ldr	r3, [sp, #20]
 80009ce:	7b1b      	ldrb	r3, [r3, #12]
 80009d0:	2b00      	cmp	r3, #0
 80009d2:	d004      	beq.n	80009de <writereg+0x3e>
       i2cAcquireBus(pca9685->driver);
 80009d4:	9b05      	ldr	r3, [sp, #20]
 80009d6:	685b      	ldr	r3, [r3, #4]
 80009d8:	4618      	mov	r0, r3
 80009da:	f006 ff41 	bl	8007860 <i2cAcquireBus>
     pca9685->status = i2cMasterTransmitTimeout(pca9685->driver,pca9685->i2caddress, pca9685->txbuf, 2, pca9685->rxbuf, 0, pca9685->tmo);
 80009de:	9b05      	ldr	r3, [sp, #20]
 80009e0:	6858      	ldr	r0, [r3, #4]
 80009e2:	9b05      	ldr	r3, [sp, #20]
 80009e4:	781b      	ldrb	r3, [r3, #0]
 80009e6:	b299      	uxth	r1, r3
 80009e8:	9b05      	ldr	r3, [sp, #20]
 80009ea:	f103 042d 	add.w	r4, r3, #45	; 0x2d
 80009ee:	9b05      	ldr	r3, [sp, #20]
 80009f0:	f103 020d 	add.w	r2, r3, #13
 80009f4:	9b05      	ldr	r3, [sp, #20]
 80009f6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80009f8:	9200      	str	r2, [sp, #0]
 80009fa:	2200      	movs	r2, #0
 80009fc:	9201      	str	r2, [sp, #4]
 80009fe:	9302      	str	r3, [sp, #8]
 8000a00:	4622      	mov	r2, r4
 8000a02:	2302      	movs	r3, #2
 8000a04:	f006 fed4 	bl	80077b0 <i2cMasterTransmitTimeout>
 8000a08:	4602      	mov	r2, r0
 8000a0a:	9b05      	ldr	r3, [sp, #20]
 8000a0c:	651a      	str	r2, [r3, #80]	; 0x50
     if(pca9685->acquire)
 8000a0e:	9b05      	ldr	r3, [sp, #20]
 8000a10:	7b1b      	ldrb	r3, [r3, #12]
 8000a12:	2b00      	cmp	r3, #0
 8000a14:	d004      	beq.n	8000a20 <writereg+0x80>
          i2cReleaseBus(pca9685->driver);
 8000a16:	9b05      	ldr	r3, [sp, #20]
 8000a18:	685b      	ldr	r3, [r3, #4]
 8000a1a:	4618      	mov	r0, r3
 8000a1c:	f006 ff38 	bl	8007890 <i2cReleaseBus>
}
 8000a20:	b006      	add	sp, #24
 8000a22:	bd10      	pop	{r4, pc}
	...

08000a30 <reset>:
void reset(PCA9685 *pca9685)
{
 8000a30:	b500      	push	{lr}
 8000a32:	b083      	sub	sp, #12
 8000a34:	9001      	str	r0, [sp, #4]
  writereg(pca9685, PCA9685_MODE1, 0x00);
 8000a36:	9801      	ldr	r0, [sp, #4]
 8000a38:	2100      	movs	r1, #0
 8000a3a:	2200      	movs	r2, #0
 8000a3c:	f7ff ffb0 	bl	80009a0 <writereg>
  chThdSleepMilliseconds(1);
 8000a40:	200a      	movs	r0, #10
 8000a42:	f00c f96d 	bl	800cd20 <chThdSleep>
}
 8000a46:	b003      	add	sp, #12
 8000a48:	f85d fb04 	ldr.w	pc, [sp], #4
 8000a4c:	0000      	movs	r0, r0
	...

08000a50 <setFreq>:
void setFreq(PCA9685 *pca9685, uint32_t freq)
{
 8000a50:	b500      	push	{lr}
 8000a52:	b085      	sub	sp, #20
 8000a54:	9001      	str	r0, [sp, #4]
 8000a56:	9100      	str	r1, [sp, #0]
      uint8_t prescale = (uint8_t)(int) (PCA9685_CLOCK / (4096 * freq)) - 1;
 8000a58:	9b00      	ldr	r3, [sp, #0]
 8000a5a:	031b      	lsls	r3, r3, #12
 8000a5c:	4a1f      	ldr	r2, [pc, #124]	; (8000adc <setFreq+0x8c>)
 8000a5e:	fbb2 f3f3 	udiv	r3, r2, r3
 8000a62:	b2db      	uxtb	r3, r3
 8000a64:	3b01      	subs	r3, #1
 8000a66:	f88d 300f 	strb.w	r3, [sp, #15]
      if (prescale < 3)
 8000a6a:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8000a6e:	2b02      	cmp	r3, #2
 8000a70:	d802      	bhi.n	8000a78 <setFreq+0x28>
          prescale = 3;
 8000a72:	2303      	movs	r3, #3
 8000a74:	f88d 300f 	strb.w	r3, [sp, #15]
      uint8_t oldmode = readreg(pca9685, PCA9685_MODE1); //Preserve old mode
 8000a78:	9801      	ldr	r0, [sp, #4]
 8000a7a:	2100      	movs	r1, #0
 8000a7c:	f7ff ff50 	bl	8000920 <readreg>
 8000a80:	4603      	mov	r3, r0
 8000a82:	f88d 300e 	strb.w	r3, [sp, #14]
      uint8_t newmode = (oldmode & !PCA9685_MODE1_RESTART) | PCA9685_MODE1_SLEEP; // Don't change any MODE1 bit except set SLEEP bit 1 and RESTART bit goes 0
 8000a86:	2310      	movs	r3, #16
 8000a88:	f88d 300d 	strb.w	r3, [sp, #13]
      writereg(pca9685, PCA9685_MODE1, newmode); // go to sleep, shutting the oscillator off
 8000a8c:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8000a90:	9801      	ldr	r0, [sp, #4]
 8000a92:	2100      	movs	r1, #0
 8000a94:	461a      	mov	r2, r3
 8000a96:	f7ff ff83 	bl	80009a0 <writereg>
      writereg(pca9685, PCA9685_PRESCALE, prescale); // set the prescaler
 8000a9a:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8000a9e:	9801      	ldr	r0, [sp, #4]
 8000aa0:	21fe      	movs	r1, #254	; 0xfe
 8000aa2:	461a      	mov	r2, r3
 8000aa4:	f7ff ff7c 	bl	80009a0 <writereg>
      writereg(pca9685, PCA9685_MODE1, oldmode);
 8000aa8:	f89d 300e 	ldrb.w	r3, [sp, #14]
 8000aac:	9801      	ldr	r0, [sp, #4]
 8000aae:	2100      	movs	r1, #0
 8000ab0:	461a      	mov	r2, r3
 8000ab2:	f7ff ff75 	bl	80009a0 <writereg>
      chThdSleepMicroseconds(500);//Wait 0.5ms for oscillator stabilisation
 8000ab6:	2005      	movs	r0, #5
 8000ab8:	f00c f932 	bl	800cd20 <chThdSleep>
      writereg(pca9685, PCA9685_MODE1, oldmode | PCA9685_MODE1_ALLCALL | PCA9685_MODE1_AI | PCA9685_MODE1_RESTART);
 8000abc:	f89d 300e 	ldrb.w	r3, [sp, #14]
 8000ac0:	f063 035e 	orn	r3, r3, #94	; 0x5e
 8000ac4:	b2db      	uxtb	r3, r3
 8000ac6:	9801      	ldr	r0, [sp, #4]
 8000ac8:	2100      	movs	r1, #0
 8000aca:	461a      	mov	r2, r3
 8000acc:	f7ff ff68 	bl	80009a0 <writereg>
      pca9685->pwm_frequency = freq;
 8000ad0:	9b01      	ldr	r3, [sp, #4]
 8000ad2:	9a00      	ldr	r2, [sp, #0]
 8000ad4:	659a      	str	r2, [r3, #88]	; 0x58
}
 8000ad6:	b005      	add	sp, #20
 8000ad8:	f85d fb04 	ldr.w	pc, [sp], #4
 8000adc:	017d7840 	.word	0x017d7840

08000ae0 <setPWM>:
void setPWM(PCA9685 *pca9685, uint8_t channel, uint16_t on, uint16_t off)
{
 8000ae0:	b510      	push	{r4, lr}
 8000ae2:	b088      	sub	sp, #32
 8000ae4:	9007      	str	r0, [sp, #28]
 8000ae6:	4608      	mov	r0, r1
 8000ae8:	4611      	mov	r1, r2
 8000aea:	461a      	mov	r2, r3
 8000aec:	4603      	mov	r3, r0
 8000aee:	f88d 301b 	strb.w	r3, [sp, #27]
 8000af2:	460b      	mov	r3, r1
 8000af4:	f8ad 3018 	strh.w	r3, [sp, #24]
 8000af8:	4613      	mov	r3, r2
 8000afa:	f8ad 3016 	strh.w	r3, [sp, #22]
     pca9685->pwm_channel = channel;
 8000afe:	9b07      	ldr	r3, [sp, #28]
 8000b00:	f89d 201b 	ldrb.w	r2, [sp, #27]
 8000b04:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
     pca9685->txbuf[0] = LED0_ON_L + 4 * channel;
 8000b08:	f89d 301b 	ldrb.w	r3, [sp, #27]
 8000b0c:	009b      	lsls	r3, r3, #2
 8000b0e:	b2db      	uxtb	r3, r3
 8000b10:	3306      	adds	r3, #6
 8000b12:	b2da      	uxtb	r2, r3
 8000b14:	9b07      	ldr	r3, [sp, #28]
 8000b16:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
     pca9685->txbuf[1] = on & 0x00FF;
 8000b1a:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 8000b1e:	b2da      	uxtb	r2, r3
 8000b20:	9b07      	ldr	r3, [sp, #28]
 8000b22:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
     pca9685->txbuf[2] = on >> 8;
 8000b26:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 8000b2a:	0a1b      	lsrs	r3, r3, #8
 8000b2c:	b29b      	uxth	r3, r3
 8000b2e:	b2da      	uxtb	r2, r3
 8000b30:	9b07      	ldr	r3, [sp, #28]
 8000b32:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
     pca9685->txbuf[3] = off & 0x00FF;
 8000b36:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8000b3a:	b2da      	uxtb	r2, r3
 8000b3c:	9b07      	ldr	r3, [sp, #28]
 8000b3e:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
     pca9685->txbuf[4] = off >> 8;
 8000b42:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8000b46:	0a1b      	lsrs	r3, r3, #8
 8000b48:	b29b      	uxth	r3, r3
 8000b4a:	b2da      	uxtb	r2, r3
 8000b4c:	9b07      	ldr	r3, [sp, #28]
 8000b4e:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
     pca9685->tmo = MS2ST(4);
 8000b52:	9b07      	ldr	r3, [sp, #28]
 8000b54:	2228      	movs	r2, #40	; 0x28
 8000b56:	655a      	str	r2, [r3, #84]	; 0x54
     if(pca9685->acquire)
 8000b58:	9b07      	ldr	r3, [sp, #28]
 8000b5a:	7b1b      	ldrb	r3, [r3, #12]
 8000b5c:	2b00      	cmp	r3, #0
 8000b5e:	d004      	beq.n	8000b6a <setPWM+0x8a>
            i2cAcquireBus(pca9685->driver);
 8000b60:	9b07      	ldr	r3, [sp, #28]
 8000b62:	685b      	ldr	r3, [r3, #4]
 8000b64:	4618      	mov	r0, r3
 8000b66:	f006 fe7b 	bl	8007860 <i2cAcquireBus>
          pca9685->status = i2cMasterTransmitTimeout(pca9685->driver,pca9685->i2caddress, pca9685->txbuf, 5, pca9685->rxbuf, 0, pca9685->tmo);
 8000b6a:	9b07      	ldr	r3, [sp, #28]
 8000b6c:	6858      	ldr	r0, [r3, #4]
 8000b6e:	9b07      	ldr	r3, [sp, #28]
 8000b70:	781b      	ldrb	r3, [r3, #0]
 8000b72:	b299      	uxth	r1, r3
 8000b74:	9b07      	ldr	r3, [sp, #28]
 8000b76:	f103 042d 	add.w	r4, r3, #45	; 0x2d
 8000b7a:	9b07      	ldr	r3, [sp, #28]
 8000b7c:	f103 020d 	add.w	r2, r3, #13
 8000b80:	9b07      	ldr	r3, [sp, #28]
 8000b82:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8000b84:	9200      	str	r2, [sp, #0]
 8000b86:	2200      	movs	r2, #0
 8000b88:	9201      	str	r2, [sp, #4]
 8000b8a:	9302      	str	r3, [sp, #8]
 8000b8c:	4622      	mov	r2, r4
 8000b8e:	2305      	movs	r3, #5
 8000b90:	f006 fe0e 	bl	80077b0 <i2cMasterTransmitTimeout>
 8000b94:	4602      	mov	r2, r0
 8000b96:	9b07      	ldr	r3, [sp, #28]
 8000b98:	651a      	str	r2, [r3, #80]	; 0x50
          if(pca9685->acquire)
 8000b9a:	9b07      	ldr	r3, [sp, #28]
 8000b9c:	7b1b      	ldrb	r3, [r3, #12]
 8000b9e:	2b00      	cmp	r3, #0
 8000ba0:	d004      	beq.n	8000bac <setPWM+0xcc>
               i2cReleaseBus(pca9685->driver);
 8000ba2:	9b07      	ldr	r3, [sp, #28]
 8000ba4:	685b      	ldr	r3, [r3, #4]
 8000ba6:	4618      	mov	r0, r3
 8000ba8:	f006 fe72 	bl	8007890 <i2cReleaseBus>
}
 8000bac:	b008      	add	sp, #32
 8000bae:	bd10      	pop	{r4, pc}

08000bb0 <trasformToPWM>:
//    pwm1=pwm>>16;
//    pwm1=(pwm1*400)/4096;
//    return pwm1;
}

int  trasformToPWM(int grado) {
 8000bb0:	b082      	sub	sp, #8
 8000bb2:	9001      	str	r0, [sp, #4]
   if(grado==-1)
 8000bb4:	9b01      	ldr	r3, [sp, #4]
 8000bb6:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000bba:	d101      	bne.n	8000bc0 <trasformToPWM+0x10>
     return grado;
 8000bbc:	9b01      	ldr	r3, [sp, #4]
 8000bbe:	e01c      	b.n	8000bfa <trasformToPWM+0x4a>
   if(grado==0)
 8000bc0:	9b01      	ldr	r3, [sp, #4]
 8000bc2:	2b00      	cmp	r3, #0
 8000bc4:	d101      	bne.n	8000bca <trasformToPWM+0x1a>
     return 150;
 8000bc6:	2396      	movs	r3, #150	; 0x96
 8000bc8:	e017      	b.n	8000bfa <trasformToPWM+0x4a>
   if(grado==180)
 8000bca:	9b01      	ldr	r3, [sp, #4]
 8000bcc:	2bb4      	cmp	r3, #180	; 0xb4
 8000bce:	d102      	bne.n	8000bd6 <trasformToPWM+0x26>
     return 750;
 8000bd0:	f240 23ee 	movw	r3, #750	; 0x2ee
 8000bd4:	e011      	b.n	8000bfa <trasformToPWM+0x4a>
   if(grado==-2)
 8000bd6:	9b01      	ldr	r3, [sp, #4]
 8000bd8:	f113 0f02 	cmn.w	r3, #2
 8000bdc:	d101      	bne.n	8000be2 <trasformToPWM+0x32>
        return 0;
 8000bde:	2300      	movs	r3, #0
 8000be0:	e00b      	b.n	8000bfa <trasformToPWM+0x4a>

   return (900*grado)/180;
 8000be2:	9b01      	ldr	r3, [sp, #4]
 8000be4:	f44f 7261 	mov.w	r2, #900	; 0x384
 8000be8:	fb02 f303 	mul.w	r3, r2, r3
 8000bec:	4a04      	ldr	r2, [pc, #16]	; (8000c00 <trasformToPWM+0x50>)
 8000bee:	fb82 1203 	smull	r1, r2, r2, r3
 8000bf2:	441a      	add	r2, r3
 8000bf4:	11d2      	asrs	r2, r2, #7
 8000bf6:	17db      	asrs	r3, r3, #31
 8000bf8:	1ad3      	subs	r3, r2, r3
}
 8000bfa:	4618      	mov	r0, r3
 8000bfc:	b002      	add	sp, #8
 8000bfe:	4770      	bx	lr
 8000c00:	b60b60b7 	.word	0xb60b60b7
	...

08000c10 <thReader>:

static SerialConfig uartCfg = {9600, // bit rate
    };

static THD_WORKING_AREA(waRead, 2048);
msg_t thReader(PCA9685 *arg) {
 8000c10:	b510      	push	{r4, lr}
 8000c12:	f5ad 6d88 	sub.w	sp, sp, #1088	; 0x440
 8000c16:	ab05      	add	r3, sp, #20
 8000c18:	6018      	str	r0, [r3, #0]
  char received[1024];
    int pos = 0;
 8000c1a:	2300      	movs	r3, #0
 8000c1c:	f8cd 343c 	str.w	r3, [sp, #1084]	; 0x43c
    int count_ch=0;
 8000c20:	2300      	movs	r3, #0
 8000c22:	f8cd 3438 	str.w	r3, [sp, #1080]	; 0x438
    int ch0,ch1,ch2,ch3,ch4,ch5;
    uint32_t g= 0;
 8000c26:	2300      	movs	r3, #0
 8000c28:	f8cd 341c 	str.w	r3, [sp, #1052]	; 0x41c
 8000c2c:	e069      	b.n	8000d02 <thReader+0xf2>
    uint8_t c;
  while(true){
    while ((char)c !='&'){
        /* This will wait for a character to be received */
        c = sdGet(&SD2);
 8000c2e:	487f      	ldr	r0, [pc, #508]	; (8000e2c <thReader+0x21c>)
 8000c30:	f7ff fe66 	bl	8000900 <chIQGet>
 8000c34:	4603      	mov	r3, r0
 8000c36:	f88d 3423 	strb.w	r3, [sp, #1059]	; 0x423
        //sdPut(&SD2,c);
        received[pos] = (char)c;
 8000c3a:	aa06      	add	r2, sp, #24
 8000c3c:	f8dd 343c 	ldr.w	r3, [sp, #1084]	; 0x43c
 8000c40:	4413      	add	r3, r2
 8000c42:	f89d 2423 	ldrb.w	r2, [sp, #1059]	; 0x423
 8000c46:	701a      	strb	r2, [r3, #0]
        pos++;
 8000c48:	f8dd 343c 	ldr.w	r3, [sp, #1084]	; 0x43c
 8000c4c:	3301      	adds	r3, #1
 8000c4e:	f8cd 343c 	str.w	r3, [sp, #1084]	; 0x43c
      if((char)c==','){
 8000c52:	f89d 3423 	ldrb.w	r3, [sp, #1059]	; 0x423
 8000c56:	2b2c      	cmp	r3, #44	; 0x2c
 8000c58:	d153      	bne.n	8000d02 <thReader+0xf2>
        received[pos] = '\0';
 8000c5a:	aa06      	add	r2, sp, #24
 8000c5c:	f8dd 343c 	ldr.w	r3, [sp, #1084]	; 0x43c
 8000c60:	4413      	add	r3, r2
 8000c62:	2200      	movs	r2, #0
 8000c64:	701a      	strb	r2, [r3, #0]
        if(count_ch==0)
 8000c66:	f8dd 3438 	ldr.w	r3, [sp, #1080]	; 0x438
 8000c6a:	2b00      	cmp	r3, #0
 8000c6c:	d109      	bne.n	8000c82 <thReader+0x72>
                  ch0=trasformToPWM(atoi(received));
 8000c6e:	ab06      	add	r3, sp, #24
 8000c70:	4618      	mov	r0, r3
 8000c72:	f00c fa2d 	bl	800d0d0 <atoi>
 8000c76:	4603      	mov	r3, r0
 8000c78:	4618      	mov	r0, r3
 8000c7a:	f7ff ff99 	bl	8000bb0 <trasformToPWM>
 8000c7e:	f8cd 0434 	str.w	r0, [sp, #1076]	; 0x434
        if(count_ch==1)
 8000c82:	f8dd 3438 	ldr.w	r3, [sp, #1080]	; 0x438
 8000c86:	2b01      	cmp	r3, #1
 8000c88:	d109      	bne.n	8000c9e <thReader+0x8e>
                  ch1=trasformToPWM(atoi(received));
 8000c8a:	ab06      	add	r3, sp, #24
 8000c8c:	4618      	mov	r0, r3
 8000c8e:	f00c fa1f 	bl	800d0d0 <atoi>
 8000c92:	4603      	mov	r3, r0
 8000c94:	4618      	mov	r0, r3
 8000c96:	f7ff ff8b 	bl	8000bb0 <trasformToPWM>
 8000c9a:	f8cd 0430 	str.w	r0, [sp, #1072]	; 0x430
        if(count_ch==2)
 8000c9e:	f8dd 3438 	ldr.w	r3, [sp, #1080]	; 0x438
 8000ca2:	2b02      	cmp	r3, #2
 8000ca4:	d109      	bne.n	8000cba <thReader+0xaa>
                  ch2=trasformToPWM(atoi(received));
 8000ca6:	ab06      	add	r3, sp, #24
 8000ca8:	4618      	mov	r0, r3
 8000caa:	f00c fa11 	bl	800d0d0 <atoi>
 8000cae:	4603      	mov	r3, r0
 8000cb0:	4618      	mov	r0, r3
 8000cb2:	f7ff ff7d 	bl	8000bb0 <trasformToPWM>
 8000cb6:	f8cd 042c 	str.w	r0, [sp, #1068]	; 0x42c
        if(count_ch)
 8000cba:	f8dd 3438 	ldr.w	r3, [sp, #1080]	; 0x438
 8000cbe:	2b00      	cmp	r3, #0
 8000cc0:	d009      	beq.n	8000cd6 <thReader+0xc6>
                  ch3=trasformToPWM(atoi(received));
 8000cc2:	ab06      	add	r3, sp, #24
 8000cc4:	4618      	mov	r0, r3
 8000cc6:	f00c fa03 	bl	800d0d0 <atoi>
 8000cca:	4603      	mov	r3, r0
 8000ccc:	4618      	mov	r0, r3
 8000cce:	f7ff ff6f 	bl	8000bb0 <trasformToPWM>
 8000cd2:	f8cd 0428 	str.w	r0, [sp, #1064]	; 0x428
        if(count_ch==4)
 8000cd6:	f8dd 3438 	ldr.w	r3, [sp, #1080]	; 0x438
 8000cda:	2b04      	cmp	r3, #4
 8000cdc:	d109      	bne.n	8000cf2 <thReader+0xe2>
                  ch4=trasformToPWM(atoi(received));
 8000cde:	ab06      	add	r3, sp, #24
 8000ce0:	4618      	mov	r0, r3
 8000ce2:	f00c f9f5 	bl	800d0d0 <atoi>
 8000ce6:	4603      	mov	r3, r0
 8000ce8:	4618      	mov	r0, r3
 8000cea:	f7ff ff61 	bl	8000bb0 <trasformToPWM>
 8000cee:	f8cd 0424 	str.w	r0, [sp, #1060]	; 0x424
        pos=0;
 8000cf2:	2300      	movs	r3, #0
 8000cf4:	f8cd 343c 	str.w	r3, [sp, #1084]	; 0x43c
        count_ch++;
 8000cf8:	f8dd 3438 	ldr.w	r3, [sp, #1080]	; 0x438
 8000cfc:	3301      	adds	r3, #1
 8000cfe:	f8cd 3438 	str.w	r3, [sp, #1080]	; 0x438
    int count_ch=0;
    int ch0,ch1,ch2,ch3,ch4,ch5;
    uint32_t g= 0;
    uint8_t c;
  while(true){
    while ((char)c !='&'){
 8000d02:	f89d 3423 	ldrb.w	r3, [sp, #1059]	; 0x423
 8000d06:	2b26      	cmp	r3, #38	; 0x26
 8000d08:	d191      	bne.n	8000c2e <thReader+0x1e>
                  ch4=trasformToPWM(atoi(received));
        pos=0;
        count_ch++;
      }
    }
    received[pos] ='\0';
 8000d0a:	aa06      	add	r2, sp, #24
 8000d0c:	f8dd 343c 	ldr.w	r3, [sp, #1084]	; 0x43c
 8000d10:	4413      	add	r3, r2
 8000d12:	2200      	movs	r2, #0
 8000d14:	701a      	strb	r2, [r3, #0]
    ch5=trasformToPWM(atoi(received));
 8000d16:	ab06      	add	r3, sp, #24
 8000d18:	4618      	mov	r0, r3
 8000d1a:	f00c f9d9 	bl	800d0d0 <atoi>
 8000d1e:	4603      	mov	r3, r0
 8000d20:	4618      	mov	r0, r3
 8000d22:	f7ff ff45 	bl	8000bb0 <trasformToPWM>
 8000d26:	f8cd 0418 	str.w	r0, [sp, #1048]	; 0x418
    chThdSleepMilliseconds(100);
 8000d2a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000d2e:	f00b fff7 	bl	800cd20 <chThdSleep>
    chprintf((BaseSequentialStream *)&SD2,"%d,%d,%d,%d,%d,%d\n",ch0,ch1,ch2,ch3,ch4,ch5);
 8000d32:	f8dd 342c 	ldr.w	r3, [sp, #1068]	; 0x42c
 8000d36:	9300      	str	r3, [sp, #0]
 8000d38:	f8dd 3428 	ldr.w	r3, [sp, #1064]	; 0x428
 8000d3c:	9301      	str	r3, [sp, #4]
 8000d3e:	f8dd 3424 	ldr.w	r3, [sp, #1060]	; 0x424
 8000d42:	9302      	str	r3, [sp, #8]
 8000d44:	f8dd 3418 	ldr.w	r3, [sp, #1048]	; 0x418
 8000d48:	9303      	str	r3, [sp, #12]
 8000d4a:	4839      	ldr	r0, [pc, #228]	; (8000e30 <thReader+0x220>)
 8000d4c:	4939      	ldr	r1, [pc, #228]	; (8000e34 <thReader+0x224>)
 8000d4e:	f8dd 2434 	ldr.w	r2, [sp, #1076]	; 0x434
 8000d52:	f8dd 3430 	ldr.w	r3, [sp, #1072]	; 0x430
 8000d56:	f7ff fdbb 	bl	80008d0 <chprintf>
    if(ch0!=-1){
 8000d5a:	f8dd 3434 	ldr.w	r3, [sp, #1076]	; 0x434
 8000d5e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000d62:	d009      	beq.n	8000d78 <thReader+0x168>
      setPWM(arg, 0, 0, ch0);
 8000d64:	f8dd 3434 	ldr.w	r3, [sp, #1076]	; 0x434
 8000d68:	b29c      	uxth	r4, r3
 8000d6a:	ab05      	add	r3, sp, #20
 8000d6c:	6818      	ldr	r0, [r3, #0]
 8000d6e:	2100      	movs	r1, #0
 8000d70:	2200      	movs	r2, #0
 8000d72:	4623      	mov	r3, r4
 8000d74:	f7ff feb4 	bl	8000ae0 <setPWM>
      //chThdSleepMilliseconds(100);
    }
    if(ch0!=-1){
 8000d78:	f8dd 3434 	ldr.w	r3, [sp, #1076]	; 0x434
 8000d7c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000d80:	d009      	beq.n	8000d96 <thReader+0x186>
      setPWM(arg, 1, 0, ch1);
 8000d82:	f8dd 3430 	ldr.w	r3, [sp, #1072]	; 0x430
 8000d86:	b29c      	uxth	r4, r3
 8000d88:	ab05      	add	r3, sp, #20
 8000d8a:	6818      	ldr	r0, [r3, #0]
 8000d8c:	2101      	movs	r1, #1
 8000d8e:	2200      	movs	r2, #0
 8000d90:	4623      	mov	r3, r4
 8000d92:	f7ff fea5 	bl	8000ae0 <setPWM>
      //chThdSleepMilliseconds(100);
    }
    if(ch0!=-1){
 8000d96:	f8dd 3434 	ldr.w	r3, [sp, #1076]	; 0x434
 8000d9a:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000d9e:	d009      	beq.n	8000db4 <thReader+0x1a4>
      setPWM(arg, 2, 0, ch2);
 8000da0:	f8dd 342c 	ldr.w	r3, [sp, #1068]	; 0x42c
 8000da4:	b29c      	uxth	r4, r3
 8000da6:	ab05      	add	r3, sp, #20
 8000da8:	6818      	ldr	r0, [r3, #0]
 8000daa:	2102      	movs	r1, #2
 8000dac:	2200      	movs	r2, #0
 8000dae:	4623      	mov	r3, r4
 8000db0:	f7ff fe96 	bl	8000ae0 <setPWM>
      //chThdSleepMilliseconds(100);
    }
    if(ch0!=-1){
 8000db4:	f8dd 3434 	ldr.w	r3, [sp, #1076]	; 0x434
 8000db8:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000dbc:	d009      	beq.n	8000dd2 <thReader+0x1c2>
      setPWM(arg, 3, 0, ch3);
 8000dbe:	f8dd 3428 	ldr.w	r3, [sp, #1064]	; 0x428
 8000dc2:	b29c      	uxth	r4, r3
 8000dc4:	ab05      	add	r3, sp, #20
 8000dc6:	6818      	ldr	r0, [r3, #0]
 8000dc8:	2103      	movs	r1, #3
 8000dca:	2200      	movs	r2, #0
 8000dcc:	4623      	mov	r3, r4
 8000dce:	f7ff fe87 	bl	8000ae0 <setPWM>
     // chThdSleepMilliseconds(100);
    }
    if(ch0!=-1){
 8000dd2:	f8dd 3434 	ldr.w	r3, [sp, #1076]	; 0x434
 8000dd6:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000dda:	d009      	beq.n	8000df0 <thReader+0x1e0>
      setPWM(arg, 4, 0, ch4);
 8000ddc:	f8dd 3424 	ldr.w	r3, [sp, #1060]	; 0x424
 8000de0:	b29c      	uxth	r4, r3
 8000de2:	ab05      	add	r3, sp, #20
 8000de4:	6818      	ldr	r0, [r3, #0]
 8000de6:	2104      	movs	r1, #4
 8000de8:	2200      	movs	r2, #0
 8000dea:	4623      	mov	r3, r4
 8000dec:	f7ff fe78 	bl	8000ae0 <setPWM>
    //  chThdSleepMilliseconds(100);
    }
    if(ch0!=-1){
 8000df0:	f8dd 3434 	ldr.w	r3, [sp, #1076]	; 0x434
 8000df4:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000df8:	d009      	beq.n	8000e0e <thReader+0x1fe>
      setPWM(arg, 5, 0, ch5);
 8000dfa:	f8dd 3418 	ldr.w	r3, [sp, #1048]	; 0x418
 8000dfe:	b29c      	uxth	r4, r3
 8000e00:	ab05      	add	r3, sp, #20
 8000e02:	6818      	ldr	r0, [r3, #0]
 8000e04:	2105      	movs	r1, #5
 8000e06:	2200      	movs	r2, #0
 8000e08:	4623      	mov	r3, r4
 8000e0a:	f7ff fe69 	bl	8000ae0 <setPWM>
    //  chThdSleepMilliseconds(100);
    }
    chThdSleepMilliseconds(100);
 8000e0e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000e12:	f00b ff85 	bl	800cd20 <chThdSleep>
    pos=0;
 8000e16:	2300      	movs	r3, #0
 8000e18:	f8cd 343c 	str.w	r3, [sp, #1084]	; 0x43c
    count_ch=0;
 8000e1c:	2300      	movs	r3, #0
 8000e1e:	f8cd 3438 	str.w	r3, [sp, #1080]	; 0x438
    c=0;
 8000e22:	2300      	movs	r3, #0
 8000e24:	f88d 3423 	strb.w	r3, [sp, #1059]	; 0x423
 8000e28:	e76b      	b.n	8000d02 <thReader+0xf2>
 8000e2a:	bf00      	nop
 8000e2c:	20001468 	.word	0x20001468
 8000e30:	2000145c 	.word	0x2000145c
 8000e34:	0800d79c 	.word	0x0800d79c
	...

08000e40 <main>:


/*
 * Application entry point.
 */
int main(void) {
 8000e40:	b500      	push	{lr}
 8000e42:	b09b      	sub	sp, #108	; 0x6c
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 8000e44:	f007 ffe4 	bl	8008e10 <halInit>
  chSysInit();
 8000e48:	f00a fe02 	bl	800ba50 <chSysInit>
  /*
   * Activates the serial driver 2 using the driver default configuration.
   */
  sdStart(&SD2, &uartCfg);
 8000e4c:	4822      	ldr	r0, [pc, #136]	; (8000ed8 <main+0x98>)
 8000e4e:	4923      	ldr	r1, [pc, #140]	; (8000edc <main+0x9c>)
 8000e50:	f006 fea6 	bl	8007ba0 <sdStart>

   palSetPadMode(GPIOB, 8, PAL_MODE_ALTERNATE(4) | PAL_STM32_OTYPE_OPENDRAIN);
 8000e54:	4822      	ldr	r0, [pc, #136]	; (8000ee0 <main+0xa0>)
 8000e56:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000e5a:	f240 2206 	movw	r2, #518	; 0x206
 8000e5e:	f005 fb6f 	bl	8006540 <_pal_lld_setgroupmode>
   palSetPadMode(GPIOB, 9, PAL_MODE_ALTERNATE(4) | PAL_STM32_OTYPE_OPENDRAIN);
 8000e62:	481f      	ldr	r0, [pc, #124]	; (8000ee0 <main+0xa0>)
 8000e64:	f44f 7100 	mov.w	r1, #512	; 0x200
 8000e68:	f240 2206 	movw	r2, #518	; 0x206
 8000e6c:	f005 fb68 	bl	8006540 <_pal_lld_setgroupmode>

   /**
      * Prepares the PCA9685
      */
   PCA9685 pca9685;
   pca9685.i2caddress = PCA9685_ADDRESS;
 8000e70:	2340      	movs	r3, #64	; 0x40
 8000e72:	f88d 3008 	strb.w	r3, [sp, #8]
   pca9685.driver = &PCA9685_DEFI2C_DRIVER;
 8000e76:	4b1b      	ldr	r3, [pc, #108]	; (8000ee4 <main+0xa4>)
 8000e78:	9303      	str	r3, [sp, #12]
   pca9685.pwm_frequency = PCA9685_FREQ;
 8000e7a:	233c      	movs	r3, #60	; 0x3c
 8000e7c:	9318      	str	r3, [sp, #96]	; 0x60
   pca9685.config = &PCA9685_I2C_CONFIG;
 8000e7e:	4b1a      	ldr	r3, [pc, #104]	; (8000ee8 <main+0xa8>)
 8000e80:	9304      	str	r3, [sp, #16]
   pca9685.acquire = TRUE;
 8000e82:	2301      	movs	r3, #1
 8000e84:	f88d 3014 	strb.w	r3, [sp, #20]
   /*
     * Starts I2C
     */
   i2cStart(pca9685.driver, pca9685.config);
 8000e88:	9a03      	ldr	r2, [sp, #12]
 8000e8a:	9b04      	ldr	r3, [sp, #16]
 8000e8c:	4610      	mov	r0, r2
 8000e8e:	4619      	mov	r1, r3
 8000e90:	f006 fc5e 	bl	8007750 <i2cStart>

   reset(&pca9685);
 8000e94:	ab02      	add	r3, sp, #8
 8000e96:	4618      	mov	r0, r3
 8000e98:	f7ff fdca 	bl	8000a30 <reset>

   setFreq(&pca9685, pca9685.pwm_frequency);
 8000e9c:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8000e9e:	aa02      	add	r2, sp, #8
 8000ea0:	4610      	mov	r0, r2
 8000ea2:	4619      	mov	r1, r3
 8000ea4:	f7ff fdd4 	bl	8000a50 <setFreq>

   chThdCreateStatic(waRead, sizeof(waRead), NORMALPRIO, thReader, &pca9685);
 8000ea8:	ab02      	add	r3, sp, #8
 8000eaa:	9300      	str	r3, [sp, #0]
 8000eac:	480f      	ldr	r0, [pc, #60]	; (8000eec <main+0xac>)
 8000eae:	f640 01e8 	movw	r1, #2280	; 0x8e8
 8000eb2:	2240      	movs	r2, #64	; 0x40
 8000eb4:	4b0e      	ldr	r3, [pc, #56]	; (8000ef0 <main+0xb0>)
 8000eb6:	f00b fea3 	bl	800cc00 <chThdCreateStatic>
  /*
   * Normal main() thread activity, in this demo it does nothing except
   * sleeping in a loop and check the button state.
   */
  while (true) {
    if (!palReadPad(GPIOC, GPIOC_BUTTON))
 8000eba:	4b0e      	ldr	r3, [pc, #56]	; (8000ef4 <main+0xb4>)
 8000ebc:	691b      	ldr	r3, [r3, #16]
 8000ebe:	0b5b      	lsrs	r3, r3, #13
 8000ec0:	f003 0301 	and.w	r3, r3, #1
 8000ec4:	2b00      	cmp	r3, #0
 8000ec6:	d102      	bne.n	8000ece <main+0x8e>
      TestThread(&SD2);
 8000ec8:	4803      	ldr	r0, [pc, #12]	; (8000ed8 <main+0x98>)
 8000eca:	f004 fd69 	bl	80059a0 <TestThread>
    chThdSleepMilliseconds(500);
 8000ece:	f241 3088 	movw	r0, #5000	; 0x1388
 8000ed2:	f00b ff25 	bl	800cd20 <chThdSleep>
 8000ed6:	e7f0      	b.n	8000eba <main+0x7a>
 8000ed8:	2000145c 	.word	0x2000145c
 8000edc:	200008ec 	.word	0x200008ec
 8000ee0:	40020400 	.word	0x40020400
 8000ee4:	200013b4 	.word	0x200013b4
 8000ee8:	0800e8a0 	.word	0x0800e8a0
 8000eec:	20001cf0 	.word	0x20001cf0
 8000ef0:	08000c11 	.word	0x08000c11
 8000ef4:	40020800 	.word	0x40020800
	...

08000f00 <queues2_setup.lto_priv.51>:
 * This test case tests synchronous and asynchronous operations on an
 * @p OutputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues2_setup(void) {
 8000f00:	b500      	push	{lr}
 8000f02:	b083      	sub	sp, #12

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 8000f04:	4b06      	ldr	r3, [pc, #24]	; (8000f20 <queues2_setup.lto_priv.51+0x20>)
 8000f06:	681a      	ldr	r2, [r3, #0]
 8000f08:	2300      	movs	r3, #0
 8000f0a:	9300      	str	r3, [sp, #0]
 8000f0c:	4805      	ldr	r0, [pc, #20]	; (8000f24 <queues2_setup.lto_priv.51+0x24>)
 8000f0e:	4611      	mov	r1, r2
 8000f10:	2204      	movs	r2, #4
 8000f12:	4b05      	ldr	r3, [pc, #20]	; (8000f28 <queues2_setup.lto_priv.51+0x28>)
 8000f14:	f009 f9c4 	bl	800a2a0 <chOQObjectInit>
}
 8000f18:	b003      	add	sp, #12
 8000f1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8000f1e:	bf00      	nop
 8000f20:	0800e420 	.word	0x0800e420
 8000f24:	200008c8 	.word	0x200008c8
 8000f28:	08002d91 	.word	0x08002d91
 8000f2c:	00000000 	.word	0x00000000

08000f30 <thread2.lto_priv.148>:

static THD_FUNCTION(thread2, p) {
 8000f30:	b500      	push	{lr}
 8000f32:	b083      	sub	sp, #12
 8000f34:	9001      	str	r0, [sp, #4]

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
 8000f36:	4804      	ldr	r0, [pc, #16]	; (8000f48 <thread2.lto_priv.148+0x18>)
 8000f38:	2100      	movs	r1, #0
 8000f3a:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8000f3e:	f007 fb07 	bl	8008550 <chOQPutTimeout>
}
 8000f42:	b003      	add	sp, #12
 8000f44:	f85d fb04 	ldr.w	pc, [sp], #4
 8000f48:	200008c8 	.word	0x200008c8
 8000f4c:	00000000 	.word	0x00000000

08000f50 <queues2_execute.lto_priv.52>:

static void queues2_execute(void) {
 8000f50:	b510      	push	{r4, lr}
 8000f52:	b086      	sub	sp, #24
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");
 8000f54:	f001 fe34 	bl	8002bc0 <chSysLock.lto_priv.155>
 8000f58:	489e      	ldr	r0, [pc, #632]	; (80011d4 <queues2_execute.lto_priv.52+0x284>)
 8000f5a:	f001 fed1 	bl	8002d00 <chOQIsEmptyI.lto_priv.165>
 8000f5e:	4603      	mov	r3, r0
 8000f60:	2001      	movs	r0, #1
 8000f62:	4619      	mov	r1, r3
 8000f64:	f004 fbd4 	bl	8005710 <_test_assert>
 8000f68:	4603      	mov	r3, r0
 8000f6a:	2b00      	cmp	r3, #0
 8000f6c:	d002      	beq.n	8000f74 <queues2_execute.lto_priv.52+0x24>
 8000f6e:	f001 fe2f 	bl	8002bd0 <chSysUnlock.lto_priv.152>
 8000f72:	e12d      	b.n	80011d0 <queues2_execute.lto_priv.52+0x280>
 8000f74:	f001 fe2c 	bl	8002bd0 <chSysUnlock.lto_priv.152>

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8000f78:	2300      	movs	r3, #0
 8000f7a:	9305      	str	r3, [sp, #20]
 8000f7c:	e00a      	b.n	8000f94 <queues2_execute.lto_priv.52+0x44>
    chOQPut(&oq, 'A' + i);
 8000f7e:	9b05      	ldr	r3, [sp, #20]
 8000f80:	b2db      	uxtb	r3, r3
 8000f82:	3341      	adds	r3, #65	; 0x41
 8000f84:	b2db      	uxtb	r3, r3
 8000f86:	4893      	ldr	r0, [pc, #588]	; (80011d4 <queues2_execute.lto_priv.52+0x284>)
 8000f88:	4619      	mov	r1, r3
 8000f8a:	f001 fee9 	bl	8002d60 <chOQPut.lto_priv.166>

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8000f8e:	9b05      	ldr	r3, [sp, #20]
 8000f90:	3301      	adds	r3, #1
 8000f92:	9305      	str	r3, [sp, #20]
 8000f94:	9b05      	ldr	r3, [sp, #20]
 8000f96:	2b03      	cmp	r3, #3
 8000f98:	d9f1      	bls.n	8000f7e <queues2_execute.lto_priv.52+0x2e>
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");
 8000f9a:	f001 fe11 	bl	8002bc0 <chSysLock.lto_priv.155>
 8000f9e:	488d      	ldr	r0, [pc, #564]	; (80011d4 <queues2_execute.lto_priv.52+0x284>)
 8000fa0:	f001 fece 	bl	8002d40 <chOQIsFullI.lto_priv.163>
 8000fa4:	4603      	mov	r3, r0
 8000fa6:	2002      	movs	r0, #2
 8000fa8:	4619      	mov	r1, r3
 8000faa:	f004 fbb1 	bl	8005710 <_test_assert>
 8000fae:	4603      	mov	r3, r0
 8000fb0:	2b00      	cmp	r3, #0
 8000fb2:	d002      	beq.n	8000fba <queues2_execute.lto_priv.52+0x6a>
 8000fb4:	f001 fe0c 	bl	8002bd0 <chSysUnlock.lto_priv.152>
 8000fb8:	e10a      	b.n	80011d0 <queues2_execute.lto_priv.52+0x280>
 8000fba:	f001 fe09 	bl	8002bd0 <chSysUnlock.lto_priv.152>

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
 8000fbe:	2300      	movs	r3, #0
 8000fc0:	9305      	str	r3, [sp, #20]
 8000fc2:	e011      	b.n	8000fe8 <queues2_execute.lto_priv.52+0x98>
    char c;

    chSysLock();
 8000fc4:	f001 fdfc 	bl	8002bc0 <chSysLock.lto_priv.155>
    c = chOQGetI(&oq);
 8000fc8:	4882      	ldr	r0, [pc, #520]	; (80011d4 <queues2_execute.lto_priv.52+0x284>)
 8000fca:	f007 fb09 	bl	80085e0 <chOQGetI>
 8000fce:	4603      	mov	r3, r0
 8000fd0:	f88d 3013 	strb.w	r3, [sp, #19]
    chSysUnlock();
 8000fd4:	f001 fdfc 	bl	8002bd0 <chSysUnlock.lto_priv.152>
    test_emit_token(c);
 8000fd8:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8000fdc:	4618      	mov	r0, r3
 8000fde:	f004 fb67 	bl	80056b0 <test_emit_token>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
 8000fe2:	9b05      	ldr	r3, [sp, #20]
 8000fe4:	3301      	adds	r3, #1
 8000fe6:	9305      	str	r3, [sp, #20]
 8000fe8:	9b05      	ldr	r3, [sp, #20]
 8000fea:	2b03      	cmp	r3, #3
 8000fec:	d9ea      	bls.n	8000fc4 <queues2_execute.lto_priv.52+0x74>
    chSysLock();
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
 8000fee:	f001 fde7 	bl	8002bc0 <chSysLock.lto_priv.155>
 8000ff2:	4878      	ldr	r0, [pc, #480]	; (80011d4 <queues2_execute.lto_priv.52+0x284>)
 8000ff4:	f001 fe84 	bl	8002d00 <chOQIsEmptyI.lto_priv.165>
 8000ff8:	4603      	mov	r3, r0
 8000ffa:	2003      	movs	r0, #3
 8000ffc:	4619      	mov	r1, r3
 8000ffe:	f004 fb87 	bl	8005710 <_test_assert>
 8001002:	4603      	mov	r3, r0
 8001004:	2b00      	cmp	r3, #0
 8001006:	d002      	beq.n	800100e <queues2_execute.lto_priv.52+0xbe>
 8001008:	f001 fde2 	bl	8002bd0 <chSysUnlock.lto_priv.152>
 800100c:	e0e0      	b.n	80011d0 <queues2_execute.lto_priv.52+0x280>
 800100e:	f001 fddf 	bl	8002bd0 <chSysUnlock.lto_priv.152>
  test_assert_sequence(4, "ABCD");
 8001012:	2004      	movs	r0, #4
 8001014:	4970      	ldr	r1, [pc, #448]	; (80011d8 <queues2_execute.lto_priv.52+0x288>)
 8001016:	f004 fb93 	bl	8005740 <_test_assert_sequence>
 800101a:	4603      	mov	r3, r0
 800101c:	2b00      	cmp	r3, #0
 800101e:	f040 80d7 	bne.w	80011d0 <queues2_execute.lto_priv.52+0x280>
  test_assert_lock(5, chOQGetI(&oq) == Q_EMPTY, "failed to report Q_EMPTY");
 8001022:	f001 fdcd 	bl	8002bc0 <chSysLock.lto_priv.155>
 8001026:	486b      	ldr	r0, [pc, #428]	; (80011d4 <queues2_execute.lto_priv.52+0x284>)
 8001028:	f007 fada 	bl	80085e0 <chOQGetI>
 800102c:	4603      	mov	r3, r0
 800102e:	f113 0f03 	cmn.w	r3, #3
 8001032:	bf0c      	ite	eq
 8001034:	2301      	moveq	r3, #1
 8001036:	2300      	movne	r3, #0
 8001038:	b2db      	uxtb	r3, r3
 800103a:	2005      	movs	r0, #5
 800103c:	4619      	mov	r1, r3
 800103e:	f004 fb67 	bl	8005710 <_test_assert>
 8001042:	4603      	mov	r3, r0
 8001044:	2b00      	cmp	r3, #0
 8001046:	d002      	beq.n	800104e <queues2_execute.lto_priv.52+0xfe>
 8001048:	f001 fdc2 	bl	8002bd0 <chSysUnlock.lto_priv.152>
 800104c:	e0c0      	b.n	80011d0 <queues2_execute.lto_priv.52+0x280>
 800104e:	f001 fdbf 	bl	8002bd0 <chSysUnlock.lto_priv.152>

  /* Writing the whole thing */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 8001052:	4b62      	ldr	r3, [pc, #392]	; (80011dc <queues2_execute.lto_priv.52+0x28c>)
 8001054:	685b      	ldr	r3, [r3, #4]
 8001056:	485f      	ldr	r0, [pc, #380]	; (80011d4 <queues2_execute.lto_priv.52+0x284>)
 8001058:	4619      	mov	r1, r3
 800105a:	2208      	movs	r2, #8
 800105c:	2300      	movs	r3, #0
 800105e:	f007 faef 	bl	8008640 <chOQWriteTimeout>
 8001062:	9003      	str	r0, [sp, #12]
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 8001064:	9b03      	ldr	r3, [sp, #12]
 8001066:	2b04      	cmp	r3, #4
 8001068:	bf0c      	ite	eq
 800106a:	2301      	moveq	r3, #1
 800106c:	2300      	movne	r3, #0
 800106e:	b2db      	uxtb	r3, r3
 8001070:	2006      	movs	r0, #6
 8001072:	4619      	mov	r1, r3
 8001074:	f004 fb4c 	bl	8005710 <_test_assert>
 8001078:	4603      	mov	r3, r0
 800107a:	2b00      	cmp	r3, #0
 800107c:	f040 80a8 	bne.w	80011d0 <queues2_execute.lto_priv.52+0x280>
  test_assert_lock(7, chOQIsFullI(&oq), "not full");
 8001080:	f001 fd9e 	bl	8002bc0 <chSysLock.lto_priv.155>
 8001084:	4853      	ldr	r0, [pc, #332]	; (80011d4 <queues2_execute.lto_priv.52+0x284>)
 8001086:	f001 fe5b 	bl	8002d40 <chOQIsFullI.lto_priv.163>
 800108a:	4603      	mov	r3, r0
 800108c:	2007      	movs	r0, #7
 800108e:	4619      	mov	r1, r3
 8001090:	f004 fb3e 	bl	8005710 <_test_assert>
 8001094:	4603      	mov	r3, r0
 8001096:	2b00      	cmp	r3, #0
 8001098:	d002      	beq.n	80010a0 <queues2_execute.lto_priv.52+0x150>
 800109a:	f001 fd99 	bl	8002bd0 <chSysUnlock.lto_priv.152>
 800109e:	e097      	b.n	80011d0 <queues2_execute.lto_priv.52+0x280>
 80010a0:	f001 fd96 	bl	8002bd0 <chSysUnlock.lto_priv.152>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 80010a4:	4b4d      	ldr	r3, [pc, #308]	; (80011dc <queues2_execute.lto_priv.52+0x28c>)
 80010a6:	681c      	ldr	r4, [r3, #0]
 80010a8:	f001 fdba 	bl	8002c20 <chThdGetPriorityX.lto_priv.150>
 80010ac:	4603      	mov	r3, r0
 80010ae:	1c5a      	adds	r2, r3, #1
 80010b0:	2300      	movs	r3, #0
 80010b2:	9300      	str	r3, [sp, #0]
 80010b4:	4620      	mov	r0, r4
 80010b6:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80010ba:	4b49      	ldr	r3, [pc, #292]	; (80011e0 <queues2_execute.lto_priv.52+0x290>)
 80010bc:	f00b fda0 	bl	800cc00 <chThdCreateStatic>
 80010c0:	4602      	mov	r2, r0
 80010c2:	4b48      	ldr	r3, [pc, #288]	; (80011e4 <queues2_execute.lto_priv.52+0x294>)
 80010c4:	601a      	str	r2, [r3, #0]
  test_assert_lock(8, chOQGetFullI(&oq) == TEST_QUEUES_SIZE, "not empty");
 80010c6:	f001 fd7b 	bl	8002bc0 <chSysLock.lto_priv.155>
 80010ca:	4842      	ldr	r0, [pc, #264]	; (80011d4 <queues2_execute.lto_priv.52+0x284>)
 80010cc:	f001 fe00 	bl	8002cd0 <chOQGetFullI.lto_priv.164>
 80010d0:	4603      	mov	r3, r0
 80010d2:	2b04      	cmp	r3, #4
 80010d4:	bf0c      	ite	eq
 80010d6:	2301      	moveq	r3, #1
 80010d8:	2300      	movne	r3, #0
 80010da:	b2db      	uxtb	r3, r3
 80010dc:	2008      	movs	r0, #8
 80010de:	4619      	mov	r1, r3
 80010e0:	f004 fb16 	bl	8005710 <_test_assert>
 80010e4:	4603      	mov	r3, r0
 80010e6:	2b00      	cmp	r3, #0
 80010e8:	d002      	beq.n	80010f0 <queues2_execute.lto_priv.52+0x1a0>
 80010ea:	f001 fd71 	bl	8002bd0 <chSysUnlock.lto_priv.152>
 80010ee:	e06f      	b.n	80011d0 <queues2_execute.lto_priv.52+0x280>
 80010f0:	f001 fd6e 	bl	8002bd0 <chSysUnlock.lto_priv.152>
  test_wait_threads();
 80010f4:	f004 fb8c 	bl	8005810 <test_wait_threads>

  /* Testing reset */
  chSysLock();
 80010f8:	f001 fd62 	bl	8002bc0 <chSysLock.lto_priv.155>
  chOQResetI(&oq);
 80010fc:	4835      	ldr	r0, [pc, #212]	; (80011d4 <queues2_execute.lto_priv.52+0x284>)
 80010fe:	f007 fa07 	bl	8008510 <chOQResetI>
  chSysUnlock();
 8001102:	f001 fd65 	bl	8002bd0 <chSysUnlock.lto_priv.152>
  test_assert_lock(9, chOQGetFullI(&oq) == 0, "still full");
 8001106:	f001 fd5b 	bl	8002bc0 <chSysLock.lto_priv.155>
 800110a:	4832      	ldr	r0, [pc, #200]	; (80011d4 <queues2_execute.lto_priv.52+0x284>)
 800110c:	f001 fde0 	bl	8002cd0 <chOQGetFullI.lto_priv.164>
 8001110:	4603      	mov	r3, r0
 8001112:	2b00      	cmp	r3, #0
 8001114:	bf0c      	ite	eq
 8001116:	2301      	moveq	r3, #1
 8001118:	2300      	movne	r3, #0
 800111a:	b2db      	uxtb	r3, r3
 800111c:	2009      	movs	r0, #9
 800111e:	4619      	mov	r1, r3
 8001120:	f004 faf6 	bl	8005710 <_test_assert>
 8001124:	4603      	mov	r3, r0
 8001126:	2b00      	cmp	r3, #0
 8001128:	d002      	beq.n	8001130 <queues2_execute.lto_priv.52+0x1e0>
 800112a:	f001 fd51 	bl	8002bd0 <chSysUnlock.lto_priv.152>
 800112e:	e04f      	b.n	80011d0 <queues2_execute.lto_priv.52+0x280>
 8001130:	f001 fd4e 	bl	8002bd0 <chSysUnlock.lto_priv.152>

  /* Partial writes */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8001134:	4b29      	ldr	r3, [pc, #164]	; (80011dc <queues2_execute.lto_priv.52+0x28c>)
 8001136:	685b      	ldr	r3, [r3, #4]
 8001138:	4826      	ldr	r0, [pc, #152]	; (80011d4 <queues2_execute.lto_priv.52+0x284>)
 800113a:	4619      	mov	r1, r3
 800113c:	2202      	movs	r2, #2
 800113e:	2300      	movs	r3, #0
 8001140:	f007 fa7e 	bl	8008640 <chOQWriteTimeout>
 8001144:	9003      	str	r0, [sp, #12]
  test_assert(10, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 8001146:	9b03      	ldr	r3, [sp, #12]
 8001148:	2b02      	cmp	r3, #2
 800114a:	bf0c      	ite	eq
 800114c:	2301      	moveq	r3, #1
 800114e:	2300      	movne	r3, #0
 8001150:	b2db      	uxtb	r3, r3
 8001152:	200a      	movs	r0, #10
 8001154:	4619      	mov	r1, r3
 8001156:	f004 fadb 	bl	8005710 <_test_assert>
 800115a:	4603      	mov	r3, r0
 800115c:	2b00      	cmp	r3, #0
 800115e:	d137      	bne.n	80011d0 <queues2_execute.lto_priv.52+0x280>
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8001160:	4b1e      	ldr	r3, [pc, #120]	; (80011dc <queues2_execute.lto_priv.52+0x28c>)
 8001162:	685b      	ldr	r3, [r3, #4]
 8001164:	481b      	ldr	r0, [pc, #108]	; (80011d4 <queues2_execute.lto_priv.52+0x284>)
 8001166:	4619      	mov	r1, r3
 8001168:	2202      	movs	r2, #2
 800116a:	2300      	movs	r3, #0
 800116c:	f007 fa68 	bl	8008640 <chOQWriteTimeout>
 8001170:	9003      	str	r0, [sp, #12]
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 8001172:	9b03      	ldr	r3, [sp, #12]
 8001174:	2b02      	cmp	r3, #2
 8001176:	bf0c      	ite	eq
 8001178:	2301      	moveq	r3, #1
 800117a:	2300      	movne	r3, #0
 800117c:	b2db      	uxtb	r3, r3
 800117e:	200b      	movs	r0, #11
 8001180:	4619      	mov	r1, r3
 8001182:	f004 fac5 	bl	8005710 <_test_assert>
 8001186:	4603      	mov	r3, r0
 8001188:	2b00      	cmp	r3, #0
 800118a:	d121      	bne.n	80011d0 <queues2_execute.lto_priv.52+0x280>
  test_assert_lock(12, chOQIsFullI(&oq), "not full");
 800118c:	f001 fd18 	bl	8002bc0 <chSysLock.lto_priv.155>
 8001190:	4810      	ldr	r0, [pc, #64]	; (80011d4 <queues2_execute.lto_priv.52+0x284>)
 8001192:	f001 fdd5 	bl	8002d40 <chOQIsFullI.lto_priv.163>
 8001196:	4603      	mov	r3, r0
 8001198:	200c      	movs	r0, #12
 800119a:	4619      	mov	r1, r3
 800119c:	f004 fab8 	bl	8005710 <_test_assert>
 80011a0:	4603      	mov	r3, r0
 80011a2:	2b00      	cmp	r3, #0
 80011a4:	d002      	beq.n	80011ac <queues2_execute.lto_priv.52+0x25c>
 80011a6:	f001 fd13 	bl	8002bd0 <chSysUnlock.lto_priv.152>
 80011aa:	e011      	b.n	80011d0 <queues2_execute.lto_priv.52+0x280>
 80011ac:	f001 fd10 	bl	8002bd0 <chSysUnlock.lto_priv.152>

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
 80011b0:	4808      	ldr	r0, [pc, #32]	; (80011d4 <queues2_execute.lto_priv.52+0x284>)
 80011b2:	2100      	movs	r1, #0
 80011b4:	220a      	movs	r2, #10
 80011b6:	f007 f9cb 	bl	8008550 <chOQPutTimeout>
 80011ba:	4603      	mov	r3, r0
 80011bc:	f1b3 3fff 	cmp.w	r3, #4294967295
 80011c0:	bf0c      	ite	eq
 80011c2:	2301      	moveq	r3, #1
 80011c4:	2300      	movne	r3, #0
 80011c6:	b2db      	uxtb	r3, r3
 80011c8:	200d      	movs	r0, #13
 80011ca:	4619      	mov	r1, r3
 80011cc:	f004 faa0 	bl	8005710 <_test_assert>
}
 80011d0:	b006      	add	sp, #24
 80011d2:	bd10      	pop	{r4, pc}
 80011d4:	200008c8 	.word	0x200008c8
 80011d8:	0800d7b0 	.word	0x0800d7b0
 80011dc:	0800e420 	.word	0x0800e420
 80011e0:	08000f31 	.word	0x08000f31
 80011e4:	20001bf8 	.word	0x20001bf8
	...

080011f0 <port_get_irq_status>:
/**
 * @brief   Returns a word encoding the current interrupts status.
 *
 * @return              The interrupts status.
 */
static inline syssts_t port_get_irq_status(void) {
 80011f0:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80011f2:	f3ef 8311 	mrs	r3, BASEPRI
 80011f6:	9300      	str	r3, [sp, #0]
  return(result);
 80011f8:	9b00      	ldr	r3, [sp, #0]
  syssts_t sts;

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  sts = (syssts_t)__get_BASEPRI();
 80011fa:	9301      	str	r3, [sp, #4]
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  sts = (syssts_t)__get_PRIMASK();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
  return sts;
 80011fc:	9b01      	ldr	r3, [sp, #4]
}
 80011fe:	4618      	mov	r0, r3
 8001200:	b002      	add	sp, #8
 8001202:	4770      	bx	lr
	...

08001210 <port_irq_enabled>:
 *
 * @return              The interrupt status.
 * @retvel false        the word specified a disabled interrupts status.
 * @retvel true         the word specified an enabled interrupts status.
 */
static inline bool port_irq_enabled(syssts_t sts) {
 8001210:	b082      	sub	sp, #8
 8001212:	9001      	str	r0, [sp, #4]

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  return sts == (syssts_t)CORTEX_BASEPRI_DISABLED;
 8001214:	9b01      	ldr	r3, [sp, #4]
 8001216:	2b00      	cmp	r3, #0
 8001218:	bf0c      	ite	eq
 800121a:	2301      	moveq	r3, #1
 800121c:	2300      	movne	r3, #0
 800121e:	b2db      	uxtb	r3, r3
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  return (sts & (syssts_t)1) == (syssts_t)0;
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8001220:	4618      	mov	r0, r3
 8001222:	b002      	add	sp, #8
 8001224:	4770      	bx	lr
 8001226:	bf00      	nop
	...

08001230 <port_lock.lto_priv.160>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001230:	b082      	sub	sp, #8
 8001232:	2320      	movs	r3, #32
 8001234:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001236:	9b01      	ldr	r3, [sp, #4]
 8001238:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800123c:	b002      	add	sp, #8
 800123e:	4770      	bx	lr

08001240 <port_unlock.lto_priv.158>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001240:	b082      	sub	sp, #8
 8001242:	2300      	movs	r3, #0
 8001244:	9301      	str	r3, [sp, #4]
 8001246:	9b01      	ldr	r3, [sp, #4]
 8001248:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800124c:	b002      	add	sp, #8
 800124e:	4770      	bx	lr

08001250 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8001250:	b508      	push	{r3, lr}

  port_lock();
 8001252:	f7ff ffed 	bl	8001230 <port_lock.lto_priv.160>
}
 8001256:	bd08      	pop	{r3, pc}
	...

08001260 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8001260:	b508      	push	{r3, lr}

  port_unlock();
 8001262:	f7ff ffed 	bl	8001240 <port_unlock.lto_priv.158>
}
 8001266:	bd08      	pop	{r3, pc}
	...

08001270 <port_disable>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001270:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 8001272:	4770      	bx	lr
	...

08001280 <port_suspend>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 * @note    Interrupt sources above kernel level remains enabled.
 * @note    In this port it raises/lowers the base priority to kernel level.
 */
static inline void port_suspend(void) {
 8001280:	b082      	sub	sp, #8
 8001282:	2320      	movs	r3, #32
 8001284:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001286:	9b01      	ldr	r3, [sp, #4]
 8001288:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800128c:	b662      	cpsie	i
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
  __enable_irq();
#else
  __disable_irq();
#endif
}
 800128e:	b002      	add	sp, #8
 8001290:	4770      	bx	lr
 8001292:	bf00      	nop
	...

080012a0 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 80012a0:	b082      	sub	sp, #8
 80012a2:	2300      	movs	r3, #0
 80012a4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80012a6:	9b01      	ldr	r3, [sp, #4]
 80012a8:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80012ac:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 80012ae:	b002      	add	sp, #8
 80012b0:	4770      	bx	lr
 80012b2:	bf00      	nop
	...

080012c0 <chSysDisable>:
 *          hardware priority.
 * @note    Do not invoke this API from within a kernel lock.
 *
 * @special
 */
static inline void chSysDisable(void) {
 80012c0:	b508      	push	{r3, lr}

  port_disable();
 80012c2:	f7ff ffd5 	bl	8001270 <port_disable>
  _dbg_check_disable();
 80012c6:	f00a fd23 	bl	800bd10 <_dbg_check_disable>
}
 80012ca:	bd08      	pop	{r3, pc}
 80012cc:	0000      	movs	r0, r0
	...

080012d0 <chSysSuspend>:
 * @note    This API is no replacement for @p chSysLock(), the @p chSysLock()
 *          could do more than just disable the interrupts.
 *
 * @special
 */
static inline void chSysSuspend(void) {
 80012d0:	b508      	push	{r3, lr}

  port_suspend();
 80012d2:	f7ff ffd5 	bl	8001280 <port_suspend>
  _dbg_check_suspend();
 80012d6:	f00a fd33 	bl	800bd40 <_dbg_check_suspend>
}
 80012da:	bd08      	pop	{r3, pc}
 80012dc:	0000      	movs	r0, r0
	...

080012e0 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 80012e0:	b508      	push	{r3, lr}

  _dbg_check_enable();
 80012e2:	f00a fd45 	bl	800bd70 <_dbg_check_enable>
  port_enable();
 80012e6:	f7ff ffdb 	bl	80012a0 <port_enable>
}
 80012ea:	bd08      	pop	{r3, pc}
 80012ec:	0000      	movs	r0, r0
	...

080012f0 <chSysLock.lto_priv.156>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80012f0:	b508      	push	{r3, lr}

  port_lock();
 80012f2:	f7ff ff9d 	bl	8001230 <port_lock.lto_priv.160>
  _stats_start_measure_crit_thd();
 80012f6:	f009 f8a3 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 80012fa:	f00a fd51 	bl	800bda0 <_dbg_check_lock>
}
 80012fe:	bd08      	pop	{r3, pc}

08001300 <chSysUnlock.lto_priv.153>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001300:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8001302:	f00a fd65 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8001306:	f009 f8a3 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800130a:	4b09      	ldr	r3, [pc, #36]	; (8001330 <chSysUnlock.lto_priv.153+0x30>)
 800130c:	681b      	ldr	r3, [r3, #0]
 800130e:	4a08      	ldr	r2, [pc, #32]	; (8001330 <chSysUnlock.lto_priv.153+0x30>)
 8001310:	4293      	cmp	r3, r2
 8001312:	d00a      	beq.n	800132a <chSysUnlock.lto_priv.153+0x2a>
 8001314:	4b06      	ldr	r3, [pc, #24]	; (8001330 <chSysUnlock.lto_priv.153+0x30>)
 8001316:	699b      	ldr	r3, [r3, #24]
 8001318:	689a      	ldr	r2, [r3, #8]
 800131a:	4b05      	ldr	r3, [pc, #20]	; (8001330 <chSysUnlock.lto_priv.153+0x30>)
 800131c:	681b      	ldr	r3, [r3, #0]
 800131e:	689b      	ldr	r3, [r3, #8]
 8001320:	429a      	cmp	r2, r3
 8001322:	d202      	bcs.n	800132a <chSysUnlock.lto_priv.153+0x2a>
 8001324:	4803      	ldr	r0, [pc, #12]	; (8001334 <chSysUnlock.lto_priv.153+0x34>)
 8001326:	f00a fbe3 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800132a:	f7ff ff89 	bl	8001240 <port_unlock.lto_priv.158>
}
 800132e:	bd08      	pop	{r3, pc}
 8001330:	20000d30 	.word	0x20000d30
 8001334:	0800e770 	.word	0x0800e770
	...

08001340 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8001340:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8001342:	f7ff ff85 	bl	8001250 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
 8001346:	f009 f88b 	bl	800a460 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 800134a:	f00a fd59 	bl	800be00 <_dbg_check_lock_from_isr>
}
 800134e:	bd08      	pop	{r3, pc}

08001350 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8001350:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 8001352:	f00a fd6d 	bl	800be30 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8001356:	f009 f88b 	bl	800a470 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 800135a:	f7ff ff81 	bl	8001260 <port_unlock_from_isr>
}
 800135e:	bd08      	pop	{r3, pc}

08001360 <chSysUnconditionalLock>:
 * @note    Can be called without previous knowledge of the current lock state.
 *          The final state is "s-locked".
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {
 8001360:	b508      	push	{r3, lr}

  if (port_irq_enabled(port_get_irq_status())) {
 8001362:	f7ff ff45 	bl	80011f0 <port_get_irq_status>
 8001366:	4603      	mov	r3, r0
 8001368:	4618      	mov	r0, r3
 800136a:	f7ff ff51 	bl	8001210 <port_irq_enabled>
 800136e:	4603      	mov	r3, r0
 8001370:	2b00      	cmp	r3, #0
 8001372:	d001      	beq.n	8001378 <chSysUnconditionalLock+0x18>
    chSysLock();
 8001374:	f7ff ffbc 	bl	80012f0 <chSysLock.lto_priv.156>
  }
}
 8001378:	bd08      	pop	{r3, pc}
 800137a:	bf00      	nop
 800137c:	0000      	movs	r0, r0
	...

08001380 <chSysUnconditionalUnlock>:
 * @note    Can be called without previous knowledge of the current lock state.
 *          The final state is "normal".
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {
 8001380:	b508      	push	{r3, lr}

  if (!port_irq_enabled(port_get_irq_status())) {
 8001382:	f7ff ff35 	bl	80011f0 <port_get_irq_status>
 8001386:	4603      	mov	r3, r0
 8001388:	4618      	mov	r0, r3
 800138a:	f7ff ff41 	bl	8001210 <port_irq_enabled>
 800138e:	4603      	mov	r3, r0
 8001390:	f083 0301 	eor.w	r3, r3, #1
 8001394:	b2db      	uxtb	r3, r3
 8001396:	2b00      	cmp	r3, #0
 8001398:	d001      	beq.n	800139e <chSysUnconditionalUnlock+0x1e>
    chSysUnlock();
 800139a:	f7ff ffb1 	bl	8001300 <chSysUnlock.lto_priv.153>
  }
}
 800139e:	bd08      	pop	{r3, pc}

080013a0 <chVTObjectInit>:
 *
 * @param[out] vtp      the @p virtual_timer_t structure pointer
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {
 80013a0:	b082      	sub	sp, #8
 80013a2:	9001      	str	r0, [sp, #4]

  vtp->vt_func = NULL;
 80013a4:	9b01      	ldr	r3, [sp, #4]
 80013a6:	2200      	movs	r2, #0
 80013a8:	60da      	str	r2, [r3, #12]
}
 80013aa:	b002      	add	sp, #8
 80013ac:	4770      	bx	lr
 80013ae:	bf00      	nop

080013b0 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 80013b0:	b500      	push	{lr}
 80013b2:	b083      	sub	sp, #12
 80013b4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 80013b6:	f00a fd93 	bl	800bee0 <chDbgCheckClassI>

  return (bool)(vtp->vt_func != NULL);
 80013ba:	9b01      	ldr	r3, [sp, #4]
 80013bc:	68db      	ldr	r3, [r3, #12]
 80013be:	2b00      	cmp	r3, #0
 80013c0:	bf14      	ite	ne
 80013c2:	2301      	movne	r3, #1
 80013c4:	2300      	moveq	r3, #0
 80013c6:	b2db      	uxtb	r3, r3
}
 80013c8:	4618      	mov	r0, r3
 80013ca:	b003      	add	sp, #12
 80013cc:	f85d fb04 	ldr.w	pc, [sp], #4

080013d0 <chVTIsArmed>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @api
 */
static inline bool chVTIsArmed(virtual_timer_t *vtp) {
 80013d0:	b500      	push	{lr}
 80013d2:	b085      	sub	sp, #20
 80013d4:	9001      	str	r0, [sp, #4]
  bool b;

  chSysLock();
 80013d6:	f7ff ff8b 	bl	80012f0 <chSysLock.lto_priv.156>
  b = chVTIsArmedI(vtp);
 80013da:	9801      	ldr	r0, [sp, #4]
 80013dc:	f7ff ffe8 	bl	80013b0 <chVTIsArmedI>
 80013e0:	4603      	mov	r3, r0
 80013e2:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
 80013e6:	f7ff ff8b 	bl	8001300 <chSysUnlock.lto_priv.153>

  return b;
 80013ea:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 80013ee:	4618      	mov	r0, r3
 80013f0:	b005      	add	sp, #20
 80013f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80013f6:	bf00      	nop
	...

08001400 <chVTResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
 8001400:	b500      	push	{lr}
 8001402:	b083      	sub	sp, #12
 8001404:	9001      	str	r0, [sp, #4]

  if (chVTIsArmedI(vtp)) {
 8001406:	9801      	ldr	r0, [sp, #4]
 8001408:	f7ff ffd2 	bl	80013b0 <chVTIsArmedI>
 800140c:	4603      	mov	r3, r0
 800140e:	2b00      	cmp	r3, #0
 8001410:	d002      	beq.n	8001418 <chVTResetI+0x18>
    chVTDoResetI(vtp);
 8001412:	9801      	ldr	r0, [sp, #4]
 8001414:	f00a febc 	bl	800c190 <chVTDoResetI>
  }
}
 8001418:	b003      	add	sp, #12
 800141a:	f85d fb04 	ldr.w	pc, [sp], #4
 800141e:	bf00      	nop

08001420 <chVTSetI>:
 *                      function
 *
 * @iclass
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {
 8001420:	b500      	push	{lr}
 8001422:	b085      	sub	sp, #20
 8001424:	9003      	str	r0, [sp, #12]
 8001426:	9102      	str	r1, [sp, #8]
 8001428:	9201      	str	r2, [sp, #4]
 800142a:	9300      	str	r3, [sp, #0]

  chVTResetI(vtp);
 800142c:	9803      	ldr	r0, [sp, #12]
 800142e:	f7ff ffe7 	bl	8001400 <chVTResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
 8001432:	9803      	ldr	r0, [sp, #12]
 8001434:	9902      	ldr	r1, [sp, #8]
 8001436:	9a01      	ldr	r2, [sp, #4]
 8001438:	9b00      	ldr	r3, [sp, #0]
 800143a:	f00a fe19 	bl	800c070 <chVTDoSetI>
}
 800143e:	b005      	add	sp, #20
 8001440:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001450 <chVTSet>:
 *                      function
 *
 * @api
 */
static inline void chVTSet(virtual_timer_t *vtp, systime_t delay,
                           vtfunc_t vtfunc, void *par) {
 8001450:	b500      	push	{lr}
 8001452:	b085      	sub	sp, #20
 8001454:	9003      	str	r0, [sp, #12]
 8001456:	9102      	str	r1, [sp, #8]
 8001458:	9201      	str	r2, [sp, #4]
 800145a:	9300      	str	r3, [sp, #0]

  chSysLock();
 800145c:	f7ff ff48 	bl	80012f0 <chSysLock.lto_priv.156>
  chVTSetI(vtp, delay, vtfunc, par);
 8001460:	9803      	ldr	r0, [sp, #12]
 8001462:	9902      	ldr	r1, [sp, #8]
 8001464:	9a01      	ldr	r2, [sp, #4]
 8001466:	9b00      	ldr	r3, [sp, #0]
 8001468:	f7ff ffda 	bl	8001420 <chVTSetI>
  chSysUnlock();
 800146c:	f7ff ff48 	bl	8001300 <chSysUnlock.lto_priv.153>
}
 8001470:	b005      	add	sp, #20
 8001472:	f85d fb04 	ldr.w	pc, [sp], #4
 8001476:	bf00      	nop
	...

08001480 <vtcb>:
 *
 * <h2>Description</h2>
 * The critical zones API is invoked for coverage.
 */

static void vtcb(void *p) {
 8001480:	b500      	push	{lr}
 8001482:	b085      	sub	sp, #20
 8001484:	9001      	str	r0, [sp, #4]
  syssts_t sts;

  (void)p;

  /* Testing normal case.*/
  chSysLockFromISR();
 8001486:	f7ff ff5b 	bl	8001340 <chSysLockFromISR>
  chSysUnlockFromISR();
 800148a:	f7ff ff61 	bl	8001350 <chSysUnlockFromISR>

  /* Reentrant case.*/
  chSysLockFromISR();
 800148e:	f7ff ff57 	bl	8001340 <chSysLockFromISR>
  sts = chSysGetStatusAndLockX();
 8001492:	f00a fbcd 	bl	800bc30 <chSysGetStatusAndLockX>
 8001496:	9003      	str	r0, [sp, #12]
  chSysRestoreStatusX(sts);
 8001498:	9803      	ldr	r0, [sp, #12]
 800149a:	f00a fbe9 	bl	800bc70 <chSysRestoreStatusX>
  chSysUnlockFromISR();
 800149e:	f7ff ff57 	bl	8001350 <chSysUnlockFromISR>
}
 80014a2:	b005      	add	sp, #20
 80014a4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080014b0 <sys1_execute.lto_priv.50>:

static void sys1_execute(void) {
 80014b0:	b500      	push	{lr}
 80014b2:	b087      	sub	sp, #28
  syssts_t sts;
  virtual_timer_t vt;

  /* Testing normal case.*/
  sts = chSysGetStatusAndLockX();
 80014b4:	f00a fbbc 	bl	800bc30 <chSysGetStatusAndLockX>
 80014b8:	9005      	str	r0, [sp, #20]
  chSysRestoreStatusX(sts);
 80014ba:	9805      	ldr	r0, [sp, #20]
 80014bc:	f00a fbd8 	bl	800bc70 <chSysRestoreStatusX>

  /* Reentrant case.*/
  chSysLock();
 80014c0:	f7ff ff16 	bl	80012f0 <chSysLock.lto_priv.156>
  sts = chSysGetStatusAndLockX();
 80014c4:	f00a fbb4 	bl	800bc30 <chSysGetStatusAndLockX>
 80014c8:	9005      	str	r0, [sp, #20]
  chSysRestoreStatusX(sts);
 80014ca:	9805      	ldr	r0, [sp, #20]
 80014cc:	f00a fbd0 	bl	800bc70 <chSysRestoreStatusX>
  chSysUnlock();
 80014d0:	f7ff ff16 	bl	8001300 <chSysUnlock.lto_priv.153>

  /* Unconditional lock.*/
  chSysUnconditionalLock();
 80014d4:	f7ff ff44 	bl	8001360 <chSysUnconditionalLock>
  chSysUnconditionalLock();
 80014d8:	f7ff ff42 	bl	8001360 <chSysUnconditionalLock>
  chSysUnlock();
 80014dc:	f7ff ff10 	bl	8001300 <chSysUnlock.lto_priv.153>

  /* Unconditional unlock.*/
  chSysLock();
 80014e0:	f7ff ff06 	bl	80012f0 <chSysLock.lto_priv.156>
  chSysUnconditionalUnlock();
 80014e4:	f7ff ff4c 	bl	8001380 <chSysUnconditionalUnlock>
  chSysUnconditionalUnlock();
 80014e8:	f7ff ff4a 	bl	8001380 <chSysUnconditionalUnlock>

  /*/Testing from ISR context using a virtual timer.*/
  chVTObjectInit(&vt);
 80014ec:	466b      	mov	r3, sp
 80014ee:	4618      	mov	r0, r3
 80014f0:	f7ff ff56 	bl	80013a0 <chVTObjectInit>
  chVTSet(&vt, 1, vtcb, NULL);
 80014f4:	466b      	mov	r3, sp
 80014f6:	4618      	mov	r0, r3
 80014f8:	2101      	movs	r1, #1
 80014fa:	4a10      	ldr	r2, [pc, #64]	; (800153c <sys1_execute.lto_priv.50+0x8c>)
 80014fc:	2300      	movs	r3, #0
 80014fe:	f7ff ffa7 	bl	8001450 <chVTSet>
  chThdSleep(10);
 8001502:	200a      	movs	r0, #10
 8001504:	f00b fc0c 	bl	800cd20 <chThdSleep>

  test_assert(1, chVTIsArmed(&vt) == false, "timer still armed");
 8001508:	466b      	mov	r3, sp
 800150a:	4618      	mov	r0, r3
 800150c:	f7ff ff60 	bl	80013d0 <chVTIsArmed>
 8001510:	4603      	mov	r3, r0
 8001512:	2b00      	cmp	r3, #0
 8001514:	bf14      	ite	ne
 8001516:	2301      	movne	r3, #1
 8001518:	2300      	moveq	r3, #0
 800151a:	b2db      	uxtb	r3, r3
 800151c:	f083 0301 	eor.w	r3, r3, #1
 8001520:	b2db      	uxtb	r3, r3
 8001522:	f003 0301 	and.w	r3, r3, #1
 8001526:	b2db      	uxtb	r3, r3
 8001528:	2001      	movs	r0, #1
 800152a:	4619      	mov	r1, r3
 800152c:	f004 f8f0 	bl	8005710 <_test_assert>
 8001530:	4603      	mov	r3, r0
 8001532:	2b00      	cmp	r3, #0
}
 8001534:	b007      	add	sp, #28
 8001536:	f85d fb04 	ldr.w	pc, [sp], #4
 800153a:	bf00      	nop
 800153c:	08001481 	.word	0x08001481

08001540 <sys2_execute.lto_priv.49>:
 *
 * <h2>Description</h2>
 * The interrupts handling API is invoked for coverage.
 */

static void sys2_execute(void) {
 8001540:	b508      	push	{r3, lr}

  chSysSuspend();
 8001542:	f7ff fec5 	bl	80012d0 <chSysSuspend>
  chSysDisable();
 8001546:	f7ff febb 	bl	80012c0 <chSysDisable>
  chSysSuspend();
 800154a:	f7ff fec1 	bl	80012d0 <chSysSuspend>
  chSysEnable();
 800154e:	f7ff fec7 	bl	80012e0 <chSysEnable>
}
 8001552:	bd08      	pop	{r3, pc}
	...

08001560 <sys3_execute.lto_priv.48>:
 * <h2>Description</h2>
 * The chSysIntegrityCheckI() API is invoked in order to asses the state of the
 * system data structures.
 */

static void sys3_execute(void) {
 8001560:	b500      	push	{lr}
 8001562:	b083      	sub	sp, #12
  bool result;

  chSysLock();
 8001564:	f7ff fec4 	bl	80012f0 <chSysLock.lto_priv.156>
  result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 8001568:	2001      	movs	r0, #1
 800156a:	f00a fad1 	bl	800bb10 <chSysIntegrityCheckI>
 800156e:	4603      	mov	r3, r0
 8001570:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 8001574:	f7ff fec4 	bl	8001300 <chSysUnlock.lto_priv.153>
  test_assert(1, result == false, "ready list check failed");
 8001578:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800157c:	2b00      	cmp	r3, #0
 800157e:	bf14      	ite	ne
 8001580:	2301      	movne	r3, #1
 8001582:	2300      	moveq	r3, #0
 8001584:	b2db      	uxtb	r3, r3
 8001586:	f083 0301 	eor.w	r3, r3, #1
 800158a:	b2db      	uxtb	r3, r3
 800158c:	f003 0301 	and.w	r3, r3, #1
 8001590:	b2db      	uxtb	r3, r3
 8001592:	2001      	movs	r0, #1
 8001594:	4619      	mov	r1, r3
 8001596:	f004 f8bb 	bl	8005710 <_test_assert>
 800159a:	4603      	mov	r3, r0
 800159c:	2b00      	cmp	r3, #0
 800159e:	d156      	bne.n	800164e <sys3_execute.lto_priv.48+0xee>

  chSysLock();
 80015a0:	f7ff fea6 	bl	80012f0 <chSysLock.lto_priv.156>
  result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 80015a4:	2002      	movs	r0, #2
 80015a6:	f00a fab3 	bl	800bb10 <chSysIntegrityCheckI>
 80015aa:	4603      	mov	r3, r0
 80015ac:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 80015b0:	f7ff fea6 	bl	8001300 <chSysUnlock.lto_priv.153>
  test_assert(2, result == false, "virtual timers list check failed");
 80015b4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80015b8:	2b00      	cmp	r3, #0
 80015ba:	bf14      	ite	ne
 80015bc:	2301      	movne	r3, #1
 80015be:	2300      	moveq	r3, #0
 80015c0:	b2db      	uxtb	r3, r3
 80015c2:	f083 0301 	eor.w	r3, r3, #1
 80015c6:	b2db      	uxtb	r3, r3
 80015c8:	f003 0301 	and.w	r3, r3, #1
 80015cc:	b2db      	uxtb	r3, r3
 80015ce:	2002      	movs	r0, #2
 80015d0:	4619      	mov	r1, r3
 80015d2:	f004 f89d 	bl	8005710 <_test_assert>
 80015d6:	4603      	mov	r3, r0
 80015d8:	2b00      	cmp	r3, #0
 80015da:	d138      	bne.n	800164e <sys3_execute.lto_priv.48+0xee>

  chSysLock();
 80015dc:	f7ff fe88 	bl	80012f0 <chSysLock.lto_priv.156>
  result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 80015e0:	2004      	movs	r0, #4
 80015e2:	f00a fa95 	bl	800bb10 <chSysIntegrityCheckI>
 80015e6:	4603      	mov	r3, r0
 80015e8:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 80015ec:	f7ff fe88 	bl	8001300 <chSysUnlock.lto_priv.153>
  test_assert(3, result == false, "registry list check failed");
 80015f0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80015f4:	2b00      	cmp	r3, #0
 80015f6:	bf14      	ite	ne
 80015f8:	2301      	movne	r3, #1
 80015fa:	2300      	moveq	r3, #0
 80015fc:	b2db      	uxtb	r3, r3
 80015fe:	f083 0301 	eor.w	r3, r3, #1
 8001602:	b2db      	uxtb	r3, r3
 8001604:	f003 0301 	and.w	r3, r3, #1
 8001608:	b2db      	uxtb	r3, r3
 800160a:	2003      	movs	r0, #3
 800160c:	4619      	mov	r1, r3
 800160e:	f004 f87f 	bl	8005710 <_test_assert>
 8001612:	4603      	mov	r3, r0
 8001614:	2b00      	cmp	r3, #0
 8001616:	d11a      	bne.n	800164e <sys3_execute.lto_priv.48+0xee>

  chSysLock();
 8001618:	f7ff fe6a 	bl	80012f0 <chSysLock.lto_priv.156>
  result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 800161c:	2008      	movs	r0, #8
 800161e:	f00a fa77 	bl	800bb10 <chSysIntegrityCheckI>
 8001622:	4603      	mov	r3, r0
 8001624:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 8001628:	f7ff fe6a 	bl	8001300 <chSysUnlock.lto_priv.153>
  test_assert(4, result == false, "port layer check failed");
 800162c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8001630:	2b00      	cmp	r3, #0
 8001632:	bf14      	ite	ne
 8001634:	2301      	movne	r3, #1
 8001636:	2300      	moveq	r3, #0
 8001638:	b2db      	uxtb	r3, r3
 800163a:	f083 0301 	eor.w	r3, r3, #1
 800163e:	b2db      	uxtb	r3, r3
 8001640:	f003 0301 	and.w	r3, r3, #1
 8001644:	b2db      	uxtb	r3, r3
 8001646:	2004      	movs	r0, #4
 8001648:	4619      	mov	r1, r3
 800164a:	f004 f861 	bl	8005710 <_test_assert>
}
 800164e:	b003      	add	sp, #12
 8001650:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001660 <port_lock.lto_priv.161>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001660:	b082      	sub	sp, #8
 8001662:	2320      	movs	r3, #32
 8001664:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001666:	9b01      	ldr	r3, [sp, #4]
 8001668:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800166c:	b002      	add	sp, #8
 800166e:	4770      	bx	lr

08001670 <port_unlock.lto_priv.159>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001670:	b082      	sub	sp, #8
 8001672:	2300      	movs	r3, #0
 8001674:	9301      	str	r3, [sp, #4]
 8001676:	9b01      	ldr	r3, [sp, #4]
 8001678:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800167c:	b002      	add	sp, #8
 800167e:	4770      	bx	lr

08001680 <chSysLock.lto_priv.157>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001680:	b508      	push	{r3, lr}

  port_lock();
 8001682:	f7ff ffed 	bl	8001660 <port_lock.lto_priv.161>
  _stats_start_measure_crit_thd();
 8001686:	f008 fedb 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800168a:	f00a fb89 	bl	800bda0 <_dbg_check_lock>
}
 800168e:	bd08      	pop	{r3, pc}

08001690 <chSysUnlock.lto_priv.154>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001690:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8001692:	f00a fb9d 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8001696:	f008 fedb 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800169a:	4b09      	ldr	r3, [pc, #36]	; (80016c0 <chSysUnlock.lto_priv.154+0x30>)
 800169c:	681b      	ldr	r3, [r3, #0]
 800169e:	4a08      	ldr	r2, [pc, #32]	; (80016c0 <chSysUnlock.lto_priv.154+0x30>)
 80016a0:	4293      	cmp	r3, r2
 80016a2:	d00a      	beq.n	80016ba <chSysUnlock.lto_priv.154+0x2a>
 80016a4:	4b06      	ldr	r3, [pc, #24]	; (80016c0 <chSysUnlock.lto_priv.154+0x30>)
 80016a6:	699b      	ldr	r3, [r3, #24]
 80016a8:	689a      	ldr	r2, [r3, #8]
 80016aa:	4b05      	ldr	r3, [pc, #20]	; (80016c0 <chSysUnlock.lto_priv.154+0x30>)
 80016ac:	681b      	ldr	r3, [r3, #0]
 80016ae:	689b      	ldr	r3, [r3, #8]
 80016b0:	429a      	cmp	r2, r3
 80016b2:	d202      	bcs.n	80016ba <chSysUnlock.lto_priv.154+0x2a>
 80016b4:	4803      	ldr	r0, [pc, #12]	; (80016c4 <chSysUnlock.lto_priv.154+0x34>)
 80016b6:	f00a fa1b 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80016ba:	f7ff ffd9 	bl	8001670 <port_unlock.lto_priv.159>
}
 80016be:	bd08      	pop	{r3, pc}
 80016c0:	20000d30 	.word	0x20000d30
 80016c4:	0800e890 	.word	0x0800e890
	...

080016d0 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80016d0:	4b01      	ldr	r3, [pc, #4]	; (80016d8 <chThdGetSelfX+0x8>)
 80016d2:	699b      	ldr	r3, [r3, #24]
}
 80016d4:	4618      	mov	r0, r3
 80016d6:	4770      	bx	lr
 80016d8:	20000d30 	.word	0x20000d30
 80016dc:	00000000 	.word	0x00000000

080016e0 <chThdGetPriorityX.lto_priv.151>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 80016e0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 80016e2:	f7ff fff5 	bl	80016d0 <chThdGetSelfX>
 80016e6:	4603      	mov	r3, r0
 80016e8:	689b      	ldr	r3, [r3, #8]
}
 80016ea:	4618      	mov	r0, r3
 80016ec:	bd08      	pop	{r3, pc}
 80016ee:	bf00      	nop

080016f0 <chThdShouldTerminateX>:
 * @retval true         termination request pending.
 * @retval false        termination request not pending.
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {
 80016f0:	b508      	push	{r3, lr}

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 80016f2:	f7ff ffed 	bl	80016d0 <chThdGetSelfX>
 80016f6:	4603      	mov	r3, r0
 80016f8:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 80016fc:	f003 0304 	and.w	r3, r3, #4
 8001700:	2b00      	cmp	r3, #0
 8001702:	bf14      	ite	ne
 8001704:	2301      	movne	r3, #1
 8001706:	2300      	moveq	r3, #0
 8001708:	b2db      	uxtb	r3, r3
}
 800170a:	4618      	mov	r0, r3
 800170c:	bd08      	pop	{r3, pc}
 800170e:	bf00      	nop

08001710 <chMsgGet>:
 * @param[in] tp        pointer to the thread
 * @return              The message carried by the sender.
 *
 * @api
 */
static inline msg_t chMsgGet(thread_t *tp) {
 8001710:	b082      	sub	sp, #8
 8001712:	9001      	str	r0, [sp, #4]

  return tp->p_msg;
 8001714:	9b01      	ldr	r3, [sp, #4]
 8001716:	6b5b      	ldr	r3, [r3, #52]	; 0x34
}
 8001718:	4618      	mov	r0, r3
 800171a:	b002      	add	sp, #8
 800171c:	4770      	bx	lr
 800171e:	bf00      	nop

08001720 <chIQGet>:
 * @return              A byte value from the queue.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {
 8001720:	b500      	push	{lr}
 8001722:	b083      	sub	sp, #12
 8001724:	9001      	str	r0, [sp, #4]

  return chIQGetTimeout(iqp, TIME_INFINITE);
 8001726:	9801      	ldr	r0, [sp, #4]
 8001728:	f04f 31ff 	mov.w	r1, #4294967295
 800172c:	f008 fd10 	bl	800a150 <chIQGetTimeout>
 8001730:	4603      	mov	r3, r0
}
 8001732:	4618      	mov	r0, r3
 8001734:	b003      	add	sp, #12
 8001736:	f85d fb04 	ldr.w	pc, [sp], #4
 800173a:	bf00      	nop
 800173c:	0000      	movs	r0, r0
	...

08001740 <thread1>:
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
static mutex_t mtx1;
#endif

static THD_FUNCTION(thread1, p) {
 8001740:	b500      	push	{lr}
 8001742:	b083      	sub	sp, #12
 8001744:	9001      	str	r0, [sp, #4]

  chThdExit((msg_t)p);
 8001746:	9b01      	ldr	r3, [sp, #4]
 8001748:	4618      	mov	r0, r3
 800174a:	f00b fb19 	bl	800cd80 <chThdExit>
}
 800174e:	b003      	add	sp, #12
 8001750:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001760 <thread2.lto_priv.149>:

#if CH_CFG_USE_MESSAGES || defined(__DOXYGEN__)
static THD_FUNCTION(thread2, p) {
 8001760:	b500      	push	{lr}
 8001762:	b085      	sub	sp, #20
 8001764:	9001      	str	r0, [sp, #4]
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
 8001766:	f008 f8e3 	bl	8009930 <chMsgWait>
 800176a:	9003      	str	r0, [sp, #12]
    msg = chMsgGet(tp);
 800176c:	9803      	ldr	r0, [sp, #12]
 800176e:	f7ff ffcf 	bl	8001710 <chMsgGet>
 8001772:	9002      	str	r0, [sp, #8]
    chMsgRelease(tp, msg);
 8001774:	9803      	ldr	r0, [sp, #12]
 8001776:	9902      	ldr	r1, [sp, #8]
 8001778:	f008 f902 	bl	8009980 <chMsgRelease>
  } while (msg);
 800177c:	9b02      	ldr	r3, [sp, #8]
 800177e:	2b00      	cmp	r3, #0
 8001780:	d1f1      	bne.n	8001766 <thread2.lto_priv.149+0x6>
}
 8001782:	b005      	add	sp, #20
 8001784:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001790 <msg_loop_test>:

#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(thread_t *tp) {
 8001790:	b500      	push	{lr}
 8001792:	b085      	sub	sp, #20
 8001794:	9001      	str	r0, [sp, #4]

  uint32_t n = 0;
 8001796:	2300      	movs	r3, #0
 8001798:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 800179a:	f004 f861 	bl	8005860 <test_wait_tick>
  test_start_timer(1000);
 800179e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80017a2:	f004 f87d 	bl	80058a0 <test_start_timer>
  do {
    (void)chMsgSend(tp, 1);
 80017a6:	9801      	ldr	r0, [sp, #4]
 80017a8:	2101      	movs	r1, #1
 80017aa:	f008 f889 	bl	80098c0 <chMsgSend>
    n++;
 80017ae:	9b03      	ldr	r3, [sp, #12]
 80017b0:	3301      	adds	r3, #1
 80017b2:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80017b4:	4b07      	ldr	r3, [pc, #28]	; (80017d4 <msg_loop_test+0x44>)
 80017b6:	781b      	ldrb	r3, [r3, #0]
 80017b8:	f083 0301 	eor.w	r3, r3, #1
 80017bc:	b2db      	uxtb	r3, r3
 80017be:	2b00      	cmp	r3, #0
 80017c0:	d1f1      	bne.n	80017a6 <msg_loop_test+0x16>
  (void)chMsgSend(tp, 0);
 80017c2:	9801      	ldr	r0, [sp, #4]
 80017c4:	2100      	movs	r1, #0
 80017c6:	f008 f87b 	bl	80098c0 <chMsgSend>
  return n;
 80017ca:	9b03      	ldr	r3, [sp, #12]
}
 80017cc:	4618      	mov	r0, r3
 80017ce:	b005      	add	sp, #20
 80017d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80017d4:	20001c10 	.word	0x20001c10
	...

080017e0 <bmk1_execute.lto_priv.45>:
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
 80017e0:	b510      	push	{r4, lr}
 80017e2:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 80017e4:	4b15      	ldr	r3, [pc, #84]	; (800183c <bmk1_execute.lto_priv.45+0x5c>)
 80017e6:	681c      	ldr	r4, [r3, #0]
 80017e8:	f7ff ff7a 	bl	80016e0 <chThdGetPriorityX.lto_priv.151>
 80017ec:	4603      	mov	r3, r0
 80017ee:	1e5a      	subs	r2, r3, #1
 80017f0:	2300      	movs	r3, #0
 80017f2:	9300      	str	r3, [sp, #0]
 80017f4:	4620      	mov	r0, r4
 80017f6:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80017fa:	4b11      	ldr	r3, [pc, #68]	; (8001840 <bmk1_execute.lto_priv.45+0x60>)
 80017fc:	f00b fa00 	bl	800cc00 <chThdCreateStatic>
 8001800:	4602      	mov	r2, r0
 8001802:	4b10      	ldr	r3, [pc, #64]	; (8001844 <bmk1_execute.lto_priv.45+0x64>)
 8001804:	601a      	str	r2, [r3, #0]
  n = msg_loop_test(threads[0]);
 8001806:	4b0f      	ldr	r3, [pc, #60]	; (8001844 <bmk1_execute.lto_priv.45+0x64>)
 8001808:	681b      	ldr	r3, [r3, #0]
 800180a:	4618      	mov	r0, r3
 800180c:	f7ff ffc0 	bl	8001790 <msg_loop_test>
 8001810:	9003      	str	r0, [sp, #12]
  test_wait_threads();
 8001812:	f003 fffd 	bl	8005810 <test_wait_threads>
  test_print("--- Score : ");
 8001816:	480c      	ldr	r0, [pc, #48]	; (8001848 <bmk1_execute.lto_priv.45+0x68>)
 8001818:	f003 feea 	bl	80055f0 <test_print>
  test_printn(n);
 800181c:	9803      	ldr	r0, [sp, #12]
 800181e:	f003 fe9f 	bl	8005560 <test_printn>
  test_print(" msgs/S, ");
 8001822:	480a      	ldr	r0, [pc, #40]	; (800184c <bmk1_execute.lto_priv.45+0x6c>)
 8001824:	f003 fee4 	bl	80055f0 <test_print>
  test_printn(n << 1);
 8001828:	9b03      	ldr	r3, [sp, #12]
 800182a:	005b      	lsls	r3, r3, #1
 800182c:	4618      	mov	r0, r3
 800182e:	f003 fe97 	bl	8005560 <test_printn>
  test_println(" ctxswc/S");
 8001832:	4807      	ldr	r0, [pc, #28]	; (8001850 <bmk1_execute.lto_priv.45+0x70>)
 8001834:	f003 fefc 	bl	8005630 <test_println>
}
 8001838:	b004      	add	sp, #16
 800183a:	bd10      	pop	{r4, pc}
 800183c:	0800e420 	.word	0x0800e420
 8001840:	08001761 	.word	0x08001761
 8001844:	20001bf8 	.word	0x20001bf8
 8001848:	0800d7b8 	.word	0x0800d7b8
 800184c:	0800d7c8 	.word	0x0800d7c8
 8001850:	0800d7d4 	.word	0x0800d7d4
	...

08001860 <bmk2_execute.lto_priv.44>:
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
 8001860:	b510      	push	{r4, lr}
 8001862:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8001864:	4b15      	ldr	r3, [pc, #84]	; (80018bc <bmk2_execute.lto_priv.44+0x5c>)
 8001866:	681c      	ldr	r4, [r3, #0]
 8001868:	f7ff ff3a 	bl	80016e0 <chThdGetPriorityX.lto_priv.151>
 800186c:	4603      	mov	r3, r0
 800186e:	1c5a      	adds	r2, r3, #1
 8001870:	2300      	movs	r3, #0
 8001872:	9300      	str	r3, [sp, #0]
 8001874:	4620      	mov	r0, r4
 8001876:	f44f 71b4 	mov.w	r1, #360	; 0x168
 800187a:	4b11      	ldr	r3, [pc, #68]	; (80018c0 <bmk2_execute.lto_priv.44+0x60>)
 800187c:	f00b f9c0 	bl	800cc00 <chThdCreateStatic>
 8001880:	4602      	mov	r2, r0
 8001882:	4b10      	ldr	r3, [pc, #64]	; (80018c4 <bmk2_execute.lto_priv.44+0x64>)
 8001884:	601a      	str	r2, [r3, #0]
  n = msg_loop_test(threads[0]);
 8001886:	4b0f      	ldr	r3, [pc, #60]	; (80018c4 <bmk2_execute.lto_priv.44+0x64>)
 8001888:	681b      	ldr	r3, [r3, #0]
 800188a:	4618      	mov	r0, r3
 800188c:	f7ff ff80 	bl	8001790 <msg_loop_test>
 8001890:	9003      	str	r0, [sp, #12]
  test_wait_threads();
 8001892:	f003 ffbd 	bl	8005810 <test_wait_threads>
  test_print("--- Score : ");
 8001896:	480c      	ldr	r0, [pc, #48]	; (80018c8 <bmk2_execute.lto_priv.44+0x68>)
 8001898:	f003 feaa 	bl	80055f0 <test_print>
  test_printn(n);
 800189c:	9803      	ldr	r0, [sp, #12]
 800189e:	f003 fe5f 	bl	8005560 <test_printn>
  test_print(" msgs/S, ");
 80018a2:	480a      	ldr	r0, [pc, #40]	; (80018cc <bmk2_execute.lto_priv.44+0x6c>)
 80018a4:	f003 fea4 	bl	80055f0 <test_print>
  test_printn(n << 1);
 80018a8:	9b03      	ldr	r3, [sp, #12]
 80018aa:	005b      	lsls	r3, r3, #1
 80018ac:	4618      	mov	r0, r3
 80018ae:	f003 fe57 	bl	8005560 <test_printn>
  test_println(" ctxswc/S");
 80018b2:	4807      	ldr	r0, [pc, #28]	; (80018d0 <bmk2_execute.lto_priv.44+0x70>)
 80018b4:	f003 febc 	bl	8005630 <test_println>
}
 80018b8:	b004      	add	sp, #16
 80018ba:	bd10      	pop	{r4, pc}
 80018bc:	0800e420 	.word	0x0800e420
 80018c0:	08001761 	.word	0x08001761
 80018c4:	20001bf8 	.word	0x20001bf8
 80018c8:	0800d7b8 	.word	0x0800d7b8
 80018cc:	0800d7c8 	.word	0x0800d7c8
 80018d0:	0800d7d4 	.word	0x0800d7d4
	...

080018e0 <bmk3_execute.lto_priv.43>:
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
 80018e0:	b510      	push	{r4, lr}
 80018e2:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 80018e4:	4b37      	ldr	r3, [pc, #220]	; (80019c4 <bmk3_execute.lto_priv.43+0xe4>)
 80018e6:	681c      	ldr	r4, [r3, #0]
 80018e8:	f7ff fefa 	bl	80016e0 <chThdGetPriorityX.lto_priv.151>
 80018ec:	4603      	mov	r3, r0
 80018ee:	1c5a      	adds	r2, r3, #1
 80018f0:	2300      	movs	r3, #0
 80018f2:	9300      	str	r3, [sp, #0]
 80018f4:	4620      	mov	r0, r4
 80018f6:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80018fa:	4b33      	ldr	r3, [pc, #204]	; (80019c8 <bmk3_execute.lto_priv.43+0xe8>)
 80018fc:	f00b f980 	bl	800cc00 <chThdCreateStatic>
 8001900:	4602      	mov	r2, r0
 8001902:	4b32      	ldr	r3, [pc, #200]	; (80019cc <bmk3_execute.lto_priv.43+0xec>)
 8001904:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8001906:	4b2f      	ldr	r3, [pc, #188]	; (80019c4 <bmk3_execute.lto_priv.43+0xe4>)
 8001908:	685c      	ldr	r4, [r3, #4]
 800190a:	f7ff fee9 	bl	80016e0 <chThdGetPriorityX.lto_priv.151>
 800190e:	4603      	mov	r3, r0
 8001910:	1e9a      	subs	r2, r3, #2
 8001912:	2300      	movs	r3, #0
 8001914:	9300      	str	r3, [sp, #0]
 8001916:	4620      	mov	r0, r4
 8001918:	f44f 71b4 	mov.w	r1, #360	; 0x168
 800191c:	4b2c      	ldr	r3, [pc, #176]	; (80019d0 <bmk3_execute.lto_priv.43+0xf0>)
 800191e:	f00b f96f 	bl	800cc00 <chThdCreateStatic>
 8001922:	4602      	mov	r2, r0
 8001924:	4b29      	ldr	r3, [pc, #164]	; (80019cc <bmk3_execute.lto_priv.43+0xec>)
 8001926:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 8001928:	4b26      	ldr	r3, [pc, #152]	; (80019c4 <bmk3_execute.lto_priv.43+0xe4>)
 800192a:	689c      	ldr	r4, [r3, #8]
 800192c:	f7ff fed8 	bl	80016e0 <chThdGetPriorityX.lto_priv.151>
 8001930:	4603      	mov	r3, r0
 8001932:	1eda      	subs	r2, r3, #3
 8001934:	2300      	movs	r3, #0
 8001936:	9300      	str	r3, [sp, #0]
 8001938:	4620      	mov	r0, r4
 800193a:	f44f 71b4 	mov.w	r1, #360	; 0x168
 800193e:	4b24      	ldr	r3, [pc, #144]	; (80019d0 <bmk3_execute.lto_priv.43+0xf0>)
 8001940:	f00b f95e 	bl	800cc00 <chThdCreateStatic>
 8001944:	4602      	mov	r2, r0
 8001946:	4b21      	ldr	r3, [pc, #132]	; (80019cc <bmk3_execute.lto_priv.43+0xec>)
 8001948:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 800194a:	4b1e      	ldr	r3, [pc, #120]	; (80019c4 <bmk3_execute.lto_priv.43+0xe4>)
 800194c:	68dc      	ldr	r4, [r3, #12]
 800194e:	f7ff fec7 	bl	80016e0 <chThdGetPriorityX.lto_priv.151>
 8001952:	4603      	mov	r3, r0
 8001954:	1f1a      	subs	r2, r3, #4
 8001956:	2300      	movs	r3, #0
 8001958:	9300      	str	r3, [sp, #0]
 800195a:	4620      	mov	r0, r4
 800195c:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001960:	4b1b      	ldr	r3, [pc, #108]	; (80019d0 <bmk3_execute.lto_priv.43+0xf0>)
 8001962:	f00b f94d 	bl	800cc00 <chThdCreateStatic>
 8001966:	4602      	mov	r2, r0
 8001968:	4b18      	ldr	r3, [pc, #96]	; (80019cc <bmk3_execute.lto_priv.43+0xec>)
 800196a:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
 800196c:	4b15      	ldr	r3, [pc, #84]	; (80019c4 <bmk3_execute.lto_priv.43+0xe4>)
 800196e:	691c      	ldr	r4, [r3, #16]
 8001970:	f7ff feb6 	bl	80016e0 <chThdGetPriorityX.lto_priv.151>
 8001974:	4603      	mov	r3, r0
 8001976:	1f5a      	subs	r2, r3, #5
 8001978:	2300      	movs	r3, #0
 800197a:	9300      	str	r3, [sp, #0]
 800197c:	4620      	mov	r0, r4
 800197e:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001982:	4b13      	ldr	r3, [pc, #76]	; (80019d0 <bmk3_execute.lto_priv.43+0xf0>)
 8001984:	f00b f93c 	bl	800cc00 <chThdCreateStatic>
 8001988:	4602      	mov	r2, r0
 800198a:	4b10      	ldr	r3, [pc, #64]	; (80019cc <bmk3_execute.lto_priv.43+0xec>)
 800198c:	611a      	str	r2, [r3, #16]
  n = msg_loop_test(threads[0]);
 800198e:	4b0f      	ldr	r3, [pc, #60]	; (80019cc <bmk3_execute.lto_priv.43+0xec>)
 8001990:	681b      	ldr	r3, [r3, #0]
 8001992:	4618      	mov	r0, r3
 8001994:	f7ff fefc 	bl	8001790 <msg_loop_test>
 8001998:	9003      	str	r0, [sp, #12]
  test_wait_threads();
 800199a:	f003 ff39 	bl	8005810 <test_wait_threads>
  test_print("--- Score : ");
 800199e:	480d      	ldr	r0, [pc, #52]	; (80019d4 <bmk3_execute.lto_priv.43+0xf4>)
 80019a0:	f003 fe26 	bl	80055f0 <test_print>
  test_printn(n);
 80019a4:	9803      	ldr	r0, [sp, #12]
 80019a6:	f003 fddb 	bl	8005560 <test_printn>
  test_print(" msgs/S, ");
 80019aa:	480b      	ldr	r0, [pc, #44]	; (80019d8 <bmk3_execute.lto_priv.43+0xf8>)
 80019ac:	f003 fe20 	bl	80055f0 <test_print>
  test_printn(n << 1);
 80019b0:	9b03      	ldr	r3, [sp, #12]
 80019b2:	005b      	lsls	r3, r3, #1
 80019b4:	4618      	mov	r0, r3
 80019b6:	f003 fdd3 	bl	8005560 <test_printn>
  test_println(" ctxswc/S");
 80019ba:	4808      	ldr	r0, [pc, #32]	; (80019dc <bmk3_execute.lto_priv.43+0xfc>)
 80019bc:	f003 fe38 	bl	8005630 <test_println>
}
 80019c0:	b004      	add	sp, #16
 80019c2:	bd10      	pop	{r4, pc}
 80019c4:	0800e420 	.word	0x0800e420
 80019c8:	08001761 	.word	0x08001761
 80019cc:	20001bf8 	.word	0x20001bf8
 80019d0:	08001741 	.word	0x08001741
 80019d4:	0800d7b8 	.word	0x0800d7b8
 80019d8:	0800d7c8 	.word	0x0800d7c8
 80019dc:	0800d7d4 	.word	0x0800d7d4

080019e0 <thread4>:
 * the thread is awakened as fast is possible by the tester thread.<br>
 * The Context Switch performance is calculated by measuring the number of
 * iterations after a second of continuous operations.
 */

static THD_FUNCTION(thread4, p) {
 80019e0:	b500      	push	{lr}
 80019e2:	b085      	sub	sp, #20
 80019e4:	9001      	str	r0, [sp, #4]
  msg_t msg;
  thread_t *self = chThdGetSelfX();
 80019e6:	f7ff fe73 	bl	80016d0 <chThdGetSelfX>
 80019ea:	9003      	str	r0, [sp, #12]

  (void)p;
  chSysLock();
 80019ec:	f7ff fe48 	bl	8001680 <chSysLock.lto_priv.157>
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
 80019f0:	2003      	movs	r0, #3
 80019f2:	f00a fd3d 	bl	800c470 <chSchGoSleepS>
    msg = self->p_u.rdymsg;
 80019f6:	9b03      	ldr	r3, [sp, #12]
 80019f8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80019fa:	9302      	str	r3, [sp, #8]
  } while (msg == MSG_OK);
 80019fc:	9b02      	ldr	r3, [sp, #8]
 80019fe:	2b00      	cmp	r3, #0
 8001a00:	d0f6      	beq.n	80019f0 <thread4+0x10>
  chSysUnlock();
 8001a02:	f7ff fe45 	bl	8001690 <chSysUnlock.lto_priv.154>
}
 8001a06:	b005      	add	sp, #20
 8001a08:	f85d fb04 	ldr.w	pc, [sp], #4
 8001a0c:	0000      	movs	r0, r0
	...

08001a10 <bmk4_execute.lto_priv.42>:

static void bmk4_execute(void) {
 8001a10:	b510      	push	{r4, lr}
 8001a12:	b084      	sub	sp, #16
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8001a14:	4b28      	ldr	r3, [pc, #160]	; (8001ab8 <bmk4_execute.lto_priv.42+0xa8>)
 8001a16:	681c      	ldr	r4, [r3, #0]
 8001a18:	f7ff fe62 	bl	80016e0 <chThdGetPriorityX.lto_priv.151>
 8001a1c:	4603      	mov	r3, r0
 8001a1e:	1c5a      	adds	r2, r3, #1
 8001a20:	2300      	movs	r3, #0
 8001a22:	9300      	str	r3, [sp, #0]
 8001a24:	4620      	mov	r0, r4
 8001a26:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001a2a:	4b24      	ldr	r3, [pc, #144]	; (8001abc <bmk4_execute.lto_priv.42+0xac>)
 8001a2c:	f00b f8e8 	bl	800cc00 <chThdCreateStatic>
 8001a30:	4602      	mov	r2, r0
 8001a32:	4b23      	ldr	r3, [pc, #140]	; (8001ac0 <bmk4_execute.lto_priv.42+0xb0>)
 8001a34:	601a      	str	r2, [r3, #0]
 8001a36:	4b22      	ldr	r3, [pc, #136]	; (8001ac0 <bmk4_execute.lto_priv.42+0xb0>)
 8001a38:	681b      	ldr	r3, [r3, #0]
 8001a3a:	9302      	str	r3, [sp, #8]
                                      thread4, NULL);
  n = 0;
 8001a3c:	2300      	movs	r3, #0
 8001a3e:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8001a40:	f003 ff0e 	bl	8005860 <test_wait_tick>
  test_start_timer(1000);
 8001a44:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001a48:	f003 ff2a 	bl	80058a0 <test_start_timer>
  do {
    chSysLock();
 8001a4c:	f7ff fe18 	bl	8001680 <chSysLock.lto_priv.157>
    chSchWakeupS(tp, MSG_OK);
 8001a50:	9802      	ldr	r0, [sp, #8]
 8001a52:	2100      	movs	r1, #0
 8001a54:	f00a fdc4 	bl	800c5e0 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8001a58:	9802      	ldr	r0, [sp, #8]
 8001a5a:	2100      	movs	r1, #0
 8001a5c:	f00a fdc0 	bl	800c5e0 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8001a60:	9802      	ldr	r0, [sp, #8]
 8001a62:	2100      	movs	r1, #0
 8001a64:	f00a fdbc 	bl	800c5e0 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8001a68:	9802      	ldr	r0, [sp, #8]
 8001a6a:	2100      	movs	r1, #0
 8001a6c:	f00a fdb8 	bl	800c5e0 <chSchWakeupS>
    chSysUnlock();
 8001a70:	f7ff fe0e 	bl	8001690 <chSysUnlock.lto_priv.154>
    n += 4;
 8001a74:	9b03      	ldr	r3, [sp, #12]
 8001a76:	3304      	adds	r3, #4
 8001a78:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001a7a:	4b12      	ldr	r3, [pc, #72]	; (8001ac4 <bmk4_execute.lto_priv.42+0xb4>)
 8001a7c:	781b      	ldrb	r3, [r3, #0]
 8001a7e:	f083 0301 	eor.w	r3, r3, #1
 8001a82:	b2db      	uxtb	r3, r3
 8001a84:	2b00      	cmp	r3, #0
 8001a86:	d1e1      	bne.n	8001a4c <bmk4_execute.lto_priv.42+0x3c>
  chSysLock();
 8001a88:	f7ff fdfa 	bl	8001680 <chSysLock.lto_priv.157>
  chSchWakeupS(tp, MSG_TIMEOUT);
 8001a8c:	9802      	ldr	r0, [sp, #8]
 8001a8e:	f04f 31ff 	mov.w	r1, #4294967295
 8001a92:	f00a fda5 	bl	800c5e0 <chSchWakeupS>
  chSysUnlock();
 8001a96:	f7ff fdfb 	bl	8001690 <chSysUnlock.lto_priv.154>

  test_wait_threads();
 8001a9a:	f003 feb9 	bl	8005810 <test_wait_threads>
  test_print("--- Score : ");
 8001a9e:	480a      	ldr	r0, [pc, #40]	; (8001ac8 <bmk4_execute.lto_priv.42+0xb8>)
 8001aa0:	f003 fda6 	bl	80055f0 <test_print>
  test_printn(n * 2);
 8001aa4:	9b03      	ldr	r3, [sp, #12]
 8001aa6:	005b      	lsls	r3, r3, #1
 8001aa8:	4618      	mov	r0, r3
 8001aaa:	f003 fd59 	bl	8005560 <test_printn>
  test_println(" ctxswc/S");
 8001aae:	4807      	ldr	r0, [pc, #28]	; (8001acc <bmk4_execute.lto_priv.42+0xbc>)
 8001ab0:	f003 fdbe 	bl	8005630 <test_println>
}
 8001ab4:	b004      	add	sp, #16
 8001ab6:	bd10      	pop	{r4, pc}
 8001ab8:	0800e420 	.word	0x0800e420
 8001abc:	080019e1 	.word	0x080019e1
 8001ac0:	20001bf8 	.word	0x20001bf8
 8001ac4:	20001c10 	.word	0x20001c10
 8001ac8:	0800d7b8 	.word	0x0800d7b8
 8001acc:	0800d7d4 	.word	0x0800d7d4

08001ad0 <bmk5_execute.lto_priv.41>:
 * in each iteration.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk5_execute(void) {
 8001ad0:	b500      	push	{lr}
 8001ad2:	b087      	sub	sp, #28

  uint32_t n = 0;
 8001ad4:	2300      	movs	r3, #0
 8001ad6:	9305      	str	r3, [sp, #20]
  void *wap = wa[0];
 8001ad8:	4b18      	ldr	r3, [pc, #96]	; (8001b3c <bmk5_execute.lto_priv.41+0x6c>)
 8001ada:	681b      	ldr	r3, [r3, #0]
 8001adc:	9304      	str	r3, [sp, #16]
  tprio_t prio = chThdGetPriorityX() - 1;
 8001ade:	f7ff fdff 	bl	80016e0 <chThdGetPriorityX.lto_priv.151>
 8001ae2:	4603      	mov	r3, r0
 8001ae4:	3b01      	subs	r3, #1
 8001ae6:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8001ae8:	f003 feba 	bl	8005860 <test_wait_tick>
  test_start_timer(1000);
 8001aec:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001af0:	f003 fed6 	bl	80058a0 <test_start_timer>
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
 8001af4:	2300      	movs	r3, #0
 8001af6:	9300      	str	r3, [sp, #0]
 8001af8:	9804      	ldr	r0, [sp, #16]
 8001afa:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001afe:	9a03      	ldr	r2, [sp, #12]
 8001b00:	4b0f      	ldr	r3, [pc, #60]	; (8001b40 <bmk5_execute.lto_priv.41+0x70>)
 8001b02:	f00b f87d 	bl	800cc00 <chThdCreateStatic>
 8001b06:	4603      	mov	r3, r0
 8001b08:	4618      	mov	r0, r3
 8001b0a:	f00b f989 	bl	800ce20 <chThdWait>
    n++;
 8001b0e:	9b05      	ldr	r3, [sp, #20]
 8001b10:	3301      	adds	r3, #1
 8001b12:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001b14:	4b0b      	ldr	r3, [pc, #44]	; (8001b44 <bmk5_execute.lto_priv.41+0x74>)
 8001b16:	781b      	ldrb	r3, [r3, #0]
 8001b18:	f083 0301 	eor.w	r3, r3, #1
 8001b1c:	b2db      	uxtb	r3, r3
 8001b1e:	2b00      	cmp	r3, #0
 8001b20:	d1e8      	bne.n	8001af4 <bmk5_execute.lto_priv.41+0x24>
  test_print("--- Score : ");
 8001b22:	4809      	ldr	r0, [pc, #36]	; (8001b48 <bmk5_execute.lto_priv.41+0x78>)
 8001b24:	f003 fd64 	bl	80055f0 <test_print>
  test_printn(n);
 8001b28:	9805      	ldr	r0, [sp, #20]
 8001b2a:	f003 fd19 	bl	8005560 <test_printn>
  test_println(" threads/S");
 8001b2e:	4807      	ldr	r0, [pc, #28]	; (8001b4c <bmk5_execute.lto_priv.41+0x7c>)
 8001b30:	f003 fd7e 	bl	8005630 <test_println>
}
 8001b34:	b007      	add	sp, #28
 8001b36:	f85d fb04 	ldr.w	pc, [sp], #4
 8001b3a:	bf00      	nop
 8001b3c:	0800e420 	.word	0x0800e420
 8001b40:	08001741 	.word	0x08001741
 8001b44:	20001c10 	.word	0x20001c10
 8001b48:	0800d7b8 	.word	0x0800d7b8
 8001b4c:	0800d7e0 	.word	0x0800d7e0

08001b50 <bmk6_execute.lto_priv.40>:
 * terminate.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk6_execute(void) {
 8001b50:	b500      	push	{lr}
 8001b52:	b087      	sub	sp, #28

  uint32_t n = 0;
 8001b54:	2300      	movs	r3, #0
 8001b56:	9305      	str	r3, [sp, #20]
  void *wap = wa[0];
 8001b58:	4b16      	ldr	r3, [pc, #88]	; (8001bb4 <bmk6_execute.lto_priv.40+0x64>)
 8001b5a:	681b      	ldr	r3, [r3, #0]
 8001b5c:	9304      	str	r3, [sp, #16]
  tprio_t prio = chThdGetPriorityX() + 1;
 8001b5e:	f7ff fdbf 	bl	80016e0 <chThdGetPriorityX.lto_priv.151>
 8001b62:	4603      	mov	r3, r0
 8001b64:	3301      	adds	r3, #1
 8001b66:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8001b68:	f003 fe7a 	bl	8005860 <test_wait_tick>
  test_start_timer(1000);
 8001b6c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001b70:	f003 fe96 	bl	80058a0 <test_start_timer>
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
 8001b74:	2300      	movs	r3, #0
 8001b76:	9300      	str	r3, [sp, #0]
 8001b78:	9804      	ldr	r0, [sp, #16]
 8001b7a:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001b7e:	9a03      	ldr	r2, [sp, #12]
 8001b80:	4b0d      	ldr	r3, [pc, #52]	; (8001bb8 <bmk6_execute.lto_priv.40+0x68>)
 8001b82:	f00b f83d 	bl	800cc00 <chThdCreateStatic>
    n++;
 8001b86:	9b05      	ldr	r3, [sp, #20]
 8001b88:	3301      	adds	r3, #1
 8001b8a:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001b8c:	4b0b      	ldr	r3, [pc, #44]	; (8001bbc <bmk6_execute.lto_priv.40+0x6c>)
 8001b8e:	781b      	ldrb	r3, [r3, #0]
 8001b90:	f083 0301 	eor.w	r3, r3, #1
 8001b94:	b2db      	uxtb	r3, r3
 8001b96:	2b00      	cmp	r3, #0
 8001b98:	d1ec      	bne.n	8001b74 <bmk6_execute.lto_priv.40+0x24>
  test_print("--- Score : ");
 8001b9a:	4809      	ldr	r0, [pc, #36]	; (8001bc0 <bmk6_execute.lto_priv.40+0x70>)
 8001b9c:	f003 fd28 	bl	80055f0 <test_print>
  test_printn(n);
 8001ba0:	9805      	ldr	r0, [sp, #20]
 8001ba2:	f003 fcdd 	bl	8005560 <test_printn>
  test_println(" threads/S");
 8001ba6:	4807      	ldr	r0, [pc, #28]	; (8001bc4 <bmk6_execute.lto_priv.40+0x74>)
 8001ba8:	f003 fd42 	bl	8005630 <test_println>
}
 8001bac:	b007      	add	sp, #28
 8001bae:	f85d fb04 	ldr.w	pc, [sp], #4
 8001bb2:	bf00      	nop
 8001bb4:	0800e420 	.word	0x0800e420
 8001bb8:	08001741 	.word	0x08001741
 8001bbc:	20001c10 	.word	0x20001c10
 8001bc0:	0800d7b8 	.word	0x0800d7b8
 8001bc4:	0800d7e0 	.word	0x0800d7e0
	...

08001bd0 <thread3>:
 * continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread3, p) {
 8001bd0:	b500      	push	{lr}
 8001bd2:	b083      	sub	sp, #12
 8001bd4:	9001      	str	r0, [sp, #4]
 8001bd6:	e002      	b.n	8001bde <thread3+0xe>

  (void)p;
  while (!chThdShouldTerminateX())
    chSemWait(&sem1);
 8001bd8:	4806      	ldr	r0, [pc, #24]	; (8001bf4 <thread3+0x24>)
 8001bda:	f008 ff49 	bl	800aa70 <chSemWait>
 */

static THD_FUNCTION(thread3, p) {

  (void)p;
  while (!chThdShouldTerminateX())
 8001bde:	f7ff fd87 	bl	80016f0 <chThdShouldTerminateX>
 8001be2:	4603      	mov	r3, r0
 8001be4:	f083 0301 	eor.w	r3, r3, #1
 8001be8:	b2db      	uxtb	r3, r3
 8001bea:	2b00      	cmp	r3, #0
 8001bec:	d1f4      	bne.n	8001bd8 <thread3+0x8>
    chSemWait(&sem1);
}
 8001bee:	b003      	add	sp, #12
 8001bf0:	f85d fb04 	ldr.w	pc, [sp], #4
 8001bf4:	20001c74 	.word	0x20001c74
	...

08001c00 <bmk7_setup.lto_priv.38>:

static void bmk7_setup(void) {
 8001c00:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 8001c02:	4802      	ldr	r0, [pc, #8]	; (8001c0c <bmk7_setup.lto_priv.38+0xc>)
 8001c04:	2100      	movs	r1, #0
 8001c06:	f008 feab 	bl	800a960 <chSemObjectInit>
}
 8001c0a:	bd08      	pop	{r3, pc}
 8001c0c:	20001c74 	.word	0x20001c74

08001c10 <bmk7_execute.lto_priv.39>:

static void bmk7_execute(void) {
 8001c10:	b510      	push	{r4, lr}
 8001c12:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8001c14:	4b44      	ldr	r3, [pc, #272]	; (8001d28 <bmk7_execute.lto_priv.39+0x118>)
 8001c16:	681c      	ldr	r4, [r3, #0]
 8001c18:	f7ff fd62 	bl	80016e0 <chThdGetPriorityX.lto_priv.151>
 8001c1c:	4603      	mov	r3, r0
 8001c1e:	1d5a      	adds	r2, r3, #5
 8001c20:	2300      	movs	r3, #0
 8001c22:	9300      	str	r3, [sp, #0]
 8001c24:	4620      	mov	r0, r4
 8001c26:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001c2a:	4b40      	ldr	r3, [pc, #256]	; (8001d2c <bmk7_execute.lto_priv.39+0x11c>)
 8001c2c:	f00a ffe8 	bl	800cc00 <chThdCreateStatic>
 8001c30:	4602      	mov	r2, r0
 8001c32:	4b3f      	ldr	r3, [pc, #252]	; (8001d30 <bmk7_execute.lto_priv.39+0x120>)
 8001c34:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8001c36:	4b3c      	ldr	r3, [pc, #240]	; (8001d28 <bmk7_execute.lto_priv.39+0x118>)
 8001c38:	685c      	ldr	r4, [r3, #4]
 8001c3a:	f7ff fd51 	bl	80016e0 <chThdGetPriorityX.lto_priv.151>
 8001c3e:	4603      	mov	r3, r0
 8001c40:	1d1a      	adds	r2, r3, #4
 8001c42:	2300      	movs	r3, #0
 8001c44:	9300      	str	r3, [sp, #0]
 8001c46:	4620      	mov	r0, r4
 8001c48:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001c4c:	4b37      	ldr	r3, [pc, #220]	; (8001d2c <bmk7_execute.lto_priv.39+0x11c>)
 8001c4e:	f00a ffd7 	bl	800cc00 <chThdCreateStatic>
 8001c52:	4602      	mov	r2, r0
 8001c54:	4b36      	ldr	r3, [pc, #216]	; (8001d30 <bmk7_execute.lto_priv.39+0x120>)
 8001c56:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 8001c58:	4b33      	ldr	r3, [pc, #204]	; (8001d28 <bmk7_execute.lto_priv.39+0x118>)
 8001c5a:	689c      	ldr	r4, [r3, #8]
 8001c5c:	f7ff fd40 	bl	80016e0 <chThdGetPriorityX.lto_priv.151>
 8001c60:	4603      	mov	r3, r0
 8001c62:	1cda      	adds	r2, r3, #3
 8001c64:	2300      	movs	r3, #0
 8001c66:	9300      	str	r3, [sp, #0]
 8001c68:	4620      	mov	r0, r4
 8001c6a:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001c6e:	4b2f      	ldr	r3, [pc, #188]	; (8001d2c <bmk7_execute.lto_priv.39+0x11c>)
 8001c70:	f00a ffc6 	bl	800cc00 <chThdCreateStatic>
 8001c74:	4602      	mov	r2, r0
 8001c76:	4b2e      	ldr	r3, [pc, #184]	; (8001d30 <bmk7_execute.lto_priv.39+0x120>)
 8001c78:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 8001c7a:	4b2b      	ldr	r3, [pc, #172]	; (8001d28 <bmk7_execute.lto_priv.39+0x118>)
 8001c7c:	68dc      	ldr	r4, [r3, #12]
 8001c7e:	f7ff fd2f 	bl	80016e0 <chThdGetPriorityX.lto_priv.151>
 8001c82:	4603      	mov	r3, r0
 8001c84:	1c9a      	adds	r2, r3, #2
 8001c86:	2300      	movs	r3, #0
 8001c88:	9300      	str	r3, [sp, #0]
 8001c8a:	4620      	mov	r0, r4
 8001c8c:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001c90:	4b26      	ldr	r3, [pc, #152]	; (8001d2c <bmk7_execute.lto_priv.39+0x11c>)
 8001c92:	f00a ffb5 	bl	800cc00 <chThdCreateStatic>
 8001c96:	4602      	mov	r2, r0
 8001c98:	4b25      	ldr	r3, [pc, #148]	; (8001d30 <bmk7_execute.lto_priv.39+0x120>)
 8001c9a:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
 8001c9c:	4b22      	ldr	r3, [pc, #136]	; (8001d28 <bmk7_execute.lto_priv.39+0x118>)
 8001c9e:	691c      	ldr	r4, [r3, #16]
 8001ca0:	f7ff fd1e 	bl	80016e0 <chThdGetPriorityX.lto_priv.151>
 8001ca4:	4603      	mov	r3, r0
 8001ca6:	1c5a      	adds	r2, r3, #1
 8001ca8:	2300      	movs	r3, #0
 8001caa:	9300      	str	r3, [sp, #0]
 8001cac:	4620      	mov	r0, r4
 8001cae:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001cb2:	4b1e      	ldr	r3, [pc, #120]	; (8001d2c <bmk7_execute.lto_priv.39+0x11c>)
 8001cb4:	f00a ffa4 	bl	800cc00 <chThdCreateStatic>
 8001cb8:	4602      	mov	r2, r0
 8001cba:	4b1d      	ldr	r3, [pc, #116]	; (8001d30 <bmk7_execute.lto_priv.39+0x120>)
 8001cbc:	611a      	str	r2, [r3, #16]

  n = 0;
 8001cbe:	2300      	movs	r3, #0
 8001cc0:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8001cc2:	f003 fdcd 	bl	8005860 <test_wait_tick>
  test_start_timer(1000);
 8001cc6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001cca:	f003 fde9 	bl	80058a0 <test_start_timer>
  do {
    chSemReset(&sem1, 0);
 8001cce:	4819      	ldr	r0, [pc, #100]	; (8001d34 <bmk7_execute.lto_priv.39+0x124>)
 8001cd0:	2100      	movs	r1, #0
 8001cd2:	f008 fe65 	bl	800a9a0 <chSemReset>
    n++;
 8001cd6:	9b03      	ldr	r3, [sp, #12]
 8001cd8:	3301      	adds	r3, #1
 8001cda:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001cdc:	4b16      	ldr	r3, [pc, #88]	; (8001d38 <bmk7_execute.lto_priv.39+0x128>)
 8001cde:	781b      	ldrb	r3, [r3, #0]
 8001ce0:	f083 0301 	eor.w	r3, r3, #1
 8001ce4:	b2db      	uxtb	r3, r3
 8001ce6:	2b00      	cmp	r3, #0
 8001ce8:	d1f1      	bne.n	8001cce <bmk7_execute.lto_priv.39+0xbe>
  test_terminate_threads();
 8001cea:	f003 fd71 	bl	80057d0 <test_terminate_threads>
  chSemReset(&sem1, 0);
 8001cee:	4811      	ldr	r0, [pc, #68]	; (8001d34 <bmk7_execute.lto_priv.39+0x124>)
 8001cf0:	2100      	movs	r1, #0
 8001cf2:	f008 fe55 	bl	800a9a0 <chSemReset>
  test_wait_threads();
 8001cf6:	f003 fd8b 	bl	8005810 <test_wait_threads>

  test_print("--- Score : ");
 8001cfa:	4810      	ldr	r0, [pc, #64]	; (8001d3c <bmk7_execute.lto_priv.39+0x12c>)
 8001cfc:	f003 fc78 	bl	80055f0 <test_print>
  test_printn(n);
 8001d00:	9803      	ldr	r0, [sp, #12]
 8001d02:	f003 fc2d 	bl	8005560 <test_printn>
  test_print(" reschedules/S, ");
 8001d06:	480e      	ldr	r0, [pc, #56]	; (8001d40 <bmk7_execute.lto_priv.39+0x130>)
 8001d08:	f003 fc72 	bl	80055f0 <test_print>
  test_printn(n * 6);
 8001d0c:	9a03      	ldr	r2, [sp, #12]
 8001d0e:	4613      	mov	r3, r2
 8001d10:	005b      	lsls	r3, r3, #1
 8001d12:	4413      	add	r3, r2
 8001d14:	005b      	lsls	r3, r3, #1
 8001d16:	4618      	mov	r0, r3
 8001d18:	f003 fc22 	bl	8005560 <test_printn>
  test_println(" ctxswc/S");
 8001d1c:	4809      	ldr	r0, [pc, #36]	; (8001d44 <bmk7_execute.lto_priv.39+0x134>)
 8001d1e:	f003 fc87 	bl	8005630 <test_println>
}
 8001d22:	b004      	add	sp, #16
 8001d24:	bd10      	pop	{r4, pc}
 8001d26:	bf00      	nop
 8001d28:	0800e420 	.word	0x0800e420
 8001d2c:	08001bd1 	.word	0x08001bd1
 8001d30:	20001bf8 	.word	0x20001bf8
 8001d34:	20001c74 	.word	0x20001c74
 8001d38:	20001c10 	.word	0x20001c10
 8001d3c:	0800d7b8 	.word	0x0800d7b8
 8001d40:	0800d7ec 	.word	0x0800d7ec
 8001d44:	0800d7d4 	.word	0x0800d7d4
	...

08001d50 <thread8>:
 * variable and yields.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread8, p) {
 8001d50:	b500      	push	{lr}
 8001d52:	b083      	sub	sp, #12
 8001d54:	9001      	str	r0, [sp, #4]

  do {
    chThdYield();
 8001d56:	f00b f80b 	bl	800cd70 <chThdYield>
    chThdYield();
 8001d5a:	f00b f809 	bl	800cd70 <chThdYield>
    chThdYield();
 8001d5e:	f00b f807 	bl	800cd70 <chThdYield>
    chThdYield();
 8001d62:	f00b f805 	bl	800cd70 <chThdYield>
    (*(uint32_t *)p) += 4;
 8001d66:	9b01      	ldr	r3, [sp, #4]
 8001d68:	681b      	ldr	r3, [r3, #0]
 8001d6a:	1d1a      	adds	r2, r3, #4
 8001d6c:	9b01      	ldr	r3, [sp, #4]
 8001d6e:	601a      	str	r2, [r3, #0]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 8001d70:	f7ff fcbe 	bl	80016f0 <chThdShouldTerminateX>
 8001d74:	4603      	mov	r3, r0
 8001d76:	f083 0301 	eor.w	r3, r3, #1
 8001d7a:	b2db      	uxtb	r3, r3
 8001d7c:	2b00      	cmp	r3, #0
 8001d7e:	d1ea      	bne.n	8001d56 <thread8+0x6>
}
 8001d80:	b003      	add	sp, #12
 8001d82:	f85d fb04 	ldr.w	pc, [sp], #4
 8001d86:	bf00      	nop
	...

08001d90 <bmk8_execute.lto_priv.37>:

static void bmk8_execute(void) {
 8001d90:	b510      	push	{r4, lr}
 8001d92:	b084      	sub	sp, #16
  uint32_t n;

  n = 0;
 8001d94:	2300      	movs	r3, #0
 8001d96:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8001d98:	f003 fd62 	bl	8005860 <test_wait_tick>

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8001d9c:	4b34      	ldr	r3, [pc, #208]	; (8001e70 <bmk8_execute.lto_priv.37+0xe0>)
 8001d9e:	681c      	ldr	r4, [r3, #0]
 8001da0:	f7ff fc9e 	bl	80016e0 <chThdGetPriorityX.lto_priv.151>
 8001da4:	4603      	mov	r3, r0
 8001da6:	1e5a      	subs	r2, r3, #1
 8001da8:	ab03      	add	r3, sp, #12
 8001daa:	9300      	str	r3, [sp, #0]
 8001dac:	4620      	mov	r0, r4
 8001dae:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001db2:	4b30      	ldr	r3, [pc, #192]	; (8001e74 <bmk8_execute.lto_priv.37+0xe4>)
 8001db4:	f00a ff24 	bl	800cc00 <chThdCreateStatic>
 8001db8:	4602      	mov	r2, r0
 8001dba:	4b2f      	ldr	r3, [pc, #188]	; (8001e78 <bmk8_execute.lto_priv.37+0xe8>)
 8001dbc:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8001dbe:	4b2c      	ldr	r3, [pc, #176]	; (8001e70 <bmk8_execute.lto_priv.37+0xe0>)
 8001dc0:	685c      	ldr	r4, [r3, #4]
 8001dc2:	f7ff fc8d 	bl	80016e0 <chThdGetPriorityX.lto_priv.151>
 8001dc6:	4603      	mov	r3, r0
 8001dc8:	1e5a      	subs	r2, r3, #1
 8001dca:	ab03      	add	r3, sp, #12
 8001dcc:	9300      	str	r3, [sp, #0]
 8001dce:	4620      	mov	r0, r4
 8001dd0:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001dd4:	4b27      	ldr	r3, [pc, #156]	; (8001e74 <bmk8_execute.lto_priv.37+0xe4>)
 8001dd6:	f00a ff13 	bl	800cc00 <chThdCreateStatic>
 8001dda:	4602      	mov	r2, r0
 8001ddc:	4b26      	ldr	r3, [pc, #152]	; (8001e78 <bmk8_execute.lto_priv.37+0xe8>)
 8001dde:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8001de0:	4b23      	ldr	r3, [pc, #140]	; (8001e70 <bmk8_execute.lto_priv.37+0xe0>)
 8001de2:	689c      	ldr	r4, [r3, #8]
 8001de4:	f7ff fc7c 	bl	80016e0 <chThdGetPriorityX.lto_priv.151>
 8001de8:	4603      	mov	r3, r0
 8001dea:	1e5a      	subs	r2, r3, #1
 8001dec:	ab03      	add	r3, sp, #12
 8001dee:	9300      	str	r3, [sp, #0]
 8001df0:	4620      	mov	r0, r4
 8001df2:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001df6:	4b1f      	ldr	r3, [pc, #124]	; (8001e74 <bmk8_execute.lto_priv.37+0xe4>)
 8001df8:	f00a ff02 	bl	800cc00 <chThdCreateStatic>
 8001dfc:	4602      	mov	r2, r0
 8001dfe:	4b1e      	ldr	r3, [pc, #120]	; (8001e78 <bmk8_execute.lto_priv.37+0xe8>)
 8001e00:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8001e02:	4b1b      	ldr	r3, [pc, #108]	; (8001e70 <bmk8_execute.lto_priv.37+0xe0>)
 8001e04:	68dc      	ldr	r4, [r3, #12]
 8001e06:	f7ff fc6b 	bl	80016e0 <chThdGetPriorityX.lto_priv.151>
 8001e0a:	4603      	mov	r3, r0
 8001e0c:	1e5a      	subs	r2, r3, #1
 8001e0e:	ab03      	add	r3, sp, #12
 8001e10:	9300      	str	r3, [sp, #0]
 8001e12:	4620      	mov	r0, r4
 8001e14:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001e18:	4b16      	ldr	r3, [pc, #88]	; (8001e74 <bmk8_execute.lto_priv.37+0xe4>)
 8001e1a:	f00a fef1 	bl	800cc00 <chThdCreateStatic>
 8001e1e:	4602      	mov	r2, r0
 8001e20:	4b15      	ldr	r3, [pc, #84]	; (8001e78 <bmk8_execute.lto_priv.37+0xe8>)
 8001e22:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8001e24:	4b12      	ldr	r3, [pc, #72]	; (8001e70 <bmk8_execute.lto_priv.37+0xe0>)
 8001e26:	691c      	ldr	r4, [r3, #16]
 8001e28:	f7ff fc5a 	bl	80016e0 <chThdGetPriorityX.lto_priv.151>
 8001e2c:	4603      	mov	r3, r0
 8001e2e:	1e5a      	subs	r2, r3, #1
 8001e30:	ab03      	add	r3, sp, #12
 8001e32:	9300      	str	r3, [sp, #0]
 8001e34:	4620      	mov	r0, r4
 8001e36:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8001e3a:	4b0e      	ldr	r3, [pc, #56]	; (8001e74 <bmk8_execute.lto_priv.37+0xe4>)
 8001e3c:	f00a fee0 	bl	800cc00 <chThdCreateStatic>
 8001e40:	4602      	mov	r2, r0
 8001e42:	4b0d      	ldr	r3, [pc, #52]	; (8001e78 <bmk8_execute.lto_priv.37+0xe8>)
 8001e44:	611a      	str	r2, [r3, #16]

  chThdSleepSeconds(1);
 8001e46:	f242 7010 	movw	r0, #10000	; 0x2710
 8001e4a:	f00a ff69 	bl	800cd20 <chThdSleep>
  test_terminate_threads();
 8001e4e:	f003 fcbf 	bl	80057d0 <test_terminate_threads>
  test_wait_threads();
 8001e52:	f003 fcdd 	bl	8005810 <test_wait_threads>

  test_print("--- Score : ");
 8001e56:	4809      	ldr	r0, [pc, #36]	; (8001e7c <bmk8_execute.lto_priv.37+0xec>)
 8001e58:	f003 fbca 	bl	80055f0 <test_print>
  test_printn(n);
 8001e5c:	9b03      	ldr	r3, [sp, #12]
 8001e5e:	4618      	mov	r0, r3
 8001e60:	f003 fb7e 	bl	8005560 <test_printn>
  test_println(" ctxswc/S");
 8001e64:	4806      	ldr	r0, [pc, #24]	; (8001e80 <bmk8_execute.lto_priv.37+0xf0>)
 8001e66:	f003 fbe3 	bl	8005630 <test_println>
}
 8001e6a:	b004      	add	sp, #16
 8001e6c:	bd10      	pop	{r4, pc}
 8001e6e:	bf00      	nop
 8001e70:	0800e420 	.word	0x0800e420
 8001e74:	08001d51 	.word	0x08001d51
 8001e78:	20001bf8 	.word	0x20001bf8
 8001e7c:	0800d7b8 	.word	0x0800d7b8
 8001e80:	0800d7d4 	.word	0x0800d7d4
	...

08001e90 <bmk9_execute.lto_priv.36>:
 * loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk9_execute(void) {
 8001e90:	b500      	push	{lr}
 8001e92:	b085      	sub	sp, #20
  uint32_t n;
  static uint8_t ib[16];
  static input_queue_t iq;

  chIQObjectInit(&iq, ib, sizeof(ib), NULL, NULL);
 8001e94:	2300      	movs	r3, #0
 8001e96:	9300      	str	r3, [sp, #0]
 8001e98:	4822      	ldr	r0, [pc, #136]	; (8001f24 <bmk9_execute.lto_priv.36+0x94>)
 8001e9a:	4923      	ldr	r1, [pc, #140]	; (8001f28 <bmk9_execute.lto_priv.36+0x98>)
 8001e9c:	2210      	movs	r2, #16
 8001e9e:	2300      	movs	r3, #0
 8001ea0:	f008 f8d6 	bl	800a050 <chIQObjectInit>
  n = 0;
 8001ea4:	2300      	movs	r3, #0
 8001ea6:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8001ea8:	f003 fcda 	bl	8005860 <test_wait_tick>
  test_start_timer(1000);
 8001eac:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001eb0:	f003 fcf6 	bl	80058a0 <test_start_timer>
  do {
    chSysLock();
 8001eb4:	f7ff fbe4 	bl	8001680 <chSysLock.lto_priv.157>
    chIQPutI(&iq, 0);
 8001eb8:	481a      	ldr	r0, [pc, #104]	; (8001f24 <bmk9_execute.lto_priv.36+0x94>)
 8001eba:	2100      	movs	r1, #0
 8001ebc:	f008 f910 	bl	800a0e0 <chIQPutI>
    chIQPutI(&iq, 1);
 8001ec0:	4818      	ldr	r0, [pc, #96]	; (8001f24 <bmk9_execute.lto_priv.36+0x94>)
 8001ec2:	2101      	movs	r1, #1
 8001ec4:	f008 f90c 	bl	800a0e0 <chIQPutI>
    chIQPutI(&iq, 2);
 8001ec8:	4816      	ldr	r0, [pc, #88]	; (8001f24 <bmk9_execute.lto_priv.36+0x94>)
 8001eca:	2102      	movs	r1, #2
 8001ecc:	f008 f908 	bl	800a0e0 <chIQPutI>
    chIQPutI(&iq, 3);
 8001ed0:	4814      	ldr	r0, [pc, #80]	; (8001f24 <bmk9_execute.lto_priv.36+0x94>)
 8001ed2:	2103      	movs	r1, #3
 8001ed4:	f008 f904 	bl	800a0e0 <chIQPutI>
    chSysUnlock();
 8001ed8:	f7ff fbda 	bl	8001690 <chSysUnlock.lto_priv.154>
    (void)chIQGet(&iq);
 8001edc:	4811      	ldr	r0, [pc, #68]	; (8001f24 <bmk9_execute.lto_priv.36+0x94>)
 8001ede:	f7ff fc1f 	bl	8001720 <chIQGet>
    (void)chIQGet(&iq);
 8001ee2:	4810      	ldr	r0, [pc, #64]	; (8001f24 <bmk9_execute.lto_priv.36+0x94>)
 8001ee4:	f7ff fc1c 	bl	8001720 <chIQGet>
    (void)chIQGet(&iq);
 8001ee8:	480e      	ldr	r0, [pc, #56]	; (8001f24 <bmk9_execute.lto_priv.36+0x94>)
 8001eea:	f7ff fc19 	bl	8001720 <chIQGet>
    (void)chIQGet(&iq);
 8001eee:	480d      	ldr	r0, [pc, #52]	; (8001f24 <bmk9_execute.lto_priv.36+0x94>)
 8001ef0:	f7ff fc16 	bl	8001720 <chIQGet>
    n++;
 8001ef4:	9b03      	ldr	r3, [sp, #12]
 8001ef6:	3301      	adds	r3, #1
 8001ef8:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001efa:	4b0c      	ldr	r3, [pc, #48]	; (8001f2c <bmk9_execute.lto_priv.36+0x9c>)
 8001efc:	781b      	ldrb	r3, [r3, #0]
 8001efe:	f083 0301 	eor.w	r3, r3, #1
 8001f02:	b2db      	uxtb	r3, r3
 8001f04:	2b00      	cmp	r3, #0
 8001f06:	d1d5      	bne.n	8001eb4 <bmk9_execute.lto_priv.36+0x24>
  test_print("--- Score : ");
 8001f08:	4809      	ldr	r0, [pc, #36]	; (8001f30 <bmk9_execute.lto_priv.36+0xa0>)
 8001f0a:	f003 fb71 	bl	80055f0 <test_print>
  test_printn(n * 4);
 8001f0e:	9b03      	ldr	r3, [sp, #12]
 8001f10:	009b      	lsls	r3, r3, #2
 8001f12:	4618      	mov	r0, r3
 8001f14:	f003 fb24 	bl	8005560 <test_printn>
  test_println(" bytes/S");
 8001f18:	4806      	ldr	r0, [pc, #24]	; (8001f34 <bmk9_execute.lto_priv.36+0xa4>)
 8001f1a:	f003 fb89 	bl	8005630 <test_println>
}
 8001f1e:	b005      	add	sp, #20
 8001f20:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f24:	20001c90 	.word	0x20001c90
 8001f28:	20001cb4 	.word	0x20001cb4
 8001f2c:	20001c10 	.word	0x20001c10
 8001f30:	0800d7b8 	.word	0x0800d7b8
 8001f34:	0800d800 	.word	0x0800d800
	...

08001f40 <tmo>:
 * A virtual timer is set and immediately reset into a continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}
 8001f40:	b082      	sub	sp, #8
 8001f42:	9001      	str	r0, [sp, #4]
 8001f44:	b002      	add	sp, #8
 8001f46:	4770      	bx	lr
	...

08001f50 <bmk10_execute.lto_priv.35>:

static void bmk10_execute(void) {
 8001f50:	b500      	push	{lr}
 8001f52:	b083      	sub	sp, #12
  static virtual_timer_t vt1, vt2;
  uint32_t n = 0;
 8001f54:	2300      	movs	r3, #0
 8001f56:	9301      	str	r3, [sp, #4]

  test_wait_tick();
 8001f58:	f003 fc82 	bl	8005860 <test_wait_tick>
  test_start_timer(1000);
 8001f5c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001f60:	f003 fc9e 	bl	80058a0 <test_start_timer>
  do {
    chSysLock();
 8001f64:	f7ff fb8c 	bl	8001680 <chSysLock.lto_priv.157>
    chVTDoSetI(&vt1, 1, tmo, NULL);
 8001f68:	4816      	ldr	r0, [pc, #88]	; (8001fc4 <bmk10_execute.lto_priv.35+0x74>)
 8001f6a:	2101      	movs	r1, #1
 8001f6c:	4a16      	ldr	r2, [pc, #88]	; (8001fc8 <bmk10_execute.lto_priv.35+0x78>)
 8001f6e:	2300      	movs	r3, #0
 8001f70:	f00a f87e 	bl	800c070 <chVTDoSetI>
    chVTDoSetI(&vt2, 10000, tmo, NULL);
 8001f74:	4815      	ldr	r0, [pc, #84]	; (8001fcc <bmk10_execute.lto_priv.35+0x7c>)
 8001f76:	f242 7110 	movw	r1, #10000	; 0x2710
 8001f7a:	4a13      	ldr	r2, [pc, #76]	; (8001fc8 <bmk10_execute.lto_priv.35+0x78>)
 8001f7c:	2300      	movs	r3, #0
 8001f7e:	f00a f877 	bl	800c070 <chVTDoSetI>
    chVTDoResetI(&vt1);
 8001f82:	4810      	ldr	r0, [pc, #64]	; (8001fc4 <bmk10_execute.lto_priv.35+0x74>)
 8001f84:	f00a f904 	bl	800c190 <chVTDoResetI>
    chVTDoResetI(&vt2);
 8001f88:	4810      	ldr	r0, [pc, #64]	; (8001fcc <bmk10_execute.lto_priv.35+0x7c>)
 8001f8a:	f00a f901 	bl	800c190 <chVTDoResetI>
    chSysUnlock();
 8001f8e:	f7ff fb7f 	bl	8001690 <chSysUnlock.lto_priv.154>
    n++;
 8001f92:	9b01      	ldr	r3, [sp, #4]
 8001f94:	3301      	adds	r3, #1
 8001f96:	9301      	str	r3, [sp, #4]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001f98:	4b0d      	ldr	r3, [pc, #52]	; (8001fd0 <bmk10_execute.lto_priv.35+0x80>)
 8001f9a:	781b      	ldrb	r3, [r3, #0]
 8001f9c:	f083 0301 	eor.w	r3, r3, #1
 8001fa0:	b2db      	uxtb	r3, r3
 8001fa2:	2b00      	cmp	r3, #0
 8001fa4:	d1de      	bne.n	8001f64 <bmk10_execute.lto_priv.35+0x14>
  test_print("--- Score : ");
 8001fa6:	480b      	ldr	r0, [pc, #44]	; (8001fd4 <bmk10_execute.lto_priv.35+0x84>)
 8001fa8:	f003 fb22 	bl	80055f0 <test_print>
  test_printn(n * 2);
 8001fac:	9b01      	ldr	r3, [sp, #4]
 8001fae:	005b      	lsls	r3, r3, #1
 8001fb0:	4618      	mov	r0, r3
 8001fb2:	f003 fad5 	bl	8005560 <test_printn>
  test_println(" timers/S");
 8001fb6:	4808      	ldr	r0, [pc, #32]	; (8001fd8 <bmk10_execute.lto_priv.35+0x88>)
 8001fb8:	f003 fb3a 	bl	8005630 <test_println>
}
 8001fbc:	b003      	add	sp, #12
 8001fbe:	f85d fb04 	ldr.w	pc, [sp], #4
 8001fc2:	bf00      	nop
 8001fc4:	20001cc4 	.word	0x20001cc4
 8001fc8:	08001f41 	.word	0x08001f41
 8001fcc:	20001cd8 	.word	0x20001cd8
 8001fd0:	20001c10 	.word	0x20001c10
 8001fd4:	0800d7b8 	.word	0x0800d7b8
 8001fd8:	0800d80c 	.word	0x0800d80c
 8001fdc:	00000000 	.word	0x00000000

08001fe0 <bmk11_setup.lto_priv.33>:
 * Switch happens because the counter is always non negative.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk11_setup(void) {
 8001fe0:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 1);
 8001fe2:	4802      	ldr	r0, [pc, #8]	; (8001fec <bmk11_setup.lto_priv.33+0xc>)
 8001fe4:	2101      	movs	r1, #1
 8001fe6:	f008 fcbb 	bl	800a960 <chSemObjectInit>
}
 8001fea:	bd08      	pop	{r3, pc}
 8001fec:	20001c74 	.word	0x20001c74

08001ff0 <bmk11_execute.lto_priv.34>:

static void bmk11_execute(void) {
 8001ff0:	b500      	push	{lr}
 8001ff2:	b083      	sub	sp, #12
  uint32_t n = 0;
 8001ff4:	2300      	movs	r3, #0
 8001ff6:	9301      	str	r3, [sp, #4]

  test_wait_tick();
 8001ff8:	f003 fc32 	bl	8005860 <test_wait_tick>
  test_start_timer(1000);
 8001ffc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8002000:	f003 fc4e 	bl	80058a0 <test_start_timer>
  do {
    chSemWait(&sem1);
 8002004:	4817      	ldr	r0, [pc, #92]	; (8002064 <bmk11_execute.lto_priv.34+0x74>)
 8002006:	f008 fd33 	bl	800aa70 <chSemWait>
    chSemSignal(&sem1);
 800200a:	4816      	ldr	r0, [pc, #88]	; (8002064 <bmk11_execute.lto_priv.34+0x74>)
 800200c:	f008 fe08 	bl	800ac20 <chSemSignal>
    chSemWait(&sem1);
 8002010:	4814      	ldr	r0, [pc, #80]	; (8002064 <bmk11_execute.lto_priv.34+0x74>)
 8002012:	f008 fd2d 	bl	800aa70 <chSemWait>
    chSemSignal(&sem1);
 8002016:	4813      	ldr	r0, [pc, #76]	; (8002064 <bmk11_execute.lto_priv.34+0x74>)
 8002018:	f008 fe02 	bl	800ac20 <chSemSignal>
    chSemWait(&sem1);
 800201c:	4811      	ldr	r0, [pc, #68]	; (8002064 <bmk11_execute.lto_priv.34+0x74>)
 800201e:	f008 fd27 	bl	800aa70 <chSemWait>
    chSemSignal(&sem1);
 8002022:	4810      	ldr	r0, [pc, #64]	; (8002064 <bmk11_execute.lto_priv.34+0x74>)
 8002024:	f008 fdfc 	bl	800ac20 <chSemSignal>
    chSemWait(&sem1);
 8002028:	480e      	ldr	r0, [pc, #56]	; (8002064 <bmk11_execute.lto_priv.34+0x74>)
 800202a:	f008 fd21 	bl	800aa70 <chSemWait>
    chSemSignal(&sem1);
 800202e:	480d      	ldr	r0, [pc, #52]	; (8002064 <bmk11_execute.lto_priv.34+0x74>)
 8002030:	f008 fdf6 	bl	800ac20 <chSemSignal>
    n++;
 8002034:	9b01      	ldr	r3, [sp, #4]
 8002036:	3301      	adds	r3, #1
 8002038:	9301      	str	r3, [sp, #4]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 800203a:	4b0b      	ldr	r3, [pc, #44]	; (8002068 <bmk11_execute.lto_priv.34+0x78>)
 800203c:	781b      	ldrb	r3, [r3, #0]
 800203e:	f083 0301 	eor.w	r3, r3, #1
 8002042:	b2db      	uxtb	r3, r3
 8002044:	2b00      	cmp	r3, #0
 8002046:	d1dd      	bne.n	8002004 <bmk11_execute.lto_priv.34+0x14>
  test_print("--- Score : ");
 8002048:	4808      	ldr	r0, [pc, #32]	; (800206c <bmk11_execute.lto_priv.34+0x7c>)
 800204a:	f003 fad1 	bl	80055f0 <test_print>
  test_printn(n * 4);
 800204e:	9b01      	ldr	r3, [sp, #4]
 8002050:	009b      	lsls	r3, r3, #2
 8002052:	4618      	mov	r0, r3
 8002054:	f003 fa84 	bl	8005560 <test_printn>
  test_println(" wait+signal/S");
 8002058:	4805      	ldr	r0, [pc, #20]	; (8002070 <bmk11_execute.lto_priv.34+0x80>)
 800205a:	f003 fae9 	bl	8005630 <test_println>
}
 800205e:	b003      	add	sp, #12
 8002060:	f85d fb04 	ldr.w	pc, [sp], #4
 8002064:	20001c74 	.word	0x20001c74
 8002068:	20001c10 	.word	0x20001c10
 800206c:	0800d7b8 	.word	0x0800d7b8
 8002070:	0800d818 	.word	0x0800d818
	...

08002080 <bmk12_setup.lto_priv.31>:
 * because there are no other threads asking for the mutex.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk12_setup(void) {
 8002080:	b508      	push	{r3, lr}

  chMtxObjectInit(&mtx1);
 8002082:	4802      	ldr	r0, [pc, #8]	; (800208c <bmk12_setup.lto_priv.31+0xc>)
 8002084:	f008 fff4 	bl	800b070 <chMtxObjectInit>
}
 8002088:	bd08      	pop	{r3, pc}
 800208a:	bf00      	nop
 800208c:	20001c80 	.word	0x20001c80

08002090 <bmk12_execute.lto_priv.32>:

static void bmk12_execute(void) {
 8002090:	b500      	push	{lr}
 8002092:	b083      	sub	sp, #12
  uint32_t n = 0;
 8002094:	2300      	movs	r3, #0
 8002096:	9301      	str	r3, [sp, #4]

  test_wait_tick();
 8002098:	f003 fbe2 	bl	8005860 <test_wait_tick>
  test_start_timer(1000);
 800209c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80020a0:	f003 fbfe 	bl	80058a0 <test_start_timer>
  do {
    chMtxLock(&mtx1);
 80020a4:	4817      	ldr	r0, [pc, #92]	; (8002104 <bmk12_execute.lto_priv.32+0x74>)
 80020a6:	f008 fffb 	bl	800b0a0 <chMtxLock>
    chMtxUnlock(&mtx1);
 80020aa:	4816      	ldr	r0, [pc, #88]	; (8002104 <bmk12_execute.lto_priv.32+0x74>)
 80020ac:	f009 f8c8 	bl	800b240 <chMtxUnlock>
    chMtxLock(&mtx1);
 80020b0:	4814      	ldr	r0, [pc, #80]	; (8002104 <bmk12_execute.lto_priv.32+0x74>)
 80020b2:	f008 fff5 	bl	800b0a0 <chMtxLock>
    chMtxUnlock(&mtx1);
 80020b6:	4813      	ldr	r0, [pc, #76]	; (8002104 <bmk12_execute.lto_priv.32+0x74>)
 80020b8:	f009 f8c2 	bl	800b240 <chMtxUnlock>
    chMtxLock(&mtx1);
 80020bc:	4811      	ldr	r0, [pc, #68]	; (8002104 <bmk12_execute.lto_priv.32+0x74>)
 80020be:	f008 ffef 	bl	800b0a0 <chMtxLock>
    chMtxUnlock(&mtx1);
 80020c2:	4810      	ldr	r0, [pc, #64]	; (8002104 <bmk12_execute.lto_priv.32+0x74>)
 80020c4:	f009 f8bc 	bl	800b240 <chMtxUnlock>
    chMtxLock(&mtx1);
 80020c8:	480e      	ldr	r0, [pc, #56]	; (8002104 <bmk12_execute.lto_priv.32+0x74>)
 80020ca:	f008 ffe9 	bl	800b0a0 <chMtxLock>
    chMtxUnlock(&mtx1);
 80020ce:	480d      	ldr	r0, [pc, #52]	; (8002104 <bmk12_execute.lto_priv.32+0x74>)
 80020d0:	f009 f8b6 	bl	800b240 <chMtxUnlock>
    n++;
 80020d4:	9b01      	ldr	r3, [sp, #4]
 80020d6:	3301      	adds	r3, #1
 80020d8:	9301      	str	r3, [sp, #4]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80020da:	4b0b      	ldr	r3, [pc, #44]	; (8002108 <bmk12_execute.lto_priv.32+0x78>)
 80020dc:	781b      	ldrb	r3, [r3, #0]
 80020de:	f083 0301 	eor.w	r3, r3, #1
 80020e2:	b2db      	uxtb	r3, r3
 80020e4:	2b00      	cmp	r3, #0
 80020e6:	d1dd      	bne.n	80020a4 <bmk12_execute.lto_priv.32+0x14>
  test_print("--- Score : ");
 80020e8:	4808      	ldr	r0, [pc, #32]	; (800210c <bmk12_execute.lto_priv.32+0x7c>)
 80020ea:	f003 fa81 	bl	80055f0 <test_print>
  test_printn(n * 4);
 80020ee:	9b01      	ldr	r3, [sp, #4]
 80020f0:	009b      	lsls	r3, r3, #2
 80020f2:	4618      	mov	r0, r3
 80020f4:	f003 fa34 	bl	8005560 <test_printn>
  test_println(" lock+unlock/S");
 80020f8:	4805      	ldr	r0, [pc, #20]	; (8002110 <bmk12_execute.lto_priv.32+0x80>)
 80020fa:	f003 fa99 	bl	8005630 <test_println>
}
 80020fe:	b003      	add	sp, #12
 8002100:	f85d fb04 	ldr.w	pc, [sp], #4
 8002104:	20001c80 	.word	0x20001c80
 8002108:	20001c10 	.word	0x20001c10
 800210c:	0800d7b8 	.word	0x0800d7b8
 8002110:	0800d828 	.word	0x0800d828
	...

08002120 <evt3_setup.lto_priv.68>:
 * - @p chEvtWaitAllTimeout()
 * .
 * After each test phase the test verifies that there are no stuck event flags.
 */

static void evt3_setup(void) {
 8002120:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 8002122:	f04f 30ff 	mov.w	r0, #4294967295
 8002126:	f007 f8d3 	bl	80092d0 <chEvtGetAndClearEvents>
}
 800212a:	bd08      	pop	{r3, pc}
 800212c:	0000      	movs	r0, r0
	...

08002130 <evt3_execute.lto_priv.69>:

static void evt3_execute(void) {
 8002130:	b500      	push	{lr}
 8002132:	b083      	sub	sp, #12
  eventmask_t m;

  /*
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8002134:	f04f 30ff 	mov.w	r0, #4294967295
 8002138:	2100      	movs	r1, #0
 800213a:	f007 fa79 	bl	8009630 <chEvtWaitOneTimeout>
 800213e:	9001      	str	r0, [sp, #4]
  test_assert(1, m == 0, "spurious event");
 8002140:	9b01      	ldr	r3, [sp, #4]
 8002142:	2b00      	cmp	r3, #0
 8002144:	bf0c      	ite	eq
 8002146:	2301      	moveq	r3, #1
 8002148:	2300      	movne	r3, #0
 800214a:	b2db      	uxtb	r3, r3
 800214c:	2001      	movs	r0, #1
 800214e:	4619      	mov	r1, r3
 8002150:	f003 fade 	bl	8005710 <_test_assert>
 8002154:	4603      	mov	r3, r0
 8002156:	2b00      	cmp	r3, #0
 8002158:	d15b      	bne.n	8002212 <evt3_execute.lto_priv.69+0xe2>
  m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 800215a:	f04f 30ff 	mov.w	r0, #4294967295
 800215e:	2100      	movs	r1, #0
 8002160:	f007 faa6 	bl	80096b0 <chEvtWaitAnyTimeout>
 8002164:	9001      	str	r0, [sp, #4]
  test_assert(2, m == 0, "spurious event");
 8002166:	9b01      	ldr	r3, [sp, #4]
 8002168:	2b00      	cmp	r3, #0
 800216a:	bf0c      	ite	eq
 800216c:	2301      	moveq	r3, #1
 800216e:	2300      	movne	r3, #0
 8002170:	b2db      	uxtb	r3, r3
 8002172:	2002      	movs	r0, #2
 8002174:	4619      	mov	r1, r3
 8002176:	f003 facb 	bl	8005710 <_test_assert>
 800217a:	4603      	mov	r3, r0
 800217c:	2b00      	cmp	r3, #0
 800217e:	d148      	bne.n	8002212 <evt3_execute.lto_priv.69+0xe2>
  m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8002180:	f04f 30ff 	mov.w	r0, #4294967295
 8002184:	2100      	movs	r1, #0
 8002186:	f007 fad3 	bl	8009730 <chEvtWaitAllTimeout>
 800218a:	9001      	str	r0, [sp, #4]
  test_assert(3, m == 0, "spurious event");
 800218c:	9b01      	ldr	r3, [sp, #4]
 800218e:	2b00      	cmp	r3, #0
 8002190:	bf0c      	ite	eq
 8002192:	2301      	moveq	r3, #1
 8002194:	2300      	movne	r3, #0
 8002196:	b2db      	uxtb	r3, r3
 8002198:	2003      	movs	r0, #3
 800219a:	4619      	mov	r1, r3
 800219c:	f003 fab8 	bl	8005710 <_test_assert>
 80021a0:	4603      	mov	r3, r0
 80021a2:	2b00      	cmp	r3, #0
 80021a4:	d135      	bne.n	8002212 <evt3_execute.lto_priv.69+0xe2>
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
 80021a6:	f04f 30ff 	mov.w	r0, #4294967295
 80021aa:	210a      	movs	r1, #10
 80021ac:	f007 fa40 	bl	8009630 <chEvtWaitOneTimeout>
 80021b0:	9001      	str	r0, [sp, #4]
  test_assert(4, m == 0, "spurious event");
 80021b2:	9b01      	ldr	r3, [sp, #4]
 80021b4:	2b00      	cmp	r3, #0
 80021b6:	bf0c      	ite	eq
 80021b8:	2301      	moveq	r3, #1
 80021ba:	2300      	movne	r3, #0
 80021bc:	b2db      	uxtb	r3, r3
 80021be:	2004      	movs	r0, #4
 80021c0:	4619      	mov	r1, r3
 80021c2:	f003 faa5 	bl	8005710 <_test_assert>
 80021c6:	4603      	mov	r3, r0
 80021c8:	2b00      	cmp	r3, #0
 80021ca:	d122      	bne.n	8002212 <evt3_execute.lto_priv.69+0xe2>
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
 80021cc:	f04f 30ff 	mov.w	r0, #4294967295
 80021d0:	210a      	movs	r1, #10
 80021d2:	f007 fa6d 	bl	80096b0 <chEvtWaitAnyTimeout>
 80021d6:	9001      	str	r0, [sp, #4]
  test_assert(5, m == 0, "spurious event");
 80021d8:	9b01      	ldr	r3, [sp, #4]
 80021da:	2b00      	cmp	r3, #0
 80021dc:	bf0c      	ite	eq
 80021de:	2301      	moveq	r3, #1
 80021e0:	2300      	movne	r3, #0
 80021e2:	b2db      	uxtb	r3, r3
 80021e4:	2005      	movs	r0, #5
 80021e6:	4619      	mov	r1, r3
 80021e8:	f003 fa92 	bl	8005710 <_test_assert>
 80021ec:	4603      	mov	r3, r0
 80021ee:	2b00      	cmp	r3, #0
 80021f0:	d10f      	bne.n	8002212 <evt3_execute.lto_priv.69+0xe2>
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
 80021f2:	f04f 30ff 	mov.w	r0, #4294967295
 80021f6:	210a      	movs	r1, #10
 80021f8:	f007 fa9a 	bl	8009730 <chEvtWaitAllTimeout>
 80021fc:	9001      	str	r0, [sp, #4]
  test_assert(6, m == 0, "spurious event");
 80021fe:	9b01      	ldr	r3, [sp, #4]
 8002200:	2b00      	cmp	r3, #0
 8002202:	bf0c      	ite	eq
 8002204:	2301      	moveq	r3, #1
 8002206:	2300      	movne	r3, #0
 8002208:	b2db      	uxtb	r3, r3
 800220a:	2006      	movs	r0, #6
 800220c:	4619      	mov	r1, r3
 800220e:	f003 fa7f 	bl	8005710 <_test_assert>
}
 8002212:	b003      	add	sp, #12
 8002214:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002220 <heap1_setup.lto_priv.66>:
 * allocator.<br>
 * The test expects to find the heap back to the initial status after each
 * sequence.
 */

static void heap1_setup(void) {
 8002220:	b508      	push	{r3, lr}

  chHeapObjectInit(&test_heap, test.buffer, sizeof(union test_buffers));
 8002222:	4803      	ldr	r0, [pc, #12]	; (8002230 <heap1_setup.lto_priv.66+0x10>)
 8002224:	4903      	ldr	r1, [pc, #12]	; (8002234 <heap1_setup.lto_priv.66+0x14>)
 8002226:	f44f 62e1 	mov.w	r2, #1800	; 0x708
 800222a:	f006 fb19 	bl	8008860 <chHeapObjectInit>
}
 800222e:	bd08      	pop	{r3, pc}
 8002230:	20001c28 	.word	0x20001c28
 8002234:	200014f0 	.word	0x200014f0
	...

08002240 <heap1_execute.lto_priv.67>:

static void heap1_execute(void) {
 8002240:	b500      	push	{lr}
 8002242:	b087      	sub	sp, #28
  void *p1, *p2, *p3;
  size_t n, sz;

  /* Unrelated, for coverage only.*/
  (void)chCoreGetStatusX();
 8002244:	f006 fae4 	bl	8008810 <chCoreGetStatusX>

  /*
   * Test on the default heap in order to cover the core allocator at
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
 8002248:	ab01      	add	r3, sp, #4
 800224a:	2000      	movs	r0, #0
 800224c:	4619      	mov	r1, r3
 800224e:	f006 fc2f 	bl	8008ab0 <chHeapStatus>
  p1 = chHeapAlloc(NULL, SIZE);
 8002252:	2000      	movs	r0, #0
 8002254:	2110      	movs	r1, #16
 8002256:	f006 fb33 	bl	80088c0 <chHeapAlloc>
 800225a:	9005      	str	r0, [sp, #20]
  test_assert(1, p1 != NULL, "allocation failed");
 800225c:	9b05      	ldr	r3, [sp, #20]
 800225e:	2b00      	cmp	r3, #0
 8002260:	bf14      	ite	ne
 8002262:	2301      	movne	r3, #1
 8002264:	2300      	moveq	r3, #0
 8002266:	b2db      	uxtb	r3, r3
 8002268:	2001      	movs	r0, #1
 800226a:	4619      	mov	r1, r3
 800226c:	f003 fa50 	bl	8005710 <_test_assert>
 8002270:	4603      	mov	r3, r0
 8002272:	2b00      	cmp	r3, #0
 8002274:	f040 8148 	bne.w	8002508 <heap1_execute.lto_priv.67+0x2c8>
  chHeapFree(p1);
 8002278:	9805      	ldr	r0, [sp, #20]
 800227a:	f006 fb99 	bl	80089b0 <chHeapFree>
  p1 = chHeapAlloc(NULL, (size_t)-256);
 800227e:	2000      	movs	r0, #0
 8002280:	f06f 01ff 	mvn.w	r1, #255	; 0xff
 8002284:	f006 fb1c 	bl	80088c0 <chHeapAlloc>
 8002288:	9005      	str	r0, [sp, #20]
  test_assert(2, p1 == NULL, "allocation not failed");
 800228a:	9b05      	ldr	r3, [sp, #20]
 800228c:	2b00      	cmp	r3, #0
 800228e:	bf0c      	ite	eq
 8002290:	2301      	moveq	r3, #1
 8002292:	2300      	movne	r3, #0
 8002294:	b2db      	uxtb	r3, r3
 8002296:	2002      	movs	r0, #2
 8002298:	4619      	mov	r1, r3
 800229a:	f003 fa39 	bl	8005710 <_test_assert>
 800229e:	4603      	mov	r3, r0
 80022a0:	2b00      	cmp	r3, #0
 80022a2:	f040 8131 	bne.w	8002508 <heap1_execute.lto_priv.67+0x2c8>

  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);
 80022a6:	ab01      	add	r3, sp, #4
 80022a8:	4899      	ldr	r0, [pc, #612]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 80022aa:	4619      	mov	r1, r3
 80022ac:	f006 fc00 	bl	8008ab0 <chHeapStatus>

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 80022b0:	4897      	ldr	r0, [pc, #604]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 80022b2:	2110      	movs	r1, #16
 80022b4:	f006 fb04 	bl	80088c0 <chHeapAlloc>
 80022b8:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 80022ba:	4895      	ldr	r0, [pc, #596]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 80022bc:	2110      	movs	r1, #16
 80022be:	f006 faff 	bl	80088c0 <chHeapAlloc>
 80022c2:	9004      	str	r0, [sp, #16]
  p3 = chHeapAlloc(&test_heap, SIZE);
 80022c4:	4892      	ldr	r0, [pc, #584]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 80022c6:	2110      	movs	r1, #16
 80022c8:	f006 fafa 	bl	80088c0 <chHeapAlloc>
 80022cc:	9003      	str	r0, [sp, #12]
  chHeapFree(p1);                               /* Does not merge.*/
 80022ce:	9805      	ldr	r0, [sp, #20]
 80022d0:	f006 fb6e 	bl	80089b0 <chHeapFree>
  chHeapFree(p2);                               /* Merges backward.*/
 80022d4:	9804      	ldr	r0, [sp, #16]
 80022d6:	f006 fb6b 	bl	80089b0 <chHeapFree>
  chHeapFree(p3);                               /* Merges both sides.*/
 80022da:	9803      	ldr	r0, [sp, #12]
 80022dc:	f006 fb68 	bl	80089b0 <chHeapFree>
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 80022e0:	ab02      	add	r3, sp, #8
 80022e2:	488b      	ldr	r0, [pc, #556]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 80022e4:	4619      	mov	r1, r3
 80022e6:	f006 fbe3 	bl	8008ab0 <chHeapStatus>
 80022ea:	4603      	mov	r3, r0
 80022ec:	2b01      	cmp	r3, #1
 80022ee:	bf0c      	ite	eq
 80022f0:	2301      	moveq	r3, #1
 80022f2:	2300      	movne	r3, #0
 80022f4:	b2db      	uxtb	r3, r3
 80022f6:	2003      	movs	r0, #3
 80022f8:	4619      	mov	r1, r3
 80022fa:	f003 fa09 	bl	8005710 <_test_assert>
 80022fe:	4603      	mov	r3, r0
 8002300:	2b00      	cmp	r3, #0
 8002302:	f040 8101 	bne.w	8002508 <heap1_execute.lto_priv.67+0x2c8>

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8002306:	4882      	ldr	r0, [pc, #520]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 8002308:	2110      	movs	r1, #16
 800230a:	f006 fad9 	bl	80088c0 <chHeapAlloc>
 800230e:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 8002310:	487f      	ldr	r0, [pc, #508]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 8002312:	2110      	movs	r1, #16
 8002314:	f006 fad4 	bl	80088c0 <chHeapAlloc>
 8002318:	9004      	str	r0, [sp, #16]
  p3 = chHeapAlloc(&test_heap, SIZE);
 800231a:	487d      	ldr	r0, [pc, #500]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 800231c:	2110      	movs	r1, #16
 800231e:	f006 facf 	bl	80088c0 <chHeapAlloc>
 8002322:	9003      	str	r0, [sp, #12]
  chHeapFree(p3);                               /* Merges forward.*/
 8002324:	9803      	ldr	r0, [sp, #12]
 8002326:	f006 fb43 	bl	80089b0 <chHeapFree>
  chHeapFree(p2);                               /* Merges forward.*/
 800232a:	9804      	ldr	r0, [sp, #16]
 800232c:	f006 fb40 	bl	80089b0 <chHeapFree>
  chHeapFree(p1);                               /* Merges forward.*/
 8002330:	9805      	ldr	r0, [sp, #20]
 8002332:	f006 fb3d 	bl	80089b0 <chHeapFree>
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8002336:	ab02      	add	r3, sp, #8
 8002338:	4875      	ldr	r0, [pc, #468]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 800233a:	4619      	mov	r1, r3
 800233c:	f006 fbb8 	bl	8008ab0 <chHeapStatus>
 8002340:	4603      	mov	r3, r0
 8002342:	2b01      	cmp	r3, #1
 8002344:	bf0c      	ite	eq
 8002346:	2301      	moveq	r3, #1
 8002348:	2300      	movne	r3, #0
 800234a:	b2db      	uxtb	r3, r3
 800234c:	2004      	movs	r0, #4
 800234e:	4619      	mov	r1, r3
 8002350:	f003 f9de 	bl	8005710 <_test_assert>
 8002354:	4603      	mov	r3, r0
 8002356:	2b00      	cmp	r3, #0
 8002358:	f040 80d6 	bne.w	8002508 <heap1_execute.lto_priv.67+0x2c8>

  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
 800235c:	486c      	ldr	r0, [pc, #432]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 800235e:	2111      	movs	r1, #17
 8002360:	f006 faae 	bl	80088c0 <chHeapAlloc>
 8002364:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 8002366:	486a      	ldr	r0, [pc, #424]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 8002368:	2110      	movs	r1, #16
 800236a:	f006 faa9 	bl	80088c0 <chHeapAlloc>
 800236e:	9004      	str	r0, [sp, #16]
  chHeapFree(p1);
 8002370:	9805      	ldr	r0, [sp, #20]
 8002372:	f006 fb1d 	bl	80089b0 <chHeapFree>
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 8002376:	ab02      	add	r3, sp, #8
 8002378:	4865      	ldr	r0, [pc, #404]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 800237a:	4619      	mov	r1, r3
 800237c:	f006 fb98 	bl	8008ab0 <chHeapStatus>
 8002380:	4603      	mov	r3, r0
 8002382:	2b02      	cmp	r3, #2
 8002384:	bf0c      	ite	eq
 8002386:	2301      	moveq	r3, #1
 8002388:	2300      	movne	r3, #0
 800238a:	b2db      	uxtb	r3, r3
 800238c:	2005      	movs	r0, #5
 800238e:	4619      	mov	r1, r3
 8002390:	f003 f9be 	bl	8005710 <_test_assert>
 8002394:	4603      	mov	r3, r0
 8002396:	2b00      	cmp	r3, #0
 8002398:	f040 80b6 	bne.w	8002508 <heap1_execute.lto_priv.67+0x2c8>
  p1 = chHeapAlloc(&test_heap, SIZE);
 800239c:	485c      	ldr	r0, [pc, #368]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 800239e:	2110      	movs	r1, #16
 80023a0:	f006 fa8e 	bl	80088c0 <chHeapAlloc>
 80023a4:	9005      	str	r0, [sp, #20]
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 80023a6:	ab02      	add	r3, sp, #8
 80023a8:	4859      	ldr	r0, [pc, #356]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 80023aa:	4619      	mov	r1, r3
 80023ac:	f006 fb80 	bl	8008ab0 <chHeapStatus>
 80023b0:	4603      	mov	r3, r0
 80023b2:	2b01      	cmp	r3, #1
 80023b4:	d007      	beq.n	80023c6 <heap1_execute.lto_priv.67+0x186>
 80023b6:	ab02      	add	r3, sp, #8
 80023b8:	4855      	ldr	r0, [pc, #340]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 80023ba:	4619      	mov	r1, r3
 80023bc:	f006 fb78 	bl	8008ab0 <chHeapStatus>
 80023c0:	4603      	mov	r3, r0
 80023c2:	2b02      	cmp	r3, #2
 80023c4:	d101      	bne.n	80023ca <heap1_execute.lto_priv.67+0x18a>
 80023c6:	2301      	movs	r3, #1
 80023c8:	e000      	b.n	80023cc <heap1_execute.lto_priv.67+0x18c>
 80023ca:	2300      	movs	r3, #0
 80023cc:	f003 0301 	and.w	r3, r3, #1
 80023d0:	b2db      	uxtb	r3, r3
 80023d2:	2006      	movs	r0, #6
 80023d4:	4619      	mov	r1, r3
 80023d6:	f003 f99b 	bl	8005710 <_test_assert>
 80023da:	4603      	mov	r3, r0
 80023dc:	2b00      	cmp	r3, #0
 80023de:	f040 8093 	bne.w	8002508 <heap1_execute.lto_priv.67+0x2c8>
                 (chHeapStatus(&test_heap, &n) == 2), "heap fragmented");
  chHeapFree(p2);
 80023e2:	9804      	ldr	r0, [sp, #16]
 80023e4:	f006 fae4 	bl	80089b0 <chHeapFree>
  chHeapFree(p1);
 80023e8:	9805      	ldr	r0, [sp, #20]
 80023ea:	f006 fae1 	bl	80089b0 <chHeapFree>
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 80023ee:	ab02      	add	r3, sp, #8
 80023f0:	4847      	ldr	r0, [pc, #284]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 80023f2:	4619      	mov	r1, r3
 80023f4:	f006 fb5c 	bl	8008ab0 <chHeapStatus>
 80023f8:	4603      	mov	r3, r0
 80023fa:	2b01      	cmp	r3, #1
 80023fc:	bf0c      	ite	eq
 80023fe:	2301      	moveq	r3, #1
 8002400:	2300      	movne	r3, #0
 8002402:	b2db      	uxtb	r3, r3
 8002404:	2007      	movs	r0, #7
 8002406:	4619      	mov	r1, r3
 8002408:	f003 f982 	bl	8005710 <_test_assert>
 800240c:	4603      	mov	r3, r0
 800240e:	2b00      	cmp	r3, #0
 8002410:	d17a      	bne.n	8002508 <heap1_execute.lto_priv.67+0x2c8>

  /* Skip fragment handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8002412:	483f      	ldr	r0, [pc, #252]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 8002414:	2110      	movs	r1, #16
 8002416:	f006 fa53 	bl	80088c0 <chHeapAlloc>
 800241a:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 800241c:	483c      	ldr	r0, [pc, #240]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 800241e:	2110      	movs	r1, #16
 8002420:	f006 fa4e 	bl	80088c0 <chHeapAlloc>
 8002424:	9004      	str	r0, [sp, #16]
  chHeapFree(p1);
 8002426:	9805      	ldr	r0, [sp, #20]
 8002428:	f006 fac2 	bl	80089b0 <chHeapFree>
  test_assert(8, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 800242c:	ab02      	add	r3, sp, #8
 800242e:	4838      	ldr	r0, [pc, #224]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 8002430:	4619      	mov	r1, r3
 8002432:	f006 fb3d 	bl	8008ab0 <chHeapStatus>
 8002436:	4603      	mov	r3, r0
 8002438:	2b02      	cmp	r3, #2
 800243a:	bf0c      	ite	eq
 800243c:	2301      	moveq	r3, #1
 800243e:	2300      	movne	r3, #0
 8002440:	b2db      	uxtb	r3, r3
 8002442:	2008      	movs	r0, #8
 8002444:	4619      	mov	r1, r3
 8002446:	f003 f963 	bl	8005710 <_test_assert>
 800244a:	4603      	mov	r3, r0
 800244c:	2b00      	cmp	r3, #0
 800244e:	d15b      	bne.n	8002508 <heap1_execute.lto_priv.67+0x2c8>
  p1 = chHeapAlloc(&test_heap, SIZE * 2);       /* Skips first fragment.*/
 8002450:	482f      	ldr	r0, [pc, #188]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 8002452:	2120      	movs	r1, #32
 8002454:	f006 fa34 	bl	80088c0 <chHeapAlloc>
 8002458:	9005      	str	r0, [sp, #20]
  chHeapFree(p1);
 800245a:	9805      	ldr	r0, [sp, #20]
 800245c:	f006 faa8 	bl	80089b0 <chHeapFree>
  chHeapFree(p2);
 8002460:	9804      	ldr	r0, [sp, #16]
 8002462:	f006 faa5 	bl	80089b0 <chHeapFree>
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8002466:	ab02      	add	r3, sp, #8
 8002468:	4829      	ldr	r0, [pc, #164]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 800246a:	4619      	mov	r1, r3
 800246c:	f006 fb20 	bl	8008ab0 <chHeapStatus>
 8002470:	4603      	mov	r3, r0
 8002472:	2b01      	cmp	r3, #1
 8002474:	bf0c      	ite	eq
 8002476:	2301      	moveq	r3, #1
 8002478:	2300      	movne	r3, #0
 800247a:	b2db      	uxtb	r3, r3
 800247c:	2009      	movs	r0, #9
 800247e:	4619      	mov	r1, r3
 8002480:	f003 f946 	bl	8005710 <_test_assert>
 8002484:	4603      	mov	r3, r0
 8002486:	2b00      	cmp	r3, #0
 8002488:	d13e      	bne.n	8002508 <heap1_execute.lto_priv.67+0x2c8>

  /* Allocate all handling.*/
  (void)chHeapStatus(&test_heap, &n);
 800248a:	ab02      	add	r3, sp, #8
 800248c:	4820      	ldr	r0, [pc, #128]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 800248e:	4619      	mov	r1, r3
 8002490:	f006 fb0e 	bl	8008ab0 <chHeapStatus>
  p1 = chHeapAlloc(&test_heap, n);
 8002494:	9b02      	ldr	r3, [sp, #8]
 8002496:	481e      	ldr	r0, [pc, #120]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 8002498:	4619      	mov	r1, r3
 800249a:	f006 fa11 	bl	80088c0 <chHeapAlloc>
 800249e:	9005      	str	r0, [sp, #20]
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
 80024a0:	ab02      	add	r3, sp, #8
 80024a2:	481b      	ldr	r0, [pc, #108]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 80024a4:	4619      	mov	r1, r3
 80024a6:	f006 fb03 	bl	8008ab0 <chHeapStatus>
 80024aa:	4603      	mov	r3, r0
 80024ac:	2b00      	cmp	r3, #0
 80024ae:	bf0c      	ite	eq
 80024b0:	2301      	moveq	r3, #1
 80024b2:	2300      	movne	r3, #0
 80024b4:	b2db      	uxtb	r3, r3
 80024b6:	200a      	movs	r0, #10
 80024b8:	4619      	mov	r1, r3
 80024ba:	f003 f929 	bl	8005710 <_test_assert>
 80024be:	4603      	mov	r3, r0
 80024c0:	2b00      	cmp	r3, #0
 80024c2:	d121      	bne.n	8002508 <heap1_execute.lto_priv.67+0x2c8>
  chHeapFree(p1);
 80024c4:	9805      	ldr	r0, [sp, #20]
 80024c6:	f006 fa73 	bl	80089b0 <chHeapFree>

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 80024ca:	ab02      	add	r3, sp, #8
 80024cc:	4810      	ldr	r0, [pc, #64]	; (8002510 <heap1_execute.lto_priv.67+0x2d0>)
 80024ce:	4619      	mov	r1, r3
 80024d0:	f006 faee 	bl	8008ab0 <chHeapStatus>
 80024d4:	4603      	mov	r3, r0
 80024d6:	2b01      	cmp	r3, #1
 80024d8:	bf0c      	ite	eq
 80024da:	2301      	moveq	r3, #1
 80024dc:	2300      	movne	r3, #0
 80024de:	b2db      	uxtb	r3, r3
 80024e0:	200b      	movs	r0, #11
 80024e2:	4619      	mov	r1, r3
 80024e4:	f003 f914 	bl	8005710 <_test_assert>
 80024e8:	4603      	mov	r3, r0
 80024ea:	2b00      	cmp	r3, #0
 80024ec:	d10c      	bne.n	8002508 <heap1_execute.lto_priv.67+0x2c8>
  test_assert(12, n == sz, "size changed");
 80024ee:	9a02      	ldr	r2, [sp, #8]
 80024f0:	9b01      	ldr	r3, [sp, #4]
 80024f2:	429a      	cmp	r2, r3
 80024f4:	bf0c      	ite	eq
 80024f6:	2301      	moveq	r3, #1
 80024f8:	2300      	movne	r3, #0
 80024fa:	b2db      	uxtb	r3, r3
 80024fc:	200c      	movs	r0, #12
 80024fe:	4619      	mov	r1, r3
 8002500:	f003 f906 	bl	8005710 <_test_assert>
 8002504:	4603      	mov	r3, r0
 8002506:	2b00      	cmp	r3, #0
}
 8002508:	b007      	add	sp, #28
 800250a:	f85d fb04 	ldr.w	pc, [sp], #4
 800250e:	bf00      	nop
 8002510:	20001c28 	.word	0x20001c28
	...

08002520 <null_provider>:
 * Five memory blocks are added to a memory pool then removed.<br>
 * The test expects to find the pool queue in the proper status after each
 * operation.
 */

static void *null_provider(size_t size) {
 8002520:	b082      	sub	sp, #8
 8002522:	9001      	str	r0, [sp, #4]

  (void)size;
  return NULL;
 8002524:	2300      	movs	r3, #0
}
 8002526:	4618      	mov	r0, r3
 8002528:	b002      	add	sp, #8
 800252a:	4770      	bx	lr
 800252c:	0000      	movs	r0, r0
	...

08002530 <pools1_setup.lto_priv.64>:

static void pools1_setup(void) {
 8002530:	b508      	push	{r3, lr}

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
 8002532:	4803      	ldr	r0, [pc, #12]	; (8002540 <pools1_setup.lto_priv.64+0x10>)
 8002534:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8002538:	2200      	movs	r2, #0
 800253a:	f006 fb39 	bl	8008bb0 <chPoolObjectInit>
}
 800253e:	bd08      	pop	{r3, pc}
 8002540:	20000898 	.word	0x20000898
	...

08002550 <pools1_execute.lto_priv.65>:

static void pools1_execute(void) {
 8002550:	b500      	push	{lr}
 8002552:	b083      	sub	sp, #12
  int i;

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);
 8002554:	4b3f      	ldr	r3, [pc, #252]	; (8002654 <pools1_execute.lto_priv.65+0x104>)
 8002556:	681b      	ldr	r3, [r3, #0]
 8002558:	483f      	ldr	r0, [pc, #252]	; (8002658 <pools1_execute.lto_priv.65+0x108>)
 800255a:	4619      	mov	r1, r3
 800255c:	2205      	movs	r2, #5
 800255e:	f006 fb47 	bl	8008bf0 <chPoolLoadArray>

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
 8002562:	2300      	movs	r3, #0
 8002564:	9301      	str	r3, [sp, #4]
 8002566:	e012      	b.n	800258e <pools1_execute.lto_priv.65+0x3e>
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");
 8002568:	483b      	ldr	r0, [pc, #236]	; (8002658 <pools1_execute.lto_priv.65+0x108>)
 800256a:	f006 fb99 	bl	8008ca0 <chPoolAlloc>
 800256e:	4603      	mov	r3, r0
 8002570:	2b00      	cmp	r3, #0
 8002572:	bf14      	ite	ne
 8002574:	2301      	movne	r3, #1
 8002576:	2300      	moveq	r3, #0
 8002578:	b2db      	uxtb	r3, r3
 800257a:	2001      	movs	r0, #1
 800257c:	4619      	mov	r1, r3
 800257e:	f003 f8c7 	bl	8005710 <_test_assert>
 8002582:	4603      	mov	r3, r0
 8002584:	2b00      	cmp	r3, #0
 8002586:	d161      	bne.n	800264c <pools1_execute.lto_priv.65+0xfc>

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
 8002588:	9b01      	ldr	r3, [sp, #4]
 800258a:	3301      	adds	r3, #1
 800258c:	9301      	str	r3, [sp, #4]
 800258e:	9b01      	ldr	r3, [sp, #4]
 8002590:	2b04      	cmp	r3, #4
 8002592:	dde9      	ble.n	8002568 <pools1_execute.lto_priv.65+0x18>
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");
 8002594:	4830      	ldr	r0, [pc, #192]	; (8002658 <pools1_execute.lto_priv.65+0x108>)
 8002596:	f006 fb83 	bl	8008ca0 <chPoolAlloc>
 800259a:	4603      	mov	r3, r0
 800259c:	2b00      	cmp	r3, #0
 800259e:	bf0c      	ite	eq
 80025a0:	2301      	moveq	r3, #1
 80025a2:	2300      	movne	r3, #0
 80025a4:	b2db      	uxtb	r3, r3
 80025a6:	2002      	movs	r0, #2
 80025a8:	4619      	mov	r1, r3
 80025aa:	f003 f8b1 	bl	8005710 <_test_assert>
 80025ae:	4603      	mov	r3, r0
 80025b0:	2b00      	cmp	r3, #0
 80025b2:	d14b      	bne.n	800264c <pools1_execute.lto_priv.65+0xfc>

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 80025b4:	2300      	movs	r3, #0
 80025b6:	9301      	str	r3, [sp, #4]
 80025b8:	e00a      	b.n	80025d0 <pools1_execute.lto_priv.65+0x80>
    chPoolFree(&mp1, wa[i]);
 80025ba:	4a26      	ldr	r2, [pc, #152]	; (8002654 <pools1_execute.lto_priv.65+0x104>)
 80025bc:	9b01      	ldr	r3, [sp, #4]
 80025be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80025c2:	4825      	ldr	r0, [pc, #148]	; (8002658 <pools1_execute.lto_priv.65+0x108>)
 80025c4:	4619      	mov	r1, r3
 80025c6:	f006 fb9b 	bl	8008d00 <chPoolFree>

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 80025ca:	9b01      	ldr	r3, [sp, #4]
 80025cc:	3301      	adds	r3, #1
 80025ce:	9301      	str	r3, [sp, #4]
 80025d0:	9b01      	ldr	r3, [sp, #4]
 80025d2:	2b04      	cmp	r3, #4
 80025d4:	ddf1      	ble.n	80025ba <pools1_execute.lto_priv.65+0x6a>
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
 80025d6:	2300      	movs	r3, #0
 80025d8:	9301      	str	r3, [sp, #4]
 80025da:	e012      	b.n	8002602 <pools1_execute.lto_priv.65+0xb2>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");
 80025dc:	481e      	ldr	r0, [pc, #120]	; (8002658 <pools1_execute.lto_priv.65+0x108>)
 80025de:	f006 fb5f 	bl	8008ca0 <chPoolAlloc>
 80025e2:	4603      	mov	r3, r0
 80025e4:	2b00      	cmp	r3, #0
 80025e6:	bf14      	ite	ne
 80025e8:	2301      	movne	r3, #1
 80025ea:	2300      	moveq	r3, #0
 80025ec:	b2db      	uxtb	r3, r3
 80025ee:	2003      	movs	r0, #3
 80025f0:	4619      	mov	r1, r3
 80025f2:	f003 f88d 	bl	8005710 <_test_assert>
 80025f6:	4603      	mov	r3, r0
 80025f8:	2b00      	cmp	r3, #0
 80025fa:	d127      	bne.n	800264c <pools1_execute.lto_priv.65+0xfc>
  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
 80025fc:	9b01      	ldr	r3, [sp, #4]
 80025fe:	3301      	adds	r3, #1
 8002600:	9301      	str	r3, [sp, #4]
 8002602:	9b01      	ldr	r3, [sp, #4]
 8002604:	2b04      	cmp	r3, #4
 8002606:	dde9      	ble.n	80025dc <pools1_execute.lto_priv.65+0x8c>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty again.*/
  test_assert(4, chPoolAlloc(&mp1) == NULL, "list not empty");
 8002608:	4813      	ldr	r0, [pc, #76]	; (8002658 <pools1_execute.lto_priv.65+0x108>)
 800260a:	f006 fb49 	bl	8008ca0 <chPoolAlloc>
 800260e:	4603      	mov	r3, r0
 8002610:	2b00      	cmp	r3, #0
 8002612:	bf0c      	ite	eq
 8002614:	2301      	moveq	r3, #1
 8002616:	2300      	movne	r3, #0
 8002618:	b2db      	uxtb	r3, r3
 800261a:	2004      	movs	r0, #4
 800261c:	4619      	mov	r1, r3
 800261e:	f003 f877 	bl	8005710 <_test_assert>
 8002622:	4603      	mov	r3, r0
 8002624:	2b00      	cmp	r3, #0
 8002626:	d111      	bne.n	800264c <pools1_execute.lto_priv.65+0xfc>

  /* Covering the case where a provider is unable to return more memory.*/
  chPoolObjectInit(&mp1, 16, null_provider);
 8002628:	480b      	ldr	r0, [pc, #44]	; (8002658 <pools1_execute.lto_priv.65+0x108>)
 800262a:	2110      	movs	r1, #16
 800262c:	4a0b      	ldr	r2, [pc, #44]	; (800265c <pools1_execute.lto_priv.65+0x10c>)
 800262e:	f006 fabf 	bl	8008bb0 <chPoolObjectInit>
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8002632:	4809      	ldr	r0, [pc, #36]	; (8002658 <pools1_execute.lto_priv.65+0x108>)
 8002634:	f006 fb34 	bl	8008ca0 <chPoolAlloc>
 8002638:	4603      	mov	r3, r0
 800263a:	2b00      	cmp	r3, #0
 800263c:	bf0c      	ite	eq
 800263e:	2301      	moveq	r3, #1
 8002640:	2300      	movne	r3, #0
 8002642:	b2db      	uxtb	r3, r3
 8002644:	2005      	movs	r0, #5
 8002646:	4619      	mov	r1, r3
 8002648:	f003 f862 	bl	8005710 <_test_assert>
}
 800264c:	b003      	add	sp, #12
 800264e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002652:	bf00      	nop
 8002654:	0800e420 	.word	0x0800e420
 8002658:	20000898 	.word	0x20000898
 800265c:	08002521 	.word	0x08002521

08002660 <chThdGetSelfX.lto_priv.168>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002660:	4b01      	ldr	r3, [pc, #4]	; (8002668 <chThdGetSelfX.lto_priv.168+0x8>)
 8002662:	699b      	ldr	r3, [r3, #24]
}
 8002664:	4618      	mov	r0, r3
 8002666:	4770      	bx	lr
 8002668:	20000d30 	.word	0x20000d30
 800266c:	00000000 	.word	0x00000000

08002670 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 8002670:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 8002672:	f7ff fff5 	bl	8002660 <chThdGetSelfX.lto_priv.168>
 8002676:	4603      	mov	r3, r0
 8002678:	689b      	ldr	r3, [r3, #8]
}
 800267a:	4618      	mov	r0, r3
 800267c:	bd08      	pop	{r3, pc}
 800267e:	bf00      	nop

08002680 <thread>:
 * is attempted.<br>
 * The test expects the first two threads to successfully start and the last
 * one to fail.
 */

static THD_FUNCTION(thread, p) {
 8002680:	b500      	push	{lr}
 8002682:	b083      	sub	sp, #12
 8002684:	9001      	str	r0, [sp, #4]

  test_emit_token(*(char *)p);
 8002686:	9b01      	ldr	r3, [sp, #4]
 8002688:	781b      	ldrb	r3, [r3, #0]
 800268a:	4618      	mov	r0, r3
 800268c:	f003 f810 	bl	80056b0 <test_emit_token>
}
 8002690:	b003      	add	sp, #12
 8002692:	f85d fb04 	ldr.w	pc, [sp], #4
 8002696:	bf00      	nop
	...

080026a0 <dyn1_setup.lto_priv.60>:

#if CH_CFG_USE_HEAP || defined(__DOXYGEN__)
static void dyn1_setup(void) {
 80026a0:	b508      	push	{r3, lr}

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
 80026a2:	4803      	ldr	r0, [pc, #12]	; (80026b0 <dyn1_setup.lto_priv.60+0x10>)
 80026a4:	4903      	ldr	r1, [pc, #12]	; (80026b4 <dyn1_setup.lto_priv.60+0x14>)
 80026a6:	f44f 62e1 	mov.w	r2, #1800	; 0x708
 80026aa:	f006 f8d9 	bl	8008860 <chHeapObjectInit>
}
 80026ae:	bd08      	pop	{r3, pc}
 80026b0:	20001c48 	.word	0x20001c48
 80026b4:	200014f0 	.word	0x200014f0
	...

080026c0 <dyn1_execute.lto_priv.61>:

static void dyn1_execute(void) {
 80026c0:	b500      	push	{lr}
 80026c2:	b087      	sub	sp, #28
  size_t n, sz;
  void *p1;
  tprio_t prio = chThdGetPriorityX();
 80026c4:	f7ff ffd4 	bl	8002670 <chThdGetPriorityX>
 80026c8:	9005      	str	r0, [sp, #20]

  (void)chHeapStatus(&heap1, &sz);
 80026ca:	ab02      	add	r3, sp, #8
 80026cc:	4842      	ldr	r0, [pc, #264]	; (80027d8 <dyn1_execute.lto_priv.61+0x118>)
 80026ce:	4619      	mov	r1, r3
 80026d0:	f006 f9ee 	bl	8008ab0 <chHeapStatus>
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 80026d4:	9b05      	ldr	r3, [sp, #20]
 80026d6:	1e5a      	subs	r2, r3, #1
 80026d8:	4b40      	ldr	r3, [pc, #256]	; (80027dc <dyn1_execute.lto_priv.61+0x11c>)
 80026da:	9300      	str	r3, [sp, #0]
 80026dc:	483e      	ldr	r0, [pc, #248]	; (80027d8 <dyn1_execute.lto_priv.61+0x118>)
 80026de:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80026e2:	4b3f      	ldr	r3, [pc, #252]	; (80027e0 <dyn1_execute.lto_priv.61+0x120>)
 80026e4:	f007 ff7c 	bl	800a5e0 <chThdCreateFromHeap>
 80026e8:	4602      	mov	r2, r0
 80026ea:	4b3e      	ldr	r3, [pc, #248]	; (80027e4 <dyn1_execute.lto_priv.61+0x124>)
 80026ec:	601a      	str	r2, [r3, #0]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 80026ee:	9b05      	ldr	r3, [sp, #20]
 80026f0:	1e9a      	subs	r2, r3, #2
 80026f2:	4b3d      	ldr	r3, [pc, #244]	; (80027e8 <dyn1_execute.lto_priv.61+0x128>)
 80026f4:	9300      	str	r3, [sp, #0]
 80026f6:	4838      	ldr	r0, [pc, #224]	; (80027d8 <dyn1_execute.lto_priv.61+0x118>)
 80026f8:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80026fc:	4b38      	ldr	r3, [pc, #224]	; (80027e0 <dyn1_execute.lto_priv.61+0x120>)
 80026fe:	f007 ff6f 	bl	800a5e0 <chThdCreateFromHeap>
 8002702:	4602      	mov	r2, r0
 8002704:	4b37      	ldr	r3, [pc, #220]	; (80027e4 <dyn1_execute.lto_priv.61+0x124>)
 8002706:	605a      	str	r2, [r3, #4]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
 8002708:	ab03      	add	r3, sp, #12
 800270a:	4833      	ldr	r0, [pc, #204]	; (80027d8 <dyn1_execute.lto_priv.61+0x118>)
 800270c:	4619      	mov	r1, r3
 800270e:	f006 f9cf 	bl	8008ab0 <chHeapStatus>
  p1 = chHeapAlloc(&heap1, n);
 8002712:	9b03      	ldr	r3, [sp, #12]
 8002714:	4830      	ldr	r0, [pc, #192]	; (80027d8 <dyn1_execute.lto_priv.61+0x118>)
 8002716:	4619      	mov	r1, r3
 8002718:	f006 f8d2 	bl	80088c0 <chHeapAlloc>
 800271c:	9004      	str	r0, [sp, #16]
  threads[2] = chThdCreateFromHeap(&heap1,
 800271e:	9b05      	ldr	r3, [sp, #20]
 8002720:	1eda      	subs	r2, r3, #3
 8002722:	4b32      	ldr	r3, [pc, #200]	; (80027ec <dyn1_execute.lto_priv.61+0x12c>)
 8002724:	9300      	str	r3, [sp, #0]
 8002726:	482c      	ldr	r0, [pc, #176]	; (80027d8 <dyn1_execute.lto_priv.61+0x118>)
 8002728:	f44f 71b4 	mov.w	r1, #360	; 0x168
 800272c:	4b2c      	ldr	r3, [pc, #176]	; (80027e0 <dyn1_execute.lto_priv.61+0x120>)
 800272e:	f007 ff57 	bl	800a5e0 <chThdCreateFromHeap>
 8002732:	4602      	mov	r2, r0
 8002734:	4b2b      	ldr	r3, [pc, #172]	; (80027e4 <dyn1_execute.lto_priv.61+0x124>)
 8002736:	609a      	str	r2, [r3, #8]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-3, thread, "C");
  chHeapFree(p1);
 8002738:	9804      	ldr	r0, [sp, #16]
 800273a:	f006 f939 	bl	80089b0 <chHeapFree>

  test_assert(1, (threads[0] != NULL) &&
 800273e:	4b29      	ldr	r3, [pc, #164]	; (80027e4 <dyn1_execute.lto_priv.61+0x124>)
 8002740:	681b      	ldr	r3, [r3, #0]
 8002742:	2b00      	cmp	r3, #0
 8002744:	d011      	beq.n	800276a <dyn1_execute.lto_priv.61+0xaa>
 8002746:	4b27      	ldr	r3, [pc, #156]	; (80027e4 <dyn1_execute.lto_priv.61+0x124>)
 8002748:	685b      	ldr	r3, [r3, #4]
 800274a:	2b00      	cmp	r3, #0
 800274c:	d00d      	beq.n	800276a <dyn1_execute.lto_priv.61+0xaa>
 800274e:	4b25      	ldr	r3, [pc, #148]	; (80027e4 <dyn1_execute.lto_priv.61+0x124>)
 8002750:	689b      	ldr	r3, [r3, #8]
 8002752:	2b00      	cmp	r3, #0
 8002754:	d109      	bne.n	800276a <dyn1_execute.lto_priv.61+0xaa>
 8002756:	4b23      	ldr	r3, [pc, #140]	; (80027e4 <dyn1_execute.lto_priv.61+0x124>)
 8002758:	68db      	ldr	r3, [r3, #12]
 800275a:	2b00      	cmp	r3, #0
 800275c:	d105      	bne.n	800276a <dyn1_execute.lto_priv.61+0xaa>
 800275e:	4b21      	ldr	r3, [pc, #132]	; (80027e4 <dyn1_execute.lto_priv.61+0x124>)
 8002760:	691b      	ldr	r3, [r3, #16]
 8002762:	2b00      	cmp	r3, #0
 8002764:	d101      	bne.n	800276a <dyn1_execute.lto_priv.61+0xaa>
 8002766:	2301      	movs	r3, #1
 8002768:	e000      	b.n	800276c <dyn1_execute.lto_priv.61+0xac>
 800276a:	2300      	movs	r3, #0
 800276c:	f003 0301 	and.w	r3, r3, #1
 8002770:	b2db      	uxtb	r3, r3
 8002772:	2001      	movs	r0, #1
 8002774:	4619      	mov	r1, r3
 8002776:	f002 ffcb 	bl	8005710 <_test_assert>
 800277a:	4603      	mov	r3, r0
 800277c:	2b00      	cmp	r3, #0
 800277e:	d127      	bne.n	80027d0 <dyn1_execute.lto_priv.61+0x110>
                 (threads[3] == NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 8002780:	f003 f846 	bl	8005810 <test_wait_threads>
  test_assert_sequence(2, "AB");
 8002784:	2002      	movs	r0, #2
 8002786:	491a      	ldr	r1, [pc, #104]	; (80027f0 <dyn1_execute.lto_priv.61+0x130>)
 8002788:	f002 ffda 	bl	8005740 <_test_assert_sequence>
 800278c:	4603      	mov	r3, r0
 800278e:	2b00      	cmp	r3, #0
 8002790:	d11e      	bne.n	80027d0 <dyn1_execute.lto_priv.61+0x110>

  /* Heap status checked again.*/
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
 8002792:	ab03      	add	r3, sp, #12
 8002794:	4810      	ldr	r0, [pc, #64]	; (80027d8 <dyn1_execute.lto_priv.61+0x118>)
 8002796:	4619      	mov	r1, r3
 8002798:	f006 f98a 	bl	8008ab0 <chHeapStatus>
 800279c:	4603      	mov	r3, r0
 800279e:	2b01      	cmp	r3, #1
 80027a0:	bf0c      	ite	eq
 80027a2:	2301      	moveq	r3, #1
 80027a4:	2300      	movne	r3, #0
 80027a6:	b2db      	uxtb	r3, r3
 80027a8:	2003      	movs	r0, #3
 80027aa:	4619      	mov	r1, r3
 80027ac:	f002 ffb0 	bl	8005710 <_test_assert>
 80027b0:	4603      	mov	r3, r0
 80027b2:	2b00      	cmp	r3, #0
 80027b4:	d10c      	bne.n	80027d0 <dyn1_execute.lto_priv.61+0x110>
  test_assert(4, n == sz, "heap size changed");
 80027b6:	9a03      	ldr	r2, [sp, #12]
 80027b8:	9b02      	ldr	r3, [sp, #8]
 80027ba:	429a      	cmp	r2, r3
 80027bc:	bf0c      	ite	eq
 80027be:	2301      	moveq	r3, #1
 80027c0:	2300      	movne	r3, #0
 80027c2:	b2db      	uxtb	r3, r3
 80027c4:	2004      	movs	r0, #4
 80027c6:	4619      	mov	r1, r3
 80027c8:	f002 ffa2 	bl	8005710 <_test_assert>
 80027cc:	4603      	mov	r3, r0
 80027ce:	2b00      	cmp	r3, #0
}
 80027d0:	b007      	add	sp, #28
 80027d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80027d6:	bf00      	nop
 80027d8:	20001c48 	.word	0x20001c48
 80027dc:	0800d840 	.word	0x0800d840
 80027e0:	08002681 	.word	0x08002681
 80027e4:	20001bf8 	.word	0x20001bf8
 80027e8:	0800d844 	.word	0x0800d844
 80027ec:	0800d848 	.word	0x0800d848
 80027f0:	0800d84c 	.word	0x0800d84c
	...

08002800 <dyn2_setup.lto_priv.58>:
 * elements.<br>
 * The test expects the first four threads to successfully start and the last
 * one to fail.
 */

static void dyn2_setup(void) {
 8002800:	b508      	push	{r3, lr}

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
 8002802:	4803      	ldr	r0, [pc, #12]	; (8002810 <dyn2_setup.lto_priv.58+0x10>)
 8002804:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8002808:	2200      	movs	r2, #0
 800280a:	f006 f9d1 	bl	8008bb0 <chPoolObjectInit>
}
 800280e:	bd08      	pop	{r3, pc}
 8002810:	20001c68 	.word	0x20001c68
	...

08002820 <dyn2_execute.lto_priv.59>:

static void dyn2_execute(void) {
 8002820:	b500      	push	{lr}
 8002822:	b083      	sub	sp, #12
  int i;
  tprio_t prio = chThdGetPriorityX();
 8002824:	f7ff ff24 	bl	8002670 <chThdGetPriorityX>
 8002828:	9000      	str	r0, [sp, #0]

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
 800282a:	2300      	movs	r3, #0
 800282c:	9301      	str	r3, [sp, #4]
 800282e:	e00a      	b.n	8002846 <dyn2_execute.lto_priv.59+0x26>
    chPoolFree(&mp1, wa[i]);
 8002830:	4a4b      	ldr	r2, [pc, #300]	; (8002960 <dyn2_execute.lto_priv.59+0x140>)
 8002832:	9b01      	ldr	r3, [sp, #4]
 8002834:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8002838:	484a      	ldr	r0, [pc, #296]	; (8002964 <dyn2_execute.lto_priv.59+0x144>)
 800283a:	4619      	mov	r1, r3
 800283c:	f006 fa60 	bl	8008d00 <chPoolFree>
static void dyn2_execute(void) {
  int i;
  tprio_t prio = chThdGetPriorityX();

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
 8002840:	9b01      	ldr	r3, [sp, #4]
 8002842:	3301      	adds	r3, #1
 8002844:	9301      	str	r3, [sp, #4]
 8002846:	9b01      	ldr	r3, [sp, #4]
 8002848:	2b03      	cmp	r3, #3
 800284a:	ddf1      	ble.n	8002830 <dyn2_execute.lto_priv.59+0x10>
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
 800284c:	9b00      	ldr	r3, [sp, #0]
 800284e:	3b01      	subs	r3, #1
 8002850:	4844      	ldr	r0, [pc, #272]	; (8002964 <dyn2_execute.lto_priv.59+0x144>)
 8002852:	4619      	mov	r1, r3
 8002854:	4a44      	ldr	r2, [pc, #272]	; (8002968 <dyn2_execute.lto_priv.59+0x148>)
 8002856:	4b45      	ldr	r3, [pc, #276]	; (800296c <dyn2_execute.lto_priv.59+0x14c>)
 8002858:	f007 ff02 	bl	800a660 <chThdCreateFromMemoryPool>
 800285c:	4602      	mov	r2, r0
 800285e:	4b44      	ldr	r3, [pc, #272]	; (8002970 <dyn2_execute.lto_priv.59+0x150>)
 8002860:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 8002862:	9b00      	ldr	r3, [sp, #0]
 8002864:	3b02      	subs	r3, #2
 8002866:	483f      	ldr	r0, [pc, #252]	; (8002964 <dyn2_execute.lto_priv.59+0x144>)
 8002868:	4619      	mov	r1, r3
 800286a:	4a3f      	ldr	r2, [pc, #252]	; (8002968 <dyn2_execute.lto_priv.59+0x148>)
 800286c:	4b41      	ldr	r3, [pc, #260]	; (8002974 <dyn2_execute.lto_priv.59+0x154>)
 800286e:	f007 fef7 	bl	800a660 <chThdCreateFromMemoryPool>
 8002872:	4602      	mov	r2, r0
 8002874:	4b3e      	ldr	r3, [pc, #248]	; (8002970 <dyn2_execute.lto_priv.59+0x150>)
 8002876:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8002878:	9b00      	ldr	r3, [sp, #0]
 800287a:	3b03      	subs	r3, #3
 800287c:	4839      	ldr	r0, [pc, #228]	; (8002964 <dyn2_execute.lto_priv.59+0x144>)
 800287e:	4619      	mov	r1, r3
 8002880:	4a39      	ldr	r2, [pc, #228]	; (8002968 <dyn2_execute.lto_priv.59+0x148>)
 8002882:	4b3d      	ldr	r3, [pc, #244]	; (8002978 <dyn2_execute.lto_priv.59+0x158>)
 8002884:	f007 feec 	bl	800a660 <chThdCreateFromMemoryPool>
 8002888:	4602      	mov	r2, r0
 800288a:	4b39      	ldr	r3, [pc, #228]	; (8002970 <dyn2_execute.lto_priv.59+0x150>)
 800288c:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 800288e:	9b00      	ldr	r3, [sp, #0]
 8002890:	3b04      	subs	r3, #4
 8002892:	4834      	ldr	r0, [pc, #208]	; (8002964 <dyn2_execute.lto_priv.59+0x144>)
 8002894:	4619      	mov	r1, r3
 8002896:	4a34      	ldr	r2, [pc, #208]	; (8002968 <dyn2_execute.lto_priv.59+0x148>)
 8002898:	4b38      	ldr	r3, [pc, #224]	; (800297c <dyn2_execute.lto_priv.59+0x15c>)
 800289a:	f007 fee1 	bl	800a660 <chThdCreateFromMemoryPool>
 800289e:	4602      	mov	r2, r0
 80028a0:	4b33      	ldr	r3, [pc, #204]	; (8002970 <dyn2_execute.lto_priv.59+0x150>)
 80028a2:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 80028a4:	9b00      	ldr	r3, [sp, #0]
 80028a6:	3b05      	subs	r3, #5
 80028a8:	482e      	ldr	r0, [pc, #184]	; (8002964 <dyn2_execute.lto_priv.59+0x144>)
 80028aa:	4619      	mov	r1, r3
 80028ac:	4a2e      	ldr	r2, [pc, #184]	; (8002968 <dyn2_execute.lto_priv.59+0x148>)
 80028ae:	4b34      	ldr	r3, [pc, #208]	; (8002980 <dyn2_execute.lto_priv.59+0x160>)
 80028b0:	f007 fed6 	bl	800a660 <chThdCreateFromMemoryPool>
 80028b4:	4602      	mov	r2, r0
 80028b6:	4b2e      	ldr	r3, [pc, #184]	; (8002970 <dyn2_execute.lto_priv.59+0x150>)
 80028b8:	611a      	str	r2, [r3, #16]

  test_assert(1, (threads[0] != NULL) &&
 80028ba:	4b2d      	ldr	r3, [pc, #180]	; (8002970 <dyn2_execute.lto_priv.59+0x150>)
 80028bc:	681b      	ldr	r3, [r3, #0]
 80028be:	2b00      	cmp	r3, #0
 80028c0:	d011      	beq.n	80028e6 <dyn2_execute.lto_priv.59+0xc6>
 80028c2:	4b2b      	ldr	r3, [pc, #172]	; (8002970 <dyn2_execute.lto_priv.59+0x150>)
 80028c4:	685b      	ldr	r3, [r3, #4]
 80028c6:	2b00      	cmp	r3, #0
 80028c8:	d00d      	beq.n	80028e6 <dyn2_execute.lto_priv.59+0xc6>
 80028ca:	4b29      	ldr	r3, [pc, #164]	; (8002970 <dyn2_execute.lto_priv.59+0x150>)
 80028cc:	689b      	ldr	r3, [r3, #8]
 80028ce:	2b00      	cmp	r3, #0
 80028d0:	d009      	beq.n	80028e6 <dyn2_execute.lto_priv.59+0xc6>
 80028d2:	4b27      	ldr	r3, [pc, #156]	; (8002970 <dyn2_execute.lto_priv.59+0x150>)
 80028d4:	68db      	ldr	r3, [r3, #12]
 80028d6:	2b00      	cmp	r3, #0
 80028d8:	d005      	beq.n	80028e6 <dyn2_execute.lto_priv.59+0xc6>
 80028da:	4b25      	ldr	r3, [pc, #148]	; (8002970 <dyn2_execute.lto_priv.59+0x150>)
 80028dc:	691b      	ldr	r3, [r3, #16]
 80028de:	2b00      	cmp	r3, #0
 80028e0:	d101      	bne.n	80028e6 <dyn2_execute.lto_priv.59+0xc6>
 80028e2:	2301      	movs	r3, #1
 80028e4:	e000      	b.n	80028e8 <dyn2_execute.lto_priv.59+0xc8>
 80028e6:	2300      	movs	r3, #0
 80028e8:	f003 0301 	and.w	r3, r3, #1
 80028ec:	b2db      	uxtb	r3, r3
 80028ee:	2001      	movs	r0, #1
 80028f0:	4619      	mov	r1, r3
 80028f2:	f002 ff0d 	bl	8005710 <_test_assert>
 80028f6:	4603      	mov	r3, r0
 80028f8:	2b00      	cmp	r3, #0
 80028fa:	d12e      	bne.n	800295a <dyn2_execute.lto_priv.59+0x13a>
                 (threads[3] != NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 80028fc:	f002 ff88 	bl	8005810 <test_wait_threads>
  test_assert_sequence(2, "ABCD");
 8002900:	2002      	movs	r0, #2
 8002902:	4920      	ldr	r1, [pc, #128]	; (8002984 <dyn2_execute.lto_priv.59+0x164>)
 8002904:	f002 ff1c 	bl	8005740 <_test_assert_sequence>
 8002908:	4603      	mov	r3, r0
 800290a:	2b00      	cmp	r3, #0
 800290c:	d125      	bne.n	800295a <dyn2_execute.lto_priv.59+0x13a>

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
 800290e:	2300      	movs	r3, #0
 8002910:	9301      	str	r3, [sp, #4]
 8002912:	e012      	b.n	800293a <dyn2_execute.lto_priv.59+0x11a>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
 8002914:	4813      	ldr	r0, [pc, #76]	; (8002964 <dyn2_execute.lto_priv.59+0x144>)
 8002916:	f006 f9c3 	bl	8008ca0 <chPoolAlloc>
 800291a:	4603      	mov	r3, r0
 800291c:	2b00      	cmp	r3, #0
 800291e:	bf14      	ite	ne
 8002920:	2301      	movne	r3, #1
 8002922:	2300      	moveq	r3, #0
 8002924:	b2db      	uxtb	r3, r3
 8002926:	2003      	movs	r0, #3
 8002928:	4619      	mov	r1, r3
 800292a:	f002 fef1 	bl	8005710 <_test_assert>
 800292e:	4603      	mov	r3, r0
 8002930:	2b00      	cmp	r3, #0
 8002932:	d112      	bne.n	800295a <dyn2_execute.lto_priv.59+0x13a>
  /* Claiming the memory from terminated threads. */
  test_wait_threads();
  test_assert_sequence(2, "ABCD");

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
 8002934:	9b01      	ldr	r3, [sp, #4]
 8002936:	3301      	adds	r3, #1
 8002938:	9301      	str	r3, [sp, #4]
 800293a:	9b01      	ldr	r3, [sp, #4]
 800293c:	2b03      	cmp	r3, #3
 800293e:	dde9      	ble.n	8002914 <dyn2_execute.lto_priv.59+0xf4>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
 8002940:	4808      	ldr	r0, [pc, #32]	; (8002964 <dyn2_execute.lto_priv.59+0x144>)
 8002942:	f006 f9ad 	bl	8008ca0 <chPoolAlloc>
 8002946:	4603      	mov	r3, r0
 8002948:	2b00      	cmp	r3, #0
 800294a:	bf0c      	ite	eq
 800294c:	2301      	moveq	r3, #1
 800294e:	2300      	movne	r3, #0
 8002950:	b2db      	uxtb	r3, r3
 8002952:	2004      	movs	r0, #4
 8002954:	4619      	mov	r1, r3
 8002956:	f002 fedb 	bl	8005710 <_test_assert>
}
 800295a:	b003      	add	sp, #12
 800295c:	f85d fb04 	ldr.w	pc, [sp], #4
 8002960:	0800e420 	.word	0x0800e420
 8002964:	20001c68 	.word	0x20001c68
 8002968:	08002681 	.word	0x08002681
 800296c:	0800d840 	.word	0x0800d840
 8002970:	20001bf8 	.word	0x20001bf8
 8002974:	0800d844 	.word	0x0800d844
 8002978:	0800d848 	.word	0x0800d848
 800297c:	0800d850 	.word	0x0800d850
 8002980:	0800d854 	.word	0x0800d854
 8002984:	0800d858 	.word	0x0800d858
	...

08002990 <regfind>:
 * <h2>Description</h2>
 * Registry and Thread References APIs are tested for functionality and
 * coverage.
 */

static bool regfind(thread_t *tp) {
 8002990:	b500      	push	{lr}
 8002992:	b085      	sub	sp, #20
 8002994:	9001      	str	r0, [sp, #4]
  thread_t *ftp;
  bool found = false;
 8002996:	2300      	movs	r3, #0
 8002998:	f88d 300b 	strb.w	r3, [sp, #11]

  ftp = chRegFirstThread();
 800299c:	f007 fee8 	bl	800a770 <chRegFirstThread>
 80029a0:	9003      	str	r0, [sp, #12]
  do {
    found |= ftp == tp;
 80029a2:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80029a6:	9903      	ldr	r1, [sp, #12]
 80029a8:	9a01      	ldr	r2, [sp, #4]
 80029aa:	4291      	cmp	r1, r2
 80029ac:	bf0c      	ite	eq
 80029ae:	2201      	moveq	r2, #1
 80029b0:	2200      	movne	r2, #0
 80029b2:	b2d2      	uxtb	r2, r2
 80029b4:	4313      	orrs	r3, r2
 80029b6:	2b00      	cmp	r3, #0
 80029b8:	bf14      	ite	ne
 80029ba:	2301      	movne	r3, #1
 80029bc:	2300      	moveq	r3, #0
 80029be:	f88d 300b 	strb.w	r3, [sp, #11]
    ftp = chRegNextThread(ftp);
 80029c2:	9803      	ldr	r0, [sp, #12]
 80029c4:	f007 feec 	bl	800a7a0 <chRegNextThread>
 80029c8:	9003      	str	r0, [sp, #12]
  } while (ftp != NULL);
 80029ca:	9b03      	ldr	r3, [sp, #12]
 80029cc:	2b00      	cmp	r3, #0
 80029ce:	d1e8      	bne.n	80029a2 <regfind+0x12>
  return found;
 80029d0:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 80029d4:	4618      	mov	r0, r3
 80029d6:	b005      	add	sp, #20
 80029d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80029dc:	0000      	movs	r0, r0
	...

080029e0 <dyn3_setup.lto_priv.56>:

static void dyn3_setup(void) {
 80029e0:	b508      	push	{r3, lr}

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
 80029e2:	4803      	ldr	r0, [pc, #12]	; (80029f0 <dyn3_setup.lto_priv.56+0x10>)
 80029e4:	4903      	ldr	r1, [pc, #12]	; (80029f4 <dyn3_setup.lto_priv.56+0x14>)
 80029e6:	f44f 62e1 	mov.w	r2, #1800	; 0x708
 80029ea:	f005 ff39 	bl	8008860 <chHeapObjectInit>
}
 80029ee:	bd08      	pop	{r3, pc}
 80029f0:	20001c48 	.word	0x20001c48
 80029f4:	200014f0 	.word	0x200014f0
	...

08002a00 <dyn3_execute.lto_priv.57>:

static void dyn3_execute(void) {
 8002a00:	b500      	push	{lr}
 8002a02:	b085      	sub	sp, #20
  thread_t *tp;
  tprio_t prio = chThdGetPriorityX();
 8002a04:	f7ff fe34 	bl	8002670 <chThdGetPriorityX>
 8002a08:	9003      	str	r0, [sp, #12]

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
 8002a0a:	9b03      	ldr	r3, [sp, #12]
 8002a0c:	1e5a      	subs	r2, r3, #1
 8002a0e:	4b5f      	ldr	r3, [pc, #380]	; (8002b8c <dyn3_execute.lto_priv.57+0x18c>)
 8002a10:	9300      	str	r3, [sp, #0]
 8002a12:	485f      	ldr	r0, [pc, #380]	; (8002b90 <dyn3_execute.lto_priv.57+0x190>)
 8002a14:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8002a18:	4b5e      	ldr	r3, [pc, #376]	; (8002b94 <dyn3_execute.lto_priv.57+0x194>)
 8002a1a:	f007 fde1 	bl	800a5e0 <chThdCreateFromHeap>
 8002a1e:	9002      	str	r0, [sp, #8]
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
 8002a20:	9b02      	ldr	r3, [sp, #8]
 8002a22:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8002a26:	2b01      	cmp	r3, #1
 8002a28:	bf0c      	ite	eq
 8002a2a:	2301      	moveq	r3, #1
 8002a2c:	2300      	movne	r3, #0
 8002a2e:	b2db      	uxtb	r3, r3
 8002a30:	2001      	movs	r0, #1
 8002a32:	4619      	mov	r1, r3
 8002a34:	f002 fe6c 	bl	8005710 <_test_assert>
 8002a38:	4603      	mov	r3, r0
 8002a3a:	2b00      	cmp	r3, #0
 8002a3c:	f040 80a3 	bne.w	8002b86 <dyn3_execute.lto_priv.57+0x186>
  chThdAddRef(tp);
 8002a40:	9802      	ldr	r0, [sp, #8]
 8002a42:	f007 fd55 	bl	800a4f0 <chThdAddRef>
  test_assert(2, tp->p_refs == 2, "references increase failure");
 8002a46:	9b02      	ldr	r3, [sp, #8]
 8002a48:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8002a4c:	2b02      	cmp	r3, #2
 8002a4e:	bf0c      	ite	eq
 8002a50:	2301      	moveq	r3, #1
 8002a52:	2300      	movne	r3, #0
 8002a54:	b2db      	uxtb	r3, r3
 8002a56:	2002      	movs	r0, #2
 8002a58:	4619      	mov	r1, r3
 8002a5a:	f002 fe59 	bl	8005710 <_test_assert>
 8002a5e:	4603      	mov	r3, r0
 8002a60:	2b00      	cmp	r3, #0
 8002a62:	f040 8090 	bne.w	8002b86 <dyn3_execute.lto_priv.57+0x186>
  chThdRelease(tp);
 8002a66:	9802      	ldr	r0, [sp, #8]
 8002a68:	f007 fd62 	bl	800a530 <chThdRelease>
  test_assert(3, tp->p_refs == 1, "references decrease failure");
 8002a6c:	9b02      	ldr	r3, [sp, #8]
 8002a6e:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8002a72:	2b01      	cmp	r3, #1
 8002a74:	bf0c      	ite	eq
 8002a76:	2301      	moveq	r3, #1
 8002a78:	2300      	movne	r3, #0
 8002a7a:	b2db      	uxtb	r3, r3
 8002a7c:	2003      	movs	r0, #3
 8002a7e:	4619      	mov	r1, r3
 8002a80:	f002 fe46 	bl	8005710 <_test_assert>
 8002a84:	4603      	mov	r3, r0
 8002a86:	2b00      	cmp	r3, #0
 8002a88:	d17d      	bne.n	8002b86 <dyn3_execute.lto_priv.57+0x186>

  /* Verify the new threads count.*/
  test_assert(4, regfind(tp), "thread missing from registry");
 8002a8a:	9802      	ldr	r0, [sp, #8]
 8002a8c:	f7ff ff80 	bl	8002990 <regfind>
 8002a90:	4603      	mov	r3, r0
 8002a92:	2004      	movs	r0, #4
 8002a94:	4619      	mov	r1, r3
 8002a96:	f002 fe3b 	bl	8005710 <_test_assert>
 8002a9a:	4603      	mov	r3, r0
 8002a9c:	2b00      	cmp	r3, #0
 8002a9e:	d172      	bne.n	8002b86 <dyn3_execute.lto_priv.57+0x186>
  test_assert(5, regfind(tp), "thread disappeared");
 8002aa0:	9802      	ldr	r0, [sp, #8]
 8002aa2:	f7ff ff75 	bl	8002990 <regfind>
 8002aa6:	4603      	mov	r3, r0
 8002aa8:	2005      	movs	r0, #5
 8002aaa:	4619      	mov	r1, r3
 8002aac:	f002 fe30 	bl	8005710 <_test_assert>
 8002ab0:	4603      	mov	r3, r0
 8002ab2:	2b00      	cmp	r3, #0
 8002ab4:	d167      	bne.n	8002b86 <dyn3_execute.lto_priv.57+0x186>

  /* Detach and let the thread execute and terminate.*/
  chThdRelease(tp);
 8002ab6:	9802      	ldr	r0, [sp, #8]
 8002ab8:	f007 fd3a 	bl	800a530 <chThdRelease>
  test_assert(6, tp->p_refs == 0, "detach failure");
 8002abc:	9b02      	ldr	r3, [sp, #8]
 8002abe:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8002ac2:	2b00      	cmp	r3, #0
 8002ac4:	bf0c      	ite	eq
 8002ac6:	2301      	moveq	r3, #1
 8002ac8:	2300      	movne	r3, #0
 8002aca:	b2db      	uxtb	r3, r3
 8002acc:	2006      	movs	r0, #6
 8002ace:	4619      	mov	r1, r3
 8002ad0:	f002 fe1e 	bl	8005710 <_test_assert>
 8002ad4:	4603      	mov	r3, r0
 8002ad6:	2b00      	cmp	r3, #0
 8002ad8:	d155      	bne.n	8002b86 <dyn3_execute.lto_priv.57+0x186>
  test_assert(7, tp->p_state == CH_STATE_READY, "invalid state");
 8002ada:	9b02      	ldr	r3, [sp, #8]
 8002adc:	f893 3020 	ldrb.w	r3, [r3, #32]
 8002ae0:	2b00      	cmp	r3, #0
 8002ae2:	bf0c      	ite	eq
 8002ae4:	2301      	moveq	r3, #1
 8002ae6:	2300      	movne	r3, #0
 8002ae8:	b2db      	uxtb	r3, r3
 8002aea:	2007      	movs	r0, #7
 8002aec:	4619      	mov	r1, r3
 8002aee:	f002 fe0f 	bl	8005710 <_test_assert>
 8002af2:	4603      	mov	r3, r0
 8002af4:	2b00      	cmp	r3, #0
 8002af6:	d146      	bne.n	8002b86 <dyn3_execute.lto_priv.57+0x186>
  test_assert(8, regfind(tp), "thread disappeared");
 8002af8:	9802      	ldr	r0, [sp, #8]
 8002afa:	f7ff ff49 	bl	8002990 <regfind>
 8002afe:	4603      	mov	r3, r0
 8002b00:	2008      	movs	r0, #8
 8002b02:	4619      	mov	r1, r3
 8002b04:	f002 fe04 	bl	8005710 <_test_assert>
 8002b08:	4603      	mov	r3, r0
 8002b0a:	2b00      	cmp	r3, #0
 8002b0c:	d13b      	bne.n	8002b86 <dyn3_execute.lto_priv.57+0x186>
  test_assert(9, regfind(tp), "thread disappeared");
 8002b0e:	9802      	ldr	r0, [sp, #8]
 8002b10:	f7ff ff3e 	bl	8002990 <regfind>
 8002b14:	4603      	mov	r3, r0
 8002b16:	2009      	movs	r0, #9
 8002b18:	4619      	mov	r1, r3
 8002b1a:	f002 fdf9 	bl	8005710 <_test_assert>
 8002b1e:	4603      	mov	r3, r0
 8002b20:	2b00      	cmp	r3, #0
 8002b22:	d130      	bne.n	8002b86 <dyn3_execute.lto_priv.57+0x186>
  chThdSleepMilliseconds(50);           /* The thread just terminates.      */
 8002b24:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8002b28:	f00a f8fa 	bl	800cd20 <chThdSleep>
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");
 8002b2c:	9b02      	ldr	r3, [sp, #8]
 8002b2e:	f893 3020 	ldrb.w	r3, [r3, #32]
 8002b32:	2b0f      	cmp	r3, #15
 8002b34:	bf0c      	ite	eq
 8002b36:	2301      	moveq	r3, #1
 8002b38:	2300      	movne	r3, #0
 8002b3a:	b2db      	uxtb	r3, r3
 8002b3c:	200a      	movs	r0, #10
 8002b3e:	4619      	mov	r1, r3
 8002b40:	f002 fde6 	bl	8005710 <_test_assert>
 8002b44:	4603      	mov	r3, r0
 8002b46:	2b00      	cmp	r3, #0
 8002b48:	d11d      	bne.n	8002b86 <dyn3_execute.lto_priv.57+0x186>

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
 8002b4a:	9802      	ldr	r0, [sp, #8]
 8002b4c:	f7ff ff20 	bl	8002990 <regfind>
 8002b50:	4603      	mov	r3, r0
 8002b52:	200b      	movs	r0, #11
 8002b54:	4619      	mov	r1, r3
 8002b56:	f002 fddb 	bl	8005710 <_test_assert>
 8002b5a:	4603      	mov	r3, r0
 8002b5c:	2b00      	cmp	r3, #0
 8002b5e:	d112      	bne.n	8002b86 <dyn3_execute.lto_priv.57+0x186>
  test_assert(12, !regfind(tp), "thread still in registry");
 8002b60:	9802      	ldr	r0, [sp, #8]
 8002b62:	f7ff ff15 	bl	8002990 <regfind>
 8002b66:	4603      	mov	r3, r0
 8002b68:	2b00      	cmp	r3, #0
 8002b6a:	bf14      	ite	ne
 8002b6c:	2301      	movne	r3, #1
 8002b6e:	2300      	moveq	r3, #0
 8002b70:	b2db      	uxtb	r3, r3
 8002b72:	f083 0301 	eor.w	r3, r3, #1
 8002b76:	b2db      	uxtb	r3, r3
 8002b78:	f003 0301 	and.w	r3, r3, #1
 8002b7c:	b2db      	uxtb	r3, r3
 8002b7e:	200c      	movs	r0, #12
 8002b80:	4619      	mov	r1, r3
 8002b82:	f002 fdc5 	bl	8005710 <_test_assert>
}
 8002b86:	b005      	add	sp, #20
 8002b88:	f85d fb04 	ldr.w	pc, [sp], #4
 8002b8c:	0800d840 	.word	0x0800d840
 8002b90:	20001c48 	.word	0x20001c48
 8002b94:	08002681 	.word	0x08002681
	...

08002ba0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002ba0:	b082      	sub	sp, #8
 8002ba2:	2320      	movs	r3, #32
 8002ba4:	9301      	str	r3, [sp, #4]
 8002ba6:	9b01      	ldr	r3, [sp, #4]
 8002ba8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002bac:	b002      	add	sp, #8
 8002bae:	4770      	bx	lr

08002bb0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002bb0:	b082      	sub	sp, #8
 8002bb2:	2300      	movs	r3, #0
 8002bb4:	9301      	str	r3, [sp, #4]
 8002bb6:	9b01      	ldr	r3, [sp, #4]
 8002bb8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002bbc:	b002      	add	sp, #8
 8002bbe:	4770      	bx	lr

08002bc0 <chSysLock.lto_priv.155>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002bc0:	b508      	push	{r3, lr}

  port_lock();
 8002bc2:	f7ff ffed 	bl	8002ba0 <port_lock>
  _stats_start_measure_crit_thd();
 8002bc6:	f007 fc3b 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8002bca:	f009 f8e9 	bl	800bda0 <_dbg_check_lock>
}
 8002bce:	bd08      	pop	{r3, pc}

08002bd0 <chSysUnlock.lto_priv.152>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002bd0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8002bd2:	f009 f8fd 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8002bd6:	f007 fc3b 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8002bda:	4b09      	ldr	r3, [pc, #36]	; (8002c00 <chSysUnlock.lto_priv.152+0x30>)
 8002bdc:	681b      	ldr	r3, [r3, #0]
 8002bde:	4a08      	ldr	r2, [pc, #32]	; (8002c00 <chSysUnlock.lto_priv.152+0x30>)
 8002be0:	4293      	cmp	r3, r2
 8002be2:	d00a      	beq.n	8002bfa <chSysUnlock.lto_priv.152+0x2a>
 8002be4:	4b06      	ldr	r3, [pc, #24]	; (8002c00 <chSysUnlock.lto_priv.152+0x30>)
 8002be6:	699b      	ldr	r3, [r3, #24]
 8002be8:	689a      	ldr	r2, [r3, #8]
 8002bea:	4b05      	ldr	r3, [pc, #20]	; (8002c00 <chSysUnlock.lto_priv.152+0x30>)
 8002bec:	681b      	ldr	r3, [r3, #0]
 8002bee:	689b      	ldr	r3, [r3, #8]
 8002bf0:	429a      	cmp	r2, r3
 8002bf2:	d202      	bcs.n	8002bfa <chSysUnlock.lto_priv.152+0x2a>
 8002bf4:	4803      	ldr	r0, [pc, #12]	; (8002c04 <chSysUnlock.lto_priv.152+0x34>)
 8002bf6:	f008 ff7b 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002bfa:	f7ff ffd9 	bl	8002bb0 <port_unlock>
}
 8002bfe:	bd08      	pop	{r3, pc}
 8002c00:	20000d30 	.word	0x20000d30
 8002c04:	0800e720 	.word	0x0800e720
	...

08002c10 <chThdGetSelfX.lto_priv.169>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002c10:	4b01      	ldr	r3, [pc, #4]	; (8002c18 <chThdGetSelfX.lto_priv.169+0x8>)
 8002c12:	699b      	ldr	r3, [r3, #24]
}
 8002c14:	4618      	mov	r0, r3
 8002c16:	4770      	bx	lr
 8002c18:	20000d30 	.word	0x20000d30
 8002c1c:	00000000 	.word	0x00000000

08002c20 <chThdGetPriorityX.lto_priv.150>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 8002c20:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 8002c22:	f7ff fff5 	bl	8002c10 <chThdGetSelfX.lto_priv.169>
 8002c26:	4603      	mov	r3, r0
 8002c28:	689b      	ldr	r3, [r3, #8]
}
 8002c2a:	4618      	mov	r0, r3
 8002c2c:	bd08      	pop	{r3, pc}
 8002c2e:	bf00      	nop

08002c30 <chIQGetFullI>:
 * @return              The number of full bytes in the queue.
 * @retval 0            if the queue is empty.
 *
 * @iclass
 */
static inline size_t chIQGetFullI(input_queue_t *iqp) {
 8002c30:	b500      	push	{lr}
 8002c32:	b083      	sub	sp, #12
 8002c34:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002c36:	f009 f953 	bl	800bee0 <chDbgCheckClassI>

  return (size_t)chQSpaceI(iqp);
 8002c3a:	9b01      	ldr	r3, [sp, #4]
 8002c3c:	689b      	ldr	r3, [r3, #8]
}
 8002c3e:	4618      	mov	r0, r3
 8002c40:	b003      	add	sp, #12
 8002c42:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c46:	bf00      	nop
	...

08002c50 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 8002c50:	b500      	push	{lr}
 8002c52:	b083      	sub	sp, #12
 8002c54:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002c56:	f009 f943 	bl	800bee0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 8002c5a:	9b01      	ldr	r3, [sp, #4]
 8002c5c:	689b      	ldr	r3, [r3, #8]
 8002c5e:	2b00      	cmp	r3, #0
 8002c60:	bf0c      	ite	eq
 8002c62:	2301      	moveq	r3, #1
 8002c64:	2300      	movne	r3, #0
 8002c66:	b2db      	uxtb	r3, r3
}
 8002c68:	4618      	mov	r0, r3
 8002c6a:	b003      	add	sp, #12
 8002c6c:	f85d fb04 	ldr.w	pc, [sp], #4

08002c70 <chIQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
 8002c70:	b500      	push	{lr}
 8002c72:	b083      	sub	sp, #12
 8002c74:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002c76:	f009 f933 	bl	800bee0 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8002c7a:	9b01      	ldr	r3, [sp, #4]
 8002c7c:	695a      	ldr	r2, [r3, #20]
 8002c7e:	9b01      	ldr	r3, [sp, #4]
 8002c80:	699b      	ldr	r3, [r3, #24]
 8002c82:	429a      	cmp	r2, r3
 8002c84:	d105      	bne.n	8002c92 <chIQIsFullI+0x22>
 8002c86:	9b01      	ldr	r3, [sp, #4]
 8002c88:	689b      	ldr	r3, [r3, #8]
 8002c8a:	2b00      	cmp	r3, #0
 8002c8c:	d001      	beq.n	8002c92 <chIQIsFullI+0x22>
 8002c8e:	2301      	movs	r3, #1
 8002c90:	e000      	b.n	8002c94 <chIQIsFullI+0x24>
 8002c92:	2300      	movs	r3, #0
 8002c94:	f003 0301 	and.w	r3, r3, #1
 8002c98:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 8002c9a:	4618      	mov	r0, r3
 8002c9c:	b003      	add	sp, #12
 8002c9e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002ca2:	bf00      	nop
	...

08002cb0 <chIQGet>:
 * @return              A byte value from the queue.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {
 8002cb0:	b500      	push	{lr}
 8002cb2:	b083      	sub	sp, #12
 8002cb4:	9001      	str	r0, [sp, #4]

  return chIQGetTimeout(iqp, TIME_INFINITE);
 8002cb6:	9801      	ldr	r0, [sp, #4]
 8002cb8:	f04f 31ff 	mov.w	r1, #4294967295
 8002cbc:	f007 fa48 	bl	800a150 <chIQGetTimeout>
 8002cc0:	4603      	mov	r3, r0
}
 8002cc2:	4618      	mov	r0, r3
 8002cc4:	b003      	add	sp, #12
 8002cc6:	f85d fb04 	ldr.w	pc, [sp], #4
 8002cca:	bf00      	nop
 8002ccc:	0000      	movs	r0, r0
	...

08002cd0 <chOQGetFullI.lto_priv.164>:
 * @return              The number of full bytes in the queue.
 * @retval 0            if the queue is empty.
 *
 * @iclass
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {
 8002cd0:	b500      	push	{lr}
 8002cd2:	b083      	sub	sp, #12
 8002cd4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002cd6:	f009 f903 	bl	800bee0 <chDbgCheckClassI>

  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 8002cda:	9b01      	ldr	r3, [sp, #4]
 8002cdc:	691b      	ldr	r3, [r3, #16]
 8002cde:	461a      	mov	r2, r3
 8002ce0:	9b01      	ldr	r3, [sp, #4]
 8002ce2:	68db      	ldr	r3, [r3, #12]
 8002ce4:	1ad3      	subs	r3, r2, r3
 8002ce6:	461a      	mov	r2, r3
 8002ce8:	9b01      	ldr	r3, [sp, #4]
 8002cea:	689b      	ldr	r3, [r3, #8]
 8002cec:	1ad3      	subs	r3, r2, r3
}
 8002cee:	4618      	mov	r0, r3
 8002cf0:	b003      	add	sp, #12
 8002cf2:	f85d fb04 	ldr.w	pc, [sp], #4
 8002cf6:	bf00      	nop
	...

08002d00 <chOQIsEmptyI.lto_priv.165>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 8002d00:	b500      	push	{lr}
 8002d02:	b083      	sub	sp, #12
 8002d04:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002d06:	f009 f8eb 	bl	800bee0 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8002d0a:	9b01      	ldr	r3, [sp, #4]
 8002d0c:	695a      	ldr	r2, [r3, #20]
 8002d0e:	9b01      	ldr	r3, [sp, #4]
 8002d10:	699b      	ldr	r3, [r3, #24]
 8002d12:	429a      	cmp	r2, r3
 8002d14:	d105      	bne.n	8002d22 <chOQIsEmptyI.lto_priv.165+0x22>
 8002d16:	9b01      	ldr	r3, [sp, #4]
 8002d18:	689b      	ldr	r3, [r3, #8]
 8002d1a:	2b00      	cmp	r3, #0
 8002d1c:	d001      	beq.n	8002d22 <chOQIsEmptyI.lto_priv.165+0x22>
 8002d1e:	2301      	movs	r3, #1
 8002d20:	e000      	b.n	8002d24 <chOQIsEmptyI.lto_priv.165+0x24>
 8002d22:	2300      	movs	r3, #0
 8002d24:	f003 0301 	and.w	r3, r3, #1
 8002d28:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 8002d2a:	4618      	mov	r0, r3
 8002d2c:	b003      	add	sp, #12
 8002d2e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d32:	bf00      	nop
	...

08002d40 <chOQIsFullI.lto_priv.163>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 8002d40:	b500      	push	{lr}
 8002d42:	b083      	sub	sp, #12
 8002d44:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002d46:	f009 f8cb 	bl	800bee0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 8002d4a:	9b01      	ldr	r3, [sp, #4]
 8002d4c:	689b      	ldr	r3, [r3, #8]
 8002d4e:	2b00      	cmp	r3, #0
 8002d50:	bf0c      	ite	eq
 8002d52:	2301      	moveq	r3, #1
 8002d54:	2300      	movne	r3, #0
 8002d56:	b2db      	uxtb	r3, r3
}
 8002d58:	4618      	mov	r0, r3
 8002d5a:	b003      	add	sp, #12
 8002d5c:	f85d fb04 	ldr.w	pc, [sp], #4

08002d60 <chOQPut.lto_priv.166>:
 * @retval Q_OK         if the operation succeeded.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
static inline msg_t chOQPut(output_queue_t *oqp, uint8_t b) {
 8002d60:	b500      	push	{lr}
 8002d62:	b083      	sub	sp, #12
 8002d64:	9001      	str	r0, [sp, #4]
 8002d66:	460b      	mov	r3, r1
 8002d68:	f88d 3003 	strb.w	r3, [sp, #3]

  return chOQPutTimeout(oqp, b, TIME_INFINITE);
 8002d6c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002d70:	9801      	ldr	r0, [sp, #4]
 8002d72:	4619      	mov	r1, r3
 8002d74:	f04f 32ff 	mov.w	r2, #4294967295
 8002d78:	f005 fbea 	bl	8008550 <chOQPutTimeout>
 8002d7c:	4603      	mov	r3, r0
}
 8002d7e:	4618      	mov	r0, r3
 8002d80:	b003      	add	sp, #12
 8002d82:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d86:	bf00      	nop
	...

08002d90 <notify.lto_priv.55>:

#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)

#define TEST_QUEUES_SIZE 4

static void notify(io_queue_t *qp) {
 8002d90:	b082      	sub	sp, #8
 8002d92:	9001      	str	r0, [sp, #4]
  (void)qp;
}
 8002d94:	b002      	add	sp, #8
 8002d96:	4770      	bx	lr
	...

08002da0 <queues1_setup.lto_priv.53>:
 * This test case tests synchronous and asynchronous operations on an
 * @p InputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues1_setup(void) {
 8002da0:	b500      	push	{lr}
 8002da2:	b083      	sub	sp, #12

  chIQObjectInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 8002da4:	4b06      	ldr	r3, [pc, #24]	; (8002dc0 <queues1_setup.lto_priv.53+0x20>)
 8002da6:	681a      	ldr	r2, [r3, #0]
 8002da8:	2300      	movs	r3, #0
 8002daa:	9300      	str	r3, [sp, #0]
 8002dac:	4805      	ldr	r0, [pc, #20]	; (8002dc4 <queues1_setup.lto_priv.53+0x24>)
 8002dae:	4611      	mov	r1, r2
 8002db0:	2204      	movs	r2, #4
 8002db2:	4b05      	ldr	r3, [pc, #20]	; (8002dc8 <queues1_setup.lto_priv.53+0x28>)
 8002db4:	f007 f94c 	bl	800a050 <chIQObjectInit>
}
 8002db8:	b003      	add	sp, #12
 8002dba:	f85d fb04 	ldr.w	pc, [sp], #4
 8002dbe:	bf00      	nop
 8002dc0:	0800e420 	.word	0x0800e420
 8002dc4:	200008a4 	.word	0x200008a4
 8002dc8:	08002d91 	.word	0x08002d91
 8002dcc:	00000000 	.word	0x00000000

08002dd0 <thread1>:

static THD_FUNCTION(thread1, p) {
 8002dd0:	b500      	push	{lr}
 8002dd2:	b083      	sub	sp, #12
 8002dd4:	9001      	str	r0, [sp, #4]

  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
 8002dd6:	4804      	ldr	r0, [pc, #16]	; (8002de8 <thread1+0x18>)
 8002dd8:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 8002ddc:	f007 f9b8 	bl	800a150 <chIQGetTimeout>
}
 8002de0:	b003      	add	sp, #12
 8002de2:	f85d fb04 	ldr.w	pc, [sp], #4
 8002de6:	bf00      	nop
 8002de8:	200008a4 	.word	0x200008a4
 8002dec:	00000000 	.word	0x00000000

08002df0 <queues1_execute.lto_priv.54>:

static void queues1_execute(void) {
 8002df0:	b510      	push	{r4, lr}
 8002df2:	b084      	sub	sp, #16
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");
 8002df4:	f7ff fee4 	bl	8002bc0 <chSysLock.lto_priv.155>
 8002df8:	48b4      	ldr	r0, [pc, #720]	; (80030cc <queues1_execute.lto_priv.54+0x2dc>)
 8002dfa:	f7ff ff29 	bl	8002c50 <chIQIsEmptyI>
 8002dfe:	4603      	mov	r3, r0
 8002e00:	2001      	movs	r0, #1
 8002e02:	4619      	mov	r1, r3
 8002e04:	f002 fc84 	bl	8005710 <_test_assert>
 8002e08:	4603      	mov	r3, r0
 8002e0a:	2b00      	cmp	r3, #0
 8002e0c:	d002      	beq.n	8002e14 <queues1_execute.lto_priv.54+0x24>
 8002e0e:	f7ff fedf 	bl	8002bd0 <chSysUnlock.lto_priv.152>
 8002e12:	e159      	b.n	80030c8 <queues1_execute.lto_priv.54+0x2d8>
 8002e14:	f7ff fedc 	bl	8002bd0 <chSysUnlock.lto_priv.152>

  /* Queue filling */
  chSysLock();
 8002e18:	f7ff fed2 	bl	8002bc0 <chSysLock.lto_priv.155>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8002e1c:	2300      	movs	r3, #0
 8002e1e:	9303      	str	r3, [sp, #12]
 8002e20:	e00a      	b.n	8002e38 <queues1_execute.lto_priv.54+0x48>
    chIQPutI(&iq, 'A' + i);
 8002e22:	9b03      	ldr	r3, [sp, #12]
 8002e24:	b2db      	uxtb	r3, r3
 8002e26:	3341      	adds	r3, #65	; 0x41
 8002e28:	b2db      	uxtb	r3, r3
 8002e2a:	48a8      	ldr	r0, [pc, #672]	; (80030cc <queues1_execute.lto_priv.54+0x2dc>)
 8002e2c:	4619      	mov	r1, r3
 8002e2e:	f007 f957 	bl	800a0e0 <chIQPutI>
  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");

  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8002e32:	9b03      	ldr	r3, [sp, #12]
 8002e34:	3301      	adds	r3, #1
 8002e36:	9303      	str	r3, [sp, #12]
 8002e38:	9b03      	ldr	r3, [sp, #12]
 8002e3a:	2b03      	cmp	r3, #3
 8002e3c:	d9f1      	bls.n	8002e22 <queues1_execute.lto_priv.54+0x32>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
 8002e3e:	f7ff fec7 	bl	8002bd0 <chSysUnlock.lto_priv.152>
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
 8002e42:	f7ff febd 	bl	8002bc0 <chSysLock.lto_priv.155>
 8002e46:	48a1      	ldr	r0, [pc, #644]	; (80030cc <queues1_execute.lto_priv.54+0x2dc>)
 8002e48:	f7ff ff12 	bl	8002c70 <chIQIsFullI>
 8002e4c:	4603      	mov	r3, r0
 8002e4e:	2002      	movs	r0, #2
 8002e50:	4619      	mov	r1, r3
 8002e52:	f002 fc5d 	bl	8005710 <_test_assert>
 8002e56:	4603      	mov	r3, r0
 8002e58:	2b00      	cmp	r3, #0
 8002e5a:	d002      	beq.n	8002e62 <queues1_execute.lto_priv.54+0x72>
 8002e5c:	f7ff feb8 	bl	8002bd0 <chSysUnlock.lto_priv.152>
 8002e60:	e132      	b.n	80030c8 <queues1_execute.lto_priv.54+0x2d8>
 8002e62:	f7ff feb5 	bl	8002bd0 <chSysUnlock.lto_priv.152>
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");
 8002e66:	f7ff feab 	bl	8002bc0 <chSysLock.lto_priv.155>
 8002e6a:	4898      	ldr	r0, [pc, #608]	; (80030cc <queues1_execute.lto_priv.54+0x2dc>)
 8002e6c:	2100      	movs	r1, #0
 8002e6e:	f007 f937 	bl	800a0e0 <chIQPutI>
 8002e72:	4603      	mov	r3, r0
 8002e74:	f113 0f04 	cmn.w	r3, #4
 8002e78:	bf0c      	ite	eq
 8002e7a:	2301      	moveq	r3, #1
 8002e7c:	2300      	movne	r3, #0
 8002e7e:	b2db      	uxtb	r3, r3
 8002e80:	2003      	movs	r0, #3
 8002e82:	4619      	mov	r1, r3
 8002e84:	f002 fc44 	bl	8005710 <_test_assert>
 8002e88:	4603      	mov	r3, r0
 8002e8a:	2b00      	cmp	r3, #0
 8002e8c:	d002      	beq.n	8002e94 <queues1_execute.lto_priv.54+0xa4>
 8002e8e:	f7ff fe9f 	bl	8002bd0 <chSysUnlock.lto_priv.152>
 8002e92:	e119      	b.n	80030c8 <queues1_execute.lto_priv.54+0x2d8>
 8002e94:	f7ff fe9c 	bl	8002bd0 <chSysUnlock.lto_priv.152>

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8002e98:	2300      	movs	r3, #0
 8002e9a:	9303      	str	r3, [sp, #12]
 8002e9c:	e00a      	b.n	8002eb4 <queues1_execute.lto_priv.54+0xc4>
    test_emit_token(chIQGet(&iq));
 8002e9e:	488b      	ldr	r0, [pc, #556]	; (80030cc <queues1_execute.lto_priv.54+0x2dc>)
 8002ea0:	f7ff ff06 	bl	8002cb0 <chIQGet>
 8002ea4:	4603      	mov	r3, r0
 8002ea6:	b2db      	uxtb	r3, r3
 8002ea8:	4618      	mov	r0, r3
 8002eaa:	f002 fc01 	bl	80056b0 <test_emit_token>
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8002eae:	9b03      	ldr	r3, [sp, #12]
 8002eb0:	3301      	adds	r3, #1
 8002eb2:	9303      	str	r3, [sp, #12]
 8002eb4:	9b03      	ldr	r3, [sp, #12]
 8002eb6:	2b03      	cmp	r3, #3
 8002eb8:	d9f1      	bls.n	8002e9e <queues1_execute.lto_priv.54+0xae>
    test_emit_token(chIQGet(&iq));
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
 8002eba:	f7ff fe81 	bl	8002bc0 <chSysLock.lto_priv.155>
 8002ebe:	4883      	ldr	r0, [pc, #524]	; (80030cc <queues1_execute.lto_priv.54+0x2dc>)
 8002ec0:	f7ff fec6 	bl	8002c50 <chIQIsEmptyI>
 8002ec4:	4603      	mov	r3, r0
 8002ec6:	2004      	movs	r0, #4
 8002ec8:	4619      	mov	r1, r3
 8002eca:	f002 fc21 	bl	8005710 <_test_assert>
 8002ece:	4603      	mov	r3, r0
 8002ed0:	2b00      	cmp	r3, #0
 8002ed2:	d002      	beq.n	8002eda <queues1_execute.lto_priv.54+0xea>
 8002ed4:	f7ff fe7c 	bl	8002bd0 <chSysUnlock.lto_priv.152>
 8002ed8:	e0f6      	b.n	80030c8 <queues1_execute.lto_priv.54+0x2d8>
 8002eda:	f7ff fe79 	bl	8002bd0 <chSysUnlock.lto_priv.152>
  test_assert_sequence(5, "ABCD");
 8002ede:	2005      	movs	r0, #5
 8002ee0:	497b      	ldr	r1, [pc, #492]	; (80030d0 <queues1_execute.lto_priv.54+0x2e0>)
 8002ee2:	f002 fc2d 	bl	8005740 <_test_assert_sequence>
 8002ee6:	4603      	mov	r3, r0
 8002ee8:	2b00      	cmp	r3, #0
 8002eea:	f040 80ed 	bne.w	80030c8 <queues1_execute.lto_priv.54+0x2d8>

  /* Queue filling again */
  chSysLock();
 8002eee:	f7ff fe67 	bl	8002bc0 <chSysLock.lto_priv.155>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8002ef2:	2300      	movs	r3, #0
 8002ef4:	9303      	str	r3, [sp, #12]
 8002ef6:	e00a      	b.n	8002f0e <queues1_execute.lto_priv.54+0x11e>
    chIQPutI(&iq, 'A' + i);
 8002ef8:	9b03      	ldr	r3, [sp, #12]
 8002efa:	b2db      	uxtb	r3, r3
 8002efc:	3341      	adds	r3, #65	; 0x41
 8002efe:	b2db      	uxtb	r3, r3
 8002f00:	4872      	ldr	r0, [pc, #456]	; (80030cc <queues1_execute.lto_priv.54+0x2dc>)
 8002f02:	4619      	mov	r1, r3
 8002f04:	f007 f8ec 	bl	800a0e0 <chIQPutI>
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
  test_assert_sequence(5, "ABCD");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8002f08:	9b03      	ldr	r3, [sp, #12]
 8002f0a:	3301      	adds	r3, #1
 8002f0c:	9303      	str	r3, [sp, #12]
 8002f0e:	9b03      	ldr	r3, [sp, #12]
 8002f10:	2b03      	cmp	r3, #3
 8002f12:	d9f1      	bls.n	8002ef8 <queues1_execute.lto_priv.54+0x108>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
 8002f14:	f7ff fe5c 	bl	8002bd0 <chSysUnlock.lto_priv.152>

  /* Reading the whole thing */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 8002f18:	4b6e      	ldr	r3, [pc, #440]	; (80030d4 <queues1_execute.lto_priv.54+0x2e4>)
 8002f1a:	685b      	ldr	r3, [r3, #4]
 8002f1c:	486b      	ldr	r0, [pc, #428]	; (80030cc <queues1_execute.lto_priv.54+0x2dc>)
 8002f1e:	4619      	mov	r1, r3
 8002f20:	2208      	movs	r2, #8
 8002f22:	2300      	movs	r3, #0
 8002f24:	f007 f95c 	bl	800a1e0 <chIQReadTimeout>
 8002f28:	9002      	str	r0, [sp, #8]
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 8002f2a:	9b02      	ldr	r3, [sp, #8]
 8002f2c:	2b04      	cmp	r3, #4
 8002f2e:	bf0c      	ite	eq
 8002f30:	2301      	moveq	r3, #1
 8002f32:	2300      	movne	r3, #0
 8002f34:	b2db      	uxtb	r3, r3
 8002f36:	2006      	movs	r0, #6
 8002f38:	4619      	mov	r1, r3
 8002f3a:	f002 fbe9 	bl	8005710 <_test_assert>
 8002f3e:	4603      	mov	r3, r0
 8002f40:	2b00      	cmp	r3, #0
 8002f42:	f040 80c1 	bne.w	80030c8 <queues1_execute.lto_priv.54+0x2d8>
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");
 8002f46:	f7ff fe3b 	bl	8002bc0 <chSysLock.lto_priv.155>
 8002f4a:	4860      	ldr	r0, [pc, #384]	; (80030cc <queues1_execute.lto_priv.54+0x2dc>)
 8002f4c:	f7ff fe80 	bl	8002c50 <chIQIsEmptyI>
 8002f50:	4603      	mov	r3, r0
 8002f52:	2007      	movs	r0, #7
 8002f54:	4619      	mov	r1, r3
 8002f56:	f002 fbdb 	bl	8005710 <_test_assert>
 8002f5a:	4603      	mov	r3, r0
 8002f5c:	2b00      	cmp	r3, #0
 8002f5e:	d002      	beq.n	8002f66 <queues1_execute.lto_priv.54+0x176>
 8002f60:	f7ff fe36 	bl	8002bd0 <chSysUnlock.lto_priv.152>
 8002f64:	e0b0      	b.n	80030c8 <queues1_execute.lto_priv.54+0x2d8>
 8002f66:	f7ff fe33 	bl	8002bd0 <chSysUnlock.lto_priv.152>

  /* Queue filling again */
  chSysLock();
 8002f6a:	f7ff fe29 	bl	8002bc0 <chSysLock.lto_priv.155>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8002f6e:	2300      	movs	r3, #0
 8002f70:	9303      	str	r3, [sp, #12]
 8002f72:	e00a      	b.n	8002f8a <queues1_execute.lto_priv.54+0x19a>
    chIQPutI(&iq, 'A' + i);
 8002f74:	9b03      	ldr	r3, [sp, #12]
 8002f76:	b2db      	uxtb	r3, r3
 8002f78:	3341      	adds	r3, #65	; 0x41
 8002f7a:	b2db      	uxtb	r3, r3
 8002f7c:	4853      	ldr	r0, [pc, #332]	; (80030cc <queues1_execute.lto_priv.54+0x2dc>)
 8002f7e:	4619      	mov	r1, r3
 8002f80:	f007 f8ae 	bl	800a0e0 <chIQPutI>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8002f84:	9b03      	ldr	r3, [sp, #12]
 8002f86:	3301      	adds	r3, #1
 8002f88:	9303      	str	r3, [sp, #12]
 8002f8a:	9b03      	ldr	r3, [sp, #12]
 8002f8c:	2b03      	cmp	r3, #3
 8002f8e:	d9f1      	bls.n	8002f74 <queues1_execute.lto_priv.54+0x184>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
 8002f90:	f7ff fe1e 	bl	8002bd0 <chSysUnlock.lto_priv.152>

  /* Partial reads */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8002f94:	4b4f      	ldr	r3, [pc, #316]	; (80030d4 <queues1_execute.lto_priv.54+0x2e4>)
 8002f96:	685b      	ldr	r3, [r3, #4]
 8002f98:	484c      	ldr	r0, [pc, #304]	; (80030cc <queues1_execute.lto_priv.54+0x2dc>)
 8002f9a:	4619      	mov	r1, r3
 8002f9c:	2202      	movs	r2, #2
 8002f9e:	2300      	movs	r3, #0
 8002fa0:	f007 f91e 	bl	800a1e0 <chIQReadTimeout>
 8002fa4:	9002      	str	r0, [sp, #8]
  test_assert(8, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 8002fa6:	9b02      	ldr	r3, [sp, #8]
 8002fa8:	2b02      	cmp	r3, #2
 8002faa:	bf0c      	ite	eq
 8002fac:	2301      	moveq	r3, #1
 8002fae:	2300      	movne	r3, #0
 8002fb0:	b2db      	uxtb	r3, r3
 8002fb2:	2008      	movs	r0, #8
 8002fb4:	4619      	mov	r1, r3
 8002fb6:	f002 fbab 	bl	8005710 <_test_assert>
 8002fba:	4603      	mov	r3, r0
 8002fbc:	2b00      	cmp	r3, #0
 8002fbe:	f040 8083 	bne.w	80030c8 <queues1_execute.lto_priv.54+0x2d8>
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8002fc2:	4b44      	ldr	r3, [pc, #272]	; (80030d4 <queues1_execute.lto_priv.54+0x2e4>)
 8002fc4:	685b      	ldr	r3, [r3, #4]
 8002fc6:	4841      	ldr	r0, [pc, #260]	; (80030cc <queues1_execute.lto_priv.54+0x2dc>)
 8002fc8:	4619      	mov	r1, r3
 8002fca:	2202      	movs	r2, #2
 8002fcc:	2300      	movs	r3, #0
 8002fce:	f007 f907 	bl	800a1e0 <chIQReadTimeout>
 8002fd2:	9002      	str	r0, [sp, #8]
  test_assert(9, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 8002fd4:	9b02      	ldr	r3, [sp, #8]
 8002fd6:	2b02      	cmp	r3, #2
 8002fd8:	bf0c      	ite	eq
 8002fda:	2301      	moveq	r3, #1
 8002fdc:	2300      	movne	r3, #0
 8002fde:	b2db      	uxtb	r3, r3
 8002fe0:	2009      	movs	r0, #9
 8002fe2:	4619      	mov	r1, r3
 8002fe4:	f002 fb94 	bl	8005710 <_test_assert>
 8002fe8:	4603      	mov	r3, r0
 8002fea:	2b00      	cmp	r3, #0
 8002fec:	d16c      	bne.n	80030c8 <queues1_execute.lto_priv.54+0x2d8>
  test_assert_lock(10, chIQIsEmptyI(&iq), "still full");
 8002fee:	f7ff fde7 	bl	8002bc0 <chSysLock.lto_priv.155>
 8002ff2:	4836      	ldr	r0, [pc, #216]	; (80030cc <queues1_execute.lto_priv.54+0x2dc>)
 8002ff4:	f7ff fe2c 	bl	8002c50 <chIQIsEmptyI>
 8002ff8:	4603      	mov	r3, r0
 8002ffa:	200a      	movs	r0, #10
 8002ffc:	4619      	mov	r1, r3
 8002ffe:	f002 fb87 	bl	8005710 <_test_assert>
 8003002:	4603      	mov	r3, r0
 8003004:	2b00      	cmp	r3, #0
 8003006:	d002      	beq.n	800300e <queues1_execute.lto_priv.54+0x21e>
 8003008:	f7ff fde2 	bl	8002bd0 <chSysUnlock.lto_priv.152>
 800300c:	e05c      	b.n	80030c8 <queues1_execute.lto_priv.54+0x2d8>
 800300e:	f7ff fddf 	bl	8002bd0 <chSysUnlock.lto_priv.152>

  /* Testing reset */
  chSysLock();
 8003012:	f7ff fdd5 	bl	8002bc0 <chSysLock.lto_priv.155>
  chIQPutI(&iq, 0);
 8003016:	482d      	ldr	r0, [pc, #180]	; (80030cc <queues1_execute.lto_priv.54+0x2dc>)
 8003018:	2100      	movs	r1, #0
 800301a:	f007 f861 	bl	800a0e0 <chIQPutI>
  chIQResetI(&iq);
 800301e:	482b      	ldr	r0, [pc, #172]	; (80030cc <queues1_execute.lto_priv.54+0x2dc>)
 8003020:	f007 f83e 	bl	800a0a0 <chIQResetI>
  chSysUnlock();
 8003024:	f7ff fdd4 	bl	8002bd0 <chSysUnlock.lto_priv.152>
  test_assert_lock(11, chIQGetFullI(&iq) == 0, "still full");
 8003028:	f7ff fdca 	bl	8002bc0 <chSysLock.lto_priv.155>
 800302c:	4827      	ldr	r0, [pc, #156]	; (80030cc <queues1_execute.lto_priv.54+0x2dc>)
 800302e:	f7ff fdff 	bl	8002c30 <chIQGetFullI>
 8003032:	4603      	mov	r3, r0
 8003034:	2b00      	cmp	r3, #0
 8003036:	bf0c      	ite	eq
 8003038:	2301      	moveq	r3, #1
 800303a:	2300      	movne	r3, #0
 800303c:	b2db      	uxtb	r3, r3
 800303e:	200b      	movs	r0, #11
 8003040:	4619      	mov	r1, r3
 8003042:	f002 fb65 	bl	8005710 <_test_assert>
 8003046:	4603      	mov	r3, r0
 8003048:	2b00      	cmp	r3, #0
 800304a:	d002      	beq.n	8003052 <queues1_execute.lto_priv.54+0x262>
 800304c:	f7ff fdc0 	bl	8002bd0 <chSysUnlock.lto_priv.152>
 8003050:	e03a      	b.n	80030c8 <queues1_execute.lto_priv.54+0x2d8>
 8003052:	f7ff fdbd 	bl	8002bd0 <chSysUnlock.lto_priv.152>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, NULL);
 8003056:	4b1f      	ldr	r3, [pc, #124]	; (80030d4 <queues1_execute.lto_priv.54+0x2e4>)
 8003058:	681c      	ldr	r4, [r3, #0]
 800305a:	f7ff fde1 	bl	8002c20 <chThdGetPriorityX.lto_priv.150>
 800305e:	4603      	mov	r3, r0
 8003060:	1c5a      	adds	r2, r3, #1
 8003062:	2300      	movs	r3, #0
 8003064:	9300      	str	r3, [sp, #0]
 8003066:	4620      	mov	r0, r4
 8003068:	f44f 71b4 	mov.w	r1, #360	; 0x168
 800306c:	4b1a      	ldr	r3, [pc, #104]	; (80030d8 <queues1_execute.lto_priv.54+0x2e8>)
 800306e:	f009 fdc7 	bl	800cc00 <chThdCreateStatic>
 8003072:	4602      	mov	r2, r0
 8003074:	4b19      	ldr	r3, [pc, #100]	; (80030dc <queues1_execute.lto_priv.54+0x2ec>)
 8003076:	601a      	str	r2, [r3, #0]
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
 8003078:	f7ff fda2 	bl	8002bc0 <chSysLock.lto_priv.155>
 800307c:	4813      	ldr	r0, [pc, #76]	; (80030cc <queues1_execute.lto_priv.54+0x2dc>)
 800307e:	f7ff fdd7 	bl	8002c30 <chIQGetFullI>
 8003082:	4603      	mov	r3, r0
 8003084:	2b00      	cmp	r3, #0
 8003086:	bf0c      	ite	eq
 8003088:	2301      	moveq	r3, #1
 800308a:	2300      	movne	r3, #0
 800308c:	b2db      	uxtb	r3, r3
 800308e:	200c      	movs	r0, #12
 8003090:	4619      	mov	r1, r3
 8003092:	f002 fb3d 	bl	8005710 <_test_assert>
 8003096:	4603      	mov	r3, r0
 8003098:	2b00      	cmp	r3, #0
 800309a:	d002      	beq.n	80030a2 <queues1_execute.lto_priv.54+0x2b2>
 800309c:	f7ff fd98 	bl	8002bd0 <chSysUnlock.lto_priv.152>
 80030a0:	e012      	b.n	80030c8 <queues1_execute.lto_priv.54+0x2d8>
 80030a2:	f7ff fd95 	bl	8002bd0 <chSysUnlock.lto_priv.152>
  test_wait_threads();
 80030a6:	f002 fbb3 	bl	8005810 <test_wait_threads>

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
 80030aa:	4808      	ldr	r0, [pc, #32]	; (80030cc <queues1_execute.lto_priv.54+0x2dc>)
 80030ac:	210a      	movs	r1, #10
 80030ae:	f007 f84f 	bl	800a150 <chIQGetTimeout>
 80030b2:	4603      	mov	r3, r0
 80030b4:	f1b3 3fff 	cmp.w	r3, #4294967295
 80030b8:	bf0c      	ite	eq
 80030ba:	2301      	moveq	r3, #1
 80030bc:	2300      	movne	r3, #0
 80030be:	b2db      	uxtb	r3, r3
 80030c0:	200d      	movs	r0, #13
 80030c2:	4619      	mov	r1, r3
 80030c4:	f002 fb24 	bl	8005710 <_test_assert>
}
 80030c8:	b004      	add	sp, #16
 80030ca:	bd10      	pop	{r4, pc}
 80030cc:	200008a4 	.word	0x200008a4
 80030d0:	0800d858 	.word	0x0800d858
 80030d4:	0800e420 	.word	0x0800e420
 80030d8:	08002dd1 	.word	0x08002dd1
 80030dc:	20001bf8 	.word	0x20001bf8

080030e0 <mbox1_setup.lto_priv.77>:
 * Messages are posted/fetched from a mailbox in carefully designed sequences
 * in order to stimulate all the possible code paths inside the mailbox.<br>
 * The test expects to find a consistent mailbox status after each operation.
 */

static void mbox1_setup(void) {
 80030e0:	b508      	push	{r3, lr}

  chMBObjectInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
 80030e2:	4803      	ldr	r0, [pc, #12]	; (80030f0 <mbox1_setup.lto_priv.77+0x10>)
 80030e4:	4903      	ldr	r1, [pc, #12]	; (80030f4 <mbox1_setup.lto_priv.77+0x14>)
 80030e6:	2205      	movs	r2, #5
 80030e8:	f006 fcc2 	bl	8009a70 <chMBObjectInit>
}
 80030ec:	bd08      	pop	{r3, pc}
 80030ee:	bf00      	nop
 80030f0:	20000868 	.word	0x20000868
 80030f4:	200014f0 	.word	0x200014f0
	...

08003100 <mbox1_execute.lto_priv.78>:

static void mbox1_execute(void) {
 8003100:	b500      	push	{lr}
 8003102:	b085      	sub	sp, #20
  unsigned i;

  /*
   * Testing initial space.
   */
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 8003104:	f001 ffec 	bl	80050e0 <chSysLock.lto_priv.177>
 8003108:	4875      	ldr	r0, [pc, #468]	; (80032e0 <mbox1_execute.lto_priv.78+0x1e0>)
 800310a:	f002 f821 	bl	8005150 <chMBGetFreeCountI.lto_priv.181>
 800310e:	4603      	mov	r3, r0
 8003110:	2b05      	cmp	r3, #5
 8003112:	bf0c      	ite	eq
 8003114:	2301      	moveq	r3, #1
 8003116:	2300      	movne	r3, #0
 8003118:	b2db      	uxtb	r3, r3
 800311a:	2001      	movs	r0, #1
 800311c:	4619      	mov	r1, r3
 800311e:	f002 faf7 	bl	8005710 <_test_assert>
 8003122:	4603      	mov	r3, r0
 8003124:	2b00      	cmp	r3, #0
 8003126:	d002      	beq.n	800312e <mbox1_execute.lto_priv.78+0x2e>
 8003128:	f001 ffe2 	bl	80050f0 <chSysUnlock.lto_priv.175>
 800312c:	e3f0      	b.n	8003910 <mbox1_execute.lto_priv.78+0x810>
 800312e:	f001 ffdf 	bl	80050f0 <chSysUnlock.lto_priv.175>

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
 8003132:	2300      	movs	r3, #0
 8003134:	9303      	str	r3, [sp, #12]
 8003136:	e019      	b.n	800316c <mbox1_execute.lto_priv.78+0x6c>
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8003138:	9b03      	ldr	r3, [sp, #12]
 800313a:	3342      	adds	r3, #66	; 0x42
 800313c:	4868      	ldr	r0, [pc, #416]	; (80032e0 <mbox1_execute.lto_priv.78+0x1e0>)
 800313e:	4619      	mov	r1, r3
 8003140:	f04f 32ff 	mov.w	r2, #4294967295
 8003144:	f006 fd0c 	bl	8009b60 <chMBPost>
 8003148:	9002      	str	r0, [sp, #8]
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
 800314a:	9b02      	ldr	r3, [sp, #8]
 800314c:	2b00      	cmp	r3, #0
 800314e:	bf0c      	ite	eq
 8003150:	2301      	moveq	r3, #1
 8003152:	2300      	movne	r3, #0
 8003154:	b2db      	uxtb	r3, r3
 8003156:	2002      	movs	r0, #2
 8003158:	4619      	mov	r1, r3
 800315a:	f002 fad9 	bl	8005710 <_test_assert>
 800315e:	4603      	mov	r3, r0
 8003160:	2b00      	cmp	r3, #0
 8003162:	f040 83d5 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
 8003166:	9b03      	ldr	r3, [sp, #12]
 8003168:	3301      	adds	r3, #1
 800316a:	9303      	str	r3, [sp, #12]
 800316c:	9b03      	ldr	r3, [sp, #12]
 800316e:	2b03      	cmp	r3, #3
 8003170:	d9e2      	bls.n	8003138 <mbox1_execute.lto_priv.78+0x38>
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
  }
  msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
 8003172:	485b      	ldr	r0, [pc, #364]	; (80032e0 <mbox1_execute.lto_priv.78+0x1e0>)
 8003174:	2141      	movs	r1, #65	; 0x41
 8003176:	f04f 32ff 	mov.w	r2, #4294967295
 800317a:	f006 fd81 	bl	8009c80 <chMBPostAhead>
 800317e:	9002      	str	r0, [sp, #8]
  test_assert(3, msg1 == MSG_OK, "wrong wake-up message");
 8003180:	9b02      	ldr	r3, [sp, #8]
 8003182:	2b00      	cmp	r3, #0
 8003184:	bf0c      	ite	eq
 8003186:	2301      	moveq	r3, #1
 8003188:	2300      	movne	r3, #0
 800318a:	b2db      	uxtb	r3, r3
 800318c:	2003      	movs	r0, #3
 800318e:	4619      	mov	r1, r3
 8003190:	f002 fabe 	bl	8005710 <_test_assert>
 8003194:	4603      	mov	r3, r0
 8003196:	2b00      	cmp	r3, #0
 8003198:	f040 83ba 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>

  /*
   * Testing post timeout.
   */
  msg1 = chMBPost(&mb1, 'X', 1);
 800319c:	4850      	ldr	r0, [pc, #320]	; (80032e0 <mbox1_execute.lto_priv.78+0x1e0>)
 800319e:	2158      	movs	r1, #88	; 0x58
 80031a0:	2201      	movs	r2, #1
 80031a2:	f006 fcdd 	bl	8009b60 <chMBPost>
 80031a6:	9002      	str	r0, [sp, #8]
  test_assert(4, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80031a8:	9b02      	ldr	r3, [sp, #8]
 80031aa:	f1b3 3fff 	cmp.w	r3, #4294967295
 80031ae:	bf0c      	ite	eq
 80031b0:	2301      	moveq	r3, #1
 80031b2:	2300      	movne	r3, #0
 80031b4:	b2db      	uxtb	r3, r3
 80031b6:	2004      	movs	r0, #4
 80031b8:	4619      	mov	r1, r3
 80031ba:	f002 faa9 	bl	8005710 <_test_assert>
 80031be:	4603      	mov	r3, r0
 80031c0:	2b00      	cmp	r3, #0
 80031c2:	f040 83a5 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  chSysLock();
 80031c6:	f001 ff8b 	bl	80050e0 <chSysLock.lto_priv.177>
  msg1 = chMBPostI(&mb1, 'X');
 80031ca:	4845      	ldr	r0, [pc, #276]	; (80032e0 <mbox1_execute.lto_priv.78+0x1e0>)
 80031cc:	2158      	movs	r1, #88	; 0x58
 80031ce:	f006 fd17 	bl	8009c00 <chMBPostI>
 80031d2:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 80031d4:	f001 ff8c 	bl	80050f0 <chSysUnlock.lto_priv.175>
  test_assert(5, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80031d8:	9b02      	ldr	r3, [sp, #8]
 80031da:	f1b3 3fff 	cmp.w	r3, #4294967295
 80031de:	bf0c      	ite	eq
 80031e0:	2301      	moveq	r3, #1
 80031e2:	2300      	movne	r3, #0
 80031e4:	b2db      	uxtb	r3, r3
 80031e6:	2005      	movs	r0, #5
 80031e8:	4619      	mov	r1, r3
 80031ea:	f002 fa91 	bl	8005710 <_test_assert>
 80031ee:	4603      	mov	r3, r0
 80031f0:	2b00      	cmp	r3, #0
 80031f2:	f040 838d 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  msg1 = chMBPostAhead(&mb1, 'X', 1);
 80031f6:	483a      	ldr	r0, [pc, #232]	; (80032e0 <mbox1_execute.lto_priv.78+0x1e0>)
 80031f8:	2158      	movs	r1, #88	; 0x58
 80031fa:	2201      	movs	r2, #1
 80031fc:	f006 fd40 	bl	8009c80 <chMBPostAhead>
 8003200:	9002      	str	r0, [sp, #8]
  test_assert(6, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8003202:	9b02      	ldr	r3, [sp, #8]
 8003204:	f1b3 3fff 	cmp.w	r3, #4294967295
 8003208:	bf0c      	ite	eq
 800320a:	2301      	moveq	r3, #1
 800320c:	2300      	movne	r3, #0
 800320e:	b2db      	uxtb	r3, r3
 8003210:	2006      	movs	r0, #6
 8003212:	4619      	mov	r1, r3
 8003214:	f002 fa7c 	bl	8005710 <_test_assert>
 8003218:	4603      	mov	r3, r0
 800321a:	2b00      	cmp	r3, #0
 800321c:	f040 8378 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  chSysLock();
 8003220:	f001 ff5e 	bl	80050e0 <chSysLock.lto_priv.177>
  msg1 = chMBPostAheadI(&mb1, 'X');
 8003224:	482e      	ldr	r0, [pc, #184]	; (80032e0 <mbox1_execute.lto_priv.78+0x1e0>)
 8003226:	2158      	movs	r1, #88	; 0x58
 8003228:	f006 fd82 	bl	8009d30 <chMBPostAheadI>
 800322c:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800322e:	f001 ff5f 	bl	80050f0 <chSysUnlock.lto_priv.175>
  test_assert(7, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8003232:	9b02      	ldr	r3, [sp, #8]
 8003234:	f1b3 3fff 	cmp.w	r3, #4294967295
 8003238:	bf0c      	ite	eq
 800323a:	2301      	moveq	r3, #1
 800323c:	2300      	movne	r3, #0
 800323e:	b2db      	uxtb	r3, r3
 8003240:	2007      	movs	r0, #7
 8003242:	4619      	mov	r1, r3
 8003244:	f002 fa64 	bl	8005710 <_test_assert>
 8003248:	4603      	mov	r3, r0
 800324a:	2b00      	cmp	r3, #0
 800324c:	f040 8360 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>

  /*
   * Testing final conditions.
   */
  test_assert_lock(8, chMBGetFreeCountI(&mb1) == 0, "still empty");
 8003250:	f001 ff46 	bl	80050e0 <chSysLock.lto_priv.177>
 8003254:	4822      	ldr	r0, [pc, #136]	; (80032e0 <mbox1_execute.lto_priv.78+0x1e0>)
 8003256:	f001 ff7b 	bl	8005150 <chMBGetFreeCountI.lto_priv.181>
 800325a:	4603      	mov	r3, r0
 800325c:	2b00      	cmp	r3, #0
 800325e:	bf0c      	ite	eq
 8003260:	2301      	moveq	r3, #1
 8003262:	2300      	movne	r3, #0
 8003264:	b2db      	uxtb	r3, r3
 8003266:	2008      	movs	r0, #8
 8003268:	4619      	mov	r1, r3
 800326a:	f002 fa51 	bl	8005710 <_test_assert>
 800326e:	4603      	mov	r3, r0
 8003270:	2b00      	cmp	r3, #0
 8003272:	d002      	beq.n	800327a <mbox1_execute.lto_priv.78+0x17a>
 8003274:	f001 ff3c 	bl	80050f0 <chSysUnlock.lto_priv.175>
 8003278:	e34a      	b.n	8003910 <mbox1_execute.lto_priv.78+0x810>
 800327a:	f001 ff39 	bl	80050f0 <chSysUnlock.lto_priv.175>
  test_assert_lock(9, chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 800327e:	f001 ff2f 	bl	80050e0 <chSysLock.lto_priv.177>
 8003282:	4817      	ldr	r0, [pc, #92]	; (80032e0 <mbox1_execute.lto_priv.78+0x1e0>)
 8003284:	f001 ff74 	bl	8005170 <chMBGetUsedCountI.lto_priv.180>
 8003288:	4603      	mov	r3, r0
 800328a:	2b05      	cmp	r3, #5
 800328c:	bf0c      	ite	eq
 800328e:	2301      	moveq	r3, #1
 8003290:	2300      	movne	r3, #0
 8003292:	b2db      	uxtb	r3, r3
 8003294:	2009      	movs	r0, #9
 8003296:	4619      	mov	r1, r3
 8003298:	f002 fa3a 	bl	8005710 <_test_assert>
 800329c:	4603      	mov	r3, r0
 800329e:	2b00      	cmp	r3, #0
 80032a0:	d002      	beq.n	80032a8 <mbox1_execute.lto_priv.78+0x1a8>
 80032a2:	f001 ff25 	bl	80050f0 <chSysUnlock.lto_priv.175>
 80032a6:	e333      	b.n	8003910 <mbox1_execute.lto_priv.78+0x810>
 80032a8:	f001 ff22 	bl	80050f0 <chSysUnlock.lto_priv.175>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 80032ac:	f001 ff18 	bl	80050e0 <chSysLock.lto_priv.177>
 80032b0:	4b0b      	ldr	r3, [pc, #44]	; (80032e0 <mbox1_execute.lto_priv.78+0x1e0>)
 80032b2:	68da      	ldr	r2, [r3, #12]
 80032b4:	4b0a      	ldr	r3, [pc, #40]	; (80032e0 <mbox1_execute.lto_priv.78+0x1e0>)
 80032b6:	689b      	ldr	r3, [r3, #8]
 80032b8:	429a      	cmp	r2, r3
 80032ba:	bf0c      	ite	eq
 80032bc:	2301      	moveq	r3, #1
 80032be:	2300      	movne	r3, #0
 80032c0:	b2db      	uxtb	r3, r3
 80032c2:	200a      	movs	r0, #10
 80032c4:	4619      	mov	r1, r3
 80032c6:	f002 fa23 	bl	8005710 <_test_assert>
 80032ca:	4603      	mov	r3, r0
 80032cc:	2b00      	cmp	r3, #0
 80032ce:	d002      	beq.n	80032d6 <mbox1_execute.lto_priv.78+0x1d6>
 80032d0:	f001 ff0e 	bl	80050f0 <chSysUnlock.lto_priv.175>
 80032d4:	e31c      	b.n	8003910 <mbox1_execute.lto_priv.78+0x810>
 80032d6:	f001 ff0b 	bl	80050f0 <chSysUnlock.lto_priv.175>

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
 80032da:	2300      	movs	r3, #0
 80032dc:	9303      	str	r3, [sp, #12]
 80032de:	e01f      	b.n	8003320 <mbox1_execute.lto_priv.78+0x220>
 80032e0:	20000868 	.word	0x20000868
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 80032e4:	ab01      	add	r3, sp, #4
 80032e6:	48b1      	ldr	r0, [pc, #708]	; (80035ac <mbox1_execute.lto_priv.78+0x4ac>)
 80032e8:	4619      	mov	r1, r3
 80032ea:	f04f 32ff 	mov.w	r2, #4294967295
 80032ee:	f006 fd5f 	bl	8009db0 <chMBFetch>
 80032f2:	9002      	str	r0, [sp, #8]
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
 80032f4:	9b02      	ldr	r3, [sp, #8]
 80032f6:	2b00      	cmp	r3, #0
 80032f8:	bf0c      	ite	eq
 80032fa:	2301      	moveq	r3, #1
 80032fc:	2300      	movne	r3, #0
 80032fe:	b2db      	uxtb	r3, r3
 8003300:	200b      	movs	r0, #11
 8003302:	4619      	mov	r1, r3
 8003304:	f002 fa04 	bl	8005710 <_test_assert>
 8003308:	4603      	mov	r3, r0
 800330a:	2b00      	cmp	r3, #0
 800330c:	f040 8300 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
    test_emit_token(msg2);
 8003310:	9b01      	ldr	r3, [sp, #4]
 8003312:	b2db      	uxtb	r3, r3
 8003314:	4618      	mov	r0, r3
 8003316:	f002 f9cb 	bl	80056b0 <test_emit_token>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
 800331a:	9b03      	ldr	r3, [sp, #12]
 800331c:	3301      	adds	r3, #1
 800331e:	9303      	str	r3, [sp, #12]
 8003320:	9b03      	ldr	r3, [sp, #12]
 8003322:	2b04      	cmp	r3, #4
 8003324:	d9de      	bls.n	80032e4 <mbox1_execute.lto_priv.78+0x1e4>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(12, "ABCDE");
 8003326:	200c      	movs	r0, #12
 8003328:	49a1      	ldr	r1, [pc, #644]	; (80035b0 <mbox1_execute.lto_priv.78+0x4b0>)
 800332a:	f002 fa09 	bl	8005740 <_test_assert_sequence>
 800332e:	4603      	mov	r3, r0
 8003330:	2b00      	cmp	r3, #0
 8003332:	f040 82ed 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>

  /*
   * Testing buffer circularity.
   */
  msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8003336:	9b03      	ldr	r3, [sp, #12]
 8003338:	3342      	adds	r3, #66	; 0x42
 800333a:	489c      	ldr	r0, [pc, #624]	; (80035ac <mbox1_execute.lto_priv.78+0x4ac>)
 800333c:	4619      	mov	r1, r3
 800333e:	f04f 32ff 	mov.w	r2, #4294967295
 8003342:	f006 fc0d 	bl	8009b60 <chMBPost>
 8003346:	9002      	str	r0, [sp, #8]
  test_assert(13, msg1 == MSG_OK, "wrong wake-up message");
 8003348:	9b02      	ldr	r3, [sp, #8]
 800334a:	2b00      	cmp	r3, #0
 800334c:	bf0c      	ite	eq
 800334e:	2301      	moveq	r3, #1
 8003350:	2300      	movne	r3, #0
 8003352:	b2db      	uxtb	r3, r3
 8003354:	200d      	movs	r0, #13
 8003356:	4619      	mov	r1, r3
 8003358:	f002 f9da 	bl	8005710 <_test_assert>
 800335c:	4603      	mov	r3, r0
 800335e:	2b00      	cmp	r3, #0
 8003360:	f040 82d6 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 8003364:	ab01      	add	r3, sp, #4
 8003366:	4891      	ldr	r0, [pc, #580]	; (80035ac <mbox1_execute.lto_priv.78+0x4ac>)
 8003368:	4619      	mov	r1, r3
 800336a:	f04f 32ff 	mov.w	r2, #4294967295
 800336e:	f006 fd1f 	bl	8009db0 <chMBFetch>
 8003372:	9002      	str	r0, [sp, #8]
  test_assert(14, msg1 == MSG_OK, "wrong wake-up message");
 8003374:	9b02      	ldr	r3, [sp, #8]
 8003376:	2b00      	cmp	r3, #0
 8003378:	bf0c      	ite	eq
 800337a:	2301      	moveq	r3, #1
 800337c:	2300      	movne	r3, #0
 800337e:	b2db      	uxtb	r3, r3
 8003380:	200e      	movs	r0, #14
 8003382:	4619      	mov	r1, r3
 8003384:	f002 f9c4 	bl	8005710 <_test_assert>
 8003388:	4603      	mov	r3, r0
 800338a:	2b00      	cmp	r3, #0
 800338c:	f040 82c0 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  test_assert(15, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 8003390:	4b86      	ldr	r3, [pc, #536]	; (80035ac <mbox1_execute.lto_priv.78+0x4ac>)
 8003392:	681a      	ldr	r2, [r3, #0]
 8003394:	4b85      	ldr	r3, [pc, #532]	; (80035ac <mbox1_execute.lto_priv.78+0x4ac>)
 8003396:	689b      	ldr	r3, [r3, #8]
 8003398:	429a      	cmp	r2, r3
 800339a:	bf0c      	ite	eq
 800339c:	2301      	moveq	r3, #1
 800339e:	2300      	movne	r3, #0
 80033a0:	b2db      	uxtb	r3, r3
 80033a2:	200f      	movs	r0, #15
 80033a4:	4619      	mov	r1, r3
 80033a6:	f002 f9b3 	bl	8005710 <_test_assert>
 80033aa:	4603      	mov	r3, r0
 80033ac:	2b00      	cmp	r3, #0
 80033ae:	f040 82af 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  test_assert(16, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 80033b2:	4b7e      	ldr	r3, [pc, #504]	; (80035ac <mbox1_execute.lto_priv.78+0x4ac>)
 80033b4:	681a      	ldr	r2, [r3, #0]
 80033b6:	4b7d      	ldr	r3, [pc, #500]	; (80035ac <mbox1_execute.lto_priv.78+0x4ac>)
 80033b8:	68db      	ldr	r3, [r3, #12]
 80033ba:	429a      	cmp	r2, r3
 80033bc:	bf0c      	ite	eq
 80033be:	2301      	moveq	r3, #1
 80033c0:	2300      	movne	r3, #0
 80033c2:	b2db      	uxtb	r3, r3
 80033c4:	2010      	movs	r0, #16
 80033c6:	4619      	mov	r1, r3
 80033c8:	f002 f9a2 	bl	8005710 <_test_assert>
 80033cc:	4603      	mov	r3, r0
 80033ce:	2b00      	cmp	r3, #0
 80033d0:	f040 829e 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>

  /*
   * Testing fetch timeout.
   */
  msg1 = chMBFetch(&mb1, &msg2, 1);
 80033d4:	ab01      	add	r3, sp, #4
 80033d6:	4875      	ldr	r0, [pc, #468]	; (80035ac <mbox1_execute.lto_priv.78+0x4ac>)
 80033d8:	4619      	mov	r1, r3
 80033da:	2201      	movs	r2, #1
 80033dc:	f006 fce8 	bl	8009db0 <chMBFetch>
 80033e0:	9002      	str	r0, [sp, #8]
  test_assert(17, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80033e2:	9b02      	ldr	r3, [sp, #8]
 80033e4:	f1b3 3fff 	cmp.w	r3, #4294967295
 80033e8:	bf0c      	ite	eq
 80033ea:	2301      	moveq	r3, #1
 80033ec:	2300      	movne	r3, #0
 80033ee:	b2db      	uxtb	r3, r3
 80033f0:	2011      	movs	r0, #17
 80033f2:	4619      	mov	r1, r3
 80033f4:	f002 f98c 	bl	8005710 <_test_assert>
 80033f8:	4603      	mov	r3, r0
 80033fa:	2b00      	cmp	r3, #0
 80033fc:	f040 8288 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  chSysLock();
 8003400:	f001 fe6e 	bl	80050e0 <chSysLock.lto_priv.177>
  msg1 = chMBFetchI(&mb1, &msg2);
 8003404:	ab01      	add	r3, sp, #4
 8003406:	4869      	ldr	r0, [pc, #420]	; (80035ac <mbox1_execute.lto_priv.78+0x4ac>)
 8003408:	4619      	mov	r1, r3
 800340a:	f006 fd29 	bl	8009e60 <chMBFetchI>
 800340e:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 8003410:	f001 fe6e 	bl	80050f0 <chSysUnlock.lto_priv.175>
  test_assert(18, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8003414:	9b02      	ldr	r3, [sp, #8]
 8003416:	f1b3 3fff 	cmp.w	r3, #4294967295
 800341a:	bf0c      	ite	eq
 800341c:	2301      	moveq	r3, #1
 800341e:	2300      	movne	r3, #0
 8003420:	b2db      	uxtb	r3, r3
 8003422:	2012      	movs	r0, #18
 8003424:	4619      	mov	r1, r3
 8003426:	f002 f973 	bl	8005710 <_test_assert>
 800342a:	4603      	mov	r3, r0
 800342c:	2b00      	cmp	r3, #0
 800342e:	f040 826f 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>

  /*
   * Testing final conditions.
   */
  test_assert_lock(19, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8003432:	f001 fe55 	bl	80050e0 <chSysLock.lto_priv.177>
 8003436:	485d      	ldr	r0, [pc, #372]	; (80035ac <mbox1_execute.lto_priv.78+0x4ac>)
 8003438:	f001 fe8a 	bl	8005150 <chMBGetFreeCountI.lto_priv.181>
 800343c:	4603      	mov	r3, r0
 800343e:	2b05      	cmp	r3, #5
 8003440:	bf0c      	ite	eq
 8003442:	2301      	moveq	r3, #1
 8003444:	2300      	movne	r3, #0
 8003446:	b2db      	uxtb	r3, r3
 8003448:	2013      	movs	r0, #19
 800344a:	4619      	mov	r1, r3
 800344c:	f002 f960 	bl	8005710 <_test_assert>
 8003450:	4603      	mov	r3, r0
 8003452:	2b00      	cmp	r3, #0
 8003454:	d002      	beq.n	800345c <mbox1_execute.lto_priv.78+0x35c>
 8003456:	f001 fe4b 	bl	80050f0 <chSysUnlock.lto_priv.175>
 800345a:	e259      	b.n	8003910 <mbox1_execute.lto_priv.78+0x810>
 800345c:	f001 fe48 	bl	80050f0 <chSysUnlock.lto_priv.175>
  test_assert_lock(20, chMBGetUsedCountI(&mb1) == 0, "still full");
 8003460:	f001 fe3e 	bl	80050e0 <chSysLock.lto_priv.177>
 8003464:	4851      	ldr	r0, [pc, #324]	; (80035ac <mbox1_execute.lto_priv.78+0x4ac>)
 8003466:	f001 fe83 	bl	8005170 <chMBGetUsedCountI.lto_priv.180>
 800346a:	4603      	mov	r3, r0
 800346c:	2b00      	cmp	r3, #0
 800346e:	bf0c      	ite	eq
 8003470:	2301      	moveq	r3, #1
 8003472:	2300      	movne	r3, #0
 8003474:	b2db      	uxtb	r3, r3
 8003476:	2014      	movs	r0, #20
 8003478:	4619      	mov	r1, r3
 800347a:	f002 f949 	bl	8005710 <_test_assert>
 800347e:	4603      	mov	r3, r0
 8003480:	2b00      	cmp	r3, #0
 8003482:	d002      	beq.n	800348a <mbox1_execute.lto_priv.78+0x38a>
 8003484:	f001 fe34 	bl	80050f0 <chSysUnlock.lto_priv.175>
 8003488:	e242      	b.n	8003910 <mbox1_execute.lto_priv.78+0x810>
 800348a:	f001 fe31 	bl	80050f0 <chSysUnlock.lto_priv.175>
  test_assert_lock(21, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800348e:	f001 fe27 	bl	80050e0 <chSysLock.lto_priv.177>
 8003492:	4b46      	ldr	r3, [pc, #280]	; (80035ac <mbox1_execute.lto_priv.78+0x4ac>)
 8003494:	68da      	ldr	r2, [r3, #12]
 8003496:	4b45      	ldr	r3, [pc, #276]	; (80035ac <mbox1_execute.lto_priv.78+0x4ac>)
 8003498:	689b      	ldr	r3, [r3, #8]
 800349a:	429a      	cmp	r2, r3
 800349c:	bf0c      	ite	eq
 800349e:	2301      	moveq	r3, #1
 80034a0:	2300      	movne	r3, #0
 80034a2:	b2db      	uxtb	r3, r3
 80034a4:	2015      	movs	r0, #21
 80034a6:	4619      	mov	r1, r3
 80034a8:	f002 f932 	bl	8005710 <_test_assert>
 80034ac:	4603      	mov	r3, r0
 80034ae:	2b00      	cmp	r3, #0
 80034b0:	d002      	beq.n	80034b8 <mbox1_execute.lto_priv.78+0x3b8>
 80034b2:	f001 fe1d 	bl	80050f0 <chSysUnlock.lto_priv.175>
 80034b6:	e22b      	b.n	8003910 <mbox1_execute.lto_priv.78+0x810>
 80034b8:	f001 fe1a 	bl	80050f0 <chSysUnlock.lto_priv.175>

  /*
   * Testing I-Class.
   */
  chSysLock();
 80034bc:	f001 fe10 	bl	80050e0 <chSysLock.lto_priv.177>
  msg1 = chMBPostI(&mb1, 'A');
 80034c0:	483a      	ldr	r0, [pc, #232]	; (80035ac <mbox1_execute.lto_priv.78+0x4ac>)
 80034c2:	2141      	movs	r1, #65	; 0x41
 80034c4:	f006 fb9c 	bl	8009c00 <chMBPostI>
 80034c8:	9002      	str	r0, [sp, #8]
  test_assert(22, msg1 == MSG_OK, "wrong wake-up message");
 80034ca:	9b02      	ldr	r3, [sp, #8]
 80034cc:	2b00      	cmp	r3, #0
 80034ce:	bf0c      	ite	eq
 80034d0:	2301      	moveq	r3, #1
 80034d2:	2300      	movne	r3, #0
 80034d4:	b2db      	uxtb	r3, r3
 80034d6:	2016      	movs	r0, #22
 80034d8:	4619      	mov	r1, r3
 80034da:	f002 f919 	bl	8005710 <_test_assert>
 80034de:	4603      	mov	r3, r0
 80034e0:	2b00      	cmp	r3, #0
 80034e2:	f040 8215 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  msg1 = chMBPostI(&mb1, 'B');
 80034e6:	4831      	ldr	r0, [pc, #196]	; (80035ac <mbox1_execute.lto_priv.78+0x4ac>)
 80034e8:	2142      	movs	r1, #66	; 0x42
 80034ea:	f006 fb89 	bl	8009c00 <chMBPostI>
 80034ee:	9002      	str	r0, [sp, #8]
  test_assert(23, msg1 == MSG_OK, "wrong wake-up message");
 80034f0:	9b02      	ldr	r3, [sp, #8]
 80034f2:	2b00      	cmp	r3, #0
 80034f4:	bf0c      	ite	eq
 80034f6:	2301      	moveq	r3, #1
 80034f8:	2300      	movne	r3, #0
 80034fa:	b2db      	uxtb	r3, r3
 80034fc:	2017      	movs	r0, #23
 80034fe:	4619      	mov	r1, r3
 8003500:	f002 f906 	bl	8005710 <_test_assert>
 8003504:	4603      	mov	r3, r0
 8003506:	2b00      	cmp	r3, #0
 8003508:	f040 8202 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  msg1 = chMBPostI(&mb1, 'C');
 800350c:	4827      	ldr	r0, [pc, #156]	; (80035ac <mbox1_execute.lto_priv.78+0x4ac>)
 800350e:	2143      	movs	r1, #67	; 0x43
 8003510:	f006 fb76 	bl	8009c00 <chMBPostI>
 8003514:	9002      	str	r0, [sp, #8]
  test_assert(24, msg1 == MSG_OK, "wrong wake-up message");
 8003516:	9b02      	ldr	r3, [sp, #8]
 8003518:	2b00      	cmp	r3, #0
 800351a:	bf0c      	ite	eq
 800351c:	2301      	moveq	r3, #1
 800351e:	2300      	movne	r3, #0
 8003520:	b2db      	uxtb	r3, r3
 8003522:	2018      	movs	r0, #24
 8003524:	4619      	mov	r1, r3
 8003526:	f002 f8f3 	bl	8005710 <_test_assert>
 800352a:	4603      	mov	r3, r0
 800352c:	2b00      	cmp	r3, #0
 800352e:	f040 81ef 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  msg1 = chMBPostI(&mb1, 'D');
 8003532:	481e      	ldr	r0, [pc, #120]	; (80035ac <mbox1_execute.lto_priv.78+0x4ac>)
 8003534:	2144      	movs	r1, #68	; 0x44
 8003536:	f006 fb63 	bl	8009c00 <chMBPostI>
 800353a:	9002      	str	r0, [sp, #8]
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
 800353c:	9b02      	ldr	r3, [sp, #8]
 800353e:	2b00      	cmp	r3, #0
 8003540:	bf0c      	ite	eq
 8003542:	2301      	moveq	r3, #1
 8003544:	2300      	movne	r3, #0
 8003546:	b2db      	uxtb	r3, r3
 8003548:	2019      	movs	r0, #25
 800354a:	4619      	mov	r1, r3
 800354c:	f002 f8e0 	bl	8005710 <_test_assert>
 8003550:	4603      	mov	r3, r0
 8003552:	2b00      	cmp	r3, #0
 8003554:	f040 81dc 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  msg1 = chMBPostI(&mb1, 'E');
 8003558:	4814      	ldr	r0, [pc, #80]	; (80035ac <mbox1_execute.lto_priv.78+0x4ac>)
 800355a:	2145      	movs	r1, #69	; 0x45
 800355c:	f006 fb50 	bl	8009c00 <chMBPostI>
 8003560:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 8003562:	f001 fdc5 	bl	80050f0 <chSysUnlock.lto_priv.175>
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
 8003566:	9b02      	ldr	r3, [sp, #8]
 8003568:	2b00      	cmp	r3, #0
 800356a:	bf0c      	ite	eq
 800356c:	2301      	moveq	r3, #1
 800356e:	2300      	movne	r3, #0
 8003570:	b2db      	uxtb	r3, r3
 8003572:	201a      	movs	r0, #26
 8003574:	4619      	mov	r1, r3
 8003576:	f002 f8cb 	bl	8005710 <_test_assert>
 800357a:	4603      	mov	r3, r0
 800357c:	2b00      	cmp	r3, #0
 800357e:	f040 81c7 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8003582:	4b0a      	ldr	r3, [pc, #40]	; (80035ac <mbox1_execute.lto_priv.78+0x4ac>)
 8003584:	68da      	ldr	r2, [r3, #12]
 8003586:	4b09      	ldr	r3, [pc, #36]	; (80035ac <mbox1_execute.lto_priv.78+0x4ac>)
 8003588:	689b      	ldr	r3, [r3, #8]
 800358a:	429a      	cmp	r2, r3
 800358c:	bf0c      	ite	eq
 800358e:	2301      	moveq	r3, #1
 8003590:	2300      	movne	r3, #0
 8003592:	b2db      	uxtb	r3, r3
 8003594:	201b      	movs	r0, #27
 8003596:	4619      	mov	r1, r3
 8003598:	f002 f8ba 	bl	8005710 <_test_assert>
 800359c:	4603      	mov	r3, r0
 800359e:	2b00      	cmp	r3, #0
 80035a0:	f040 81b6 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  for (i = 0; i < MB_SIZE; i++) {
 80035a4:	2300      	movs	r3, #0
 80035a6:	9303      	str	r3, [sp, #12]
 80035a8:	e024      	b.n	80035f4 <mbox1_execute.lto_priv.78+0x4f4>
 80035aa:	bf00      	nop
 80035ac:	20000868 	.word	0x20000868
 80035b0:	0800d860 	.word	0x0800d860
    chSysLock();
 80035b4:	f001 fd94 	bl	80050e0 <chSysLock.lto_priv.177>
    msg1 = chMBFetchI(&mb1, &msg2);
 80035b8:	ab01      	add	r3, sp, #4
 80035ba:	48bb      	ldr	r0, [pc, #748]	; (80038a8 <mbox1_execute.lto_priv.78+0x7a8>)
 80035bc:	4619      	mov	r1, r3
 80035be:	f006 fc4f 	bl	8009e60 <chMBFetchI>
 80035c2:	9002      	str	r0, [sp, #8]
    chSysUnlock();
 80035c4:	f001 fd94 	bl	80050f0 <chSysUnlock.lto_priv.175>
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
 80035c8:	9b02      	ldr	r3, [sp, #8]
 80035ca:	2b00      	cmp	r3, #0
 80035cc:	bf0c      	ite	eq
 80035ce:	2301      	moveq	r3, #1
 80035d0:	2300      	movne	r3, #0
 80035d2:	b2db      	uxtb	r3, r3
 80035d4:	201c      	movs	r0, #28
 80035d6:	4619      	mov	r1, r3
 80035d8:	f002 f89a 	bl	8005710 <_test_assert>
 80035dc:	4603      	mov	r3, r0
 80035de:	2b00      	cmp	r3, #0
 80035e0:	f040 8196 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
    test_emit_token(msg2);
 80035e4:	9b01      	ldr	r3, [sp, #4]
 80035e6:	b2db      	uxtb	r3, r3
 80035e8:	4618      	mov	r0, r3
 80035ea:	f002 f861 	bl	80056b0 <test_emit_token>
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostI(&mb1, 'E');
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 80035ee:	9b03      	ldr	r3, [sp, #12]
 80035f0:	3301      	adds	r3, #1
 80035f2:	9303      	str	r3, [sp, #12]
 80035f4:	9b03      	ldr	r3, [sp, #12]
 80035f6:	2b04      	cmp	r3, #4
 80035f8:	d9dc      	bls.n	80035b4 <mbox1_execute.lto_priv.78+0x4b4>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(29, "ABCDE");
 80035fa:	201d      	movs	r0, #29
 80035fc:	49ab      	ldr	r1, [pc, #684]	; (80038ac <mbox1_execute.lto_priv.78+0x7ac>)
 80035fe:	f002 f89f 	bl	8005740 <_test_assert_sequence>
 8003602:	4603      	mov	r3, r0
 8003604:	2b00      	cmp	r3, #0
 8003606:	f040 8183 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  test_assert_lock(30, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800360a:	f001 fd69 	bl	80050e0 <chSysLock.lto_priv.177>
 800360e:	48a6      	ldr	r0, [pc, #664]	; (80038a8 <mbox1_execute.lto_priv.78+0x7a8>)
 8003610:	f001 fd9e 	bl	8005150 <chMBGetFreeCountI.lto_priv.181>
 8003614:	4603      	mov	r3, r0
 8003616:	2b05      	cmp	r3, #5
 8003618:	bf0c      	ite	eq
 800361a:	2301      	moveq	r3, #1
 800361c:	2300      	movne	r3, #0
 800361e:	b2db      	uxtb	r3, r3
 8003620:	201e      	movs	r0, #30
 8003622:	4619      	mov	r1, r3
 8003624:	f002 f874 	bl	8005710 <_test_assert>
 8003628:	4603      	mov	r3, r0
 800362a:	2b00      	cmp	r3, #0
 800362c:	d002      	beq.n	8003634 <mbox1_execute.lto_priv.78+0x534>
 800362e:	f001 fd5f 	bl	80050f0 <chSysUnlock.lto_priv.175>
 8003632:	e16d      	b.n	8003910 <mbox1_execute.lto_priv.78+0x810>
 8003634:	f001 fd5c 	bl	80050f0 <chSysUnlock.lto_priv.175>
  test_assert_lock(31, chMBGetUsedCountI(&mb1) == 0, "still full");
 8003638:	f001 fd52 	bl	80050e0 <chSysLock.lto_priv.177>
 800363c:	489a      	ldr	r0, [pc, #616]	; (80038a8 <mbox1_execute.lto_priv.78+0x7a8>)
 800363e:	f001 fd97 	bl	8005170 <chMBGetUsedCountI.lto_priv.180>
 8003642:	4603      	mov	r3, r0
 8003644:	2b00      	cmp	r3, #0
 8003646:	bf0c      	ite	eq
 8003648:	2301      	moveq	r3, #1
 800364a:	2300      	movne	r3, #0
 800364c:	b2db      	uxtb	r3, r3
 800364e:	201f      	movs	r0, #31
 8003650:	4619      	mov	r1, r3
 8003652:	f002 f85d 	bl	8005710 <_test_assert>
 8003656:	4603      	mov	r3, r0
 8003658:	2b00      	cmp	r3, #0
 800365a:	d002      	beq.n	8003662 <mbox1_execute.lto_priv.78+0x562>
 800365c:	f001 fd48 	bl	80050f0 <chSysUnlock.lto_priv.175>
 8003660:	e156      	b.n	8003910 <mbox1_execute.lto_priv.78+0x810>
 8003662:	f001 fd45 	bl	80050f0 <chSysUnlock.lto_priv.175>
  test_assert(32, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8003666:	4b90      	ldr	r3, [pc, #576]	; (80038a8 <mbox1_execute.lto_priv.78+0x7a8>)
 8003668:	68da      	ldr	r2, [r3, #12]
 800366a:	4b8f      	ldr	r3, [pc, #572]	; (80038a8 <mbox1_execute.lto_priv.78+0x7a8>)
 800366c:	689b      	ldr	r3, [r3, #8]
 800366e:	429a      	cmp	r2, r3
 8003670:	bf0c      	ite	eq
 8003672:	2301      	moveq	r3, #1
 8003674:	2300      	movne	r3, #0
 8003676:	b2db      	uxtb	r3, r3
 8003678:	2020      	movs	r0, #32
 800367a:	4619      	mov	r1, r3
 800367c:	f002 f848 	bl	8005710 <_test_assert>
 8003680:	4603      	mov	r3, r0
 8003682:	2b00      	cmp	r3, #0
 8003684:	f040 8144 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>

  chSysLock();
 8003688:	f001 fd2a 	bl	80050e0 <chSysLock.lto_priv.177>
  msg1 = chMBPostAheadI(&mb1, 'E');
 800368c:	4886      	ldr	r0, [pc, #536]	; (80038a8 <mbox1_execute.lto_priv.78+0x7a8>)
 800368e:	2145      	movs	r1, #69	; 0x45
 8003690:	f006 fb4e 	bl	8009d30 <chMBPostAheadI>
 8003694:	9002      	str	r0, [sp, #8]
  test_assert(33, msg1 == MSG_OK, "wrong wake-up message");
 8003696:	9b02      	ldr	r3, [sp, #8]
 8003698:	2b00      	cmp	r3, #0
 800369a:	bf0c      	ite	eq
 800369c:	2301      	moveq	r3, #1
 800369e:	2300      	movne	r3, #0
 80036a0:	b2db      	uxtb	r3, r3
 80036a2:	2021      	movs	r0, #33	; 0x21
 80036a4:	4619      	mov	r1, r3
 80036a6:	f002 f833 	bl	8005710 <_test_assert>
 80036aa:	4603      	mov	r3, r0
 80036ac:	2b00      	cmp	r3, #0
 80036ae:	f040 812f 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  msg1 = chMBPostAheadI(&mb1, 'D');
 80036b2:	487d      	ldr	r0, [pc, #500]	; (80038a8 <mbox1_execute.lto_priv.78+0x7a8>)
 80036b4:	2144      	movs	r1, #68	; 0x44
 80036b6:	f006 fb3b 	bl	8009d30 <chMBPostAheadI>
 80036ba:	9002      	str	r0, [sp, #8]
  test_assert(34, msg1 == MSG_OK, "wrong wake-up message");
 80036bc:	9b02      	ldr	r3, [sp, #8]
 80036be:	2b00      	cmp	r3, #0
 80036c0:	bf0c      	ite	eq
 80036c2:	2301      	moveq	r3, #1
 80036c4:	2300      	movne	r3, #0
 80036c6:	b2db      	uxtb	r3, r3
 80036c8:	2022      	movs	r0, #34	; 0x22
 80036ca:	4619      	mov	r1, r3
 80036cc:	f002 f820 	bl	8005710 <_test_assert>
 80036d0:	4603      	mov	r3, r0
 80036d2:	2b00      	cmp	r3, #0
 80036d4:	f040 811c 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  msg1 = chMBPostAheadI(&mb1, 'C');
 80036d8:	4873      	ldr	r0, [pc, #460]	; (80038a8 <mbox1_execute.lto_priv.78+0x7a8>)
 80036da:	2143      	movs	r1, #67	; 0x43
 80036dc:	f006 fb28 	bl	8009d30 <chMBPostAheadI>
 80036e0:	9002      	str	r0, [sp, #8]
  test_assert(35, msg1 == MSG_OK, "wrong wake-up message");
 80036e2:	9b02      	ldr	r3, [sp, #8]
 80036e4:	2b00      	cmp	r3, #0
 80036e6:	bf0c      	ite	eq
 80036e8:	2301      	moveq	r3, #1
 80036ea:	2300      	movne	r3, #0
 80036ec:	b2db      	uxtb	r3, r3
 80036ee:	2023      	movs	r0, #35	; 0x23
 80036f0:	4619      	mov	r1, r3
 80036f2:	f002 f80d 	bl	8005710 <_test_assert>
 80036f6:	4603      	mov	r3, r0
 80036f8:	2b00      	cmp	r3, #0
 80036fa:	f040 8109 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  msg1 = chMBPostAheadI(&mb1, 'B');
 80036fe:	486a      	ldr	r0, [pc, #424]	; (80038a8 <mbox1_execute.lto_priv.78+0x7a8>)
 8003700:	2142      	movs	r1, #66	; 0x42
 8003702:	f006 fb15 	bl	8009d30 <chMBPostAheadI>
 8003706:	9002      	str	r0, [sp, #8]
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
 8003708:	9b02      	ldr	r3, [sp, #8]
 800370a:	2b00      	cmp	r3, #0
 800370c:	bf0c      	ite	eq
 800370e:	2301      	moveq	r3, #1
 8003710:	2300      	movne	r3, #0
 8003712:	b2db      	uxtb	r3, r3
 8003714:	2024      	movs	r0, #36	; 0x24
 8003716:	4619      	mov	r1, r3
 8003718:	f001 fffa 	bl	8005710 <_test_assert>
 800371c:	4603      	mov	r3, r0
 800371e:	2b00      	cmp	r3, #0
 8003720:	f040 80f6 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  msg1 = chMBPostAheadI(&mb1, 'A');
 8003724:	4860      	ldr	r0, [pc, #384]	; (80038a8 <mbox1_execute.lto_priv.78+0x7a8>)
 8003726:	2141      	movs	r1, #65	; 0x41
 8003728:	f006 fb02 	bl	8009d30 <chMBPostAheadI>
 800372c:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800372e:	f001 fcdf 	bl	80050f0 <chSysUnlock.lto_priv.175>
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
 8003732:	9b02      	ldr	r3, [sp, #8]
 8003734:	2b00      	cmp	r3, #0
 8003736:	bf0c      	ite	eq
 8003738:	2301      	moveq	r3, #1
 800373a:	2300      	movne	r3, #0
 800373c:	b2db      	uxtb	r3, r3
 800373e:	2025      	movs	r0, #37	; 0x25
 8003740:	4619      	mov	r1, r3
 8003742:	f001 ffe5 	bl	8005710 <_test_assert>
 8003746:	4603      	mov	r3, r0
 8003748:	2b00      	cmp	r3, #0
 800374a:	f040 80e1 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800374e:	4b56      	ldr	r3, [pc, #344]	; (80038a8 <mbox1_execute.lto_priv.78+0x7a8>)
 8003750:	68da      	ldr	r2, [r3, #12]
 8003752:	4b55      	ldr	r3, [pc, #340]	; (80038a8 <mbox1_execute.lto_priv.78+0x7a8>)
 8003754:	689b      	ldr	r3, [r3, #8]
 8003756:	429a      	cmp	r2, r3
 8003758:	bf0c      	ite	eq
 800375a:	2301      	moveq	r3, #1
 800375c:	2300      	movne	r3, #0
 800375e:	b2db      	uxtb	r3, r3
 8003760:	2026      	movs	r0, #38	; 0x26
 8003762:	4619      	mov	r1, r3
 8003764:	f001 ffd4 	bl	8005710 <_test_assert>
 8003768:	4603      	mov	r3, r0
 800376a:	2b00      	cmp	r3, #0
 800376c:	f040 80d0 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  for (i = 0; i < MB_SIZE; i++) {
 8003770:	2300      	movs	r3, #0
 8003772:	9303      	str	r3, [sp, #12]
 8003774:	e01f      	b.n	80037b6 <mbox1_execute.lto_priv.78+0x6b6>
    chSysLock();
 8003776:	f001 fcb3 	bl	80050e0 <chSysLock.lto_priv.177>
    msg1 = chMBFetchI(&mb1, &msg2);
 800377a:	ab01      	add	r3, sp, #4
 800377c:	484a      	ldr	r0, [pc, #296]	; (80038a8 <mbox1_execute.lto_priv.78+0x7a8>)
 800377e:	4619      	mov	r1, r3
 8003780:	f006 fb6e 	bl	8009e60 <chMBFetchI>
 8003784:	9002      	str	r0, [sp, #8]
    chSysUnlock();
 8003786:	f001 fcb3 	bl	80050f0 <chSysUnlock.lto_priv.175>
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
 800378a:	9b02      	ldr	r3, [sp, #8]
 800378c:	2b00      	cmp	r3, #0
 800378e:	bf0c      	ite	eq
 8003790:	2301      	moveq	r3, #1
 8003792:	2300      	movne	r3, #0
 8003794:	b2db      	uxtb	r3, r3
 8003796:	2027      	movs	r0, #39	; 0x27
 8003798:	4619      	mov	r1, r3
 800379a:	f001 ffb9 	bl	8005710 <_test_assert>
 800379e:	4603      	mov	r3, r0
 80037a0:	2b00      	cmp	r3, #0
 80037a2:	f040 80b5 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
    test_emit_token(msg2);
 80037a6:	9b01      	ldr	r3, [sp, #4]
 80037a8:	b2db      	uxtb	r3, r3
 80037aa:	4618      	mov	r0, r3
 80037ac:	f001 ff80 	bl	80056b0 <test_emit_token>
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostAheadI(&mb1, 'A');
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 80037b0:	9b03      	ldr	r3, [sp, #12]
 80037b2:	3301      	adds	r3, #1
 80037b4:	9303      	str	r3, [sp, #12]
 80037b6:	9b03      	ldr	r3, [sp, #12]
 80037b8:	2b04      	cmp	r3, #4
 80037ba:	d9dc      	bls.n	8003776 <mbox1_execute.lto_priv.78+0x676>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(40, "ABCDE");
 80037bc:	2028      	movs	r0, #40	; 0x28
 80037be:	493b      	ldr	r1, [pc, #236]	; (80038ac <mbox1_execute.lto_priv.78+0x7ac>)
 80037c0:	f001 ffbe 	bl	8005740 <_test_assert_sequence>
 80037c4:	4603      	mov	r3, r0
 80037c6:	2b00      	cmp	r3, #0
 80037c8:	f040 80a2 	bne.w	8003910 <mbox1_execute.lto_priv.78+0x810>
  test_assert_lock(41, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 80037cc:	f001 fc88 	bl	80050e0 <chSysLock.lto_priv.177>
 80037d0:	4835      	ldr	r0, [pc, #212]	; (80038a8 <mbox1_execute.lto_priv.78+0x7a8>)
 80037d2:	f001 fcbd 	bl	8005150 <chMBGetFreeCountI.lto_priv.181>
 80037d6:	4603      	mov	r3, r0
 80037d8:	2b05      	cmp	r3, #5
 80037da:	bf0c      	ite	eq
 80037dc:	2301      	moveq	r3, #1
 80037de:	2300      	movne	r3, #0
 80037e0:	b2db      	uxtb	r3, r3
 80037e2:	2029      	movs	r0, #41	; 0x29
 80037e4:	4619      	mov	r1, r3
 80037e6:	f001 ff93 	bl	8005710 <_test_assert>
 80037ea:	4603      	mov	r3, r0
 80037ec:	2b00      	cmp	r3, #0
 80037ee:	d002      	beq.n	80037f6 <mbox1_execute.lto_priv.78+0x6f6>
 80037f0:	f001 fc7e 	bl	80050f0 <chSysUnlock.lto_priv.175>
 80037f4:	e08c      	b.n	8003910 <mbox1_execute.lto_priv.78+0x810>
 80037f6:	f001 fc7b 	bl	80050f0 <chSysUnlock.lto_priv.175>
  test_assert_lock(42, chMBGetUsedCountI(&mb1) == 0, "still full");
 80037fa:	f001 fc71 	bl	80050e0 <chSysLock.lto_priv.177>
 80037fe:	482a      	ldr	r0, [pc, #168]	; (80038a8 <mbox1_execute.lto_priv.78+0x7a8>)
 8003800:	f001 fcb6 	bl	8005170 <chMBGetUsedCountI.lto_priv.180>
 8003804:	4603      	mov	r3, r0
 8003806:	2b00      	cmp	r3, #0
 8003808:	bf0c      	ite	eq
 800380a:	2301      	moveq	r3, #1
 800380c:	2300      	movne	r3, #0
 800380e:	b2db      	uxtb	r3, r3
 8003810:	202a      	movs	r0, #42	; 0x2a
 8003812:	4619      	mov	r1, r3
 8003814:	f001 ff7c 	bl	8005710 <_test_assert>
 8003818:	4603      	mov	r3, r0
 800381a:	2b00      	cmp	r3, #0
 800381c:	d002      	beq.n	8003824 <mbox1_execute.lto_priv.78+0x724>
 800381e:	f001 fc67 	bl	80050f0 <chSysUnlock.lto_priv.175>
 8003822:	e075      	b.n	8003910 <mbox1_execute.lto_priv.78+0x810>
 8003824:	f001 fc64 	bl	80050f0 <chSysUnlock.lto_priv.175>
  test_assert(43, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8003828:	4b1f      	ldr	r3, [pc, #124]	; (80038a8 <mbox1_execute.lto_priv.78+0x7a8>)
 800382a:	68da      	ldr	r2, [r3, #12]
 800382c:	4b1e      	ldr	r3, [pc, #120]	; (80038a8 <mbox1_execute.lto_priv.78+0x7a8>)
 800382e:	689b      	ldr	r3, [r3, #8]
 8003830:	429a      	cmp	r2, r3
 8003832:	bf0c      	ite	eq
 8003834:	2301      	moveq	r3, #1
 8003836:	2300      	movne	r3, #0
 8003838:	b2db      	uxtb	r3, r3
 800383a:	202b      	movs	r0, #43	; 0x2b
 800383c:	4619      	mov	r1, r3
 800383e:	f001 ff67 	bl	8005710 <_test_assert>
 8003842:	4603      	mov	r3, r0
 8003844:	2b00      	cmp	r3, #0
 8003846:	d163      	bne.n	8003910 <mbox1_execute.lto_priv.78+0x810>

  /*
   * Testing reset.
   */
  chMBReset(&mb1);
 8003848:	4817      	ldr	r0, [pc, #92]	; (80038a8 <mbox1_execute.lto_priv.78+0x7a8>)
 800384a:	f006 f949 	bl	8009ae0 <chMBReset>

  /*
   * Re-testing final conditions.
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800384e:	f001 fc47 	bl	80050e0 <chSysLock.lto_priv.177>
 8003852:	4815      	ldr	r0, [pc, #84]	; (80038a8 <mbox1_execute.lto_priv.78+0x7a8>)
 8003854:	f001 fc7c 	bl	8005150 <chMBGetFreeCountI.lto_priv.181>
 8003858:	4603      	mov	r3, r0
 800385a:	2b05      	cmp	r3, #5
 800385c:	bf0c      	ite	eq
 800385e:	2301      	moveq	r3, #1
 8003860:	2300      	movne	r3, #0
 8003862:	b2db      	uxtb	r3, r3
 8003864:	202c      	movs	r0, #44	; 0x2c
 8003866:	4619      	mov	r1, r3
 8003868:	f001 ff52 	bl	8005710 <_test_assert>
 800386c:	4603      	mov	r3, r0
 800386e:	2b00      	cmp	r3, #0
 8003870:	d002      	beq.n	8003878 <mbox1_execute.lto_priv.78+0x778>
 8003872:	f001 fc3d 	bl	80050f0 <chSysUnlock.lto_priv.175>
 8003876:	e04b      	b.n	8003910 <mbox1_execute.lto_priv.78+0x810>
 8003878:	f001 fc3a 	bl	80050f0 <chSysUnlock.lto_priv.175>
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
 800387c:	f001 fc30 	bl	80050e0 <chSysLock.lto_priv.177>
 8003880:	4809      	ldr	r0, [pc, #36]	; (80038a8 <mbox1_execute.lto_priv.78+0x7a8>)
 8003882:	f001 fc75 	bl	8005170 <chMBGetUsedCountI.lto_priv.180>
 8003886:	4603      	mov	r3, r0
 8003888:	2b00      	cmp	r3, #0
 800388a:	bf0c      	ite	eq
 800388c:	2301      	moveq	r3, #1
 800388e:	2300      	movne	r3, #0
 8003890:	b2db      	uxtb	r3, r3
 8003892:	202d      	movs	r0, #45	; 0x2d
 8003894:	4619      	mov	r1, r3
 8003896:	f001 ff3b 	bl	8005710 <_test_assert>
 800389a:	4603      	mov	r3, r0
 800389c:	2b00      	cmp	r3, #0
 800389e:	d007      	beq.n	80038b0 <mbox1_execute.lto_priv.78+0x7b0>
 80038a0:	f001 fc26 	bl	80050f0 <chSysUnlock.lto_priv.175>
 80038a4:	e034      	b.n	8003910 <mbox1_execute.lto_priv.78+0x810>
 80038a6:	bf00      	nop
 80038a8:	20000868 	.word	0x20000868
 80038ac:	0800d860 	.word	0x0800d860
 80038b0:	f001 fc1e 	bl	80050f0 <chSysUnlock.lto_priv.175>
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 80038b4:	f001 fc14 	bl	80050e0 <chSysLock.lto_priv.177>
 80038b8:	4b17      	ldr	r3, [pc, #92]	; (8003918 <mbox1_execute.lto_priv.78+0x818>)
 80038ba:	681a      	ldr	r2, [r3, #0]
 80038bc:	4b16      	ldr	r3, [pc, #88]	; (8003918 <mbox1_execute.lto_priv.78+0x818>)
 80038be:	689b      	ldr	r3, [r3, #8]
 80038c0:	429a      	cmp	r2, r3
 80038c2:	bf0c      	ite	eq
 80038c4:	2301      	moveq	r3, #1
 80038c6:	2300      	movne	r3, #0
 80038c8:	b2db      	uxtb	r3, r3
 80038ca:	202e      	movs	r0, #46	; 0x2e
 80038cc:	4619      	mov	r1, r3
 80038ce:	f001 ff1f 	bl	8005710 <_test_assert>
 80038d2:	4603      	mov	r3, r0
 80038d4:	2b00      	cmp	r3, #0
 80038d6:	d002      	beq.n	80038de <mbox1_execute.lto_priv.78+0x7de>
 80038d8:	f001 fc0a 	bl	80050f0 <chSysUnlock.lto_priv.175>
 80038dc:	e018      	b.n	8003910 <mbox1_execute.lto_priv.78+0x810>
 80038de:	f001 fc07 	bl	80050f0 <chSysUnlock.lto_priv.175>
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 80038e2:	f001 fbfd 	bl	80050e0 <chSysLock.lto_priv.177>
 80038e6:	4b0c      	ldr	r3, [pc, #48]	; (8003918 <mbox1_execute.lto_priv.78+0x818>)
 80038e8:	681a      	ldr	r2, [r3, #0]
 80038ea:	4b0b      	ldr	r3, [pc, #44]	; (8003918 <mbox1_execute.lto_priv.78+0x818>)
 80038ec:	68db      	ldr	r3, [r3, #12]
 80038ee:	429a      	cmp	r2, r3
 80038f0:	bf0c      	ite	eq
 80038f2:	2301      	moveq	r3, #1
 80038f4:	2300      	movne	r3, #0
 80038f6:	b2db      	uxtb	r3, r3
 80038f8:	202f      	movs	r0, #47	; 0x2f
 80038fa:	4619      	mov	r1, r3
 80038fc:	f001 ff08 	bl	8005710 <_test_assert>
 8003900:	4603      	mov	r3, r0
 8003902:	2b00      	cmp	r3, #0
 8003904:	d002      	beq.n	800390c <mbox1_execute.lto_priv.78+0x80c>
 8003906:	f001 fbf3 	bl	80050f0 <chSysUnlock.lto_priv.175>
 800390a:	e001      	b.n	8003910 <mbox1_execute.lto_priv.78+0x810>
 800390c:	f001 fbf0 	bl	80050f0 <chSysUnlock.lto_priv.175>
}
 8003910:	b005      	add	sp, #20
 8003912:	f85d fb04 	ldr.w	pc, [sp], #4
 8003916:	bf00      	nop
 8003918:	20000868 	.word	0x20000868
 800391c:	00000000 	.word	0x00000000

08003920 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003920:	b082      	sub	sp, #8
 8003922:	2320      	movs	r3, #32
 8003924:	9301      	str	r3, [sp, #4]
 8003926:	9b01      	ldr	r3, [sp, #4]
 8003928:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800392c:	b002      	add	sp, #8
 800392e:	4770      	bx	lr

08003930 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003930:	b082      	sub	sp, #8
 8003932:	2300      	movs	r3, #0
 8003934:	9301      	str	r3, [sp, #4]
 8003936:	9b01      	ldr	r3, [sp, #4]
 8003938:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800393c:	b002      	add	sp, #8
 800393e:	4770      	bx	lr

08003940 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8003940:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003944:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8003946:	4618      	mov	r0, r3
 8003948:	4770      	bx	lr
 800394a:	bf00      	nop
 800394c:	0000      	movs	r0, r0
	...

08003950 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8003950:	b508      	push	{r3, lr}

  return stGetCounter();
 8003952:	f7ff fff5 	bl	8003940 <st_lld_get_counter>
 8003956:	4603      	mov	r3, r0
}
 8003958:	4618      	mov	r0, r3
 800395a:	bd08      	pop	{r3, pc}
 800395c:	0000      	movs	r0, r0
	...

08003960 <chSysLock.lto_priv.178>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8003960:	b508      	push	{r3, lr}

  port_lock();
 8003962:	f7ff ffdd 	bl	8003920 <port_lock>
  _stats_start_measure_crit_thd();
 8003966:	f006 fd6b 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800396a:	f008 fa19 	bl	800bda0 <_dbg_check_lock>
}
 800396e:	bd08      	pop	{r3, pc}

08003970 <chSysUnlock.lto_priv.176>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003970:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8003972:	f008 fa2d 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8003976:	f006 fd6b 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800397a:	4b09      	ldr	r3, [pc, #36]	; (80039a0 <chSysUnlock.lto_priv.176+0x30>)
 800397c:	681b      	ldr	r3, [r3, #0]
 800397e:	4a08      	ldr	r2, [pc, #32]	; (80039a0 <chSysUnlock.lto_priv.176+0x30>)
 8003980:	4293      	cmp	r3, r2
 8003982:	d00a      	beq.n	800399a <chSysUnlock.lto_priv.176+0x2a>
 8003984:	4b06      	ldr	r3, [pc, #24]	; (80039a0 <chSysUnlock.lto_priv.176+0x30>)
 8003986:	699b      	ldr	r3, [r3, #24]
 8003988:	689a      	ldr	r2, [r3, #8]
 800398a:	4b05      	ldr	r3, [pc, #20]	; (80039a0 <chSysUnlock.lto_priv.176+0x30>)
 800398c:	681b      	ldr	r3, [r3, #0]
 800398e:	689b      	ldr	r3, [r3, #8]
 8003990:	429a      	cmp	r2, r3
 8003992:	d202      	bcs.n	800399a <chSysUnlock.lto_priv.176+0x2a>
 8003994:	4803      	ldr	r0, [pc, #12]	; (80039a4 <chSysUnlock.lto_priv.176+0x34>)
 8003996:	f008 f8ab 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800399a:	f7ff ffc9 	bl	8003930 <port_unlock>
}
 800399e:	bd08      	pop	{r3, pc}
 80039a0:	20000d30 	.word	0x20000d30
 80039a4:	0800e660 	.word	0x0800e660
	...

080039b0 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 80039b0:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 80039b2:	f7ff ffcd 	bl	8003950 <port_timer_get_time>
 80039b6:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80039b8:	4618      	mov	r0, r3
 80039ba:	bd08      	pop	{r3, pc}
 80039bc:	0000      	movs	r0, r0
	...

080039c0 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 80039c0:	b500      	push	{lr}
 80039c2:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 80039c4:	f7ff ffcc 	bl	8003960 <chSysLock.lto_priv.178>
  systime = chVTGetSystemTimeX();
 80039c8:	f7ff fff2 	bl	80039b0 <chVTGetSystemTimeX>
 80039cc:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 80039ce:	f7ff ffcf 	bl	8003970 <chSysUnlock.lto_priv.176>

  return systime;
 80039d2:	9b01      	ldr	r3, [sp, #4]
}
 80039d4:	4618      	mov	r0, r3
 80039d6:	b003      	add	sp, #12
 80039d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80039dc:	0000      	movs	r0, r0
	...

080039e0 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80039e0:	4b01      	ldr	r3, [pc, #4]	; (80039e8 <chThdGetSelfX+0x8>)
 80039e2:	699b      	ldr	r3, [r3, #24]
}
 80039e4:	4618      	mov	r0, r3
 80039e6:	4770      	bx	lr
 80039e8:	20000d30 	.word	0x20000d30
 80039ec:	00000000 	.word	0x00000000

080039f0 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 80039f0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 80039f2:	f7ff fff5 	bl	80039e0 <chThdGetSelfX>
 80039f6:	4603      	mov	r3, r0
 80039f8:	689b      	ldr	r3, [r3, #8]
}
 80039fa:	4618      	mov	r0, r3
 80039fc:	bd08      	pop	{r3, pc}
 80039fe:	bf00      	nop

08003a00 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8003a00:	b082      	sub	sp, #8
 8003a02:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 8003a04:	9b01      	ldr	r3, [sp, #4]
 8003a06:	9a01      	ldr	r2, [sp, #4]
 8003a08:	601a      	str	r2, [r3, #0]
}
 8003a0a:	b002      	add	sp, #8
 8003a0c:	4770      	bx	lr
 8003a0e:	bf00      	nop

08003a10 <chEvtRegisterMask>:
 *
 * @api
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {
 8003a10:	b500      	push	{lr}
 8003a12:	b085      	sub	sp, #20
 8003a14:	9003      	str	r0, [sp, #12]
 8003a16:	9102      	str	r1, [sp, #8]
 8003a18:	9201      	str	r2, [sp, #4]

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 8003a1a:	9803      	ldr	r0, [sp, #12]
 8003a1c:	9902      	ldr	r1, [sp, #8]
 8003a1e:	9a01      	ldr	r2, [sp, #4]
 8003a20:	f04f 33ff 	mov.w	r3, #4294967295
 8003a24:	f005 fbf4 	bl	8009210 <chEvtRegisterMaskWithFlags>
}
 8003a28:	b005      	add	sp, #20
 8003a2a:	f85d fb04 	ldr.w	pc, [sp], #4
 8003a2e:	bf00      	nop

08003a30 <chEvtIsListeningI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @return              The event source status.
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {
 8003a30:	b082      	sub	sp, #8
 8003a32:	9001      	str	r0, [sp, #4]

  return (bool)(esp != (event_source_t *)esp->es_next);
 8003a34:	9b01      	ldr	r3, [sp, #4]
 8003a36:	681a      	ldr	r2, [r3, #0]
 8003a38:	9b01      	ldr	r3, [sp, #4]
 8003a3a:	429a      	cmp	r2, r3
 8003a3c:	bf14      	ite	ne
 8003a3e:	2301      	movne	r3, #1
 8003a40:	2300      	moveq	r3, #0
 8003a42:	b2db      	uxtb	r3, r3
}
 8003a44:	4618      	mov	r0, r3
 8003a46:	b002      	add	sp, #8
 8003a48:	4770      	bx	lr
 8003a4a:	bf00      	nop
 8003a4c:	0000      	movs	r0, r0
	...

08003a50 <chEvtBroadcast>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @api
 */
static inline void chEvtBroadcast(event_source_t *esp) {
 8003a50:	b500      	push	{lr}
 8003a52:	b083      	sub	sp, #12
 8003a54:	9001      	str	r0, [sp, #4]

  chEvtBroadcastFlags(esp, (eventflags_t)0);
 8003a56:	9801      	ldr	r0, [sp, #4]
 8003a58:	2100      	movs	r1, #0
 8003a5a:	f005 fd09 	bl	8009470 <chEvtBroadcastFlags>
}
 8003a5e:	b003      	add	sp, #12
 8003a60:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003a70 <evt1_setup.lto_priv.72>:
 * the test expects no more listeners.<br>
 * In the second part the test dispatches three event flags and verifies that
 * the associated event handlers are invoked in LSb-first order.
 */

static void evt1_setup(void) {
 8003a70:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 8003a72:	f04f 30ff 	mov.w	r0, #4294967295
 8003a76:	f005 fc2b 	bl	80092d0 <chEvtGetAndClearEvents>
}
 8003a7a:	bd08      	pop	{r3, pc}
 8003a7c:	0000      	movs	r0, r0
	...

08003a80 <h1.lto_priv.74>:

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 8003a80:	b500      	push	{lr}
 8003a82:	b083      	sub	sp, #12
 8003a84:	9001      	str	r0, [sp, #4]
 8003a86:	2041      	movs	r0, #65	; 0x41
 8003a88:	f001 fe12 	bl	80056b0 <test_emit_token>
 8003a8c:	b003      	add	sp, #12
 8003a8e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003a92:	bf00      	nop
	...

08003aa0 <h2.lto_priv.75>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 8003aa0:	b500      	push	{lr}
 8003aa2:	b083      	sub	sp, #12
 8003aa4:	9001      	str	r0, [sp, #4]
 8003aa6:	2042      	movs	r0, #66	; 0x42
 8003aa8:	f001 fe02 	bl	80056b0 <test_emit_token>
 8003aac:	b003      	add	sp, #12
 8003aae:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ab2:	bf00      	nop
	...

08003ac0 <h3.lto_priv.76>:
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 8003ac0:	b500      	push	{lr}
 8003ac2:	b083      	sub	sp, #12
 8003ac4:	9001      	str	r0, [sp, #4]
 8003ac6:	2043      	movs	r0, #67	; 0x43
 8003ac8:	f001 fdf2 	bl	80056b0 <test_emit_token>
 8003acc:	b003      	add	sp, #12
 8003ace:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ad2:	bf00      	nop
	...

08003ae0 <evt1_execute.lto_priv.73>:
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static void evt1_execute(void) {
 8003ae0:	b500      	push	{lr}
 8003ae2:	b08b      	sub	sp, #44	; 0x2c
  event_listener_t el1, el2;

  /*
   * Testing chEvtRegisterMask() and chEvtUnregister().
   */
  chEvtObjectInit(&es1);
 8003ae4:	4828      	ldr	r0, [pc, #160]	; (8003b88 <evt1_execute.lto_priv.73+0xa8>)
 8003ae6:	f7ff ff8b 	bl	8003a00 <chEvtObjectInit>
  chEvtRegisterMask(&es1, &el1, 1);
 8003aea:	ab05      	add	r3, sp, #20
 8003aec:	4826      	ldr	r0, [pc, #152]	; (8003b88 <evt1_execute.lto_priv.73+0xa8>)
 8003aee:	4619      	mov	r1, r3
 8003af0:	2201      	movs	r2, #1
 8003af2:	f7ff ff8d 	bl	8003a10 <chEvtRegisterMask>
  chEvtRegisterMask(&es1, &el2, 2);
 8003af6:	466b      	mov	r3, sp
 8003af8:	4823      	ldr	r0, [pc, #140]	; (8003b88 <evt1_execute.lto_priv.73+0xa8>)
 8003afa:	4619      	mov	r1, r3
 8003afc:	2202      	movs	r2, #2
 8003afe:	f7ff ff87 	bl	8003a10 <chEvtRegisterMask>
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
 8003b02:	4821      	ldr	r0, [pc, #132]	; (8003b88 <evt1_execute.lto_priv.73+0xa8>)
 8003b04:	f7ff ff94 	bl	8003a30 <chEvtIsListeningI>
 8003b08:	4603      	mov	r3, r0
 8003b0a:	2001      	movs	r0, #1
 8003b0c:	4619      	mov	r1, r3
 8003b0e:	f001 fdff 	bl	8005710 <_test_assert>
 8003b12:	4603      	mov	r3, r0
 8003b14:	2b00      	cmp	r3, #0
 8003b16:	d134      	bne.n	8003b82 <evt1_execute.lto_priv.73+0xa2>
  chEvtUnregister(&es1, &el1);
 8003b18:	ab05      	add	r3, sp, #20
 8003b1a:	481b      	ldr	r0, [pc, #108]	; (8003b88 <evt1_execute.lto_priv.73+0xa8>)
 8003b1c:	4619      	mov	r1, r3
 8003b1e:	f005 fba7 	bl	8009270 <chEvtUnregister>
  test_assert(2, chEvtIsListeningI(&es1), "no listener");
 8003b22:	4819      	ldr	r0, [pc, #100]	; (8003b88 <evt1_execute.lto_priv.73+0xa8>)
 8003b24:	f7ff ff84 	bl	8003a30 <chEvtIsListeningI>
 8003b28:	4603      	mov	r3, r0
 8003b2a:	2002      	movs	r0, #2
 8003b2c:	4619      	mov	r1, r3
 8003b2e:	f001 fdef 	bl	8005710 <_test_assert>
 8003b32:	4603      	mov	r3, r0
 8003b34:	2b00      	cmp	r3, #0
 8003b36:	d124      	bne.n	8003b82 <evt1_execute.lto_priv.73+0xa2>
  chEvtUnregister(&es1, &el2);
 8003b38:	466b      	mov	r3, sp
 8003b3a:	4813      	ldr	r0, [pc, #76]	; (8003b88 <evt1_execute.lto_priv.73+0xa8>)
 8003b3c:	4619      	mov	r1, r3
 8003b3e:	f005 fb97 	bl	8009270 <chEvtUnregister>
  test_assert(3, !chEvtIsListeningI(&es1), "stuck listener");
 8003b42:	4811      	ldr	r0, [pc, #68]	; (8003b88 <evt1_execute.lto_priv.73+0xa8>)
 8003b44:	f7ff ff74 	bl	8003a30 <chEvtIsListeningI>
 8003b48:	4603      	mov	r3, r0
 8003b4a:	2b00      	cmp	r3, #0
 8003b4c:	bf14      	ite	ne
 8003b4e:	2301      	movne	r3, #1
 8003b50:	2300      	moveq	r3, #0
 8003b52:	b2db      	uxtb	r3, r3
 8003b54:	f083 0301 	eor.w	r3, r3, #1
 8003b58:	b2db      	uxtb	r3, r3
 8003b5a:	f003 0301 	and.w	r3, r3, #1
 8003b5e:	b2db      	uxtb	r3, r3
 8003b60:	2003      	movs	r0, #3
 8003b62:	4619      	mov	r1, r3
 8003b64:	f001 fdd4 	bl	8005710 <_test_assert>
 8003b68:	4603      	mov	r3, r0
 8003b6a:	2b00      	cmp	r3, #0
 8003b6c:	d109      	bne.n	8003b82 <evt1_execute.lto_priv.73+0xa2>

  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
 8003b6e:	4807      	ldr	r0, [pc, #28]	; (8003b8c <evt1_execute.lto_priv.73+0xac>)
 8003b70:	2107      	movs	r1, #7
 8003b72:	f005 fc95 	bl	80094a0 <chEvtDispatch>
  test_assert_sequence(4, "ABC");
 8003b76:	2004      	movs	r0, #4
 8003b78:	4905      	ldr	r1, [pc, #20]	; (8003b90 <evt1_execute.lto_priv.73+0xb0>)
 8003b7a:	f001 fde1 	bl	8005740 <_test_assert_sequence>
 8003b7e:	4603      	mov	r3, r0
 8003b80:	2b00      	cmp	r3, #0
}
 8003b82:	b00b      	add	sp, #44	; 0x2c
 8003b84:	f85d fb04 	ldr.w	pc, [sp], #4
 8003b88:	20000890 	.word	0x20000890
 8003b8c:	0800e610 	.word	0x0800e610
 8003b90:	0800d868 	.word	0x0800d868
	...

08003ba0 <evt2_setup.lto_priv.70>:
 * .
 * After each test phase the test verifies that the events have been served at
 * the expected time and that there are no stuck event flags.
 */

static void evt2_setup(void) {
 8003ba0:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 8003ba2:	f04f 30ff 	mov.w	r0, #4294967295
 8003ba6:	f005 fb93 	bl	80092d0 <chEvtGetAndClearEvents>
}
 8003baa:	bd08      	pop	{r3, pc}
 8003bac:	0000      	movs	r0, r0
	...

08003bb0 <thread1>:

static THD_FUNCTION(thread1, p) {
 8003bb0:	b500      	push	{lr}
 8003bb2:	b083      	sub	sp, #12
 8003bb4:	9001      	str	r0, [sp, #4]

  chThdSleepMilliseconds(50);
 8003bb6:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8003bba:	f009 f8b1 	bl	800cd20 <chThdSleep>
  chEvtSignal((thread_t *)p, 1);
 8003bbe:	9801      	ldr	r0, [sp, #4]
 8003bc0:	2101      	movs	r1, #1
 8003bc2:	f005 fbfd 	bl	80093c0 <chEvtSignal>
}
 8003bc6:	b003      	add	sp, #12
 8003bc8:	f85d fb04 	ldr.w	pc, [sp], #4
 8003bcc:	0000      	movs	r0, r0
	...

08003bd0 <thread2>:

static THD_FUNCTION(thread2, p) {
 8003bd0:	b500      	push	{lr}
 8003bd2:	b083      	sub	sp, #12
 8003bd4:	9001      	str	r0, [sp, #4]

  (void)p;
  chEvtBroadcast(&es1);
 8003bd6:	4806      	ldr	r0, [pc, #24]	; (8003bf0 <thread2+0x20>)
 8003bd8:	f7ff ff3a 	bl	8003a50 <chEvtBroadcast>
  chThdSleepMilliseconds(50);
 8003bdc:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8003be0:	f009 f89e 	bl	800cd20 <chThdSleep>
  chEvtBroadcast(&es2);
 8003be4:	4803      	ldr	r0, [pc, #12]	; (8003bf4 <thread2+0x24>)
 8003be6:	f7ff ff33 	bl	8003a50 <chEvtBroadcast>
}
 8003bea:	b003      	add	sp, #12
 8003bec:	f85d fb04 	ldr.w	pc, [sp], #4
 8003bf0:	20000890 	.word	0x20000890
 8003bf4:	20000894 	.word	0x20000894
	...

08003c00 <evt2_execute.lto_priv.71>:

static void evt2_execute(void) {
 8003c00:	b530      	push	{r4, r5, lr}
 8003c02:	b08f      	sub	sp, #60	; 0x3c
  systime_t target_time;

  /*
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
 8003c04:	2007      	movs	r0, #7
 8003c06:	f005 fb83 	bl	8009310 <chEvtAddEvents>
  m = chEvtWaitOne(ALL_EVENTS);
 8003c0a:	f04f 30ff 	mov.w	r0, #4294967295
 8003c0e:	f005 fc87 	bl	8009520 <chEvtWaitOne>
 8003c12:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(1, m == 1, "single event error");
 8003c14:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003c16:	2b01      	cmp	r3, #1
 8003c18:	bf0c      	ite	eq
 8003c1a:	2301      	moveq	r3, #1
 8003c1c:	2300      	movne	r3, #0
 8003c1e:	b2db      	uxtb	r3, r3
 8003c20:	2001      	movs	r0, #1
 8003c22:	4619      	mov	r1, r3
 8003c24:	f001 fd74 	bl	8005710 <_test_assert>
 8003c28:	4603      	mov	r3, r0
 8003c2a:	2b00      	cmp	r3, #0
 8003c2c:	f040 8182 	bne.w	8003f34 <evt2_execute.lto_priv.71+0x334>
  m = chEvtWaitOne(ALL_EVENTS);
 8003c30:	f04f 30ff 	mov.w	r0, #4294967295
 8003c34:	f005 fc74 	bl	8009520 <chEvtWaitOne>
 8003c38:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(2, m == 2, "single event error");
 8003c3a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003c3c:	2b02      	cmp	r3, #2
 8003c3e:	bf0c      	ite	eq
 8003c40:	2301      	moveq	r3, #1
 8003c42:	2300      	movne	r3, #0
 8003c44:	b2db      	uxtb	r3, r3
 8003c46:	2002      	movs	r0, #2
 8003c48:	4619      	mov	r1, r3
 8003c4a:	f001 fd61 	bl	8005710 <_test_assert>
 8003c4e:	4603      	mov	r3, r0
 8003c50:	2b00      	cmp	r3, #0
 8003c52:	f040 816f 	bne.w	8003f34 <evt2_execute.lto_priv.71+0x334>
  m = chEvtWaitOne(ALL_EVENTS);
 8003c56:	f04f 30ff 	mov.w	r0, #4294967295
 8003c5a:	f005 fc61 	bl	8009520 <chEvtWaitOne>
 8003c5e:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(3, m == 4, "single event error");
 8003c60:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003c62:	2b04      	cmp	r3, #4
 8003c64:	bf0c      	ite	eq
 8003c66:	2301      	moveq	r3, #1
 8003c68:	2300      	movne	r3, #0
 8003c6a:	b2db      	uxtb	r3, r3
 8003c6c:	2003      	movs	r0, #3
 8003c6e:	4619      	mov	r1, r3
 8003c70:	f001 fd4e 	bl	8005710 <_test_assert>
 8003c74:	4603      	mov	r3, r0
 8003c76:	2b00      	cmp	r3, #0
 8003c78:	f040 815c 	bne.w	8003f34 <evt2_execute.lto_priv.71+0x334>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8003c7c:	f04f 30ff 	mov.w	r0, #4294967295
 8003c80:	f005 fb26 	bl	80092d0 <chEvtGetAndClearEvents>
 8003c84:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(4, m == 0, "stuck event");
 8003c86:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003c88:	2b00      	cmp	r3, #0
 8003c8a:	bf0c      	ite	eq
 8003c8c:	2301      	moveq	r3, #1
 8003c8e:	2300      	movne	r3, #0
 8003c90:	b2db      	uxtb	r3, r3
 8003c92:	2004      	movs	r0, #4
 8003c94:	4619      	mov	r1, r3
 8003c96:	f001 fd3b 	bl	8005710 <_test_assert>
 8003c9a:	4603      	mov	r3, r0
 8003c9c:	2b00      	cmp	r3, #0
 8003c9e:	f040 8149 	bne.w	8003f34 <evt2_execute.lto_priv.71+0x334>

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
 8003ca2:	f001 fddd 	bl	8005860 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(50);
 8003ca6:	f7ff fe8b 	bl	80039c0 <chVTGetSystemTime>
 8003caa:	4603      	mov	r3, r0
 8003cac:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 8003cb0:	930c      	str	r3, [sp, #48]	; 0x30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8003cb2:	4ba1      	ldr	r3, [pc, #644]	; (8003f38 <evt2_execute.lto_priv.71+0x338>)
 8003cb4:	681d      	ldr	r5, [r3, #0]
 8003cb6:	f7ff fe9b 	bl	80039f0 <chThdGetPriorityX>
 8003cba:	4603      	mov	r3, r0
 8003cbc:	1e5c      	subs	r4, r3, #1
                                 thread1, chThdGetSelfX());
 8003cbe:	f7ff fe8f 	bl	80039e0 <chThdGetSelfX>
 8003cc2:	4603      	mov	r3, r0
  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8003cc4:	9300      	str	r3, [sp, #0]
 8003cc6:	4628      	mov	r0, r5
 8003cc8:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8003ccc:	4622      	mov	r2, r4
 8003cce:	4b9b      	ldr	r3, [pc, #620]	; (8003f3c <evt2_execute.lto_priv.71+0x33c>)
 8003cd0:	f008 ff96 	bl	800cc00 <chThdCreateStatic>
 8003cd4:	4602      	mov	r2, r0
 8003cd6:	4b9a      	ldr	r3, [pc, #616]	; (8003f40 <evt2_execute.lto_priv.71+0x340>)
 8003cd8:	601a      	str	r2, [r3, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
 8003cda:	f04f 30ff 	mov.w	r0, #4294967295
 8003cde:	f005 fc1f 	bl	8009520 <chEvtWaitOne>
 8003ce2:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
 8003ce4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8003ce6:	3332      	adds	r3, #50	; 0x32
 8003ce8:	2005      	movs	r0, #5
 8003cea:	990c      	ldr	r1, [sp, #48]	; 0x30
 8003cec:	461a      	mov	r2, r3
 8003cee:	f001 fd57 	bl	80057a0 <_test_assert_time_window>
 8003cf2:	4603      	mov	r3, r0
 8003cf4:	2b00      	cmp	r3, #0
 8003cf6:	f040 811d 	bne.w	8003f34 <evt2_execute.lto_priv.71+0x334>
  test_assert(6, m == 1, "single event error");
 8003cfa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003cfc:	2b01      	cmp	r3, #1
 8003cfe:	bf0c      	ite	eq
 8003d00:	2301      	moveq	r3, #1
 8003d02:	2300      	movne	r3, #0
 8003d04:	b2db      	uxtb	r3, r3
 8003d06:	2006      	movs	r0, #6
 8003d08:	4619      	mov	r1, r3
 8003d0a:	f001 fd01 	bl	8005710 <_test_assert>
 8003d0e:	4603      	mov	r3, r0
 8003d10:	2b00      	cmp	r3, #0
 8003d12:	f040 810f 	bne.w	8003f34 <evt2_execute.lto_priv.71+0x334>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8003d16:	f04f 30ff 	mov.w	r0, #4294967295
 8003d1a:	f005 fad9 	bl	80092d0 <chEvtGetAndClearEvents>
 8003d1e:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(7, m == 0, "stuck event");
 8003d20:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003d22:	2b00      	cmp	r3, #0
 8003d24:	bf0c      	ite	eq
 8003d26:	2301      	moveq	r3, #1
 8003d28:	2300      	movne	r3, #0
 8003d2a:	b2db      	uxtb	r3, r3
 8003d2c:	2007      	movs	r0, #7
 8003d2e:	4619      	mov	r1, r3
 8003d30:	f001 fcee 	bl	8005710 <_test_assert>
 8003d34:	4603      	mov	r3, r0
 8003d36:	2b00      	cmp	r3, #0
 8003d38:	f040 80fc 	bne.w	8003f34 <evt2_execute.lto_priv.71+0x334>
  test_wait_threads();
 8003d3c:	f001 fd68 	bl	8005810 <test_wait_threads>

  /*
   * Test on chEvtWaitAny() without wait.
   */
  chEvtAddEvents(5);
 8003d40:	2005      	movs	r0, #5
 8003d42:	f005 fae5 	bl	8009310 <chEvtAddEvents>
  m = chEvtWaitAny(ALL_EVENTS);
 8003d46:	f04f 30ff 	mov.w	r0, #4294967295
 8003d4a:	f005 fc19 	bl	8009580 <chEvtWaitAny>
 8003d4e:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(8, m == 5, "unexpected pending bit");
 8003d50:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003d52:	2b05      	cmp	r3, #5
 8003d54:	bf0c      	ite	eq
 8003d56:	2301      	moveq	r3, #1
 8003d58:	2300      	movne	r3, #0
 8003d5a:	b2db      	uxtb	r3, r3
 8003d5c:	2008      	movs	r0, #8
 8003d5e:	4619      	mov	r1, r3
 8003d60:	f001 fcd6 	bl	8005710 <_test_assert>
 8003d64:	4603      	mov	r3, r0
 8003d66:	2b00      	cmp	r3, #0
 8003d68:	f040 80e4 	bne.w	8003f34 <evt2_execute.lto_priv.71+0x334>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8003d6c:	f04f 30ff 	mov.w	r0, #4294967295
 8003d70:	f005 faae 	bl	80092d0 <chEvtGetAndClearEvents>
 8003d74:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(9, m == 0, "stuck event");
 8003d76:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003d78:	2b00      	cmp	r3, #0
 8003d7a:	bf0c      	ite	eq
 8003d7c:	2301      	moveq	r3, #1
 8003d7e:	2300      	movne	r3, #0
 8003d80:	b2db      	uxtb	r3, r3
 8003d82:	2009      	movs	r0, #9
 8003d84:	4619      	mov	r1, r3
 8003d86:	f001 fcc3 	bl	8005710 <_test_assert>
 8003d8a:	4603      	mov	r3, r0
 8003d8c:	2b00      	cmp	r3, #0
 8003d8e:	f040 80d1 	bne.w	8003f34 <evt2_execute.lto_priv.71+0x334>

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
 8003d92:	f001 fd65 	bl	8005860 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(50);
 8003d96:	f7ff fe13 	bl	80039c0 <chVTGetSystemTime>
 8003d9a:	4603      	mov	r3, r0
 8003d9c:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 8003da0:	930c      	str	r3, [sp, #48]	; 0x30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8003da2:	4b65      	ldr	r3, [pc, #404]	; (8003f38 <evt2_execute.lto_priv.71+0x338>)
 8003da4:	681d      	ldr	r5, [r3, #0]
 8003da6:	f7ff fe23 	bl	80039f0 <chThdGetPriorityX>
 8003daa:	4603      	mov	r3, r0
 8003dac:	1e5c      	subs	r4, r3, #1
                                 thread1, chThdGetSelfX());
 8003dae:	f7ff fe17 	bl	80039e0 <chThdGetSelfX>
 8003db2:	4603      	mov	r3, r0
  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8003db4:	9300      	str	r3, [sp, #0]
 8003db6:	4628      	mov	r0, r5
 8003db8:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8003dbc:	4622      	mov	r2, r4
 8003dbe:	4b5f      	ldr	r3, [pc, #380]	; (8003f3c <evt2_execute.lto_priv.71+0x33c>)
 8003dc0:	f008 ff1e 	bl	800cc00 <chThdCreateStatic>
 8003dc4:	4602      	mov	r2, r0
 8003dc6:	4b5e      	ldr	r3, [pc, #376]	; (8003f40 <evt2_execute.lto_priv.71+0x340>)
 8003dc8:	601a      	str	r2, [r3, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
 8003dca:	f04f 30ff 	mov.w	r0, #4294967295
 8003dce:	f005 fbd7 	bl	8009580 <chEvtWaitAny>
 8003dd2:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 8003dd4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8003dd6:	3332      	adds	r3, #50	; 0x32
 8003dd8:	200a      	movs	r0, #10
 8003dda:	990c      	ldr	r1, [sp, #48]	; 0x30
 8003ddc:	461a      	mov	r2, r3
 8003dde:	f001 fcdf 	bl	80057a0 <_test_assert_time_window>
 8003de2:	4603      	mov	r3, r0
 8003de4:	2b00      	cmp	r3, #0
 8003de6:	f040 80a5 	bne.w	8003f34 <evt2_execute.lto_priv.71+0x334>
  test_assert(11, m == 1, "single event error");
 8003dea:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003dec:	2b01      	cmp	r3, #1
 8003dee:	bf0c      	ite	eq
 8003df0:	2301      	moveq	r3, #1
 8003df2:	2300      	movne	r3, #0
 8003df4:	b2db      	uxtb	r3, r3
 8003df6:	200b      	movs	r0, #11
 8003df8:	4619      	mov	r1, r3
 8003dfa:	f001 fc89 	bl	8005710 <_test_assert>
 8003dfe:	4603      	mov	r3, r0
 8003e00:	2b00      	cmp	r3, #0
 8003e02:	f040 8097 	bne.w	8003f34 <evt2_execute.lto_priv.71+0x334>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8003e06:	f04f 30ff 	mov.w	r0, #4294967295
 8003e0a:	f005 fa61 	bl	80092d0 <chEvtGetAndClearEvents>
 8003e0e:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(12, m == 0, "stuck event");
 8003e10:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003e12:	2b00      	cmp	r3, #0
 8003e14:	bf0c      	ite	eq
 8003e16:	2301      	moveq	r3, #1
 8003e18:	2300      	movne	r3, #0
 8003e1a:	b2db      	uxtb	r3, r3
 8003e1c:	200c      	movs	r0, #12
 8003e1e:	4619      	mov	r1, r3
 8003e20:	f001 fc76 	bl	8005710 <_test_assert>
 8003e24:	4603      	mov	r3, r0
 8003e26:	2b00      	cmp	r3, #0
 8003e28:	f040 8084 	bne.w	8003f34 <evt2_execute.lto_priv.71+0x334>
  test_wait_threads();
 8003e2c:	f001 fcf0 	bl	8005810 <test_wait_threads>

  /*
   * Test on chEvtWaitAll().
   */
  chEvtObjectInit(&es1);
 8003e30:	4844      	ldr	r0, [pc, #272]	; (8003f44 <evt2_execute.lto_priv.71+0x344>)
 8003e32:	f7ff fde5 	bl	8003a00 <chEvtObjectInit>
  chEvtObjectInit(&es2);
 8003e36:	4844      	ldr	r0, [pc, #272]	; (8003f48 <evt2_execute.lto_priv.71+0x348>)
 8003e38:	f7ff fde2 	bl	8003a00 <chEvtObjectInit>
  chEvtRegisterMask(&es1, &el1, 1);
 8003e3c:	ab07      	add	r3, sp, #28
 8003e3e:	4841      	ldr	r0, [pc, #260]	; (8003f44 <evt2_execute.lto_priv.71+0x344>)
 8003e40:	4619      	mov	r1, r3
 8003e42:	2201      	movs	r2, #1
 8003e44:	f7ff fde4 	bl	8003a10 <chEvtRegisterMask>
  chEvtRegisterMask(&es2, &el2, 4);
 8003e48:	ab02      	add	r3, sp, #8
 8003e4a:	483f      	ldr	r0, [pc, #252]	; (8003f48 <evt2_execute.lto_priv.71+0x348>)
 8003e4c:	4619      	mov	r1, r3
 8003e4e:	2204      	movs	r2, #4
 8003e50:	f7ff fdde 	bl	8003a10 <chEvtRegisterMask>
  test_wait_tick();
 8003e54:	f001 fd04 	bl	8005860 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(50);
 8003e58:	f7ff fdb2 	bl	80039c0 <chVTGetSystemTime>
 8003e5c:	4603      	mov	r3, r0
 8003e5e:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 8003e62:	930c      	str	r3, [sp, #48]	; 0x30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8003e64:	4b34      	ldr	r3, [pc, #208]	; (8003f38 <evt2_execute.lto_priv.71+0x338>)
 8003e66:	681c      	ldr	r4, [r3, #0]
 8003e68:	f7ff fdc2 	bl	80039f0 <chThdGetPriorityX>
 8003e6c:	4603      	mov	r3, r0
 8003e6e:	1e5a      	subs	r2, r3, #1
 8003e70:	4b36      	ldr	r3, [pc, #216]	; (8003f4c <evt2_execute.lto_priv.71+0x34c>)
 8003e72:	9300      	str	r3, [sp, #0]
 8003e74:	4620      	mov	r0, r4
 8003e76:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8003e7a:	4b35      	ldr	r3, [pc, #212]	; (8003f50 <evt2_execute.lto_priv.71+0x350>)
 8003e7c:	f008 fec0 	bl	800cc00 <chThdCreateStatic>
 8003e80:	4602      	mov	r2, r0
 8003e82:	4b2f      	ldr	r3, [pc, #188]	; (8003f40 <evt2_execute.lto_priv.71+0x340>)
 8003e84:	601a      	str	r2, [r3, #0]
                                 thread2, "A");
  m = chEvtWaitAll(5);
 8003e86:	2005      	movs	r0, #5
 8003e88:	f005 fbaa 	bl	80095e0 <chEvtWaitAll>
 8003e8c:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert_time_window(13, target_time, target_time + ALLOWED_DELAY);
 8003e8e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8003e90:	3332      	adds	r3, #50	; 0x32
 8003e92:	200d      	movs	r0, #13
 8003e94:	990c      	ldr	r1, [sp, #48]	; 0x30
 8003e96:	461a      	mov	r2, r3
 8003e98:	f001 fc82 	bl	80057a0 <_test_assert_time_window>
 8003e9c:	4603      	mov	r3, r0
 8003e9e:	2b00      	cmp	r3, #0
 8003ea0:	d148      	bne.n	8003f34 <evt2_execute.lto_priv.71+0x334>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8003ea2:	f04f 30ff 	mov.w	r0, #4294967295
 8003ea6:	f005 fa13 	bl	80092d0 <chEvtGetAndClearEvents>
 8003eaa:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(14, m == 0, "stuck event");
 8003eac:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8003eae:	2b00      	cmp	r3, #0
 8003eb0:	bf0c      	ite	eq
 8003eb2:	2301      	moveq	r3, #1
 8003eb4:	2300      	movne	r3, #0
 8003eb6:	b2db      	uxtb	r3, r3
 8003eb8:	200e      	movs	r0, #14
 8003eba:	4619      	mov	r1, r3
 8003ebc:	f001 fc28 	bl	8005710 <_test_assert>
 8003ec0:	4603      	mov	r3, r0
 8003ec2:	2b00      	cmp	r3, #0
 8003ec4:	d136      	bne.n	8003f34 <evt2_execute.lto_priv.71+0x334>
  test_wait_threads();
 8003ec6:	f001 fca3 	bl	8005810 <test_wait_threads>
  chEvtUnregister(&es1, &el1);
 8003eca:	ab07      	add	r3, sp, #28
 8003ecc:	481d      	ldr	r0, [pc, #116]	; (8003f44 <evt2_execute.lto_priv.71+0x344>)
 8003ece:	4619      	mov	r1, r3
 8003ed0:	f005 f9ce 	bl	8009270 <chEvtUnregister>
  chEvtUnregister(&es2, &el2);
 8003ed4:	ab02      	add	r3, sp, #8
 8003ed6:	481c      	ldr	r0, [pc, #112]	; (8003f48 <evt2_execute.lto_priv.71+0x348>)
 8003ed8:	4619      	mov	r1, r3
 8003eda:	f005 f9c9 	bl	8009270 <chEvtUnregister>
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
 8003ede:	4819      	ldr	r0, [pc, #100]	; (8003f44 <evt2_execute.lto_priv.71+0x344>)
 8003ee0:	f7ff fda6 	bl	8003a30 <chEvtIsListeningI>
 8003ee4:	4603      	mov	r3, r0
 8003ee6:	2b00      	cmp	r3, #0
 8003ee8:	bf14      	ite	ne
 8003eea:	2301      	movne	r3, #1
 8003eec:	2300      	moveq	r3, #0
 8003eee:	b2db      	uxtb	r3, r3
 8003ef0:	f083 0301 	eor.w	r3, r3, #1
 8003ef4:	b2db      	uxtb	r3, r3
 8003ef6:	f003 0301 	and.w	r3, r3, #1
 8003efa:	b2db      	uxtb	r3, r3
 8003efc:	200f      	movs	r0, #15
 8003efe:	4619      	mov	r1, r3
 8003f00:	f001 fc06 	bl	8005710 <_test_assert>
 8003f04:	4603      	mov	r3, r0
 8003f06:	2b00      	cmp	r3, #0
 8003f08:	d114      	bne.n	8003f34 <evt2_execute.lto_priv.71+0x334>
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
 8003f0a:	480f      	ldr	r0, [pc, #60]	; (8003f48 <evt2_execute.lto_priv.71+0x348>)
 8003f0c:	f7ff fd90 	bl	8003a30 <chEvtIsListeningI>
 8003f10:	4603      	mov	r3, r0
 8003f12:	2b00      	cmp	r3, #0
 8003f14:	bf14      	ite	ne
 8003f16:	2301      	movne	r3, #1
 8003f18:	2300      	moveq	r3, #0
 8003f1a:	b2db      	uxtb	r3, r3
 8003f1c:	f083 0301 	eor.w	r3, r3, #1
 8003f20:	b2db      	uxtb	r3, r3
 8003f22:	f003 0301 	and.w	r3, r3, #1
 8003f26:	b2db      	uxtb	r3, r3
 8003f28:	2010      	movs	r0, #16
 8003f2a:	4619      	mov	r1, r3
 8003f2c:	f001 fbf0 	bl	8005710 <_test_assert>
 8003f30:	4603      	mov	r3, r0
 8003f32:	2b00      	cmp	r3, #0
}
 8003f34:	b00f      	add	sp, #60	; 0x3c
 8003f36:	bd30      	pop	{r4, r5, pc}
 8003f38:	0800e420 	.word	0x0800e420
 8003f3c:	08003bb1 	.word	0x08003bb1
 8003f40:	20001bf8 	.word	0x20001bf8
 8003f44:	20000890 	.word	0x20000890
 8003f48:	20000894 	.word	0x20000894
 8003f4c:	0800d86c 	.word	0x0800d86c
 8003f50:	08003bd1 	.word	0x08003bd1
	...

08003f60 <sem1_execute.lto_priv.98>:

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static void sem1_execute(void) {
 8003f60:	b510      	push	{r4, lr}
 8003f62:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8003f64:	4b51      	ldr	r3, [pc, #324]	; (80040ac <sem1_execute.lto_priv.98+0x14c>)
 8003f66:	681c      	ldr	r4, [r3, #0]
 8003f68:	f002 f95a 	bl	8006220 <chThdGetPriorityX.lto_priv.188>
 8003f6c:	4603      	mov	r3, r0
 8003f6e:	1d5a      	adds	r2, r3, #5
 8003f70:	4b4f      	ldr	r3, [pc, #316]	; (80040b0 <sem1_execute.lto_priv.98+0x150>)
 8003f72:	9300      	str	r3, [sp, #0]
 8003f74:	4620      	mov	r0, r4
 8003f76:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8003f7a:	4b4e      	ldr	r3, [pc, #312]	; (80040b4 <sem1_execute.lto_priv.98+0x154>)
 8003f7c:	f008 fe40 	bl	800cc00 <chThdCreateStatic>
 8003f80:	4602      	mov	r2, r0
 8003f82:	4b4d      	ldr	r3, [pc, #308]	; (80040b8 <sem1_execute.lto_priv.98+0x158>)
 8003f84:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8003f86:	4b49      	ldr	r3, [pc, #292]	; (80040ac <sem1_execute.lto_priv.98+0x14c>)
 8003f88:	685c      	ldr	r4, [r3, #4]
 8003f8a:	f002 f949 	bl	8006220 <chThdGetPriorityX.lto_priv.188>
 8003f8e:	4603      	mov	r3, r0
 8003f90:	1c5a      	adds	r2, r3, #1
 8003f92:	4b4a      	ldr	r3, [pc, #296]	; (80040bc <sem1_execute.lto_priv.98+0x15c>)
 8003f94:	9300      	str	r3, [sp, #0]
 8003f96:	4620      	mov	r0, r4
 8003f98:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8003f9c:	4b45      	ldr	r3, [pc, #276]	; (80040b4 <sem1_execute.lto_priv.98+0x154>)
 8003f9e:	f008 fe2f 	bl	800cc00 <chThdCreateStatic>
 8003fa2:	4602      	mov	r2, r0
 8003fa4:	4b44      	ldr	r3, [pc, #272]	; (80040b8 <sem1_execute.lto_priv.98+0x158>)
 8003fa6:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8003fa8:	4b40      	ldr	r3, [pc, #256]	; (80040ac <sem1_execute.lto_priv.98+0x14c>)
 8003faa:	689c      	ldr	r4, [r3, #8]
 8003fac:	f002 f938 	bl	8006220 <chThdGetPriorityX.lto_priv.188>
 8003fb0:	4603      	mov	r3, r0
 8003fb2:	1cda      	adds	r2, r3, #3
 8003fb4:	4b42      	ldr	r3, [pc, #264]	; (80040c0 <sem1_execute.lto_priv.98+0x160>)
 8003fb6:	9300      	str	r3, [sp, #0]
 8003fb8:	4620      	mov	r0, r4
 8003fba:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8003fbe:	4b3d      	ldr	r3, [pc, #244]	; (80040b4 <sem1_execute.lto_priv.98+0x154>)
 8003fc0:	f008 fe1e 	bl	800cc00 <chThdCreateStatic>
 8003fc4:	4602      	mov	r2, r0
 8003fc6:	4b3c      	ldr	r3, [pc, #240]	; (80040b8 <sem1_execute.lto_priv.98+0x158>)
 8003fc8:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8003fca:	4b38      	ldr	r3, [pc, #224]	; (80040ac <sem1_execute.lto_priv.98+0x14c>)
 8003fcc:	68dc      	ldr	r4, [r3, #12]
 8003fce:	f002 f927 	bl	8006220 <chThdGetPriorityX.lto_priv.188>
 8003fd2:	4603      	mov	r3, r0
 8003fd4:	1d1a      	adds	r2, r3, #4
 8003fd6:	4b3b      	ldr	r3, [pc, #236]	; (80040c4 <sem1_execute.lto_priv.98+0x164>)
 8003fd8:	9300      	str	r3, [sp, #0]
 8003fda:	4620      	mov	r0, r4
 8003fdc:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8003fe0:	4b34      	ldr	r3, [pc, #208]	; (80040b4 <sem1_execute.lto_priv.98+0x154>)
 8003fe2:	f008 fe0d 	bl	800cc00 <chThdCreateStatic>
 8003fe6:	4602      	mov	r2, r0
 8003fe8:	4b33      	ldr	r3, [pc, #204]	; (80040b8 <sem1_execute.lto_priv.98+0x158>)
 8003fea:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8003fec:	4b2f      	ldr	r3, [pc, #188]	; (80040ac <sem1_execute.lto_priv.98+0x14c>)
 8003fee:	691c      	ldr	r4, [r3, #16]
 8003ff0:	f002 f916 	bl	8006220 <chThdGetPriorityX.lto_priv.188>
 8003ff4:	4603      	mov	r3, r0
 8003ff6:	1c9a      	adds	r2, r3, #2
 8003ff8:	4b33      	ldr	r3, [pc, #204]	; (80040c8 <sem1_execute.lto_priv.98+0x168>)
 8003ffa:	9300      	str	r3, [sp, #0]
 8003ffc:	4620      	mov	r0, r4
 8003ffe:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004002:	4b2c      	ldr	r3, [pc, #176]	; (80040b4 <sem1_execute.lto_priv.98+0x154>)
 8004004:	f008 fdfc 	bl	800cc00 <chThdCreateStatic>
 8004008:	4602      	mov	r2, r0
 800400a:	4b2b      	ldr	r3, [pc, #172]	; (80040b8 <sem1_execute.lto_priv.98+0x158>)
 800400c:	611a      	str	r2, [r3, #16]
  chSemSignal(&sem1);
 800400e:	482f      	ldr	r0, [pc, #188]	; (80040cc <sem1_execute.lto_priv.98+0x16c>)
 8004010:	f006 fe06 	bl	800ac20 <chSemSignal>
  chSemSignal(&sem1);
 8004014:	482d      	ldr	r0, [pc, #180]	; (80040cc <sem1_execute.lto_priv.98+0x16c>)
 8004016:	f006 fe03 	bl	800ac20 <chSemSignal>
  chSemSignal(&sem1);
 800401a:	482c      	ldr	r0, [pc, #176]	; (80040cc <sem1_execute.lto_priv.98+0x16c>)
 800401c:	f006 fe00 	bl	800ac20 <chSemSignal>
  chSemSignal(&sem1);
 8004020:	482a      	ldr	r0, [pc, #168]	; (80040cc <sem1_execute.lto_priv.98+0x16c>)
 8004022:	f006 fdfd 	bl	800ac20 <chSemSignal>
  chSemSignal(&sem1);
 8004026:	4829      	ldr	r0, [pc, #164]	; (80040cc <sem1_execute.lto_priv.98+0x16c>)
 8004028:	f006 fdfa 	bl	800ac20 <chSemSignal>
  test_wait_threads();
 800402c:	f001 fbf0 	bl	8005810 <test_wait_threads>
#if CH_CFG_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
 8004030:	2001      	movs	r0, #1
 8004032:	4927      	ldr	r1, [pc, #156]	; (80040d0 <sem1_execute.lto_priv.98+0x170>)
 8004034:	f001 fb84 	bl	8005740 <_test_assert_sequence>
 8004038:	4603      	mov	r3, r0
 800403a:	2b00      	cmp	r3, #0
 800403c:	d133      	bne.n	80040a6 <sem1_execute.lto_priv.98+0x146>
#endif
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 800403e:	4b1b      	ldr	r3, [pc, #108]	; (80040ac <sem1_execute.lto_priv.98+0x14c>)
 8004040:	681c      	ldr	r4, [r3, #0]
 8004042:	f002 f8ed 	bl	8006220 <chThdGetPriorityX.lto_priv.188>
 8004046:	4603      	mov	r3, r0
 8004048:	1d5a      	adds	r2, r3, #5
 800404a:	4b19      	ldr	r3, [pc, #100]	; (80040b0 <sem1_execute.lto_priv.98+0x150>)
 800404c:	9300      	str	r3, [sp, #0]
 800404e:	4620      	mov	r0, r4
 8004050:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004054:	4b17      	ldr	r3, [pc, #92]	; (80040b4 <sem1_execute.lto_priv.98+0x154>)
 8004056:	f008 fdd3 	bl	800cc00 <chThdCreateStatic>
 800405a:	4602      	mov	r2, r0
 800405c:	4b16      	ldr	r3, [pc, #88]	; (80040b8 <sem1_execute.lto_priv.98+0x158>)
 800405e:	601a      	str	r2, [r3, #0]
  chSysLock();
 8004060:	f002 f896 	bl	8006190 <chSysLock.lto_priv.200>
  chSemAddCounterI(&sem1, 2);
 8004064:	4819      	ldr	r0, [pc, #100]	; (80040cc <sem1_execute.lto_priv.98+0x16c>)
 8004066:	2102      	movs	r1, #2
 8004068:	f006 fe6a 	bl	800ad40 <chSemAddCounterI>
  chSchRescheduleS();
 800406c:	f008 fb10 	bl	800c690 <chSchRescheduleS>
  chSysUnlock();
 8004070:	f002 f896 	bl	80061a0 <chSysUnlock.lto_priv.198>
  test_wait_threads();
 8004074:	f001 fbcc 	bl	8005810 <test_wait_threads>
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
 8004078:	f002 f88a 	bl	8006190 <chSysLock.lto_priv.200>
 800407c:	4813      	ldr	r0, [pc, #76]	; (80040cc <sem1_execute.lto_priv.98+0x16c>)
 800407e:	f002 f8d7 	bl	8006230 <chSemGetCounterI.lto_priv.182>
 8004082:	4603      	mov	r3, r0
 8004084:	2b01      	cmp	r3, #1
 8004086:	bf0c      	ite	eq
 8004088:	2301      	moveq	r3, #1
 800408a:	2300      	movne	r3, #0
 800408c:	b2db      	uxtb	r3, r3
 800408e:	2002      	movs	r0, #2
 8004090:	4619      	mov	r1, r3
 8004092:	f001 fb3d 	bl	8005710 <_test_assert>
 8004096:	4603      	mov	r3, r0
 8004098:	2b00      	cmp	r3, #0
 800409a:	d002      	beq.n	80040a2 <sem1_execute.lto_priv.98+0x142>
 800409c:	f002 f880 	bl	80061a0 <chSysUnlock.lto_priv.198>
 80040a0:	e001      	b.n	80040a6 <sem1_execute.lto_priv.98+0x146>
 80040a2:	f002 f87d 	bl	80061a0 <chSysUnlock.lto_priv.198>
}
 80040a6:	b002      	add	sp, #8
 80040a8:	bd10      	pop	{r4, pc}
 80040aa:	bf00      	nop
 80040ac:	0800e420 	.word	0x0800e420
 80040b0:	0800d870 	.word	0x0800d870
 80040b4:	08006341 	.word	0x08006341
 80040b8:	20001bf8 	.word	0x20001bf8
 80040bc:	0800d874 	.word	0x0800d874
 80040c0:	0800d878 	.word	0x0800d878
 80040c4:	0800d87c 	.word	0x0800d87c
 80040c8:	0800d880 	.word	0x0800d880
 80040cc:	20000834 	.word	0x20000834
 80040d0:	0800d884 	.word	0x0800d884
	...

080040e0 <sem2_setup.lto_priv.95>:
 * The test expects that the semaphore wait function returns the correct value
 * in each of the above scenario and that the semaphore structure status is
 * correct after each operation.
 */

static void sem2_setup(void) {
 80040e0:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 80040e2:	4802      	ldr	r0, [pc, #8]	; (80040ec <sem2_setup.lto_priv.95+0xc>)
 80040e4:	2100      	movs	r1, #0
 80040e6:	f006 fc3b 	bl	800a960 <chSemObjectInit>
}
 80040ea:	bd08      	pop	{r3, pc}
 80040ec:	20000834 	.word	0x20000834

080040f0 <thread2>:

static THD_FUNCTION(thread2, p) {
 80040f0:	b500      	push	{lr}
 80040f2:	b083      	sub	sp, #12
 80040f4:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(50);
 80040f6:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80040fa:	f008 fe11 	bl	800cd20 <chThdSleep>
  chSysLock();
 80040fe:	f002 f847 	bl	8006190 <chSysLock.lto_priv.200>
  chSemSignalI(&sem1); /* For coverage reasons */
 8004102:	4805      	ldr	r0, [pc, #20]	; (8004118 <thread2+0x28>)
 8004104:	f006 fdd4 	bl	800acb0 <chSemSignalI>
  chSchRescheduleS();
 8004108:	f008 fac2 	bl	800c690 <chSchRescheduleS>
  chSysUnlock();
 800410c:	f002 f848 	bl	80061a0 <chSysUnlock.lto_priv.198>
}
 8004110:	b003      	add	sp, #12
 8004112:	f85d fb04 	ldr.w	pc, [sp], #4
 8004116:	bf00      	nop
 8004118:	20000834 	.word	0x20000834
 800411c:	00000000 	.word	0x00000000

08004120 <sem2_execute.lto_priv.96>:

static void sem2_execute(void) {
 8004120:	b510      	push	{r4, lr}
 8004122:	b086      	sub	sp, #24
  msg_t msg;

  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
 8004124:	4861      	ldr	r0, [pc, #388]	; (80042ac <sem2_execute.lto_priv.96+0x18c>)
 8004126:	2100      	movs	r1, #0
 8004128:	f006 fd02 	bl	800ab30 <chSemWaitTimeout>
 800412c:	9004      	str	r0, [sp, #16]
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
 800412e:	9b04      	ldr	r3, [sp, #16]
 8004130:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004134:	bf0c      	ite	eq
 8004136:	2301      	moveq	r3, #1
 8004138:	2300      	movne	r3, #0
 800413a:	b2db      	uxtb	r3, r3
 800413c:	2001      	movs	r0, #1
 800413e:	4619      	mov	r1, r3
 8004140:	f001 fae6 	bl	8005710 <_test_assert>
 8004144:	4603      	mov	r3, r0
 8004146:	2b00      	cmp	r3, #0
 8004148:	f040 80ad 	bne.w	80042a6 <sem2_execute.lto_priv.96+0x186>
  test_assert(2, queue_isempty(&sem1.s_queue), "queue not empty");
 800414c:	4857      	ldr	r0, [pc, #348]	; (80042ac <sem2_execute.lto_priv.96+0x18c>)
 800414e:	f002 f80f 	bl	8006170 <queue_isempty.lto_priv.202>
 8004152:	4603      	mov	r3, r0
 8004154:	2002      	movs	r0, #2
 8004156:	4619      	mov	r1, r3
 8004158:	f001 fada 	bl	8005710 <_test_assert>
 800415c:	4603      	mov	r3, r0
 800415e:	2b00      	cmp	r3, #0
 8004160:	f040 80a1 	bne.w	80042a6 <sem2_execute.lto_priv.96+0x186>
  test_assert(3, sem1.s_cnt == 0, "counter not zero");
 8004164:	4b51      	ldr	r3, [pc, #324]	; (80042ac <sem2_execute.lto_priv.96+0x18c>)
 8004166:	689b      	ldr	r3, [r3, #8]
 8004168:	2b00      	cmp	r3, #0
 800416a:	bf0c      	ite	eq
 800416c:	2301      	moveq	r3, #1
 800416e:	2300      	movne	r3, #0
 8004170:	b2db      	uxtb	r3, r3
 8004172:	2003      	movs	r0, #3
 8004174:	4619      	mov	r1, r3
 8004176:	f001 facb 	bl	8005710 <_test_assert>
 800417a:	4603      	mov	r3, r0
 800417c:	2b00      	cmp	r3, #0
 800417e:	f040 8092 	bne.w	80042a6 <sem2_execute.lto_priv.96+0x186>

  /*
   * Testing not timeout condition.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8004182:	4b4b      	ldr	r3, [pc, #300]	; (80042b0 <sem2_execute.lto_priv.96+0x190>)
 8004184:	681c      	ldr	r4, [r3, #0]
 8004186:	f002 f84b 	bl	8006220 <chThdGetPriorityX.lto_priv.188>
 800418a:	4603      	mov	r3, r0
 800418c:	1e5a      	subs	r2, r3, #1
 800418e:	2300      	movs	r3, #0
 8004190:	9300      	str	r3, [sp, #0]
 8004192:	4620      	mov	r0, r4
 8004194:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004198:	4b46      	ldr	r3, [pc, #280]	; (80042b4 <sem2_execute.lto_priv.96+0x194>)
 800419a:	f008 fd31 	bl	800cc00 <chThdCreateStatic>
 800419e:	4602      	mov	r2, r0
 80041a0:	4b45      	ldr	r3, [pc, #276]	; (80042b8 <sem2_execute.lto_priv.96+0x198>)
 80041a2:	601a      	str	r2, [r3, #0]
                                 thread2, 0);
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
 80041a4:	4841      	ldr	r0, [pc, #260]	; (80042ac <sem2_execute.lto_priv.96+0x18c>)
 80041a6:	f241 3188 	movw	r1, #5000	; 0x1388
 80041aa:	f006 fcc1 	bl	800ab30 <chSemWaitTimeout>
 80041ae:	9004      	str	r0, [sp, #16]
  test_wait_threads();
 80041b0:	f001 fb2e 	bl	8005810 <test_wait_threads>
  test_assert(4, msg == MSG_OK, "wrong wake-up message");
 80041b4:	9b04      	ldr	r3, [sp, #16]
 80041b6:	2b00      	cmp	r3, #0
 80041b8:	bf0c      	ite	eq
 80041ba:	2301      	moveq	r3, #1
 80041bc:	2300      	movne	r3, #0
 80041be:	b2db      	uxtb	r3, r3
 80041c0:	2004      	movs	r0, #4
 80041c2:	4619      	mov	r1, r3
 80041c4:	f001 faa4 	bl	8005710 <_test_assert>
 80041c8:	4603      	mov	r3, r0
 80041ca:	2b00      	cmp	r3, #0
 80041cc:	d16b      	bne.n	80042a6 <sem2_execute.lto_priv.96+0x186>
  test_assert(5, queue_isempty(&sem1.s_queue), "queue not empty");
 80041ce:	4837      	ldr	r0, [pc, #220]	; (80042ac <sem2_execute.lto_priv.96+0x18c>)
 80041d0:	f001 ffce 	bl	8006170 <queue_isempty.lto_priv.202>
 80041d4:	4603      	mov	r3, r0
 80041d6:	2005      	movs	r0, #5
 80041d8:	4619      	mov	r1, r3
 80041da:	f001 fa99 	bl	8005710 <_test_assert>
 80041de:	4603      	mov	r3, r0
 80041e0:	2b00      	cmp	r3, #0
 80041e2:	d160      	bne.n	80042a6 <sem2_execute.lto_priv.96+0x186>
  test_assert(6, sem1.s_cnt == 0, "counter not zero");
 80041e4:	4b31      	ldr	r3, [pc, #196]	; (80042ac <sem2_execute.lto_priv.96+0x18c>)
 80041e6:	689b      	ldr	r3, [r3, #8]
 80041e8:	2b00      	cmp	r3, #0
 80041ea:	bf0c      	ite	eq
 80041ec:	2301      	moveq	r3, #1
 80041ee:	2300      	movne	r3, #0
 80041f0:	b2db      	uxtb	r3, r3
 80041f2:	2006      	movs	r0, #6
 80041f4:	4619      	mov	r1, r3
 80041f6:	f001 fa8b 	bl	8005710 <_test_assert>
 80041fa:	4603      	mov	r3, r0
 80041fc:	2b00      	cmp	r3, #0
 80041fe:	d152      	bne.n	80042a6 <sem2_execute.lto_priv.96+0x186>

  /*
   * Testing timeout condition.
   */
  test_wait_tick();
 8004200:	f001 fb2e 	bl	8005860 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
 8004204:	f001 fff4 	bl	80061f0 <chVTGetSystemTime.lto_priv.209>
 8004208:	4603      	mov	r3, r0
 800420a:	f603 13c4 	addw	r3, r3, #2500	; 0x9c4
 800420e:	9303      	str	r3, [sp, #12]
  for (i = 0; i < 5; i++) {
 8004210:	2300      	movs	r3, #0
 8004212:	9305      	str	r3, [sp, #20]
 8004214:	e036      	b.n	8004284 <sem2_execute.lto_priv.96+0x164>
    test_emit_token('A' + i);
 8004216:	9b05      	ldr	r3, [sp, #20]
 8004218:	b2db      	uxtb	r3, r3
 800421a:	3341      	adds	r3, #65	; 0x41
 800421c:	b2db      	uxtb	r3, r3
 800421e:	4618      	mov	r0, r3
 8004220:	f001 fa46 	bl	80056b0 <test_emit_token>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
 8004224:	4821      	ldr	r0, [pc, #132]	; (80042ac <sem2_execute.lto_priv.96+0x18c>)
 8004226:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800422a:	f006 fc81 	bl	800ab30 <chSemWaitTimeout>
 800422e:	9004      	str	r0, [sp, #16]
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
 8004230:	9b04      	ldr	r3, [sp, #16]
 8004232:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004236:	bf0c      	ite	eq
 8004238:	2301      	moveq	r3, #1
 800423a:	2300      	movne	r3, #0
 800423c:	b2db      	uxtb	r3, r3
 800423e:	2007      	movs	r0, #7
 8004240:	4619      	mov	r1, r3
 8004242:	f001 fa65 	bl	8005710 <_test_assert>
 8004246:	4603      	mov	r3, r0
 8004248:	2b00      	cmp	r3, #0
 800424a:	d12c      	bne.n	80042a6 <sem2_execute.lto_priv.96+0x186>
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
 800424c:	4817      	ldr	r0, [pc, #92]	; (80042ac <sem2_execute.lto_priv.96+0x18c>)
 800424e:	f001 ff8f 	bl	8006170 <queue_isempty.lto_priv.202>
 8004252:	4603      	mov	r3, r0
 8004254:	2008      	movs	r0, #8
 8004256:	4619      	mov	r1, r3
 8004258:	f001 fa5a 	bl	8005710 <_test_assert>
 800425c:	4603      	mov	r3, r0
 800425e:	2b00      	cmp	r3, #0
 8004260:	d121      	bne.n	80042a6 <sem2_execute.lto_priv.96+0x186>
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
 8004262:	4b12      	ldr	r3, [pc, #72]	; (80042ac <sem2_execute.lto_priv.96+0x18c>)
 8004264:	689b      	ldr	r3, [r3, #8]
 8004266:	2b00      	cmp	r3, #0
 8004268:	bf0c      	ite	eq
 800426a:	2301      	moveq	r3, #1
 800426c:	2300      	movne	r3, #0
 800426e:	b2db      	uxtb	r3, r3
 8004270:	2009      	movs	r0, #9
 8004272:	4619      	mov	r1, r3
 8004274:	f001 fa4c 	bl	8005710 <_test_assert>
 8004278:	4603      	mov	r3, r0
 800427a:	2b00      	cmp	r3, #0
 800427c:	d113      	bne.n	80042a6 <sem2_execute.lto_priv.96+0x186>
  /*
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
 800427e:	9b05      	ldr	r3, [sp, #20]
 8004280:	3301      	adds	r3, #1
 8004282:	9305      	str	r3, [sp, #20]
 8004284:	9b05      	ldr	r3, [sp, #20]
 8004286:	2b04      	cmp	r3, #4
 8004288:	ddc5      	ble.n	8004216 <sem2_execute.lto_priv.96+0xf6>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
 800428a:	200a      	movs	r0, #10
 800428c:	490b      	ldr	r1, [pc, #44]	; (80042bc <sem2_execute.lto_priv.96+0x19c>)
 800428e:	f001 fa57 	bl	8005740 <_test_assert_sequence>
 8004292:	4603      	mov	r3, r0
 8004294:	2b00      	cmp	r3, #0
 8004296:	d106      	bne.n	80042a6 <sem2_execute.lto_priv.96+0x186>
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
 8004298:	9b03      	ldr	r3, [sp, #12]
 800429a:	3314      	adds	r3, #20
 800429c:	200b      	movs	r0, #11
 800429e:	9903      	ldr	r1, [sp, #12]
 80042a0:	461a      	mov	r2, r3
 80042a2:	f001 fa7d 	bl	80057a0 <_test_assert_time_window>
}
 80042a6:	b006      	add	sp, #24
 80042a8:	bd10      	pop	{r4, pc}
 80042aa:	bf00      	nop
 80042ac:	20000834 	.word	0x20000834
 80042b0:	0800e420 	.word	0x0800e420
 80042b4:	080040f1 	.word	0x080040f1
 80042b8:	20001bf8 	.word	0x20001bf8
 80042bc:	0800d884 	.word	0x0800d884

080042c0 <sem3_setup.lto_priv.93>:
 * The test expects that the semaphore wait function returns the correct value
 * in each of the above scenario and that the semaphore structure status is
 * correct after each operation.
 */

static void sem3_setup(void) {
 80042c0:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 80042c2:	4802      	ldr	r0, [pc, #8]	; (80042cc <sem3_setup.lto_priv.93+0xc>)
 80042c4:	2100      	movs	r1, #0
 80042c6:	f006 fb4b 	bl	800a960 <chSemObjectInit>
}
 80042ca:	bd08      	pop	{r3, pc}
 80042cc:	20000834 	.word	0x20000834

080042d0 <thread3>:

static THD_FUNCTION(thread3, p) {
 80042d0:	b500      	push	{lr}
 80042d2:	b083      	sub	sp, #12
 80042d4:	9001      	str	r0, [sp, #4]

  (void)p;
  chSemWait(&sem1);
 80042d6:	4804      	ldr	r0, [pc, #16]	; (80042e8 <thread3+0x18>)
 80042d8:	f006 fbca 	bl	800aa70 <chSemWait>
  chSemSignal(&sem1);
 80042dc:	4802      	ldr	r0, [pc, #8]	; (80042e8 <thread3+0x18>)
 80042de:	f006 fc9f 	bl	800ac20 <chSemSignal>
}
 80042e2:	b003      	add	sp, #12
 80042e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80042e8:	20000834 	.word	0x20000834
 80042ec:	00000000 	.word	0x00000000

080042f0 <sem3_execute.lto_priv.94>:

static void sem3_execute(void) {
 80042f0:	b510      	push	{r4, lr}
 80042f2:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 80042f4:	4b24      	ldr	r3, [pc, #144]	; (8004388 <sem3_execute.lto_priv.94+0x98>)
 80042f6:	681c      	ldr	r4, [r3, #0]
 80042f8:	f001 ff92 	bl	8006220 <chThdGetPriorityX.lto_priv.188>
 80042fc:	4603      	mov	r3, r0
 80042fe:	1c5a      	adds	r2, r3, #1
 8004300:	2300      	movs	r3, #0
 8004302:	9300      	str	r3, [sp, #0]
 8004304:	4620      	mov	r0, r4
 8004306:	f44f 71b4 	mov.w	r1, #360	; 0x168
 800430a:	4b20      	ldr	r3, [pc, #128]	; (800438c <sem3_execute.lto_priv.94+0x9c>)
 800430c:	f008 fc78 	bl	800cc00 <chThdCreateStatic>
 8004310:	4602      	mov	r2, r0
 8004312:	4b1f      	ldr	r3, [pc, #124]	; (8004390 <sem3_execute.lto_priv.94+0xa0>)
 8004314:	601a      	str	r2, [r3, #0]
  chSemSignalWait(&sem1, &sem1);
 8004316:	481f      	ldr	r0, [pc, #124]	; (8004394 <sem3_execute.lto_priv.94+0xa4>)
 8004318:	491e      	ldr	r1, [pc, #120]	; (8004394 <sem3_execute.lto_priv.94+0xa4>)
 800431a:	f006 fd61 	bl	800ade0 <chSemSignalWait>
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
 800431e:	481d      	ldr	r0, [pc, #116]	; (8004394 <sem3_execute.lto_priv.94+0xa4>)
 8004320:	f001 ff26 	bl	8006170 <queue_isempty.lto_priv.202>
 8004324:	4603      	mov	r3, r0
 8004326:	2001      	movs	r0, #1
 8004328:	4619      	mov	r1, r3
 800432a:	f001 f9f1 	bl	8005710 <_test_assert>
 800432e:	4603      	mov	r3, r0
 8004330:	2b00      	cmp	r3, #0
 8004332:	d127      	bne.n	8004384 <sem3_execute.lto_priv.94+0x94>
  test_assert(2, sem1.s_cnt == 0, "counter not zero");
 8004334:	4b17      	ldr	r3, [pc, #92]	; (8004394 <sem3_execute.lto_priv.94+0xa4>)
 8004336:	689b      	ldr	r3, [r3, #8]
 8004338:	2b00      	cmp	r3, #0
 800433a:	bf0c      	ite	eq
 800433c:	2301      	moveq	r3, #1
 800433e:	2300      	movne	r3, #0
 8004340:	b2db      	uxtb	r3, r3
 8004342:	2002      	movs	r0, #2
 8004344:	4619      	mov	r1, r3
 8004346:	f001 f9e3 	bl	8005710 <_test_assert>
 800434a:	4603      	mov	r3, r0
 800434c:	2b00      	cmp	r3, #0
 800434e:	d119      	bne.n	8004384 <sem3_execute.lto_priv.94+0x94>

  chSemSignalWait(&sem1, &sem1);
 8004350:	4810      	ldr	r0, [pc, #64]	; (8004394 <sem3_execute.lto_priv.94+0xa4>)
 8004352:	4910      	ldr	r1, [pc, #64]	; (8004394 <sem3_execute.lto_priv.94+0xa4>)
 8004354:	f006 fd44 	bl	800ade0 <chSemSignalWait>
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
 8004358:	480e      	ldr	r0, [pc, #56]	; (8004394 <sem3_execute.lto_priv.94+0xa4>)
 800435a:	f001 ff09 	bl	8006170 <queue_isempty.lto_priv.202>
 800435e:	4603      	mov	r3, r0
 8004360:	2003      	movs	r0, #3
 8004362:	4619      	mov	r1, r3
 8004364:	f001 f9d4 	bl	8005710 <_test_assert>
 8004368:	4603      	mov	r3, r0
 800436a:	2b00      	cmp	r3, #0
 800436c:	d10a      	bne.n	8004384 <sem3_execute.lto_priv.94+0x94>
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
 800436e:	4b09      	ldr	r3, [pc, #36]	; (8004394 <sem3_execute.lto_priv.94+0xa4>)
 8004370:	689b      	ldr	r3, [r3, #8]
 8004372:	2b00      	cmp	r3, #0
 8004374:	bf0c      	ite	eq
 8004376:	2301      	moveq	r3, #1
 8004378:	2300      	movne	r3, #0
 800437a:	b2db      	uxtb	r3, r3
 800437c:	2004      	movs	r0, #4
 800437e:	4619      	mov	r1, r3
 8004380:	f001 f9c6 	bl	8005710 <_test_assert>
}
 8004384:	b002      	add	sp, #8
 8004386:	bd10      	pop	{r4, pc}
 8004388:	0800e420 	.word	0x0800e420
 800438c:	080042d1 	.word	0x080042d1
 8004390:	20001bf8 	.word	0x20001bf8
 8004394:	20000834 	.word	0x20000834
	...

080043a0 <thread4>:
 * <h2>Description</h2>
 * This test case tests the binary semaphores functionality. The test both
 * checks the binary semaphore status and the expected status of the underlying
 * counting semaphore.
 */
static THD_FUNCTION(thread4, p) {
 80043a0:	b500      	push	{lr}
 80043a2:	b083      	sub	sp, #12
 80043a4:	9001      	str	r0, [sp, #4]

  chBSemSignal((binary_semaphore_t *)p);
 80043a6:	9801      	ldr	r0, [sp, #4]
 80043a8:	f001 ffa2 	bl	80062f0 <chBSemSignal.lto_priv.205>
}
 80043ac:	b003      	add	sp, #12
 80043ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80043b2:	bf00      	nop
	...

080043c0 <sem4_execute.lto_priv.92>:

static void sem4_execute(void) {
 80043c0:	b510      	push	{r4, lr}
 80043c2:	b086      	sub	sp, #24
  binary_semaphore_t bsem;
  
  /* Creates a taken binary semaphore.*/
  chBSemObjectInit(&bsem, TRUE);
 80043c4:	ab03      	add	r3, sp, #12
 80043c6:	4618      	mov	r0, r3
 80043c8:	2101      	movs	r1, #1
 80043ca:	f001 ff41 	bl	8006250 <chBSemObjectInit.lto_priv.208>
  chBSemReset(&bsem, TRUE);
 80043ce:	ab03      	add	r3, sp, #12
 80043d0:	4618      	mov	r0, r3
 80043d2:	2101      	movs	r1, #1
 80043d4:	f001 ff64 	bl	80062a0 <chBSemReset.lto_priv.207>
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");
 80043d8:	f001 feda 	bl	8006190 <chSysLock.lto_priv.200>
 80043dc:	ab03      	add	r3, sp, #12
 80043de:	4618      	mov	r0, r3
 80043e0:	f001 ff96 	bl	8006310 <chBSemGetStateI.lto_priv.204>
 80043e4:	4603      	mov	r3, r0
 80043e6:	2b00      	cmp	r3, #0
 80043e8:	bf14      	ite	ne
 80043ea:	2301      	movne	r3, #1
 80043ec:	2300      	moveq	r3, #0
 80043ee:	b2db      	uxtb	r3, r3
 80043f0:	2001      	movs	r0, #1
 80043f2:	4619      	mov	r1, r3
 80043f4:	f001 f98c 	bl	8005710 <_test_assert>
 80043f8:	4603      	mov	r3, r0
 80043fa:	2b00      	cmp	r3, #0
 80043fc:	d002      	beq.n	8004404 <sem4_execute.lto_priv.92+0x44>
 80043fe:	f001 fecf 	bl	80061a0 <chSysUnlock.lto_priv.198>
 8004402:	e0a2      	b.n	800454a <sem4_execute.lto_priv.92+0x18a>
 8004404:	f001 fecc 	bl	80061a0 <chSysUnlock.lto_priv.198>

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8004408:	4b51      	ldr	r3, [pc, #324]	; (8004550 <sem4_execute.lto_priv.92+0x190>)
 800440a:	681c      	ldr	r4, [r3, #0]
                                 chThdGetPriorityX()-1, thread4, &bsem);
 800440c:	f001 ff08 	bl	8006220 <chThdGetPriorityX.lto_priv.188>
 8004410:	4603      	mov	r3, r0
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8004412:	1e5a      	subs	r2, r3, #1
 8004414:	ab03      	add	r3, sp, #12
 8004416:	9300      	str	r3, [sp, #0]
 8004418:	4620      	mov	r0, r4
 800441a:	f44f 71b4 	mov.w	r1, #360	; 0x168
 800441e:	4b4d      	ldr	r3, [pc, #308]	; (8004554 <sem4_execute.lto_priv.92+0x194>)
 8004420:	f008 fbee 	bl	800cc00 <chThdCreateStatic>
 8004424:	4602      	mov	r2, r0
 8004426:	4b4c      	ldr	r3, [pc, #304]	; (8004558 <sem4_execute.lto_priv.92+0x198>)
 8004428:	601a      	str	r2, [r3, #0]
                                 chThdGetPriorityX()-1, thread4, &bsem);
                                 
  /* Waits to be signaled.*/
  chBSemWait(&bsem);
 800442a:	ab03      	add	r3, sp, #12
 800442c:	4618      	mov	r0, r3
 800442e:	f001 ff27 	bl	8006280 <chBSemWait.lto_priv.206>
  
  /* The binary semaphore is expected to be taken.*/
  test_assert_lock(2, chBSemGetStateI(&bsem) == TRUE, "not taken");
 8004432:	f001 fead 	bl	8006190 <chSysLock.lto_priv.200>
 8004436:	ab03      	add	r3, sp, #12
 8004438:	4618      	mov	r0, r3
 800443a:	f001 ff69 	bl	8006310 <chBSemGetStateI.lto_priv.204>
 800443e:	4603      	mov	r3, r0
 8004440:	2b00      	cmp	r3, #0
 8004442:	bf14      	ite	ne
 8004444:	2301      	movne	r3, #1
 8004446:	2300      	moveq	r3, #0
 8004448:	b2db      	uxtb	r3, r3
 800444a:	2002      	movs	r0, #2
 800444c:	4619      	mov	r1, r3
 800444e:	f001 f95f 	bl	8005710 <_test_assert>
 8004452:	4603      	mov	r3, r0
 8004454:	2b00      	cmp	r3, #0
 8004456:	d002      	beq.n	800445e <sem4_execute.lto_priv.92+0x9e>
 8004458:	f001 fea2 	bl	80061a0 <chSysUnlock.lto_priv.198>
 800445c:	e075      	b.n	800454a <sem4_execute.lto_priv.92+0x18a>
 800445e:	f001 fe9f 	bl	80061a0 <chSysUnlock.lto_priv.198>

  /* Releasing it, check both the binary semaphore state and the underlying
     counter semaphore state..*/
  chBSemSignal(&bsem);
 8004462:	ab03      	add	r3, sp, #12
 8004464:	4618      	mov	r0, r3
 8004466:	f001 ff43 	bl	80062f0 <chBSemSignal.lto_priv.205>
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
 800446a:	f001 fe91 	bl	8006190 <chSysLock.lto_priv.200>
 800446e:	ab03      	add	r3, sp, #12
 8004470:	4618      	mov	r0, r3
 8004472:	f001 ff4d 	bl	8006310 <chBSemGetStateI.lto_priv.204>
 8004476:	4603      	mov	r3, r0
 8004478:	2b00      	cmp	r3, #0
 800447a:	bf14      	ite	ne
 800447c:	2301      	movne	r3, #1
 800447e:	2300      	moveq	r3, #0
 8004480:	b2db      	uxtb	r3, r3
 8004482:	f083 0301 	eor.w	r3, r3, #1
 8004486:	b2db      	uxtb	r3, r3
 8004488:	f003 0301 	and.w	r3, r3, #1
 800448c:	b2db      	uxtb	r3, r3
 800448e:	2003      	movs	r0, #3
 8004490:	4619      	mov	r1, r3
 8004492:	f001 f93d 	bl	8005710 <_test_assert>
 8004496:	4603      	mov	r3, r0
 8004498:	2b00      	cmp	r3, #0
 800449a:	d002      	beq.n	80044a2 <sem4_execute.lto_priv.92+0xe2>
 800449c:	f001 fe80 	bl	80061a0 <chSysUnlock.lto_priv.198>
 80044a0:	e053      	b.n	800454a <sem4_execute.lto_priv.92+0x18a>
 80044a2:	f001 fe7d 	bl	80061a0 <chSysUnlock.lto_priv.198>
  test_assert_lock(4, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 80044a6:	f001 fe73 	bl	8006190 <chSysLock.lto_priv.200>
 80044aa:	ab03      	add	r3, sp, #12
 80044ac:	4618      	mov	r0, r3
 80044ae:	f001 febf 	bl	8006230 <chSemGetCounterI.lto_priv.182>
 80044b2:	4603      	mov	r3, r0
 80044b4:	2b01      	cmp	r3, #1
 80044b6:	bf0c      	ite	eq
 80044b8:	2301      	moveq	r3, #1
 80044ba:	2300      	movne	r3, #0
 80044bc:	b2db      	uxtb	r3, r3
 80044be:	2004      	movs	r0, #4
 80044c0:	4619      	mov	r1, r3
 80044c2:	f001 f925 	bl	8005710 <_test_assert>
 80044c6:	4603      	mov	r3, r0
 80044c8:	2b00      	cmp	r3, #0
 80044ca:	d002      	beq.n	80044d2 <sem4_execute.lto_priv.92+0x112>
 80044cc:	f001 fe68 	bl	80061a0 <chSysUnlock.lto_priv.198>
 80044d0:	e03b      	b.n	800454a <sem4_execute.lto_priv.92+0x18a>
 80044d2:	f001 fe65 	bl	80061a0 <chSysUnlock.lto_priv.198>

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
 80044d6:	ab03      	add	r3, sp, #12
 80044d8:	4618      	mov	r0, r3
 80044da:	f001 ff09 	bl	80062f0 <chBSemSignal.lto_priv.205>
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
 80044de:	f001 fe57 	bl	8006190 <chSysLock.lto_priv.200>
 80044e2:	ab03      	add	r3, sp, #12
 80044e4:	4618      	mov	r0, r3
 80044e6:	f001 ff13 	bl	8006310 <chBSemGetStateI.lto_priv.204>
 80044ea:	4603      	mov	r3, r0
 80044ec:	2b00      	cmp	r3, #0
 80044ee:	bf14      	ite	ne
 80044f0:	2301      	movne	r3, #1
 80044f2:	2300      	moveq	r3, #0
 80044f4:	b2db      	uxtb	r3, r3
 80044f6:	f083 0301 	eor.w	r3, r3, #1
 80044fa:	b2db      	uxtb	r3, r3
 80044fc:	f003 0301 	and.w	r3, r3, #1
 8004500:	b2db      	uxtb	r3, r3
 8004502:	2003      	movs	r0, #3
 8004504:	4619      	mov	r1, r3
 8004506:	f001 f903 	bl	8005710 <_test_assert>
 800450a:	4603      	mov	r3, r0
 800450c:	2b00      	cmp	r3, #0
 800450e:	d002      	beq.n	8004516 <sem4_execute.lto_priv.92+0x156>
 8004510:	f001 fe46 	bl	80061a0 <chSysUnlock.lto_priv.198>
 8004514:	e019      	b.n	800454a <sem4_execute.lto_priv.92+0x18a>
 8004516:	f001 fe43 	bl	80061a0 <chSysUnlock.lto_priv.198>
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 800451a:	f001 fe39 	bl	8006190 <chSysLock.lto_priv.200>
 800451e:	ab03      	add	r3, sp, #12
 8004520:	4618      	mov	r0, r3
 8004522:	f001 fe85 	bl	8006230 <chSemGetCounterI.lto_priv.182>
 8004526:	4603      	mov	r3, r0
 8004528:	2b01      	cmp	r3, #1
 800452a:	bf0c      	ite	eq
 800452c:	2301      	moveq	r3, #1
 800452e:	2300      	movne	r3, #0
 8004530:	b2db      	uxtb	r3, r3
 8004532:	2005      	movs	r0, #5
 8004534:	4619      	mov	r1, r3
 8004536:	f001 f8eb 	bl	8005710 <_test_assert>
 800453a:	4603      	mov	r3, r0
 800453c:	2b00      	cmp	r3, #0
 800453e:	d002      	beq.n	8004546 <sem4_execute.lto_priv.92+0x186>
 8004540:	f001 fe2e 	bl	80061a0 <chSysUnlock.lto_priv.198>
 8004544:	e001      	b.n	800454a <sem4_execute.lto_priv.92+0x18a>
 8004546:	f001 fe2b 	bl	80061a0 <chSysUnlock.lto_priv.198>
}
 800454a:	b006      	add	sp, #24
 800454c:	bd10      	pop	{r4, pc}
 800454e:	bf00      	nop
 8004550:	0800e420 	.word	0x0800e420
 8004554:	080043a1 	.word	0x080043a1
 8004558:	20001bf8 	.word	0x20001bf8
 800455c:	00000000 	.word	0x00000000

08004560 <port_lock.lto_priv.186>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8004560:	b082      	sub	sp, #8
 8004562:	2320      	movs	r3, #32
 8004564:	9301      	str	r3, [sp, #4]
 8004566:	9b01      	ldr	r3, [sp, #4]
 8004568:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800456c:	b002      	add	sp, #8
 800456e:	4770      	bx	lr

08004570 <port_unlock.lto_priv.184>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8004570:	b082      	sub	sp, #8
 8004572:	2300      	movs	r3, #0
 8004574:	9301      	str	r3, [sp, #4]
 8004576:	9b01      	ldr	r3, [sp, #4]
 8004578:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800457c:	b002      	add	sp, #8
 800457e:	4770      	bx	lr

08004580 <queue_isempty.lto_priv.203>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
 8004580:	b082      	sub	sp, #8
 8004582:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 8004584:	9b01      	ldr	r3, [sp, #4]
 8004586:	681a      	ldr	r2, [r3, #0]
 8004588:	9b01      	ldr	r3, [sp, #4]
 800458a:	429a      	cmp	r2, r3
 800458c:	bf0c      	ite	eq
 800458e:	2301      	moveq	r3, #1
 8004590:	2300      	movne	r3, #0
 8004592:	b2db      	uxtb	r3, r3
}
 8004594:	4618      	mov	r0, r3
 8004596:	b002      	add	sp, #8
 8004598:	4770      	bx	lr
 800459a:	bf00      	nop
 800459c:	0000      	movs	r0, r0
	...

080045a0 <chSysLock.lto_priv.201>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80045a0:	b508      	push	{r3, lr}

  port_lock();
 80045a2:	f7ff ffdd 	bl	8004560 <port_lock.lto_priv.186>
  _stats_start_measure_crit_thd();
 80045a6:	f005 ff4b 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 80045aa:	f007 fbf9 	bl	800bda0 <_dbg_check_lock>
}
 80045ae:	bd08      	pop	{r3, pc}

080045b0 <chSysUnlock.lto_priv.199>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80045b0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 80045b2:	f007 fc0d 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80045b6:	f005 ff4b 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80045ba:	4b09      	ldr	r3, [pc, #36]	; (80045e0 <chSysUnlock.lto_priv.199+0x30>)
 80045bc:	681b      	ldr	r3, [r3, #0]
 80045be:	4a08      	ldr	r2, [pc, #32]	; (80045e0 <chSysUnlock.lto_priv.199+0x30>)
 80045c0:	4293      	cmp	r3, r2
 80045c2:	d00a      	beq.n	80045da <chSysUnlock.lto_priv.199+0x2a>
 80045c4:	4b06      	ldr	r3, [pc, #24]	; (80045e0 <chSysUnlock.lto_priv.199+0x30>)
 80045c6:	699b      	ldr	r3, [r3, #24]
 80045c8:	689a      	ldr	r2, [r3, #8]
 80045ca:	4b05      	ldr	r3, [pc, #20]	; (80045e0 <chSysUnlock.lto_priv.199+0x30>)
 80045cc:	681b      	ldr	r3, [r3, #0]
 80045ce:	689b      	ldr	r3, [r3, #8]
 80045d0:	429a      	cmp	r2, r3
 80045d2:	d202      	bcs.n	80045da <chSysUnlock.lto_priv.199+0x2a>
 80045d4:	4803      	ldr	r0, [pc, #12]	; (80045e4 <chSysUnlock.lto_priv.199+0x34>)
 80045d6:	f007 fa8b 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80045da:	f7ff ffc9 	bl	8004570 <port_unlock.lto_priv.184>
}
 80045de:	bd08      	pop	{r3, pc}
 80045e0:	20000d30 	.word	0x20000d30
 80045e4:	0800e5b0 	.word	0x0800e5b0
	...

080045f0 <chThdGetSelfX.lto_priv.191>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80045f0:	4b01      	ldr	r3, [pc, #4]	; (80045f8 <chThdGetSelfX.lto_priv.191+0x8>)
 80045f2:	699b      	ldr	r3, [r3, #24]
}
 80045f4:	4618      	mov	r0, r3
 80045f6:	4770      	bx	lr
 80045f8:	20000d30 	.word	0x20000d30
 80045fc:	00000000 	.word	0x00000000

08004600 <chThdGetPriorityX.lto_priv.189>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 8004600:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 8004602:	f7ff fff5 	bl	80045f0 <chThdGetSelfX.lto_priv.191>
 8004606:	4603      	mov	r3, r0
 8004608:	689b      	ldr	r3, [r3, #8]
}
 800460a:	4618      	mov	r0, r3
 800460c:	bd08      	pop	{r3, pc}
 800460e:	bf00      	nop

08004610 <mtx1_setup.lto_priv.90>:
 * the mutex is unlocked.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void mtx1_setup(void) {
 8004610:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 8004612:	4802      	ldr	r0, [pc, #8]	; (800461c <mtx1_setup.lto_priv.90+0xc>)
 8004614:	f006 fd2c 	bl	800b070 <chMtxObjectInit>
}
 8004618:	bd08      	pop	{r3, pc}
 800461a:	bf00      	nop
 800461c:	20000840 	.word	0x20000840

08004620 <thread1.lto_priv.197>:

static THD_FUNCTION(thread1, p) {
 8004620:	b500      	push	{lr}
 8004622:	b083      	sub	sp, #12
 8004624:	9001      	str	r0, [sp, #4]

  chMtxLock(&m1);
 8004626:	4807      	ldr	r0, [pc, #28]	; (8004644 <thread1.lto_priv.197+0x24>)
 8004628:	f006 fd3a 	bl	800b0a0 <chMtxLock>
  test_emit_token(*(char *)p);
 800462c:	9b01      	ldr	r3, [sp, #4]
 800462e:	781b      	ldrb	r3, [r3, #0]
 8004630:	4618      	mov	r0, r3
 8004632:	f001 f83d 	bl	80056b0 <test_emit_token>
  chMtxUnlock(&m1);
 8004636:	4803      	ldr	r0, [pc, #12]	; (8004644 <thread1.lto_priv.197+0x24>)
 8004638:	f006 fe02 	bl	800b240 <chMtxUnlock>
}
 800463c:	b003      	add	sp, #12
 800463e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004642:	bf00      	nop
 8004644:	20000840 	.word	0x20000840
	...

08004650 <mtx1_execute.lto_priv.91>:

static void mtx1_execute(void) {
 8004650:	b500      	push	{lr}
 8004652:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
 8004654:	f7ff ffd4 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 8004658:	9003      	str	r0, [sp, #12]
  chMtxLock(&m1);
 800465a:	4835      	ldr	r0, [pc, #212]	; (8004730 <mtx1_execute.lto_priv.91+0xe0>)
 800465c:	f006 fd20 	bl	800b0a0 <chMtxLock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 8004660:	4b34      	ldr	r3, [pc, #208]	; (8004734 <mtx1_execute.lto_priv.91+0xe4>)
 8004662:	6819      	ldr	r1, [r3, #0]
 8004664:	9b03      	ldr	r3, [sp, #12]
 8004666:	1c5a      	adds	r2, r3, #1
 8004668:	4b33      	ldr	r3, [pc, #204]	; (8004738 <mtx1_execute.lto_priv.91+0xe8>)
 800466a:	9300      	str	r3, [sp, #0]
 800466c:	4608      	mov	r0, r1
 800466e:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004672:	4b32      	ldr	r3, [pc, #200]	; (800473c <mtx1_execute.lto_priv.91+0xec>)
 8004674:	f008 fac4 	bl	800cc00 <chThdCreateStatic>
 8004678:	4602      	mov	r2, r0
 800467a:	4b31      	ldr	r3, [pc, #196]	; (8004740 <mtx1_execute.lto_priv.91+0xf0>)
 800467c:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 800467e:	4b2d      	ldr	r3, [pc, #180]	; (8004734 <mtx1_execute.lto_priv.91+0xe4>)
 8004680:	6859      	ldr	r1, [r3, #4]
 8004682:	9b03      	ldr	r3, [sp, #12]
 8004684:	1c9a      	adds	r2, r3, #2
 8004686:	4b2f      	ldr	r3, [pc, #188]	; (8004744 <mtx1_execute.lto_priv.91+0xf4>)
 8004688:	9300      	str	r3, [sp, #0]
 800468a:	4608      	mov	r0, r1
 800468c:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004690:	4b2a      	ldr	r3, [pc, #168]	; (800473c <mtx1_execute.lto_priv.91+0xec>)
 8004692:	f008 fab5 	bl	800cc00 <chThdCreateStatic>
 8004696:	4602      	mov	r2, r0
 8004698:	4b29      	ldr	r3, [pc, #164]	; (8004740 <mtx1_execute.lto_priv.91+0xf0>)
 800469a:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 800469c:	4b25      	ldr	r3, [pc, #148]	; (8004734 <mtx1_execute.lto_priv.91+0xe4>)
 800469e:	6899      	ldr	r1, [r3, #8]
 80046a0:	9b03      	ldr	r3, [sp, #12]
 80046a2:	1cda      	adds	r2, r3, #3
 80046a4:	4b28      	ldr	r3, [pc, #160]	; (8004748 <mtx1_execute.lto_priv.91+0xf8>)
 80046a6:	9300      	str	r3, [sp, #0]
 80046a8:	4608      	mov	r0, r1
 80046aa:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80046ae:	4b23      	ldr	r3, [pc, #140]	; (800473c <mtx1_execute.lto_priv.91+0xec>)
 80046b0:	f008 faa6 	bl	800cc00 <chThdCreateStatic>
 80046b4:	4602      	mov	r2, r0
 80046b6:	4b22      	ldr	r3, [pc, #136]	; (8004740 <mtx1_execute.lto_priv.91+0xf0>)
 80046b8:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 80046ba:	4b1e      	ldr	r3, [pc, #120]	; (8004734 <mtx1_execute.lto_priv.91+0xe4>)
 80046bc:	68d9      	ldr	r1, [r3, #12]
 80046be:	9b03      	ldr	r3, [sp, #12]
 80046c0:	1d1a      	adds	r2, r3, #4
 80046c2:	4b22      	ldr	r3, [pc, #136]	; (800474c <mtx1_execute.lto_priv.91+0xfc>)
 80046c4:	9300      	str	r3, [sp, #0]
 80046c6:	4608      	mov	r0, r1
 80046c8:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80046cc:	4b1b      	ldr	r3, [pc, #108]	; (800473c <mtx1_execute.lto_priv.91+0xec>)
 80046ce:	f008 fa97 	bl	800cc00 <chThdCreateStatic>
 80046d2:	4602      	mov	r2, r0
 80046d4:	4b1a      	ldr	r3, [pc, #104]	; (8004740 <mtx1_execute.lto_priv.91+0xf0>)
 80046d6:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 80046d8:	4b16      	ldr	r3, [pc, #88]	; (8004734 <mtx1_execute.lto_priv.91+0xe4>)
 80046da:	6919      	ldr	r1, [r3, #16]
 80046dc:	9b03      	ldr	r3, [sp, #12]
 80046de:	1d5a      	adds	r2, r3, #5
 80046e0:	4b1b      	ldr	r3, [pc, #108]	; (8004750 <mtx1_execute.lto_priv.91+0x100>)
 80046e2:	9300      	str	r3, [sp, #0]
 80046e4:	4608      	mov	r0, r1
 80046e6:	f44f 71b4 	mov.w	r1, #360	; 0x168
 80046ea:	4b14      	ldr	r3, [pc, #80]	; (800473c <mtx1_execute.lto_priv.91+0xec>)
 80046ec:	f008 fa88 	bl	800cc00 <chThdCreateStatic>
 80046f0:	4602      	mov	r2, r0
 80046f2:	4b13      	ldr	r3, [pc, #76]	; (8004740 <mtx1_execute.lto_priv.91+0xf0>)
 80046f4:	611a      	str	r2, [r3, #16]
  chMtxUnlock(&m1);
 80046f6:	480e      	ldr	r0, [pc, #56]	; (8004730 <mtx1_execute.lto_priv.91+0xe0>)
 80046f8:	f006 fda2 	bl	800b240 <chMtxUnlock>
  test_wait_threads();
 80046fc:	f001 f888 	bl	8005810 <test_wait_threads>
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
 8004700:	f7ff ff7e 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 8004704:	4602      	mov	r2, r0
 8004706:	9b03      	ldr	r3, [sp, #12]
 8004708:	429a      	cmp	r2, r3
 800470a:	bf0c      	ite	eq
 800470c:	2301      	moveq	r3, #1
 800470e:	2300      	movne	r3, #0
 8004710:	b2db      	uxtb	r3, r3
 8004712:	2001      	movs	r0, #1
 8004714:	4619      	mov	r1, r3
 8004716:	f000 fffb 	bl	8005710 <_test_assert>
 800471a:	4603      	mov	r3, r0
 800471c:	2b00      	cmp	r3, #0
 800471e:	d103      	bne.n	8004728 <mtx1_execute.lto_priv.91+0xd8>
  test_assert_sequence(2, "ABCDE");
 8004720:	2002      	movs	r0, #2
 8004722:	490c      	ldr	r1, [pc, #48]	; (8004754 <mtx1_execute.lto_priv.91+0x104>)
 8004724:	f001 f80c 	bl	8005740 <_test_assert_sequence>
}
 8004728:	b005      	add	sp, #20
 800472a:	f85d fb04 	ldr.w	pc, [sp], #4
 800472e:	bf00      	nop
 8004730:	20000840 	.word	0x20000840
 8004734:	0800e420 	.word	0x0800e420
 8004738:	0800d880 	.word	0x0800d880
 800473c:	08004621 	.word	0x08004621
 8004740:	20001bf8 	.word	0x20001bf8
 8004744:	0800d87c 	.word	0x0800d87c
 8004748:	0800d878 	.word	0x0800d878
 800474c:	0800d874 	.word	0x0800d874
 8004750:	0800d870 	.word	0x0800d870
 8004754:	0800d884 	.word	0x0800d884
	...

08004760 <mtx4_setup.lto_priv.88>:
 * thread with precise timing.<br>
 * The test expects that the priority changes caused by the priority
 * inheritance algorithm happen at the right moment and with the right values.
 */

static void mtx4_setup(void) {
 8004760:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 8004762:	4803      	ldr	r0, [pc, #12]	; (8004770 <mtx4_setup.lto_priv.88+0x10>)
 8004764:	f006 fc84 	bl	800b070 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 8004768:	4802      	ldr	r0, [pc, #8]	; (8004774 <mtx4_setup.lto_priv.88+0x14>)
 800476a:	f006 fc81 	bl	800b070 <chMtxObjectInit>
}
 800476e:	bd08      	pop	{r3, pc}
 8004770:	20000840 	.word	0x20000840
 8004774:	20000850 	.word	0x20000850
	...

08004780 <thread4a>:

static THD_FUNCTION(thread4a, p) {
 8004780:	b500      	push	{lr}
 8004782:	b083      	sub	sp, #12
 8004784:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(50);
 8004786:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800478a:	f008 fac9 	bl	800cd20 <chThdSleep>
  chMtxLock(&m2);
 800478e:	4804      	ldr	r0, [pc, #16]	; (80047a0 <thread4a+0x20>)
 8004790:	f006 fc86 	bl	800b0a0 <chMtxLock>
  chMtxUnlock(&m2);
 8004794:	4802      	ldr	r0, [pc, #8]	; (80047a0 <thread4a+0x20>)
 8004796:	f006 fd53 	bl	800b240 <chMtxUnlock>
}
 800479a:	b003      	add	sp, #12
 800479c:	f85d fb04 	ldr.w	pc, [sp], #4
 80047a0:	20000850 	.word	0x20000850
	...

080047b0 <thread4b>:

static THD_FUNCTION(thread4b, p) {
 80047b0:	b500      	push	{lr}
 80047b2:	b083      	sub	sp, #12
 80047b4:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(150);
 80047b6:	f240 50dc 	movw	r0, #1500	; 0x5dc
 80047ba:	f008 fab1 	bl	800cd20 <chThdSleep>
  chMtxLock(&m1);
 80047be:	4804      	ldr	r0, [pc, #16]	; (80047d0 <thread4b+0x20>)
 80047c0:	f006 fc6e 	bl	800b0a0 <chMtxLock>
  chMtxUnlock(&m1);
 80047c4:	4802      	ldr	r0, [pc, #8]	; (80047d0 <thread4b+0x20>)
 80047c6:	f006 fd3b 	bl	800b240 <chMtxUnlock>
}
 80047ca:	b003      	add	sp, #12
 80047cc:	f85d fb04 	ldr.w	pc, [sp], #4
 80047d0:	20000840 	.word	0x20000840
	...

080047e0 <mtx4_execute.lto_priv.89>:

static void mtx4_execute(void) {
 80047e0:	b500      	push	{lr}
 80047e2:	b087      	sub	sp, #28
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
 80047e4:	f7ff ff0c 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 80047e8:	9005      	str	r0, [sp, #20]
  p1 = p + 1;
 80047ea:	9b05      	ldr	r3, [sp, #20]
 80047ec:	3301      	adds	r3, #1
 80047ee:	9304      	str	r3, [sp, #16]
  p2 = p + 2;
 80047f0:	9b05      	ldr	r3, [sp, #20]
 80047f2:	3302      	adds	r3, #2
 80047f4:	9303      	str	r3, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 80047f6:	4bad      	ldr	r3, [pc, #692]	; (8004aac <mtx4_execute.lto_priv.89+0x2cc>)
 80047f8:	681a      	ldr	r2, [r3, #0]
 80047fa:	4bad      	ldr	r3, [pc, #692]	; (8004ab0 <mtx4_execute.lto_priv.89+0x2d0>)
 80047fc:	9300      	str	r3, [sp, #0]
 80047fe:	4610      	mov	r0, r2
 8004800:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004804:	9a04      	ldr	r2, [sp, #16]
 8004806:	4bab      	ldr	r3, [pc, #684]	; (8004ab4 <mtx4_execute.lto_priv.89+0x2d4>)
 8004808:	f008 f9fa 	bl	800cc00 <chThdCreateStatic>
 800480c:	4602      	mov	r2, r0
 800480e:	4baa      	ldr	r3, [pc, #680]	; (8004ab8 <mtx4_execute.lto_priv.89+0x2d8>)
 8004810:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 8004812:	4ba6      	ldr	r3, [pc, #664]	; (8004aac <mtx4_execute.lto_priv.89+0x2cc>)
 8004814:	685a      	ldr	r2, [r3, #4]
 8004816:	4ba9      	ldr	r3, [pc, #676]	; (8004abc <mtx4_execute.lto_priv.89+0x2dc>)
 8004818:	9300      	str	r3, [sp, #0]
 800481a:	4610      	mov	r0, r2
 800481c:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004820:	9a03      	ldr	r2, [sp, #12]
 8004822:	4ba7      	ldr	r3, [pc, #668]	; (8004ac0 <mtx4_execute.lto_priv.89+0x2e0>)
 8004824:	f008 f9ec 	bl	800cc00 <chThdCreateStatic>
 8004828:	4602      	mov	r2, r0
 800482a:	4ba3      	ldr	r3, [pc, #652]	; (8004ab8 <mtx4_execute.lto_priv.89+0x2d8>)
 800482c:	605a      	str	r2, [r3, #4]
  chMtxLock(&m2);
 800482e:	48a5      	ldr	r0, [pc, #660]	; (8004ac4 <mtx4_execute.lto_priv.89+0x2e4>)
 8004830:	f006 fc36 	bl	800b0a0 <chMtxLock>
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
 8004834:	f7ff fee4 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 8004838:	4602      	mov	r2, r0
 800483a:	9b05      	ldr	r3, [sp, #20]
 800483c:	429a      	cmp	r2, r3
 800483e:	bf0c      	ite	eq
 8004840:	2301      	moveq	r3, #1
 8004842:	2300      	movne	r3, #0
 8004844:	b2db      	uxtb	r3, r3
 8004846:	2001      	movs	r0, #1
 8004848:	4619      	mov	r1, r3
 800484a:	f000 ff61 	bl	8005710 <_test_assert>
 800484e:	4603      	mov	r3, r0
 8004850:	2b00      	cmp	r3, #0
 8004852:	f040 8127 	bne.w	8004aa4 <mtx4_execute.lto_priv.89+0x2c4>
  chThdSleepMilliseconds(100);
 8004856:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800485a:	f008 fa61 	bl	800cd20 <chThdSleep>
  test_assert(2, chThdGetPriorityX() == p1, "wrong priority level");
 800485e:	f7ff fecf 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 8004862:	4602      	mov	r2, r0
 8004864:	9b04      	ldr	r3, [sp, #16]
 8004866:	429a      	cmp	r2, r3
 8004868:	bf0c      	ite	eq
 800486a:	2301      	moveq	r3, #1
 800486c:	2300      	movne	r3, #0
 800486e:	b2db      	uxtb	r3, r3
 8004870:	2002      	movs	r0, #2
 8004872:	4619      	mov	r1, r3
 8004874:	f000 ff4c 	bl	8005710 <_test_assert>
 8004878:	4603      	mov	r3, r0
 800487a:	2b00      	cmp	r3, #0
 800487c:	f040 8112 	bne.w	8004aa4 <mtx4_execute.lto_priv.89+0x2c4>
  chMtxLock(&m1);
 8004880:	4891      	ldr	r0, [pc, #580]	; (8004ac8 <mtx4_execute.lto_priv.89+0x2e8>)
 8004882:	f006 fc0d 	bl	800b0a0 <chMtxLock>
  test_assert(3, chThdGetPriorityX() == p1, "wrong priority level");
 8004886:	f7ff febb 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 800488a:	4602      	mov	r2, r0
 800488c:	9b04      	ldr	r3, [sp, #16]
 800488e:	429a      	cmp	r2, r3
 8004890:	bf0c      	ite	eq
 8004892:	2301      	moveq	r3, #1
 8004894:	2300      	movne	r3, #0
 8004896:	b2db      	uxtb	r3, r3
 8004898:	2003      	movs	r0, #3
 800489a:	4619      	mov	r1, r3
 800489c:	f000 ff38 	bl	8005710 <_test_assert>
 80048a0:	4603      	mov	r3, r0
 80048a2:	2b00      	cmp	r3, #0
 80048a4:	f040 80fe 	bne.w	8004aa4 <mtx4_execute.lto_priv.89+0x2c4>
  chThdSleepMilliseconds(100);
 80048a8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80048ac:	f008 fa38 	bl	800cd20 <chThdSleep>
  test_assert(4, chThdGetPriorityX() == p2, "wrong priority level");
 80048b0:	f7ff fea6 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 80048b4:	4602      	mov	r2, r0
 80048b6:	9b03      	ldr	r3, [sp, #12]
 80048b8:	429a      	cmp	r2, r3
 80048ba:	bf0c      	ite	eq
 80048bc:	2301      	moveq	r3, #1
 80048be:	2300      	movne	r3, #0
 80048c0:	b2db      	uxtb	r3, r3
 80048c2:	2004      	movs	r0, #4
 80048c4:	4619      	mov	r1, r3
 80048c6:	f000 ff23 	bl	8005710 <_test_assert>
 80048ca:	4603      	mov	r3, r0
 80048cc:	2b00      	cmp	r3, #0
 80048ce:	f040 80e9 	bne.w	8004aa4 <mtx4_execute.lto_priv.89+0x2c4>
  chMtxUnlock(&m1);
 80048d2:	487d      	ldr	r0, [pc, #500]	; (8004ac8 <mtx4_execute.lto_priv.89+0x2e8>)
 80048d4:	f006 fcb4 	bl	800b240 <chMtxUnlock>
  test_assert(5, chThdGetPriorityX() == p1, "wrong priority level");
 80048d8:	f7ff fe92 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 80048dc:	4602      	mov	r2, r0
 80048de:	9b04      	ldr	r3, [sp, #16]
 80048e0:	429a      	cmp	r2, r3
 80048e2:	bf0c      	ite	eq
 80048e4:	2301      	moveq	r3, #1
 80048e6:	2300      	movne	r3, #0
 80048e8:	b2db      	uxtb	r3, r3
 80048ea:	2005      	movs	r0, #5
 80048ec:	4619      	mov	r1, r3
 80048ee:	f000 ff0f 	bl	8005710 <_test_assert>
 80048f2:	4603      	mov	r3, r0
 80048f4:	2b00      	cmp	r3, #0
 80048f6:	f040 80d5 	bne.w	8004aa4 <mtx4_execute.lto_priv.89+0x2c4>
  chThdSleepMilliseconds(100);
 80048fa:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80048fe:	f008 fa0f 	bl	800cd20 <chThdSleep>
  test_assert(6, chThdGetPriorityX() == p1, "wrong priority level");
 8004902:	f7ff fe7d 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 8004906:	4602      	mov	r2, r0
 8004908:	9b04      	ldr	r3, [sp, #16]
 800490a:	429a      	cmp	r2, r3
 800490c:	bf0c      	ite	eq
 800490e:	2301      	moveq	r3, #1
 8004910:	2300      	movne	r3, #0
 8004912:	b2db      	uxtb	r3, r3
 8004914:	2006      	movs	r0, #6
 8004916:	4619      	mov	r1, r3
 8004918:	f000 fefa 	bl	8005710 <_test_assert>
 800491c:	4603      	mov	r3, r0
 800491e:	2b00      	cmp	r3, #0
 8004920:	f040 80c0 	bne.w	8004aa4 <mtx4_execute.lto_priv.89+0x2c4>
  chMtxUnlockAll();
 8004924:	f006 fd74 	bl	800b410 <chMtxUnlockAll>
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
 8004928:	f7ff fe6a 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 800492c:	4602      	mov	r2, r0
 800492e:	9b05      	ldr	r3, [sp, #20]
 8004930:	429a      	cmp	r2, r3
 8004932:	bf0c      	ite	eq
 8004934:	2301      	moveq	r3, #1
 8004936:	2300      	movne	r3, #0
 8004938:	b2db      	uxtb	r3, r3
 800493a:	2007      	movs	r0, #7
 800493c:	4619      	mov	r1, r3
 800493e:	f000 fee7 	bl	8005710 <_test_assert>
 8004942:	4603      	mov	r3, r0
 8004944:	2b00      	cmp	r3, #0
 8004946:	f040 80ad 	bne.w	8004aa4 <mtx4_execute.lto_priv.89+0x2c4>
  test_wait_threads();
 800494a:	f000 ff61 	bl	8005810 <test_wait_threads>

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
 800494e:	4b57      	ldr	r3, [pc, #348]	; (8004aac <mtx4_execute.lto_priv.89+0x2cc>)
 8004950:	681a      	ldr	r2, [r3, #0]
 8004952:	4b5e      	ldr	r3, [pc, #376]	; (8004acc <mtx4_execute.lto_priv.89+0x2ec>)
 8004954:	9300      	str	r3, [sp, #0]
 8004956:	4610      	mov	r0, r2
 8004958:	f44f 71b4 	mov.w	r1, #360	; 0x168
 800495c:	9a04      	ldr	r2, [sp, #16]
 800495e:	4b55      	ldr	r3, [pc, #340]	; (8004ab4 <mtx4_execute.lto_priv.89+0x2d4>)
 8004960:	f008 f94e 	bl	800cc00 <chThdCreateStatic>
 8004964:	4602      	mov	r2, r0
 8004966:	4b54      	ldr	r3, [pc, #336]	; (8004ab8 <mtx4_execute.lto_priv.89+0x2d8>)
 8004968:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
 800496a:	4b50      	ldr	r3, [pc, #320]	; (8004aac <mtx4_execute.lto_priv.89+0x2cc>)
 800496c:	685a      	ldr	r2, [r3, #4]
 800496e:	4b58      	ldr	r3, [pc, #352]	; (8004ad0 <mtx4_execute.lto_priv.89+0x2f0>)
 8004970:	9300      	str	r3, [sp, #0]
 8004972:	4610      	mov	r0, r2
 8004974:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004978:	9a03      	ldr	r2, [sp, #12]
 800497a:	4b51      	ldr	r3, [pc, #324]	; (8004ac0 <mtx4_execute.lto_priv.89+0x2e0>)
 800497c:	f008 f940 	bl	800cc00 <chThdCreateStatic>
 8004980:	4602      	mov	r2, r0
 8004982:	4b4d      	ldr	r3, [pc, #308]	; (8004ab8 <mtx4_execute.lto_priv.89+0x2d8>)
 8004984:	605a      	str	r2, [r3, #4]
  chMtxLock(&m2);
 8004986:	484f      	ldr	r0, [pc, #316]	; (8004ac4 <mtx4_execute.lto_priv.89+0x2e4>)
 8004988:	f006 fb8a 	bl	800b0a0 <chMtxLock>
  test_assert(8, chThdGetPriorityX() == p, "wrong priority level");
 800498c:	f7ff fe38 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 8004990:	4602      	mov	r2, r0
 8004992:	9b05      	ldr	r3, [sp, #20]
 8004994:	429a      	cmp	r2, r3
 8004996:	bf0c      	ite	eq
 8004998:	2301      	moveq	r3, #1
 800499a:	2300      	movne	r3, #0
 800499c:	b2db      	uxtb	r3, r3
 800499e:	2008      	movs	r0, #8
 80049a0:	4619      	mov	r1, r3
 80049a2:	f000 feb5 	bl	8005710 <_test_assert>
 80049a6:	4603      	mov	r3, r0
 80049a8:	2b00      	cmp	r3, #0
 80049aa:	d17b      	bne.n	8004aa4 <mtx4_execute.lto_priv.89+0x2c4>
  chThdSleepMilliseconds(100);
 80049ac:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80049b0:	f008 f9b6 	bl	800cd20 <chThdSleep>
  test_assert(9, chThdGetPriorityX() == p1, "wrong priority level");
 80049b4:	f7ff fe24 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 80049b8:	4602      	mov	r2, r0
 80049ba:	9b04      	ldr	r3, [sp, #16]
 80049bc:	429a      	cmp	r2, r3
 80049be:	bf0c      	ite	eq
 80049c0:	2301      	moveq	r3, #1
 80049c2:	2300      	movne	r3, #0
 80049c4:	b2db      	uxtb	r3, r3
 80049c6:	2009      	movs	r0, #9
 80049c8:	4619      	mov	r1, r3
 80049ca:	f000 fea1 	bl	8005710 <_test_assert>
 80049ce:	4603      	mov	r3, r0
 80049d0:	2b00      	cmp	r3, #0
 80049d2:	d167      	bne.n	8004aa4 <mtx4_execute.lto_priv.89+0x2c4>
  chMtxLock(&m1);
 80049d4:	483c      	ldr	r0, [pc, #240]	; (8004ac8 <mtx4_execute.lto_priv.89+0x2e8>)
 80049d6:	f006 fb63 	bl	800b0a0 <chMtxLock>
  test_assert(10, chThdGetPriorityX() == p1, "wrong priority level");
 80049da:	f7ff fe11 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 80049de:	4602      	mov	r2, r0
 80049e0:	9b04      	ldr	r3, [sp, #16]
 80049e2:	429a      	cmp	r2, r3
 80049e4:	bf0c      	ite	eq
 80049e6:	2301      	moveq	r3, #1
 80049e8:	2300      	movne	r3, #0
 80049ea:	b2db      	uxtb	r3, r3
 80049ec:	200a      	movs	r0, #10
 80049ee:	4619      	mov	r1, r3
 80049f0:	f000 fe8e 	bl	8005710 <_test_assert>
 80049f4:	4603      	mov	r3, r0
 80049f6:	2b00      	cmp	r3, #0
 80049f8:	d154      	bne.n	8004aa4 <mtx4_execute.lto_priv.89+0x2c4>
  chThdSleepMilliseconds(100);
 80049fa:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80049fe:	f008 f98f 	bl	800cd20 <chThdSleep>
  test_assert(11, chThdGetPriorityX() == p2, "wrong priority level");
 8004a02:	f7ff fdfd 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 8004a06:	4602      	mov	r2, r0
 8004a08:	9b03      	ldr	r3, [sp, #12]
 8004a0a:	429a      	cmp	r2, r3
 8004a0c:	bf0c      	ite	eq
 8004a0e:	2301      	moveq	r3, #1
 8004a10:	2300      	movne	r3, #0
 8004a12:	b2db      	uxtb	r3, r3
 8004a14:	200b      	movs	r0, #11
 8004a16:	4619      	mov	r1, r3
 8004a18:	f000 fe7a 	bl	8005710 <_test_assert>
 8004a1c:	4603      	mov	r3, r0
 8004a1e:	2b00      	cmp	r3, #0
 8004a20:	d140      	bne.n	8004aa4 <mtx4_execute.lto_priv.89+0x2c4>
  chSysLock();
 8004a22:	f7ff fdbd 	bl	80045a0 <chSysLock.lto_priv.201>
  chMtxUnlockS(&m1);
 8004a26:	4828      	ldr	r0, [pc, #160]	; (8004ac8 <mtx4_execute.lto_priv.89+0x2e8>)
 8004a28:	f006 fc82 	bl	800b330 <chMtxUnlockS>
  chSchRescheduleS();
 8004a2c:	f007 fe30 	bl	800c690 <chSchRescheduleS>
  chSysUnlock();
 8004a30:	f7ff fdbe 	bl	80045b0 <chSysUnlock.lto_priv.199>
  test_assert(12, chThdGetPriorityX() == p1, "wrong priority level");
 8004a34:	f7ff fde4 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 8004a38:	4602      	mov	r2, r0
 8004a3a:	9b04      	ldr	r3, [sp, #16]
 8004a3c:	429a      	cmp	r2, r3
 8004a3e:	bf0c      	ite	eq
 8004a40:	2301      	moveq	r3, #1
 8004a42:	2300      	movne	r3, #0
 8004a44:	b2db      	uxtb	r3, r3
 8004a46:	200c      	movs	r0, #12
 8004a48:	4619      	mov	r1, r3
 8004a4a:	f000 fe61 	bl	8005710 <_test_assert>
 8004a4e:	4603      	mov	r3, r0
 8004a50:	2b00      	cmp	r3, #0
 8004a52:	d127      	bne.n	8004aa4 <mtx4_execute.lto_priv.89+0x2c4>
  chThdSleepMilliseconds(100);
 8004a54:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8004a58:	f008 f962 	bl	800cd20 <chThdSleep>
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
 8004a5c:	f7ff fdd0 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 8004a60:	4602      	mov	r2, r0
 8004a62:	9b04      	ldr	r3, [sp, #16]
 8004a64:	429a      	cmp	r2, r3
 8004a66:	bf0c      	ite	eq
 8004a68:	2301      	moveq	r3, #1
 8004a6a:	2300      	movne	r3, #0
 8004a6c:	b2db      	uxtb	r3, r3
 8004a6e:	200d      	movs	r0, #13
 8004a70:	4619      	mov	r1, r3
 8004a72:	f000 fe4d 	bl	8005710 <_test_assert>
 8004a76:	4603      	mov	r3, r0
 8004a78:	2b00      	cmp	r3, #0
 8004a7a:	d113      	bne.n	8004aa4 <mtx4_execute.lto_priv.89+0x2c4>
  chMtxUnlockAll();
 8004a7c:	f006 fcc8 	bl	800b410 <chMtxUnlockAll>
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
 8004a80:	f7ff fdbe 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 8004a84:	4602      	mov	r2, r0
 8004a86:	9b05      	ldr	r3, [sp, #20]
 8004a88:	429a      	cmp	r2, r3
 8004a8a:	bf0c      	ite	eq
 8004a8c:	2301      	moveq	r3, #1
 8004a8e:	2300      	movne	r3, #0
 8004a90:	b2db      	uxtb	r3, r3
 8004a92:	200e      	movs	r0, #14
 8004a94:	4619      	mov	r1, r3
 8004a96:	f000 fe3b 	bl	8005710 <_test_assert>
 8004a9a:	4603      	mov	r3, r0
 8004a9c:	2b00      	cmp	r3, #0
 8004a9e:	d101      	bne.n	8004aa4 <mtx4_execute.lto_priv.89+0x2c4>
  test_wait_threads();
 8004aa0:	f000 feb6 	bl	8005810 <test_wait_threads>
}
 8004aa4:	b007      	add	sp, #28
 8004aa6:	f85d fb04 	ldr.w	pc, [sp], #4
 8004aaa:	bf00      	nop
 8004aac:	0800e420 	.word	0x0800e420
 8004ab0:	0800d874 	.word	0x0800d874
 8004ab4:	08004781 	.word	0x08004781
 8004ab8:	20001bf8 	.word	0x20001bf8
 8004abc:	0800d870 	.word	0x0800d870
 8004ac0:	080047b1 	.word	0x080047b1
 8004ac4:	20000850 	.word	0x20000850
 8004ac8:	20000840 	.word	0x20000840
 8004acc:	0800d87c 	.word	0x0800d87c
 8004ad0:	0800d878 	.word	0x0800d878
	...

08004ae0 <mtx5_setup.lto_priv.86>:
 * unlock operations.<br>
 * The test expects that the internal mutex status is consistent after each
 * operation.
 */

static void mtx5_setup(void) {
 8004ae0:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 8004ae2:	4802      	ldr	r0, [pc, #8]	; (8004aec <mtx5_setup.lto_priv.86+0xc>)
 8004ae4:	f006 fac4 	bl	800b070 <chMtxObjectInit>
}
 8004ae8:	bd08      	pop	{r3, pc}
 8004aea:	bf00      	nop
 8004aec:	20000840 	.word	0x20000840

08004af0 <mtx5_execute.lto_priv.87>:

static void mtx5_execute(void) {
 8004af0:	b500      	push	{lr}
 8004af2:	b083      	sub	sp, #12

#if !CH_CFG_USE_MUTEXES_RECURSIVE
  bool b;
  tprio_t prio = chThdGetPriorityX();
 8004af4:	f7ff fd84 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 8004af8:	9001      	str	r0, [sp, #4]

  b = chMtxTryLock(&m1);
 8004afa:	483b      	ldr	r0, [pc, #236]	; (8004be8 <mtx5_execute.lto_priv.87+0xf8>)
 8004afc:	f006 fb60 	bl	800b1c0 <chMtxTryLock>
 8004b00:	4603      	mov	r3, r0
 8004b02:	f88d 3003 	strb.w	r3, [sp, #3]
  test_assert(1, b, "already locked");
 8004b06:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004b0a:	2001      	movs	r0, #1
 8004b0c:	4619      	mov	r1, r3
 8004b0e:	f000 fdff 	bl	8005710 <_test_assert>
 8004b12:	4603      	mov	r3, r0
 8004b14:	2b00      	cmp	r3, #0
 8004b16:	d164      	bne.n	8004be2 <mtx5_execute.lto_priv.87+0xf2>

  b = chMtxTryLock(&m1);
 8004b18:	4833      	ldr	r0, [pc, #204]	; (8004be8 <mtx5_execute.lto_priv.87+0xf8>)
 8004b1a:	f006 fb51 	bl	800b1c0 <chMtxTryLock>
 8004b1e:	4603      	mov	r3, r0
 8004b20:	f88d 3003 	strb.w	r3, [sp, #3]
  test_assert(2, !b, "not locked");
 8004b24:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8004b28:	2b00      	cmp	r3, #0
 8004b2a:	bf14      	ite	ne
 8004b2c:	2301      	movne	r3, #1
 8004b2e:	2300      	moveq	r3, #0
 8004b30:	b2db      	uxtb	r3, r3
 8004b32:	f083 0301 	eor.w	r3, r3, #1
 8004b36:	b2db      	uxtb	r3, r3
 8004b38:	f003 0301 	and.w	r3, r3, #1
 8004b3c:	b2db      	uxtb	r3, r3
 8004b3e:	2002      	movs	r0, #2
 8004b40:	4619      	mov	r1, r3
 8004b42:	f000 fde5 	bl	8005710 <_test_assert>
 8004b46:	4603      	mov	r3, r0
 8004b48:	2b00      	cmp	r3, #0
 8004b4a:	d14a      	bne.n	8004be2 <mtx5_execute.lto_priv.87+0xf2>

  chSysLock();
 8004b4c:	f7ff fd28 	bl	80045a0 <chSysLock.lto_priv.201>
  chMtxUnlockS(&m1);
 8004b50:	4825      	ldr	r0, [pc, #148]	; (8004be8 <mtx5_execute.lto_priv.87+0xf8>)
 8004b52:	f006 fbed 	bl	800b330 <chMtxUnlockS>
  chSysUnlock();
 8004b56:	f7ff fd2b 	bl	80045b0 <chSysUnlock.lto_priv.199>

  test_assert(3, queue_isempty(&m1.m_queue), "queue not empty");
 8004b5a:	4823      	ldr	r0, [pc, #140]	; (8004be8 <mtx5_execute.lto_priv.87+0xf8>)
 8004b5c:	f7ff fd10 	bl	8004580 <queue_isempty.lto_priv.203>
 8004b60:	4603      	mov	r3, r0
 8004b62:	2003      	movs	r0, #3
 8004b64:	4619      	mov	r1, r3
 8004b66:	f000 fdd3 	bl	8005710 <_test_assert>
 8004b6a:	4603      	mov	r3, r0
 8004b6c:	2b00      	cmp	r3, #0
 8004b6e:	d138      	bne.n	8004be2 <mtx5_execute.lto_priv.87+0xf2>
  test_assert(4, m1.m_owner == NULL, "still owned");
 8004b70:	4b1d      	ldr	r3, [pc, #116]	; (8004be8 <mtx5_execute.lto_priv.87+0xf8>)
 8004b72:	689b      	ldr	r3, [r3, #8]
 8004b74:	2b00      	cmp	r3, #0
 8004b76:	bf0c      	ite	eq
 8004b78:	2301      	moveq	r3, #1
 8004b7a:	2300      	movne	r3, #0
 8004b7c:	b2db      	uxtb	r3, r3
 8004b7e:	2004      	movs	r0, #4
 8004b80:	4619      	mov	r1, r3
 8004b82:	f000 fdc5 	bl	8005710 <_test_assert>
 8004b86:	4603      	mov	r3, r0
 8004b88:	2b00      	cmp	r3, #0
 8004b8a:	d12a      	bne.n	8004be2 <mtx5_execute.lto_priv.87+0xf2>
  test_assert(5, chThdGetPriorityX() == prio, "wrong priority level");
 8004b8c:	f7ff fd38 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 8004b90:	4602      	mov	r2, r0
 8004b92:	9b01      	ldr	r3, [sp, #4]
 8004b94:	429a      	cmp	r2, r3
 8004b96:	bf0c      	ite	eq
 8004b98:	2301      	moveq	r3, #1
 8004b9a:	2300      	movne	r3, #0
 8004b9c:	b2db      	uxtb	r3, r3
 8004b9e:	2005      	movs	r0, #5
 8004ba0:	4619      	mov	r1, r3
 8004ba2:	f000 fdb5 	bl	8005710 <_test_assert>
 8004ba6:	4603      	mov	r3, r0
 8004ba8:	2b00      	cmp	r3, #0
 8004baa:	d11a      	bne.n	8004be2 <mtx5_execute.lto_priv.87+0xf2>
#endif /* !CH_CFG_USE_MUTEXES_RECURSIVE */
  
  chMtxLock(&m1);
 8004bac:	480e      	ldr	r0, [pc, #56]	; (8004be8 <mtx5_execute.lto_priv.87+0xf8>)
 8004bae:	f006 fa77 	bl	800b0a0 <chMtxLock>
  chMtxUnlockAll();
 8004bb2:	f006 fc2d 	bl	800b410 <chMtxUnlockAll>
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
 8004bb6:	480c      	ldr	r0, [pc, #48]	; (8004be8 <mtx5_execute.lto_priv.87+0xf8>)
 8004bb8:	f7ff fce2 	bl	8004580 <queue_isempty.lto_priv.203>
 8004bbc:	4603      	mov	r3, r0
 8004bbe:	2006      	movs	r0, #6
 8004bc0:	4619      	mov	r1, r3
 8004bc2:	f000 fda5 	bl	8005710 <_test_assert>
 8004bc6:	4603      	mov	r3, r0
 8004bc8:	2b00      	cmp	r3, #0
 8004bca:	d10a      	bne.n	8004be2 <mtx5_execute.lto_priv.87+0xf2>
  test_assert(7, m1.m_owner == NULL, "still owned");
 8004bcc:	4b06      	ldr	r3, [pc, #24]	; (8004be8 <mtx5_execute.lto_priv.87+0xf8>)
 8004bce:	689b      	ldr	r3, [r3, #8]
 8004bd0:	2b00      	cmp	r3, #0
 8004bd2:	bf0c      	ite	eq
 8004bd4:	2301      	moveq	r3, #1
 8004bd6:	2300      	movne	r3, #0
 8004bd8:	b2db      	uxtb	r3, r3
 8004bda:	2007      	movs	r0, #7
 8004bdc:	4619      	mov	r1, r3
 8004bde:	f000 fd97 	bl	8005710 <_test_assert>
}
 8004be2:	b003      	add	sp, #12
 8004be4:	f85d fb04 	ldr.w	pc, [sp], #4
 8004be8:	20000840 	.word	0x20000840
 8004bec:	00000000 	.word	0x00000000

08004bf0 <mtx6_setup.lto_priv.84>:
 * atomically.<br>
 * The test expects the threads to reach their goal in increasing priority
 * order regardless of the initial order.
 */

static void mtx6_setup(void) {
 8004bf0:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 8004bf2:	4803      	ldr	r0, [pc, #12]	; (8004c00 <mtx6_setup.lto_priv.84+0x10>)
 8004bf4:	f004 f994 	bl	8008f20 <chCondObjectInit>
  chMtxObjectInit(&m1);
 8004bf8:	4802      	ldr	r0, [pc, #8]	; (8004c04 <mtx6_setup.lto_priv.84+0x14>)
 8004bfa:	f006 fa39 	bl	800b070 <chMtxObjectInit>
}
 8004bfe:	bd08      	pop	{r3, pc}
 8004c00:	20000860 	.word	0x20000860
 8004c04:	20000840 	.word	0x20000840
	...

08004c10 <thread10>:

static THD_FUNCTION(thread10, p) {
 8004c10:	b500      	push	{lr}
 8004c12:	b083      	sub	sp, #12
 8004c14:	9001      	str	r0, [sp, #4]

  chMtxLock(&m1);
 8004c16:	4808      	ldr	r0, [pc, #32]	; (8004c38 <thread10+0x28>)
 8004c18:	f006 fa42 	bl	800b0a0 <chMtxLock>
  chCondWait(&c1);
 8004c1c:	4807      	ldr	r0, [pc, #28]	; (8004c3c <thread10+0x2c>)
 8004c1e:	f004 fa1f 	bl	8009060 <chCondWait>
  test_emit_token(*(char *)p);
 8004c22:	9b01      	ldr	r3, [sp, #4]
 8004c24:	781b      	ldrb	r3, [r3, #0]
 8004c26:	4618      	mov	r0, r3
 8004c28:	f000 fd42 	bl	80056b0 <test_emit_token>
  chMtxUnlock(&m1);
 8004c2c:	4802      	ldr	r0, [pc, #8]	; (8004c38 <thread10+0x28>)
 8004c2e:	f006 fb07 	bl	800b240 <chMtxUnlock>
}
 8004c32:	b003      	add	sp, #12
 8004c34:	f85d fb04 	ldr.w	pc, [sp], #4
 8004c38:	20000840 	.word	0x20000840
 8004c3c:	20000860 	.word	0x20000860

08004c40 <mtx6_execute.lto_priv.85>:

static void mtx6_execute(void) {
 8004c40:	b500      	push	{lr}
 8004c42:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX();
 8004c44:	f7ff fcdc 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 8004c48:	9003      	str	r0, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8004c4a:	4b34      	ldr	r3, [pc, #208]	; (8004d1c <mtx6_execute.lto_priv.85+0xdc>)
 8004c4c:	6819      	ldr	r1, [r3, #0]
 8004c4e:	9b03      	ldr	r3, [sp, #12]
 8004c50:	1c5a      	adds	r2, r3, #1
 8004c52:	4b33      	ldr	r3, [pc, #204]	; (8004d20 <mtx6_execute.lto_priv.85+0xe0>)
 8004c54:	9300      	str	r3, [sp, #0]
 8004c56:	4608      	mov	r0, r1
 8004c58:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004c5c:	4b31      	ldr	r3, [pc, #196]	; (8004d24 <mtx6_execute.lto_priv.85+0xe4>)
 8004c5e:	f007 ffcf 	bl	800cc00 <chThdCreateStatic>
 8004c62:	4602      	mov	r2, r0
 8004c64:	4b30      	ldr	r3, [pc, #192]	; (8004d28 <mtx6_execute.lto_priv.85+0xe8>)
 8004c66:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8004c68:	4b2c      	ldr	r3, [pc, #176]	; (8004d1c <mtx6_execute.lto_priv.85+0xdc>)
 8004c6a:	6859      	ldr	r1, [r3, #4]
 8004c6c:	9b03      	ldr	r3, [sp, #12]
 8004c6e:	1c9a      	adds	r2, r3, #2
 8004c70:	4b2e      	ldr	r3, [pc, #184]	; (8004d2c <mtx6_execute.lto_priv.85+0xec>)
 8004c72:	9300      	str	r3, [sp, #0]
 8004c74:	4608      	mov	r0, r1
 8004c76:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004c7a:	4b2a      	ldr	r3, [pc, #168]	; (8004d24 <mtx6_execute.lto_priv.85+0xe4>)
 8004c7c:	f007 ffc0 	bl	800cc00 <chThdCreateStatic>
 8004c80:	4602      	mov	r2, r0
 8004c82:	4b29      	ldr	r3, [pc, #164]	; (8004d28 <mtx6_execute.lto_priv.85+0xe8>)
 8004c84:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8004c86:	4b25      	ldr	r3, [pc, #148]	; (8004d1c <mtx6_execute.lto_priv.85+0xdc>)
 8004c88:	6899      	ldr	r1, [r3, #8]
 8004c8a:	9b03      	ldr	r3, [sp, #12]
 8004c8c:	1cda      	adds	r2, r3, #3
 8004c8e:	4b28      	ldr	r3, [pc, #160]	; (8004d30 <mtx6_execute.lto_priv.85+0xf0>)
 8004c90:	9300      	str	r3, [sp, #0]
 8004c92:	4608      	mov	r0, r1
 8004c94:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004c98:	4b22      	ldr	r3, [pc, #136]	; (8004d24 <mtx6_execute.lto_priv.85+0xe4>)
 8004c9a:	f007 ffb1 	bl	800cc00 <chThdCreateStatic>
 8004c9e:	4602      	mov	r2, r0
 8004ca0:	4b21      	ldr	r3, [pc, #132]	; (8004d28 <mtx6_execute.lto_priv.85+0xe8>)
 8004ca2:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8004ca4:	4b1d      	ldr	r3, [pc, #116]	; (8004d1c <mtx6_execute.lto_priv.85+0xdc>)
 8004ca6:	68d9      	ldr	r1, [r3, #12]
 8004ca8:	9b03      	ldr	r3, [sp, #12]
 8004caa:	1d1a      	adds	r2, r3, #4
 8004cac:	4b21      	ldr	r3, [pc, #132]	; (8004d34 <mtx6_execute.lto_priv.85+0xf4>)
 8004cae:	9300      	str	r3, [sp, #0]
 8004cb0:	4608      	mov	r0, r1
 8004cb2:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004cb6:	4b1b      	ldr	r3, [pc, #108]	; (8004d24 <mtx6_execute.lto_priv.85+0xe4>)
 8004cb8:	f007 ffa2 	bl	800cc00 <chThdCreateStatic>
 8004cbc:	4602      	mov	r2, r0
 8004cbe:	4b1a      	ldr	r3, [pc, #104]	; (8004d28 <mtx6_execute.lto_priv.85+0xe8>)
 8004cc0:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8004cc2:	4b16      	ldr	r3, [pc, #88]	; (8004d1c <mtx6_execute.lto_priv.85+0xdc>)
 8004cc4:	6919      	ldr	r1, [r3, #16]
 8004cc6:	9b03      	ldr	r3, [sp, #12]
 8004cc8:	1d5a      	adds	r2, r3, #5
 8004cca:	4b1b      	ldr	r3, [pc, #108]	; (8004d38 <mtx6_execute.lto_priv.85+0xf8>)
 8004ccc:	9300      	str	r3, [sp, #0]
 8004cce:	4608      	mov	r0, r1
 8004cd0:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004cd4:	4b13      	ldr	r3, [pc, #76]	; (8004d24 <mtx6_execute.lto_priv.85+0xe4>)
 8004cd6:	f007 ff93 	bl	800cc00 <chThdCreateStatic>
 8004cda:	4602      	mov	r2, r0
 8004cdc:	4b12      	ldr	r3, [pc, #72]	; (8004d28 <mtx6_execute.lto_priv.85+0xe8>)
 8004cde:	611a      	str	r2, [r3, #16]
  chSysLock();
 8004ce0:	f7ff fc5e 	bl	80045a0 <chSysLock.lto_priv.201>
  chCondSignalI(&c1);
 8004ce4:	4815      	ldr	r0, [pc, #84]	; (8004d3c <mtx6_execute.lto_priv.85+0xfc>)
 8004ce6:	f004 f95b 	bl	8008fa0 <chCondSignalI>
  chCondSignalI(&c1);
 8004cea:	4814      	ldr	r0, [pc, #80]	; (8004d3c <mtx6_execute.lto_priv.85+0xfc>)
 8004cec:	f004 f958 	bl	8008fa0 <chCondSignalI>
  chCondSignalI(&c1);
 8004cf0:	4812      	ldr	r0, [pc, #72]	; (8004d3c <mtx6_execute.lto_priv.85+0xfc>)
 8004cf2:	f004 f955 	bl	8008fa0 <chCondSignalI>
  chCondSignalI(&c1);
 8004cf6:	4811      	ldr	r0, [pc, #68]	; (8004d3c <mtx6_execute.lto_priv.85+0xfc>)
 8004cf8:	f004 f952 	bl	8008fa0 <chCondSignalI>
  chCondSignalI(&c1);
 8004cfc:	480f      	ldr	r0, [pc, #60]	; (8004d3c <mtx6_execute.lto_priv.85+0xfc>)
 8004cfe:	f004 f94f 	bl	8008fa0 <chCondSignalI>
  chSchRescheduleS();
 8004d02:	f007 fcc5 	bl	800c690 <chSchRescheduleS>
  chSysUnlock();
 8004d06:	f7ff fc53 	bl	80045b0 <chSysUnlock.lto_priv.199>
  test_wait_threads();
 8004d0a:	f000 fd81 	bl	8005810 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8004d0e:	2001      	movs	r0, #1
 8004d10:	490b      	ldr	r1, [pc, #44]	; (8004d40 <mtx6_execute.lto_priv.85+0x100>)
 8004d12:	f000 fd15 	bl	8005740 <_test_assert_sequence>
}
 8004d16:	b005      	add	sp, #20
 8004d18:	f85d fb04 	ldr.w	pc, [sp], #4
 8004d1c:	0800e420 	.word	0x0800e420
 8004d20:	0800d880 	.word	0x0800d880
 8004d24:	08004c11 	.word	0x08004c11
 8004d28:	20001bf8 	.word	0x20001bf8
 8004d2c:	0800d87c 	.word	0x0800d87c
 8004d30:	0800d878 	.word	0x0800d878
 8004d34:	0800d874 	.word	0x0800d874
 8004d38:	0800d870 	.word	0x0800d870
 8004d3c:	20000860 	.word	0x20000860
 8004d40:	0800d884 	.word	0x0800d884
	...

08004d50 <mtx7_setup.lto_priv.82>:
 * tester thread then proceeds to broadcast the conditional variable.<br>
 * The test expects the threads to reach their goal in increasing priority
 * order regardless of the initial order.
 */

static void mtx7_setup(void) {
 8004d50:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 8004d52:	4803      	ldr	r0, [pc, #12]	; (8004d60 <mtx7_setup.lto_priv.82+0x10>)
 8004d54:	f004 f8e4 	bl	8008f20 <chCondObjectInit>
  chMtxObjectInit(&m1);
 8004d58:	4802      	ldr	r0, [pc, #8]	; (8004d64 <mtx7_setup.lto_priv.82+0x14>)
 8004d5a:	f006 f989 	bl	800b070 <chMtxObjectInit>
}
 8004d5e:	bd08      	pop	{r3, pc}
 8004d60:	20000860 	.word	0x20000860
 8004d64:	20000840 	.word	0x20000840
	...

08004d70 <mtx7_execute.lto_priv.83>:

static void mtx7_execute(void) {
 8004d70:	b500      	push	{lr}
 8004d72:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX();
 8004d74:	f7ff fc44 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 8004d78:	9003      	str	r0, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8004d7a:	4b2b      	ldr	r3, [pc, #172]	; (8004e28 <mtx7_execute.lto_priv.83+0xb8>)
 8004d7c:	6819      	ldr	r1, [r3, #0]
 8004d7e:	9b03      	ldr	r3, [sp, #12]
 8004d80:	1c5a      	adds	r2, r3, #1
 8004d82:	4b2a      	ldr	r3, [pc, #168]	; (8004e2c <mtx7_execute.lto_priv.83+0xbc>)
 8004d84:	9300      	str	r3, [sp, #0]
 8004d86:	4608      	mov	r0, r1
 8004d88:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004d8c:	4b28      	ldr	r3, [pc, #160]	; (8004e30 <mtx7_execute.lto_priv.83+0xc0>)
 8004d8e:	f007 ff37 	bl	800cc00 <chThdCreateStatic>
 8004d92:	4602      	mov	r2, r0
 8004d94:	4b27      	ldr	r3, [pc, #156]	; (8004e34 <mtx7_execute.lto_priv.83+0xc4>)
 8004d96:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8004d98:	4b23      	ldr	r3, [pc, #140]	; (8004e28 <mtx7_execute.lto_priv.83+0xb8>)
 8004d9a:	6859      	ldr	r1, [r3, #4]
 8004d9c:	9b03      	ldr	r3, [sp, #12]
 8004d9e:	1c9a      	adds	r2, r3, #2
 8004da0:	4b25      	ldr	r3, [pc, #148]	; (8004e38 <mtx7_execute.lto_priv.83+0xc8>)
 8004da2:	9300      	str	r3, [sp, #0]
 8004da4:	4608      	mov	r0, r1
 8004da6:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004daa:	4b21      	ldr	r3, [pc, #132]	; (8004e30 <mtx7_execute.lto_priv.83+0xc0>)
 8004dac:	f007 ff28 	bl	800cc00 <chThdCreateStatic>
 8004db0:	4602      	mov	r2, r0
 8004db2:	4b20      	ldr	r3, [pc, #128]	; (8004e34 <mtx7_execute.lto_priv.83+0xc4>)
 8004db4:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8004db6:	4b1c      	ldr	r3, [pc, #112]	; (8004e28 <mtx7_execute.lto_priv.83+0xb8>)
 8004db8:	6899      	ldr	r1, [r3, #8]
 8004dba:	9b03      	ldr	r3, [sp, #12]
 8004dbc:	1cda      	adds	r2, r3, #3
 8004dbe:	4b1f      	ldr	r3, [pc, #124]	; (8004e3c <mtx7_execute.lto_priv.83+0xcc>)
 8004dc0:	9300      	str	r3, [sp, #0]
 8004dc2:	4608      	mov	r0, r1
 8004dc4:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004dc8:	4b19      	ldr	r3, [pc, #100]	; (8004e30 <mtx7_execute.lto_priv.83+0xc0>)
 8004dca:	f007 ff19 	bl	800cc00 <chThdCreateStatic>
 8004dce:	4602      	mov	r2, r0
 8004dd0:	4b18      	ldr	r3, [pc, #96]	; (8004e34 <mtx7_execute.lto_priv.83+0xc4>)
 8004dd2:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8004dd4:	4b14      	ldr	r3, [pc, #80]	; (8004e28 <mtx7_execute.lto_priv.83+0xb8>)
 8004dd6:	68d9      	ldr	r1, [r3, #12]
 8004dd8:	9b03      	ldr	r3, [sp, #12]
 8004dda:	1d1a      	adds	r2, r3, #4
 8004ddc:	4b18      	ldr	r3, [pc, #96]	; (8004e40 <mtx7_execute.lto_priv.83+0xd0>)
 8004dde:	9300      	str	r3, [sp, #0]
 8004de0:	4608      	mov	r0, r1
 8004de2:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004de6:	4b12      	ldr	r3, [pc, #72]	; (8004e30 <mtx7_execute.lto_priv.83+0xc0>)
 8004de8:	f007 ff0a 	bl	800cc00 <chThdCreateStatic>
 8004dec:	4602      	mov	r2, r0
 8004dee:	4b11      	ldr	r3, [pc, #68]	; (8004e34 <mtx7_execute.lto_priv.83+0xc4>)
 8004df0:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8004df2:	4b0d      	ldr	r3, [pc, #52]	; (8004e28 <mtx7_execute.lto_priv.83+0xb8>)
 8004df4:	6919      	ldr	r1, [r3, #16]
 8004df6:	9b03      	ldr	r3, [sp, #12]
 8004df8:	1d5a      	adds	r2, r3, #5
 8004dfa:	4b12      	ldr	r3, [pc, #72]	; (8004e44 <mtx7_execute.lto_priv.83+0xd4>)
 8004dfc:	9300      	str	r3, [sp, #0]
 8004dfe:	4608      	mov	r0, r1
 8004e00:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004e04:	4b0a      	ldr	r3, [pc, #40]	; (8004e30 <mtx7_execute.lto_priv.83+0xc0>)
 8004e06:	f007 fefb 	bl	800cc00 <chThdCreateStatic>
 8004e0a:	4602      	mov	r2, r0
 8004e0c:	4b09      	ldr	r3, [pc, #36]	; (8004e34 <mtx7_execute.lto_priv.83+0xc4>)
 8004e0e:	611a      	str	r2, [r3, #16]
  chCondBroadcast(&c1);
 8004e10:	480d      	ldr	r0, [pc, #52]	; (8004e48 <mtx7_execute.lto_priv.83+0xd8>)
 8004e12:	f004 f8ed 	bl	8008ff0 <chCondBroadcast>
  test_wait_threads();
 8004e16:	f000 fcfb 	bl	8005810 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8004e1a:	2001      	movs	r0, #1
 8004e1c:	490b      	ldr	r1, [pc, #44]	; (8004e4c <mtx7_execute.lto_priv.83+0xdc>)
 8004e1e:	f000 fc8f 	bl	8005740 <_test_assert_sequence>
}
 8004e22:	b005      	add	sp, #20
 8004e24:	f85d fb04 	ldr.w	pc, [sp], #4
 8004e28:	0800e420 	.word	0x0800e420
 8004e2c:	0800d880 	.word	0x0800d880
 8004e30:	08004c11 	.word	0x08004c11
 8004e34:	20001bf8 	.word	0x20001bf8
 8004e38:	0800d87c 	.word	0x0800d87c
 8004e3c:	0800d878 	.word	0x0800d878
 8004e40:	0800d874 	.word	0x0800d874
 8004e44:	0800d870 	.word	0x0800d870
 8004e48:	20000860 	.word	0x20000860
 8004e4c:	0800d884 	.word	0x0800d884

08004e50 <mtx8_setup.lto_priv.80>:
 * This test case verifies the priority boost of a thread waiting on a
 * conditional variable queue. It tests this very specific situation in order
 * to complete the code coverage.
 */

static void mtx8_setup(void) {
 8004e50:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 8004e52:	4805      	ldr	r0, [pc, #20]	; (8004e68 <mtx8_setup.lto_priv.80+0x18>)
 8004e54:	f004 f864 	bl	8008f20 <chCondObjectInit>
  chMtxObjectInit(&m1);
 8004e58:	4804      	ldr	r0, [pc, #16]	; (8004e6c <mtx8_setup.lto_priv.80+0x1c>)
 8004e5a:	f006 f909 	bl	800b070 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 8004e5e:	4804      	ldr	r0, [pc, #16]	; (8004e70 <mtx8_setup.lto_priv.80+0x20>)
 8004e60:	f006 f906 	bl	800b070 <chMtxObjectInit>
}
 8004e64:	bd08      	pop	{r3, pc}
 8004e66:	bf00      	nop
 8004e68:	20000860 	.word	0x20000860
 8004e6c:	20000840 	.word	0x20000840
 8004e70:	20000850 	.word	0x20000850
	...

08004e80 <thread11>:

static THD_FUNCTION(thread11, p) {
 8004e80:	b500      	push	{lr}
 8004e82:	b083      	sub	sp, #12
 8004e84:	9001      	str	r0, [sp, #4]

  chMtxLock(&m2);
 8004e86:	480c      	ldr	r0, [pc, #48]	; (8004eb8 <thread11+0x38>)
 8004e88:	f006 f90a 	bl	800b0a0 <chMtxLock>
  chMtxLock(&m1);
 8004e8c:	480b      	ldr	r0, [pc, #44]	; (8004ebc <thread11+0x3c>)
 8004e8e:	f006 f907 	bl	800b0a0 <chMtxLock>
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
 8004e92:	480b      	ldr	r0, [pc, #44]	; (8004ec0 <thread11+0x40>)
 8004e94:	f04f 31ff 	mov.w	r1, #4294967295
 8004e98:	f004 f92a 	bl	80090f0 <chCondWaitTimeout>
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
 8004e9c:	9b01      	ldr	r3, [sp, #4]
 8004e9e:	781b      	ldrb	r3, [r3, #0]
 8004ea0:	4618      	mov	r0, r3
 8004ea2:	f000 fc05 	bl	80056b0 <test_emit_token>
  chMtxUnlock(&m1);
 8004ea6:	4805      	ldr	r0, [pc, #20]	; (8004ebc <thread11+0x3c>)
 8004ea8:	f006 f9ca 	bl	800b240 <chMtxUnlock>
  chMtxUnlock(&m2);
 8004eac:	4802      	ldr	r0, [pc, #8]	; (8004eb8 <thread11+0x38>)
 8004eae:	f006 f9c7 	bl	800b240 <chMtxUnlock>
}
 8004eb2:	b003      	add	sp, #12
 8004eb4:	f85d fb04 	ldr.w	pc, [sp], #4
 8004eb8:	20000850 	.word	0x20000850
 8004ebc:	20000840 	.word	0x20000840
 8004ec0:	20000860 	.word	0x20000860
	...

08004ed0 <thread12>:

static THD_FUNCTION(thread12, p) {
 8004ed0:	b500      	push	{lr}
 8004ed2:	b083      	sub	sp, #12
 8004ed4:	9001      	str	r0, [sp, #4]

  chMtxLock(&m2);
 8004ed6:	4807      	ldr	r0, [pc, #28]	; (8004ef4 <thread12+0x24>)
 8004ed8:	f006 f8e2 	bl	800b0a0 <chMtxLock>
  test_emit_token(*(char *)p);
 8004edc:	9b01      	ldr	r3, [sp, #4]
 8004ede:	781b      	ldrb	r3, [r3, #0]
 8004ee0:	4618      	mov	r0, r3
 8004ee2:	f000 fbe5 	bl	80056b0 <test_emit_token>
  chMtxUnlock(&m2);
 8004ee6:	4803      	ldr	r0, [pc, #12]	; (8004ef4 <thread12+0x24>)
 8004ee8:	f006 f9aa 	bl	800b240 <chMtxUnlock>
}
 8004eec:	b003      	add	sp, #12
 8004eee:	f85d fb04 	ldr.w	pc, [sp], #4
 8004ef2:	bf00      	nop
 8004ef4:	20000850 	.word	0x20000850
	...

08004f00 <mtx8_execute.lto_priv.81>:

static void mtx8_execute(void) {
 8004f00:	b500      	push	{lr}
 8004f02:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX();
 8004f04:	f7ff fb7c 	bl	8004600 <chThdGetPriorityX.lto_priv.189>
 8004f08:	9003      	str	r0, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 8004f0a:	4b1e      	ldr	r3, [pc, #120]	; (8004f84 <mtx8_execute.lto_priv.81+0x84>)
 8004f0c:	6819      	ldr	r1, [r3, #0]
 8004f0e:	9b03      	ldr	r3, [sp, #12]
 8004f10:	1c5a      	adds	r2, r3, #1
 8004f12:	4b1d      	ldr	r3, [pc, #116]	; (8004f88 <mtx8_execute.lto_priv.81+0x88>)
 8004f14:	9300      	str	r3, [sp, #0]
 8004f16:	4608      	mov	r0, r1
 8004f18:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004f1c:	4b1b      	ldr	r3, [pc, #108]	; (8004f8c <mtx8_execute.lto_priv.81+0x8c>)
 8004f1e:	f007 fe6f 	bl	800cc00 <chThdCreateStatic>
 8004f22:	4602      	mov	r2, r0
 8004f24:	4b1a      	ldr	r3, [pc, #104]	; (8004f90 <mtx8_execute.lto_priv.81+0x90>)
 8004f26:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 8004f28:	4b16      	ldr	r3, [pc, #88]	; (8004f84 <mtx8_execute.lto_priv.81+0x84>)
 8004f2a:	6859      	ldr	r1, [r3, #4]
 8004f2c:	9b03      	ldr	r3, [sp, #12]
 8004f2e:	1c9a      	adds	r2, r3, #2
 8004f30:	4b18      	ldr	r3, [pc, #96]	; (8004f94 <mtx8_execute.lto_priv.81+0x94>)
 8004f32:	9300      	str	r3, [sp, #0]
 8004f34:	4608      	mov	r0, r1
 8004f36:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004f3a:	4b17      	ldr	r3, [pc, #92]	; (8004f98 <mtx8_execute.lto_priv.81+0x98>)
 8004f3c:	f007 fe60 	bl	800cc00 <chThdCreateStatic>
 8004f40:	4602      	mov	r2, r0
 8004f42:	4b13      	ldr	r3, [pc, #76]	; (8004f90 <mtx8_execute.lto_priv.81+0x90>)
 8004f44:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 8004f46:	4b0f      	ldr	r3, [pc, #60]	; (8004f84 <mtx8_execute.lto_priv.81+0x84>)
 8004f48:	6899      	ldr	r1, [r3, #8]
 8004f4a:	9b03      	ldr	r3, [sp, #12]
 8004f4c:	1cda      	adds	r2, r3, #3
 8004f4e:	4b13      	ldr	r3, [pc, #76]	; (8004f9c <mtx8_execute.lto_priv.81+0x9c>)
 8004f50:	9300      	str	r3, [sp, #0]
 8004f52:	4608      	mov	r0, r1
 8004f54:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8004f58:	4b11      	ldr	r3, [pc, #68]	; (8004fa0 <mtx8_execute.lto_priv.81+0xa0>)
 8004f5a:	f007 fe51 	bl	800cc00 <chThdCreateStatic>
 8004f5e:	4602      	mov	r2, r0
 8004f60:	4b0b      	ldr	r3, [pc, #44]	; (8004f90 <mtx8_execute.lto_priv.81+0x90>)
 8004f62:	609a      	str	r2, [r3, #8]
  chCondSignal(&c1);
 8004f64:	480f      	ldr	r0, [pc, #60]	; (8004fa4 <mtx8_execute.lto_priv.81+0xa4>)
 8004f66:	f003 fff3 	bl	8008f50 <chCondSignal>
  chCondSignal(&c1);
 8004f6a:	480e      	ldr	r0, [pc, #56]	; (8004fa4 <mtx8_execute.lto_priv.81+0xa4>)
 8004f6c:	f003 fff0 	bl	8008f50 <chCondSignal>
  test_wait_threads();
 8004f70:	f000 fc4e 	bl	8005810 <test_wait_threads>
  test_assert_sequence(1, "ABC");
 8004f74:	2001      	movs	r0, #1
 8004f76:	490c      	ldr	r1, [pc, #48]	; (8004fa8 <mtx8_execute.lto_priv.81+0xa8>)
 8004f78:	f000 fbe2 	bl	8005740 <_test_assert_sequence>
}
 8004f7c:	b005      	add	sp, #20
 8004f7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004f82:	bf00      	nop
 8004f84:	0800e420 	.word	0x0800e420
 8004f88:	0800d870 	.word	0x0800d870
 8004f8c:	08004e81 	.word	0x08004e81
 8004f90:	20001bf8 	.word	0x20001bf8
 8004f94:	0800d878 	.word	0x0800d878
 8004f98:	08004c11 	.word	0x08004c11
 8004f9c:	0800d874 	.word	0x0800d874
 8004fa0:	08004ed1 	.word	0x08004ed1
 8004fa4:	20000860 	.word	0x20000860
 8004fa8:	0800d88c 	.word	0x0800d88c
 8004fac:	00000000 	.word	0x00000000

08004fb0 <chThdGetSelfX.lto_priv.192>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004fb0:	4b01      	ldr	r3, [pc, #4]	; (8004fb8 <chThdGetSelfX.lto_priv.192+0x8>)
 8004fb2:	699b      	ldr	r3, [r3, #24]
}
 8004fb4:	4618      	mov	r0, r3
 8004fb6:	4770      	bx	lr
 8004fb8:	20000d30 	.word	0x20000d30
 8004fbc:	00000000 	.word	0x00000000

08004fc0 <chThdGetPriorityX.lto_priv.190>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 8004fc0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 8004fc2:	f7ff fff5 	bl	8004fb0 <chThdGetSelfX.lto_priv.192>
 8004fc6:	4603      	mov	r3, r0
 8004fc8:	689b      	ldr	r3, [r3, #8]
}
 8004fca:	4618      	mov	r0, r3
 8004fcc:	bd08      	pop	{r3, pc}
 8004fce:	bf00      	nop

08004fd0 <chMsgGet>:
 * @param[in] tp        pointer to the thread
 * @return              The message carried by the sender.
 *
 * @api
 */
static inline msg_t chMsgGet(thread_t *tp) {
 8004fd0:	b082      	sub	sp, #8
 8004fd2:	9001      	str	r0, [sp, #4]

  return tp->p_msg;
 8004fd4:	9b01      	ldr	r3, [sp, #4]
 8004fd6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
}
 8004fd8:	4618      	mov	r0, r3
 8004fda:	b002      	add	sp, #8
 8004fdc:	4770      	bx	lr
 8004fde:	bf00      	nop

08004fe0 <thread>:
 * A thread is spawned that sends four messages back to the tester thread.<br>
 * The test expect to receive the messages in the correct sequence and to
 * not find a fifth message waiting.
 */

static THD_FUNCTION(thread, p) {
 8004fe0:	b500      	push	{lr}
 8004fe2:	b083      	sub	sp, #12
 8004fe4:	9001      	str	r0, [sp, #4]

  chMsgSend(p, 'A');
 8004fe6:	9801      	ldr	r0, [sp, #4]
 8004fe8:	2141      	movs	r1, #65	; 0x41
 8004fea:	f004 fc69 	bl	80098c0 <chMsgSend>
  chMsgSend(p, 'B');
 8004fee:	9801      	ldr	r0, [sp, #4]
 8004ff0:	2142      	movs	r1, #66	; 0x42
 8004ff2:	f004 fc65 	bl	80098c0 <chMsgSend>
  chMsgSend(p, 'C');
 8004ff6:	9801      	ldr	r0, [sp, #4]
 8004ff8:	2143      	movs	r1, #67	; 0x43
 8004ffa:	f004 fc61 	bl	80098c0 <chMsgSend>
}
 8004ffe:	b003      	add	sp, #12
 8005000:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08005010 <msg1_execute.lto_priv.79>:

static void msg1_execute(void) {
 8005010:	b530      	push	{r4, r5, lr}
 8005012:	b085      	sub	sp, #20
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8005014:	4b24      	ldr	r3, [pc, #144]	; (80050a8 <msg1_execute.lto_priv.79+0x98>)
 8005016:	681d      	ldr	r5, [r3, #0]
 8005018:	f7ff ffd2 	bl	8004fc0 <chThdGetPriorityX.lto_priv.190>
 800501c:	4603      	mov	r3, r0
 800501e:	1c5c      	adds	r4, r3, #1
                                 thread, chThdGetSelfX());
 8005020:	f7ff ffc6 	bl	8004fb0 <chThdGetSelfX.lto_priv.192>
 8005024:	4603      	mov	r3, r0
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8005026:	9300      	str	r3, [sp, #0]
 8005028:	4628      	mov	r0, r5
 800502a:	f44f 71b4 	mov.w	r1, #360	; 0x168
 800502e:	4622      	mov	r2, r4
 8005030:	4b1e      	ldr	r3, [pc, #120]	; (80050ac <msg1_execute.lto_priv.79+0x9c>)
 8005032:	f007 fde5 	bl	800cc00 <chThdCreateStatic>
 8005036:	4602      	mov	r2, r0
 8005038:	4b1d      	ldr	r3, [pc, #116]	; (80050b0 <msg1_execute.lto_priv.79+0xa0>)
 800503a:	601a      	str	r2, [r3, #0]
                                 thread, chThdGetSelfX());
  tp = chMsgWait();
 800503c:	f004 fc78 	bl	8009930 <chMsgWait>
 8005040:	9003      	str	r0, [sp, #12]
  msg = chMsgGet(tp);
 8005042:	9803      	ldr	r0, [sp, #12]
 8005044:	f7ff ffc4 	bl	8004fd0 <chMsgGet>
 8005048:	9002      	str	r0, [sp, #8]
  chMsgRelease(tp, msg);
 800504a:	9803      	ldr	r0, [sp, #12]
 800504c:	9902      	ldr	r1, [sp, #8]
 800504e:	f004 fc97 	bl	8009980 <chMsgRelease>
  test_emit_token(msg);
 8005052:	9b02      	ldr	r3, [sp, #8]
 8005054:	b2db      	uxtb	r3, r3
 8005056:	4618      	mov	r0, r3
 8005058:	f000 fb2a 	bl	80056b0 <test_emit_token>
  tp = chMsgWait();
 800505c:	f004 fc68 	bl	8009930 <chMsgWait>
 8005060:	9003      	str	r0, [sp, #12]
  msg = chMsgGet(tp);
 8005062:	9803      	ldr	r0, [sp, #12]
 8005064:	f7ff ffb4 	bl	8004fd0 <chMsgGet>
 8005068:	9002      	str	r0, [sp, #8]
  chMsgRelease(tp, msg);
 800506a:	9803      	ldr	r0, [sp, #12]
 800506c:	9902      	ldr	r1, [sp, #8]
 800506e:	f004 fc87 	bl	8009980 <chMsgRelease>
  test_emit_token(msg);
 8005072:	9b02      	ldr	r3, [sp, #8]
 8005074:	b2db      	uxtb	r3, r3
 8005076:	4618      	mov	r0, r3
 8005078:	f000 fb1a 	bl	80056b0 <test_emit_token>
  tp = chMsgWait();
 800507c:	f004 fc58 	bl	8009930 <chMsgWait>
 8005080:	9003      	str	r0, [sp, #12]
  msg = chMsgGet(tp);
 8005082:	9803      	ldr	r0, [sp, #12]
 8005084:	f7ff ffa4 	bl	8004fd0 <chMsgGet>
 8005088:	9002      	str	r0, [sp, #8]
  chMsgRelease(tp, msg);
 800508a:	9803      	ldr	r0, [sp, #12]
 800508c:	9902      	ldr	r1, [sp, #8]
 800508e:	f004 fc77 	bl	8009980 <chMsgRelease>
  test_emit_token(msg);
 8005092:	9b02      	ldr	r3, [sp, #8]
 8005094:	b2db      	uxtb	r3, r3
 8005096:	4618      	mov	r0, r3
 8005098:	f000 fb0a 	bl	80056b0 <test_emit_token>
  test_assert_sequence(1, "ABC");
 800509c:	2001      	movs	r0, #1
 800509e:	4905      	ldr	r1, [pc, #20]	; (80050b4 <msg1_execute.lto_priv.79+0xa4>)
 80050a0:	f000 fb4e 	bl	8005740 <_test_assert_sequence>
}
 80050a4:	b005      	add	sp, #20
 80050a6:	bd30      	pop	{r4, r5, pc}
 80050a8:	0800e420 	.word	0x0800e420
 80050ac:	08004fe1 	.word	0x08004fe1
 80050b0:	20001bf8 	.word	0x20001bf8
 80050b4:	0800d88c 	.word	0x0800d88c
	...

080050c0 <port_lock.lto_priv.187>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80050c0:	b082      	sub	sp, #8
 80050c2:	2320      	movs	r3, #32
 80050c4:	9301      	str	r3, [sp, #4]
 80050c6:	9b01      	ldr	r3, [sp, #4]
 80050c8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80050cc:	b002      	add	sp, #8
 80050ce:	4770      	bx	lr

080050d0 <port_unlock.lto_priv.185>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80050d0:	b082      	sub	sp, #8
 80050d2:	2300      	movs	r3, #0
 80050d4:	9301      	str	r3, [sp, #4]
 80050d6:	9b01      	ldr	r3, [sp, #4]
 80050d8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80050dc:	b002      	add	sp, #8
 80050de:	4770      	bx	lr

080050e0 <chSysLock.lto_priv.177>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80050e0:	b508      	push	{r3, lr}

  port_lock();
 80050e2:	f7ff ffed 	bl	80050c0 <port_lock.lto_priv.187>
  _stats_start_measure_crit_thd();
 80050e6:	f005 f9ab 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 80050ea:	f006 fe59 	bl	800bda0 <_dbg_check_lock>
}
 80050ee:	bd08      	pop	{r3, pc}

080050f0 <chSysUnlock.lto_priv.175>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80050f0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 80050f2:	f006 fe6d 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80050f6:	f005 f9ab 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80050fa:	4b09      	ldr	r3, [pc, #36]	; (8005120 <chSysUnlock.lto_priv.175+0x30>)
 80050fc:	681b      	ldr	r3, [r3, #0]
 80050fe:	4a08      	ldr	r2, [pc, #32]	; (8005120 <chSysUnlock.lto_priv.175+0x30>)
 8005100:	4293      	cmp	r3, r2
 8005102:	d00a      	beq.n	800511a <chSysUnlock.lto_priv.175+0x2a>
 8005104:	4b06      	ldr	r3, [pc, #24]	; (8005120 <chSysUnlock.lto_priv.175+0x30>)
 8005106:	699b      	ldr	r3, [r3, #24]
 8005108:	689a      	ldr	r2, [r3, #8]
 800510a:	4b05      	ldr	r3, [pc, #20]	; (8005120 <chSysUnlock.lto_priv.175+0x30>)
 800510c:	681b      	ldr	r3, [r3, #0]
 800510e:	689b      	ldr	r3, [r3, #8]
 8005110:	429a      	cmp	r2, r3
 8005112:	d202      	bcs.n	800511a <chSysUnlock.lto_priv.175+0x2a>
 8005114:	4803      	ldr	r0, [pc, #12]	; (8005124 <chSysUnlock.lto_priv.175+0x34>)
 8005116:	f006 fceb 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800511a:	f7ff ffd9 	bl	80050d0 <port_unlock.lto_priv.185>
}
 800511e:	bd08      	pop	{r3, pc}
 8005120:	20000d30 	.word	0x20000d30
 8005124:	0800e600 	.word	0x0800e600
	...

08005130 <chSemGetCounterI.lto_priv.183>:
 * @param[in] sp        pointer to a @p semaphore_t structure
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {
 8005130:	b500      	push	{lr}
 8005132:	b083      	sub	sp, #12
 8005134:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8005136:	f006 fed3 	bl	800bee0 <chDbgCheckClassI>

  return sp->s_cnt;
 800513a:	9b01      	ldr	r3, [sp, #4]
 800513c:	689b      	ldr	r3, [r3, #8]
}
 800513e:	4618      	mov	r0, r3
 8005140:	b003      	add	sp, #12
 8005142:	f85d fb04 	ldr.w	pc, [sp], #4
 8005146:	bf00      	nop
	...

08005150 <chMBGetFreeCountI.lto_priv.181>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(mailbox_t *mbp) {
 8005150:	b500      	push	{lr}
 8005152:	b083      	sub	sp, #12
 8005154:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8005156:	f006 fec3 	bl	800bee0 <chDbgCheckClassI>

  return chSemGetCounterI(&mbp->mb_emptysem);
 800515a:	9b01      	ldr	r3, [sp, #4]
 800515c:	331c      	adds	r3, #28
 800515e:	4618      	mov	r0, r3
 8005160:	f7ff ffe6 	bl	8005130 <chSemGetCounterI.lto_priv.183>
 8005164:	4603      	mov	r3, r0
}
 8005166:	4618      	mov	r0, r3
 8005168:	b003      	add	sp, #12
 800516a:	f85d fb04 	ldr.w	pc, [sp], #4
 800516e:	bf00      	nop

08005170 <chMBGetUsedCountI.lto_priv.180>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of queued messages.
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {
 8005170:	b500      	push	{lr}
 8005172:	b083      	sub	sp, #12
 8005174:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8005176:	f006 feb3 	bl	800bee0 <chDbgCheckClassI>

  return chSemGetCounterI(&mbp->mb_fullsem);
 800517a:	9b01      	ldr	r3, [sp, #4]
 800517c:	3310      	adds	r3, #16
 800517e:	4618      	mov	r0, r3
 8005180:	f7ff ffd6 	bl	8005130 <chSemGetCounterI.lto_priv.183>
 8005184:	4603      	mov	r3, r0
}
 8005186:	4618      	mov	r0, r3
 8005188:	b003      	add	sp, #12
 800518a:	f85d fb04 	ldr.w	pc, [sp], #4
 800518e:	bf00      	nop

08005190 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8005190:	b500      	push	{lr}
 8005192:	b087      	sub	sp, #28
 8005194:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 8005196:	9b01      	ldr	r3, [sp, #4]
 8005198:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800519a:	9304      	str	r3, [sp, #16]
  uint16_t cr1 = u->CR1;
 800519c:	9b04      	ldr	r3, [sp, #16]
 800519e:	68db      	ldr	r3, [r3, #12]
 80051a0:	f8ad 300e 	strh.w	r3, [sp, #14]
  uint16_t sr = u->SR;
 80051a4:	9b04      	ldr	r3, [sp, #16]
 80051a6:	681b      	ldr	r3, [r3, #0]
 80051a8:	f8ad 3016 	strh.w	r3, [sp, #22]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 80051ac:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 80051b0:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80051b4:	2b00      	cmp	r3, #0
 80051b6:	d00e      	beq.n	80051d6 <serve_interrupt+0x46>
    osalSysLockFromISR();
 80051b8:	f002 f982 	bl	80074c0 <osalSysLockFromISR.lto_priv.246>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 80051bc:	9b01      	ldr	r3, [sp, #4]
 80051be:	3304      	adds	r3, #4
 80051c0:	4618      	mov	r0, r3
 80051c2:	f44f 7100 	mov.w	r1, #512	; 0x200
 80051c6:	f002 f98b 	bl	80074e0 <osalEventBroadcastFlagsI.lto_priv.244>
    u->SR = ~USART_SR_LBD;
 80051ca:	9b04      	ldr	r3, [sp, #16]
 80051cc:	f46f 7280 	mvn.w	r2, #256	; 0x100
 80051d0:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 80051d2:	f002 f97d 	bl	80074d0 <osalSysUnlockFromISR.lto_priv.243>
  }

  /* Data available.*/
  osalSysLockFromISR();
 80051d6:	f002 f973 	bl	80074c0 <osalSysLockFromISR.lto_priv.246>
 80051da:	e01f      	b.n	800521c <serve_interrupt+0x8c>
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 80051dc:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 80051e0:	f003 030f 	and.w	r3, r3, #15
 80051e4:	2b00      	cmp	r3, #0
 80051e6:	d005      	beq.n	80051f4 <serve_interrupt+0x64>
      set_error(sdp, sr);
 80051e8:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 80051ec:	9801      	ldr	r0, [sp, #4]
 80051ee:	4619      	mov	r1, r3
 80051f0:	f002 f9d6 	bl	80075a0 <set_error.lto_priv.247>
    b = u->DR;
 80051f4:	9b04      	ldr	r3, [sp, #16]
 80051f6:	685b      	ldr	r3, [r3, #4]
 80051f8:	f88d 300d 	strb.w	r3, [sp, #13]
    if (sr & USART_SR_RXNE)
 80051fc:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8005200:	f003 0320 	and.w	r3, r3, #32
 8005204:	2b00      	cmp	r3, #0
 8005206:	d005      	beq.n	8005214 <serve_interrupt+0x84>
      sdIncomingDataI(sdp, b);
 8005208:	f89d 300d 	ldrb.w	r3, [sp, #13]
 800520c:	9801      	ldr	r0, [sp, #4]
 800520e:	4619      	mov	r1, r3
 8005210:	f002 fcee 	bl	8007bf0 <sdIncomingDataI>
    sr = u->SR;
 8005214:	9b04      	ldr	r3, [sp, #16]
 8005216:	681b      	ldr	r3, [r3, #0]
 8005218:	f8ad 3016 	strh.w	r3, [sp, #22]
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800521c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8005220:	f003 032f 	and.w	r3, r3, #47	; 0x2f
 8005224:	2b00      	cmp	r3, #0
 8005226:	d1d9      	bne.n	80051dc <serve_interrupt+0x4c>
    b = u->DR;
    if (sr & USART_SR_RXNE)
      sdIncomingDataI(sdp, b);
    sr = u->SR;
  }
  osalSysUnlockFromISR();
 8005228:	f002 f952 	bl	80074d0 <osalSysUnlockFromISR.lto_priv.243>

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 800522c:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8005230:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8005234:	2b00      	cmp	r3, #0
 8005236:	d024      	beq.n	8005282 <serve_interrupt+0xf2>
 8005238:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 800523c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8005240:	2b00      	cmp	r3, #0
 8005242:	d01e      	beq.n	8005282 <serve_interrupt+0xf2>
    msg_t b;
    osalSysLockFromISR();
 8005244:	f002 f93c 	bl	80074c0 <osalSysLockFromISR.lto_priv.246>
    b = oqGetI(&sdp->oqueue);
 8005248:	9b01      	ldr	r3, [sp, #4]
 800524a:	3330      	adds	r3, #48	; 0x30
 800524c:	4618      	mov	r0, r3
 800524e:	f003 f9c7 	bl	80085e0 <chOQGetI>
 8005252:	9002      	str	r0, [sp, #8]
    if (b < Q_OK) {
 8005254:	9b02      	ldr	r3, [sp, #8]
 8005256:	2b00      	cmp	r3, #0
 8005258:	da0e      	bge.n	8005278 <serve_interrupt+0xe8>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 800525a:	9b01      	ldr	r3, [sp, #4]
 800525c:	3304      	adds	r3, #4
 800525e:	4618      	mov	r0, r3
 8005260:	2108      	movs	r1, #8
 8005262:	f002 f93d 	bl	80074e0 <osalEventBroadcastFlagsI.lto_priv.244>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8005266:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 800526a:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800526e:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8005272:	9b04      	ldr	r3, [sp, #16]
 8005274:	60da      	str	r2, [r3, #12]
 8005276:	e002      	b.n	800527e <serve_interrupt+0xee>
    }
    else
      u->DR = b;
 8005278:	9a02      	ldr	r2, [sp, #8]
 800527a:	9b04      	ldr	r3, [sp, #16]
 800527c:	605a      	str	r2, [r3, #4]
    osalSysUnlockFromISR();
 800527e:	f002 f927 	bl	80074d0 <osalSysUnlockFromISR.lto_priv.243>
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 8005282:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8005286:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800528a:	2b00      	cmp	r3, #0
 800528c:	d01b      	beq.n	80052c6 <serve_interrupt+0x136>
    osalSysLockFromISR();
 800528e:	f002 f917 	bl	80074c0 <osalSysLockFromISR.lto_priv.246>
    if (oqIsEmptyI(&sdp->oqueue))
 8005292:	9b01      	ldr	r3, [sp, #4]
 8005294:	3330      	adds	r3, #48	; 0x30
 8005296:	4618      	mov	r0, r3
 8005298:	f002 f8f2 	bl	8007480 <chOQIsEmptyI.lto_priv.245>
 800529c:	4603      	mov	r3, r0
 800529e:	2b00      	cmp	r3, #0
 80052a0:	d005      	beq.n	80052ae <serve_interrupt+0x11e>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 80052a2:	9b01      	ldr	r3, [sp, #4]
 80052a4:	3304      	adds	r3, #4
 80052a6:	4618      	mov	r0, r3
 80052a8:	2110      	movs	r1, #16
 80052aa:	f002 f919 	bl	80074e0 <osalEventBroadcastFlagsI.lto_priv.244>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 80052ae:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 80052b2:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 80052b6:	9b04      	ldr	r3, [sp, #16]
 80052b8:	60da      	str	r2, [r3, #12]
    u->SR = ~USART_SR_TC;
 80052ba:	9b04      	ldr	r3, [sp, #16]
 80052bc:	f06f 0240 	mvn.w	r2, #64	; 0x40
 80052c0:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 80052c2:	f002 f905 	bl	80074d0 <osalSysUnlockFromISR.lto_priv.243>
  }
}
 80052c6:	b007      	add	sp, #28
 80052c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80052cc:	0000      	movs	r0, r0
	...

080052d0 <notify2>:
  USART1->CR1 |= USART_CR1_TXEIE;
}
#endif

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {
 80052d0:	b082      	sub	sp, #8
 80052d2:	9001      	str	r0, [sp, #4]

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 80052d4:	4a03      	ldr	r2, [pc, #12]	; (80052e4 <notify2+0x14>)
 80052d6:	4b03      	ldr	r3, [pc, #12]	; (80052e4 <notify2+0x14>)
 80052d8:	68db      	ldr	r3, [r3, #12]
 80052da:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80052de:	60d3      	str	r3, [r2, #12]
}
 80052e0:	b002      	add	sp, #8
 80052e2:	4770      	bx	lr
 80052e4:	40004400 	.word	0x40004400
	...

080052f0 <VectorD8>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 80052f0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 80052f2:	f005 f875 	bl	800a3e0 <_stats_increase_irq>
 80052f6:	f006 fdb3 	bl	800be60 <_dbg_check_enter_isr>

  serve_interrupt(&SD2);
 80052fa:	4804      	ldr	r0, [pc, #16]	; (800530c <VectorD8+0x1c>)
 80052fc:	f7ff ff48 	bl	8005190 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8005300:	f006 fdce 	bl	800bea0 <_dbg_check_leave_isr>
 8005304:	f003 fd44 	bl	8008d90 <_port_irq_epilogue>
}
 8005308:	bd08      	pop	{r3, pc}
 800530a:	bf00      	nop
 800530c:	2000145c 	.word	0x2000145c

08005310 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8005310:	b508      	push	{r3, lr}
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 8005312:	4804      	ldr	r0, [pc, #16]	; (8005324 <sd_lld_init+0x14>)
 8005314:	2100      	movs	r1, #0
 8005316:	4a04      	ldr	r2, [pc, #16]	; (8005328 <sd_lld_init+0x18>)
 8005318:	f002 fc0a 	bl	8007b30 <sdObjectInit>
  SD2.usart = USART2;
 800531c:	4b01      	ldr	r3, [pc, #4]	; (8005324 <sd_lld_init+0x14>)
 800531e:	4a03      	ldr	r2, [pc, #12]	; (800532c <sd_lld_init+0x1c>)
 8005320:	675a      	str	r2, [r3, #116]	; 0x74

#if STM32_SERIAL_USE_UART8
  sdObjectInit(&SD8, NULL, notify8);
  SD8.usart = UART8;
#endif
}
 8005322:	bd08      	pop	{r3, pc}
 8005324:	2000145c 	.word	0x2000145c
 8005328:	080052d1 	.word	0x080052d1
 800532c:	40004400 	.word	0x40004400

08005330 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8005330:	b500      	push	{lr}
 8005332:	b083      	sub	sp, #12
 8005334:	9001      	str	r0, [sp, #4]
 8005336:	9100      	str	r1, [sp, #0]

  if (config == NULL)
 8005338:	9b00      	ldr	r3, [sp, #0]
 800533a:	2b00      	cmp	r3, #0
 800533c:	d101      	bne.n	8005342 <sd_lld_start+0x12>
    config = &default_config;
 800533e:	4b0d      	ldr	r3, [pc, #52]	; (8005374 <sd_lld_start+0x44>)
 8005340:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
 8005342:	9b01      	ldr	r3, [sp, #4]
 8005344:	7a1b      	ldrb	r3, [r3, #8]
 8005346:	2b01      	cmp	r3, #1
 8005348:	d10d      	bne.n	8005366 <sd_lld_start+0x36>
      rccEnableUSART1(FALSE);
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
 800534a:	9b01      	ldr	r3, [sp, #4]
 800534c:	4a0a      	ldr	r2, [pc, #40]	; (8005378 <sd_lld_start+0x48>)
 800534e:	4293      	cmp	r3, r2
 8005350:	d109      	bne.n	8005366 <sd_lld_start+0x36>
      rccEnableUSART2(FALSE);
 8005352:	4a0a      	ldr	r2, [pc, #40]	; (800537c <sd_lld_start+0x4c>)
 8005354:	4b09      	ldr	r3, [pc, #36]	; (800537c <sd_lld_start+0x4c>)
 8005356:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8005358:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800535c:	6413      	str	r3, [r2, #64]	; 0x40
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
 800535e:	2026      	movs	r0, #38	; 0x26
 8005360:	210c      	movs	r1, #12
 8005362:	f002 fc7d 	bl	8007c60 <nvicEnableVector>
      rccEnableUART8(FALSE);
      nvicEnableVector(STM32_UART8_NUMBER, STM32_SERIAL_UART8_PRIORITY);
    }
#endif
  }
  usart_init(sdp, config);
 8005366:	9801      	ldr	r0, [sp, #4]
 8005368:	9900      	ldr	r1, [sp, #0]
 800536a:	f002 f8c9 	bl	8007500 <usart_init.lto_priv.242>
}
 800536e:	b003      	add	sp, #12
 8005370:	f85d fb04 	ldr.w	pc, [sp], #4
 8005374:	0800e360 	.word	0x0800e360
 8005378:	2000145c 	.word	0x2000145c
 800537c:	40023800 	.word	0x40023800

08005380 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 8005380:	b508      	push	{r3, lr}

  stm32_clock_init();
 8005382:	f002 fcf5 	bl	8007d70 <stm32_clock_init>
}
 8005386:	bd08      	pop	{r3, pc}
	...

08005390 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 8005390:	4770      	bx	lr
 8005392:	bf00      	nop
	...

080053a0 <port_lock.lto_priv.224>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80053a0:	b082      	sub	sp, #8
 80053a2:	2320      	movs	r3, #32
 80053a4:	9301      	str	r3, [sp, #4]
 80053a6:	9b01      	ldr	r3, [sp, #4]
 80053a8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80053ac:	b002      	add	sp, #8
 80053ae:	4770      	bx	lr

080053b0 <port_unlock.lto_priv.221>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80053b0:	b082      	sub	sp, #8
 80053b2:	2300      	movs	r3, #0
 80053b4:	9301      	str	r3, [sp, #4]
 80053b6:	9b01      	ldr	r3, [sp, #4]
 80053b8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80053bc:	b002      	add	sp, #8
 80053be:	4770      	bx	lr

080053c0 <st_lld_get_counter.lto_priv.218>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80053c0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80053c4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 80053c6:	4618      	mov	r0, r3
 80053c8:	4770      	bx	lr
 80053ca:	bf00      	nop
 80053cc:	0000      	movs	r0, r0
	...

080053d0 <port_timer_get_time.lto_priv.215>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 80053d0:	b508      	push	{r3, lr}

  return stGetCounter();
 80053d2:	f7ff fff5 	bl	80053c0 <st_lld_get_counter.lto_priv.218>
 80053d6:	4603      	mov	r3, r0
}
 80053d8:	4618      	mov	r0, r3
 80053da:	bd08      	pop	{r3, pc}
 80053dc:	0000      	movs	r0, r0
	...

080053e0 <chSysLock.lto_priv.231>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80053e0:	b508      	push	{r3, lr}

  port_lock();
 80053e2:	f7ff ffdd 	bl	80053a0 <port_lock.lto_priv.224>
  _stats_start_measure_crit_thd();
 80053e6:	f005 f82b 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 80053ea:	f006 fcd9 	bl	800bda0 <_dbg_check_lock>
}
 80053ee:	bd08      	pop	{r3, pc}

080053f0 <chSysUnlock.lto_priv.229>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80053f0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 80053f2:	f006 fced 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80053f6:	f005 f82b 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80053fa:	4b09      	ldr	r3, [pc, #36]	; (8005420 <chSysUnlock.lto_priv.229+0x30>)
 80053fc:	681b      	ldr	r3, [r3, #0]
 80053fe:	4a08      	ldr	r2, [pc, #32]	; (8005420 <chSysUnlock.lto_priv.229+0x30>)
 8005400:	4293      	cmp	r3, r2
 8005402:	d00a      	beq.n	800541a <chSysUnlock.lto_priv.229+0x2a>
 8005404:	4b06      	ldr	r3, [pc, #24]	; (8005420 <chSysUnlock.lto_priv.229+0x30>)
 8005406:	699b      	ldr	r3, [r3, #24]
 8005408:	689a      	ldr	r2, [r3, #8]
 800540a:	4b05      	ldr	r3, [pc, #20]	; (8005420 <chSysUnlock.lto_priv.229+0x30>)
 800540c:	681b      	ldr	r3, [r3, #0]
 800540e:	689b      	ldr	r3, [r3, #8]
 8005410:	429a      	cmp	r2, r3
 8005412:	d202      	bcs.n	800541a <chSysUnlock.lto_priv.229+0x2a>
 8005414:	4803      	ldr	r0, [pc, #12]	; (8005424 <chSysUnlock.lto_priv.229+0x34>)
 8005416:	f006 fb6b 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800541a:	f7ff ffc9 	bl	80053b0 <port_unlock.lto_priv.221>
}
 800541e:	bd08      	pop	{r3, pc}
 8005420:	20000d30 	.word	0x20000d30
 8005424:	0800e440 	.word	0x0800e440
	...

08005430 <chVTGetSystemTimeX.lto_priv.212>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8005430:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8005432:	f7ff ffcd 	bl	80053d0 <port_timer_get_time.lto_priv.215>
 8005436:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8005438:	4618      	mov	r0, r3
 800543a:	bd08      	pop	{r3, pc}
 800543c:	0000      	movs	r0, r0
	...

08005440 <chVTGetSystemTime.lto_priv.227>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 8005440:	b500      	push	{lr}
 8005442:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 8005444:	f7ff ffcc 	bl	80053e0 <chSysLock.lto_priv.231>
  systime = chVTGetSystemTimeX();
 8005448:	f7ff fff2 	bl	8005430 <chVTGetSystemTimeX.lto_priv.212>
 800544c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800544e:	f7ff ffcf 	bl	80053f0 <chSysUnlock.lto_priv.229>

  return systime;
 8005452:	9b01      	ldr	r3, [sp, #4]
}
 8005454:	4618      	mov	r0, r3
 8005456:	b003      	add	sp, #12
 8005458:	f85d fb04 	ldr.w	pc, [sp], #4
 800545c:	0000      	movs	r0, r0
	...

08005460 <chVTIsTimeWithinX>:
 *
 * @xclass
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {
 8005460:	b084      	sub	sp, #16
 8005462:	9003      	str	r0, [sp, #12]
 8005464:	9102      	str	r1, [sp, #8]
 8005466:	9201      	str	r2, [sp, #4]

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8005468:	9a03      	ldr	r2, [sp, #12]
 800546a:	9b02      	ldr	r3, [sp, #8]
 800546c:	1ad2      	subs	r2, r2, r3
 800546e:	9901      	ldr	r1, [sp, #4]
 8005470:	9b02      	ldr	r3, [sp, #8]
 8005472:	1acb      	subs	r3, r1, r3
 8005474:	429a      	cmp	r2, r3
 8005476:	bf34      	ite	cc
 8005478:	2301      	movcc	r3, #1
 800547a:	2300      	movcs	r3, #0
 800547c:	b2db      	uxtb	r3, r3
}
 800547e:	4618      	mov	r0, r3
 8005480:	b004      	add	sp, #16
 8005482:	4770      	bx	lr
	...

08005490 <chVTIsSystemTimeWithin>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @api
 */
static inline bool chVTIsSystemTimeWithin(systime_t start, systime_t end) {
 8005490:	b500      	push	{lr}
 8005492:	b083      	sub	sp, #12
 8005494:	9001      	str	r0, [sp, #4]
 8005496:	9100      	str	r1, [sp, #0]

  return chVTIsTimeWithinX(chVTGetSystemTime(), start, end);
 8005498:	f7ff ffd2 	bl	8005440 <chVTGetSystemTime.lto_priv.227>
 800549c:	4603      	mov	r3, r0
 800549e:	4618      	mov	r0, r3
 80054a0:	9901      	ldr	r1, [sp, #4]
 80054a2:	9a00      	ldr	r2, [sp, #0]
 80054a4:	f7ff ffdc 	bl	8005460 <chVTIsTimeWithinX>
 80054a8:	4603      	mov	r3, r0
}
 80054aa:	4618      	mov	r0, r3
 80054ac:	b003      	add	sp, #12
 80054ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80054b2:	bf00      	nop
	...

080054c0 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 80054c0:	b500      	push	{lr}
 80054c2:	b083      	sub	sp, #12
 80054c4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 80054c6:	f006 fd0b 	bl	800bee0 <chDbgCheckClassI>

  return (bool)(vtp->vt_func != NULL);
 80054ca:	9b01      	ldr	r3, [sp, #4]
 80054cc:	68db      	ldr	r3, [r3, #12]
 80054ce:	2b00      	cmp	r3, #0
 80054d0:	bf14      	ite	ne
 80054d2:	2301      	movne	r3, #1
 80054d4:	2300      	moveq	r3, #0
 80054d6:	b2db      	uxtb	r3, r3
}
 80054d8:	4618      	mov	r0, r3
 80054da:	b003      	add	sp, #12
 80054dc:	f85d fb04 	ldr.w	pc, [sp], #4

080054e0 <chVTResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
 80054e0:	b500      	push	{lr}
 80054e2:	b083      	sub	sp, #12
 80054e4:	9001      	str	r0, [sp, #4]

  if (chVTIsArmedI(vtp)) {
 80054e6:	9801      	ldr	r0, [sp, #4]
 80054e8:	f7ff ffea 	bl	80054c0 <chVTIsArmedI>
 80054ec:	4603      	mov	r3, r0
 80054ee:	2b00      	cmp	r3, #0
 80054f0:	d002      	beq.n	80054f8 <chVTResetI+0x18>
    chVTDoResetI(vtp);
 80054f2:	9801      	ldr	r0, [sp, #4]
 80054f4:	f006 fe4c 	bl	800c190 <chVTDoResetI>
  }
}
 80054f8:	b003      	add	sp, #12
 80054fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80054fe:	bf00      	nop

08005500 <chVTSetI>:
 *                      function
 *
 * @iclass
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {
 8005500:	b500      	push	{lr}
 8005502:	b085      	sub	sp, #20
 8005504:	9003      	str	r0, [sp, #12]
 8005506:	9102      	str	r1, [sp, #8]
 8005508:	9201      	str	r2, [sp, #4]
 800550a:	9300      	str	r3, [sp, #0]

  chVTResetI(vtp);
 800550c:	9803      	ldr	r0, [sp, #12]
 800550e:	f7ff ffe7 	bl	80054e0 <chVTResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
 8005512:	9803      	ldr	r0, [sp, #12]
 8005514:	9902      	ldr	r1, [sp, #8]
 8005516:	9a01      	ldr	r2, [sp, #4]
 8005518:	9b00      	ldr	r3, [sp, #0]
 800551a:	f006 fda9 	bl	800c070 <chVTDoSetI>
}
 800551e:	b005      	add	sp, #20
 8005520:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08005530 <chVTSet>:
 *                      function
 *
 * @api
 */
static inline void chVTSet(virtual_timer_t *vtp, systime_t delay,
                           vtfunc_t vtfunc, void *par) {
 8005530:	b500      	push	{lr}
 8005532:	b085      	sub	sp, #20
 8005534:	9003      	str	r0, [sp, #12]
 8005536:	9102      	str	r1, [sp, #8]
 8005538:	9201      	str	r2, [sp, #4]
 800553a:	9300      	str	r3, [sp, #0]

  chSysLock();
 800553c:	f7ff ff50 	bl	80053e0 <chSysLock.lto_priv.231>
  chVTSetI(vtp, delay, vtfunc, par);
 8005540:	9803      	ldr	r0, [sp, #12]
 8005542:	9902      	ldr	r1, [sp, #8]
 8005544:	9a01      	ldr	r2, [sp, #4]
 8005546:	9b00      	ldr	r3, [sp, #0]
 8005548:	f7ff ffda 	bl	8005500 <chVTSetI>
  chSysUnlock();
 800554c:	f7ff ff50 	bl	80053f0 <chSysUnlock.lto_priv.229>
}
 8005550:	b005      	add	sp, #20
 8005552:	f85d fb04 	ldr.w	pc, [sp], #4
 8005556:	bf00      	nop
	...

08005560 <test_printn>:
/**
 * @brief   Prints a decimal unsigned number.
 *
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
 8005560:	b500      	push	{lr}
 8005562:	b089      	sub	sp, #36	; 0x24
 8005564:	9001      	str	r0, [sp, #4]
  char buf[16], *p;

  if (!n)
 8005566:	9b01      	ldr	r3, [sp, #4]
 8005568:	2b00      	cmp	r3, #0
 800556a:	d109      	bne.n	8005580 <test_printn+0x20>
    chSequentialStreamPut(chp, '0');
 800556c:	4b1e      	ldr	r3, [pc, #120]	; (80055e8 <test_printn+0x88>)
 800556e:	681b      	ldr	r3, [r3, #0]
 8005570:	681b      	ldr	r3, [r3, #0]
 8005572:	689b      	ldr	r3, [r3, #8]
 8005574:	4a1c      	ldr	r2, [pc, #112]	; (80055e8 <test_printn+0x88>)
 8005576:	6812      	ldr	r2, [r2, #0]
 8005578:	4610      	mov	r0, r2
 800557a:	2130      	movs	r1, #48	; 0x30
 800557c:	4798      	blx	r3
 800557e:	e02f      	b.n	80055e0 <test_printn+0x80>
  else {
    p = buf;
 8005580:	ab03      	add	r3, sp, #12
 8005582:	9307      	str	r3, [sp, #28]
 8005584:	e016      	b.n	80055b4 <test_printn+0x54>
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 8005586:	9907      	ldr	r1, [sp, #28]
 8005588:	1c4b      	adds	r3, r1, #1
 800558a:	9307      	str	r3, [sp, #28]
 800558c:	9801      	ldr	r0, [sp, #4]
 800558e:	4b17      	ldr	r3, [pc, #92]	; (80055ec <test_printn+0x8c>)
 8005590:	fba3 2300 	umull	r2, r3, r3, r0
 8005594:	08da      	lsrs	r2, r3, #3
 8005596:	4613      	mov	r3, r2
 8005598:	009b      	lsls	r3, r3, #2
 800559a:	4413      	add	r3, r2
 800559c:	005b      	lsls	r3, r3, #1
 800559e:	1ac2      	subs	r2, r0, r3
 80055a0:	b2d3      	uxtb	r3, r2
 80055a2:	3330      	adds	r3, #48	; 0x30
 80055a4:	b2db      	uxtb	r3, r3
 80055a6:	700b      	strb	r3, [r1, #0]
 80055a8:	9b01      	ldr	r3, [sp, #4]
 80055aa:	4a10      	ldr	r2, [pc, #64]	; (80055ec <test_printn+0x8c>)
 80055ac:	fba2 2303 	umull	r2, r3, r2, r3
 80055b0:	08db      	lsrs	r3, r3, #3
 80055b2:	9301      	str	r3, [sp, #4]

  if (!n)
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
 80055b4:	9b01      	ldr	r3, [sp, #4]
 80055b6:	2b00      	cmp	r3, #0
 80055b8:	d1e5      	bne.n	8005586 <test_printn+0x26>
 80055ba:	e00d      	b.n	80055d8 <test_printn+0x78>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
      chSequentialStreamPut(chp, *--p);
 80055bc:	4b0a      	ldr	r3, [pc, #40]	; (80055e8 <test_printn+0x88>)
 80055be:	681b      	ldr	r3, [r3, #0]
 80055c0:	681b      	ldr	r3, [r3, #0]
 80055c2:	689b      	ldr	r3, [r3, #8]
 80055c4:	4a08      	ldr	r2, [pc, #32]	; (80055e8 <test_printn+0x88>)
 80055c6:	6811      	ldr	r1, [r2, #0]
 80055c8:	9a07      	ldr	r2, [sp, #28]
 80055ca:	3a01      	subs	r2, #1
 80055cc:	9207      	str	r2, [sp, #28]
 80055ce:	9a07      	ldr	r2, [sp, #28]
 80055d0:	7812      	ldrb	r2, [r2, #0]
 80055d2:	4608      	mov	r0, r1
 80055d4:	4611      	mov	r1, r2
 80055d6:	4798      	blx	r3
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 80055d8:	ab03      	add	r3, sp, #12
 80055da:	9a07      	ldr	r2, [sp, #28]
 80055dc:	429a      	cmp	r2, r3
 80055de:	d8ed      	bhi.n	80055bc <test_printn+0x5c>
      chSequentialStreamPut(chp, *--p);
  }
}
 80055e0:	b009      	add	sp, #36	; 0x24
 80055e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80055e6:	bf00      	nop
 80055e8:	20001c0c 	.word	0x20001c0c
 80055ec:	cccccccd 	.word	0xcccccccd

080055f0 <test_print>:
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
 80055f0:	b500      	push	{lr}
 80055f2:	b083      	sub	sp, #12
 80055f4:	9001      	str	r0, [sp, #4]
 80055f6:	e00b      	b.n	8005610 <test_print+0x20>

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 80055f8:	4b09      	ldr	r3, [pc, #36]	; (8005620 <test_print+0x30>)
 80055fa:	681b      	ldr	r3, [r3, #0]
 80055fc:	681b      	ldr	r3, [r3, #0]
 80055fe:	689a      	ldr	r2, [r3, #8]
 8005600:	4b07      	ldr	r3, [pc, #28]	; (8005620 <test_print+0x30>)
 8005602:	6818      	ldr	r0, [r3, #0]
 8005604:	9b01      	ldr	r3, [sp, #4]
 8005606:	1c59      	adds	r1, r3, #1
 8005608:	9101      	str	r1, [sp, #4]
 800560a:	781b      	ldrb	r3, [r3, #0]
 800560c:	4619      	mov	r1, r3
 800560e:	4790      	blx	r2
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8005610:	9b01      	ldr	r3, [sp, #4]
 8005612:	781b      	ldrb	r3, [r3, #0]
 8005614:	2b00      	cmp	r3, #0
 8005616:	d1ef      	bne.n	80055f8 <test_print+0x8>
    chSequentialStreamPut(chp, *msgp++);
}
 8005618:	b003      	add	sp, #12
 800561a:	f85d fb04 	ldr.w	pc, [sp], #4
 800561e:	bf00      	nop
 8005620:	20001c0c 	.word	0x20001c0c
	...

08005630 <test_println>:
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
 8005630:	b500      	push	{lr}
 8005632:	b083      	sub	sp, #12
 8005634:	9001      	str	r0, [sp, #4]

  test_print(msgp);
 8005636:	9801      	ldr	r0, [sp, #4]
 8005638:	f7ff ffda 	bl	80055f0 <test_print>
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 800563c:	4b06      	ldr	r3, [pc, #24]	; (8005658 <test_println+0x28>)
 800563e:	681b      	ldr	r3, [r3, #0]
 8005640:	681b      	ldr	r3, [r3, #0]
 8005642:	681b      	ldr	r3, [r3, #0]
 8005644:	4a04      	ldr	r2, [pc, #16]	; (8005658 <test_println+0x28>)
 8005646:	6812      	ldr	r2, [r2, #0]
 8005648:	4610      	mov	r0, r2
 800564a:	4904      	ldr	r1, [pc, #16]	; (800565c <test_println+0x2c>)
 800564c:	2202      	movs	r2, #2
 800564e:	4798      	blx	r3
}
 8005650:	b003      	add	sp, #12
 8005652:	f85d fb04 	ldr.w	pc, [sp], #4
 8005656:	bf00      	nop
 8005658:	20001c0c 	.word	0x20001c0c
 800565c:	0800d890 	.word	0x0800d890

08005660 <clear_tokens>:
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 8005660:	4b01      	ldr	r3, [pc, #4]	; (8005668 <clear_tokens+0x8>)
 8005662:	4a02      	ldr	r2, [pc, #8]	; (800566c <clear_tokens+0xc>)
 8005664:	601a      	str	r2, [r3, #0]
}
 8005666:	4770      	bx	lr
 8005668:	200014ec 	.word	0x200014ec
 800566c:	200014dc 	.word	0x200014dc

08005670 <print_tokens>:

static void print_tokens(void) {
 8005670:	b500      	push	{lr}
 8005672:	b083      	sub	sp, #12
  char *cp = tokens_buffer;
 8005674:	4b0b      	ldr	r3, [pc, #44]	; (80056a4 <print_tokens+0x34>)
 8005676:	9301      	str	r3, [sp, #4]
 8005678:	e00b      	b.n	8005692 <print_tokens+0x22>

  while (cp < tokp)
    chSequentialStreamPut(chp, *cp++);
 800567a:	4b0b      	ldr	r3, [pc, #44]	; (80056a8 <print_tokens+0x38>)
 800567c:	681b      	ldr	r3, [r3, #0]
 800567e:	681b      	ldr	r3, [r3, #0]
 8005680:	689a      	ldr	r2, [r3, #8]
 8005682:	4b09      	ldr	r3, [pc, #36]	; (80056a8 <print_tokens+0x38>)
 8005684:	6818      	ldr	r0, [r3, #0]
 8005686:	9b01      	ldr	r3, [sp, #4]
 8005688:	1c59      	adds	r1, r3, #1
 800568a:	9101      	str	r1, [sp, #4]
 800568c:	781b      	ldrb	r3, [r3, #0]
 800568e:	4619      	mov	r1, r3
 8005690:	4790      	blx	r2
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 8005692:	4b06      	ldr	r3, [pc, #24]	; (80056ac <print_tokens+0x3c>)
 8005694:	681b      	ldr	r3, [r3, #0]
 8005696:	9a01      	ldr	r2, [sp, #4]
 8005698:	429a      	cmp	r2, r3
 800569a:	d3ee      	bcc.n	800567a <print_tokens+0xa>
    chSequentialStreamPut(chp, *cp++);
}
 800569c:	b003      	add	sp, #12
 800569e:	f85d fb04 	ldr.w	pc, [sp], #4
 80056a2:	bf00      	nop
 80056a4:	200014dc 	.word	0x200014dc
 80056a8:	20001c0c 	.word	0x20001c0c
 80056ac:	200014ec 	.word	0x200014ec

080056b0 <test_emit_token>:
/**
 * @brief   Emits a token into the tokens buffer.
 *
 * @param[in] token     the token as a char
 */
void test_emit_token(char token) {
 80056b0:	b500      	push	{lr}
 80056b2:	b083      	sub	sp, #12
 80056b4:	4603      	mov	r3, r0
 80056b6:	f88d 3007 	strb.w	r3, [sp, #7]

  chSysLock();
 80056ba:	f7ff fe91 	bl	80053e0 <chSysLock.lto_priv.231>
  *tokp++ = token;
 80056be:	4b06      	ldr	r3, [pc, #24]	; (80056d8 <test_emit_token+0x28>)
 80056c0:	681b      	ldr	r3, [r3, #0]
 80056c2:	1c5a      	adds	r2, r3, #1
 80056c4:	4904      	ldr	r1, [pc, #16]	; (80056d8 <test_emit_token+0x28>)
 80056c6:	600a      	str	r2, [r1, #0]
 80056c8:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80056cc:	701a      	strb	r2, [r3, #0]
  chSysUnlock();
 80056ce:	f7ff fe8f 	bl	80053f0 <chSysUnlock.lto_priv.229>
}
 80056d2:	b003      	add	sp, #12
 80056d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80056d8:	200014ec 	.word	0x200014ec
 80056dc:	00000000 	.word	0x00000000

080056e0 <_test_fail>:

/*
 * Assertions.
 */
bool _test_fail(unsigned point) {
 80056e0:	b082      	sub	sp, #8
 80056e2:	9001      	str	r0, [sp, #4]

  test_global_fail = TRUE;
 80056e4:	4b06      	ldr	r3, [pc, #24]	; (8005700 <_test_fail+0x20>)
 80056e6:	2201      	movs	r2, #1
 80056e8:	701a      	strb	r2, [r3, #0]
  local_fail = TRUE;
 80056ea:	4b06      	ldr	r3, [pc, #24]	; (8005704 <_test_fail+0x24>)
 80056ec:	2201      	movs	r2, #1
 80056ee:	701a      	strb	r2, [r3, #0]
  failpoint = point;
 80056f0:	4a05      	ldr	r2, [pc, #20]	; (8005708 <_test_fail+0x28>)
 80056f2:	9b01      	ldr	r3, [sp, #4]
 80056f4:	6013      	str	r3, [r2, #0]
  return TRUE;
 80056f6:	2301      	movs	r3, #1
}
 80056f8:	4618      	mov	r0, r3
 80056fa:	b002      	add	sp, #8
 80056fc:	4770      	bx	lr
 80056fe:	bf00      	nop
 8005700:	200014d4 	.word	0x200014d4
 8005704:	200014d5 	.word	0x200014d5
 8005708:	200014d8 	.word	0x200014d8
 800570c:	00000000 	.word	0x00000000

08005710 <_test_assert>:

bool _test_assert(unsigned point, bool condition) {
 8005710:	b500      	push	{lr}
 8005712:	b083      	sub	sp, #12
 8005714:	9001      	str	r0, [sp, #4]
 8005716:	460b      	mov	r3, r1
 8005718:	f88d 3003 	strb.w	r3, [sp, #3]

  if (!condition)
 800571c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005720:	f083 0301 	eor.w	r3, r3, #1
 8005724:	b2db      	uxtb	r3, r3
 8005726:	2b00      	cmp	r3, #0
 8005728:	d004      	beq.n	8005734 <_test_assert+0x24>
    return _test_fail(point);
 800572a:	9801      	ldr	r0, [sp, #4]
 800572c:	f7ff ffd8 	bl	80056e0 <_test_fail>
 8005730:	4603      	mov	r3, r0
 8005732:	e000      	b.n	8005736 <_test_assert+0x26>
  return FALSE;
 8005734:	2300      	movs	r3, #0
}
 8005736:	4618      	mov	r0, r3
 8005738:	b003      	add	sp, #12
 800573a:	f85d fb04 	ldr.w	pc, [sp], #4
 800573e:	bf00      	nop

08005740 <_test_assert_sequence>:

bool _test_assert_sequence(unsigned point, char *expected) {
 8005740:	b500      	push	{lr}
 8005742:	b085      	sub	sp, #20
 8005744:	9001      	str	r0, [sp, #4]
 8005746:	9100      	str	r1, [sp, #0]
  char *cp = tokens_buffer;
 8005748:	4b13      	ldr	r3, [pc, #76]	; (8005798 <_test_assert_sequence+0x58>)
 800574a:	9303      	str	r3, [sp, #12]
 800574c:	e00e      	b.n	800576c <_test_assert_sequence+0x2c>
  while (cp < tokp) {
    if (*cp++ != *expected++)
 800574e:	9b03      	ldr	r3, [sp, #12]
 8005750:	1c5a      	adds	r2, r3, #1
 8005752:	9203      	str	r2, [sp, #12]
 8005754:	781a      	ldrb	r2, [r3, #0]
 8005756:	9b00      	ldr	r3, [sp, #0]
 8005758:	1c59      	adds	r1, r3, #1
 800575a:	9100      	str	r1, [sp, #0]
 800575c:	781b      	ldrb	r3, [r3, #0]
 800575e:	429a      	cmp	r2, r3
 8005760:	d004      	beq.n	800576c <_test_assert_sequence+0x2c>
     return _test_fail(point);
 8005762:	9801      	ldr	r0, [sp, #4]
 8005764:	f7ff ffbc 	bl	80056e0 <_test_fail>
 8005768:	4603      	mov	r3, r0
 800576a:	e010      	b.n	800578e <_test_assert_sequence+0x4e>
  return FALSE;
}

bool _test_assert_sequence(unsigned point, char *expected) {
  char *cp = tokens_buffer;
  while (cp < tokp) {
 800576c:	4b0b      	ldr	r3, [pc, #44]	; (800579c <_test_assert_sequence+0x5c>)
 800576e:	681b      	ldr	r3, [r3, #0]
 8005770:	9a03      	ldr	r2, [sp, #12]
 8005772:	429a      	cmp	r2, r3
 8005774:	d3eb      	bcc.n	800574e <_test_assert_sequence+0xe>
    if (*cp++ != *expected++)
     return _test_fail(point);
  }
  if (*expected)
 8005776:	9b00      	ldr	r3, [sp, #0]
 8005778:	781b      	ldrb	r3, [r3, #0]
 800577a:	2b00      	cmp	r3, #0
 800577c:	d004      	beq.n	8005788 <_test_assert_sequence+0x48>
    return _test_fail(point);
 800577e:	9801      	ldr	r0, [sp, #4]
 8005780:	f7ff ffae 	bl	80056e0 <_test_fail>
 8005784:	4603      	mov	r3, r0
 8005786:	e002      	b.n	800578e <_test_assert_sequence+0x4e>
  clear_tokens();
 8005788:	f7ff ff6a 	bl	8005660 <clear_tokens>
  return FALSE;
 800578c:	2300      	movs	r3, #0
}
 800578e:	4618      	mov	r0, r3
 8005790:	b005      	add	sp, #20
 8005792:	f85d fb04 	ldr.w	pc, [sp], #4
 8005796:	bf00      	nop
 8005798:	200014dc 	.word	0x200014dc
 800579c:	200014ec 	.word	0x200014ec

080057a0 <_test_assert_time_window>:

bool _test_assert_time_window(unsigned point, systime_t start, systime_t end) {
 80057a0:	b500      	push	{lr}
 80057a2:	b085      	sub	sp, #20
 80057a4:	9003      	str	r0, [sp, #12]
 80057a6:	9102      	str	r1, [sp, #8]
 80057a8:	9201      	str	r2, [sp, #4]

  return _test_assert(point, chVTIsSystemTimeWithin(start, end));
 80057aa:	9802      	ldr	r0, [sp, #8]
 80057ac:	9901      	ldr	r1, [sp, #4]
 80057ae:	f7ff fe6f 	bl	8005490 <chVTIsSystemTimeWithin>
 80057b2:	4603      	mov	r3, r0
 80057b4:	9803      	ldr	r0, [sp, #12]
 80057b6:	4619      	mov	r1, r3
 80057b8:	f7ff ffaa 	bl	8005710 <_test_assert>
 80057bc:	4603      	mov	r3, r0
}
 80057be:	4618      	mov	r0, r3
 80057c0:	b005      	add	sp, #20
 80057c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80057c6:	bf00      	nop
	...

080057d0 <test_terminate_threads>:
 */

/**
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 80057d0:	b500      	push	{lr}
 80057d2:	b083      	sub	sp, #12
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 80057d4:	2300      	movs	r3, #0
 80057d6:	9301      	str	r3, [sp, #4]
 80057d8:	e00f      	b.n	80057fa <test_terminate_threads+0x2a>
    if (threads[i])
 80057da:	4a0b      	ldr	r2, [pc, #44]	; (8005808 <test_terminate_threads+0x38>)
 80057dc:	9b01      	ldr	r3, [sp, #4]
 80057de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80057e2:	2b00      	cmp	r3, #0
 80057e4:	d006      	beq.n	80057f4 <test_terminate_threads+0x24>
      chThdTerminate(threads[i]);
 80057e6:	4a08      	ldr	r2, [pc, #32]	; (8005808 <test_terminate_threads+0x38>)
 80057e8:	9b01      	ldr	r3, [sp, #4]
 80057ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80057ee:	4618      	mov	r0, r3
 80057f0:	f007 fa7e 	bl	800ccf0 <chThdTerminate>
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 80057f4:	9b01      	ldr	r3, [sp, #4]
 80057f6:	3301      	adds	r3, #1
 80057f8:	9301      	str	r3, [sp, #4]
 80057fa:	9b01      	ldr	r3, [sp, #4]
 80057fc:	2b04      	cmp	r3, #4
 80057fe:	ddec      	ble.n	80057da <test_terminate_threads+0xa>
    if (threads[i])
      chThdTerminate(threads[i]);
}
 8005800:	b003      	add	sp, #12
 8005802:	f85d fb04 	ldr.w	pc, [sp], #4
 8005806:	bf00      	nop
 8005808:	20001bf8 	.word	0x20001bf8
 800580c:	00000000 	.word	0x00000000

08005810 <test_wait_threads>:

/**
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 8005810:	b500      	push	{lr}
 8005812:	b083      	sub	sp, #12
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 8005814:	2300      	movs	r3, #0
 8005816:	9301      	str	r3, [sp, #4]
 8005818:	e014      	b.n	8005844 <test_wait_threads+0x34>
    if (threads[i] != NULL) {
 800581a:	4a0d      	ldr	r2, [pc, #52]	; (8005850 <test_wait_threads+0x40>)
 800581c:	9b01      	ldr	r3, [sp, #4]
 800581e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8005822:	2b00      	cmp	r3, #0
 8005824:	d00b      	beq.n	800583e <test_wait_threads+0x2e>
      chThdWait(threads[i]);
 8005826:	4a0a      	ldr	r2, [pc, #40]	; (8005850 <test_wait_threads+0x40>)
 8005828:	9b01      	ldr	r3, [sp, #4]
 800582a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800582e:	4618      	mov	r0, r3
 8005830:	f007 faf6 	bl	800ce20 <chThdWait>
      threads[i] = NULL;
 8005834:	4a06      	ldr	r2, [pc, #24]	; (8005850 <test_wait_threads+0x40>)
 8005836:	9b01      	ldr	r3, [sp, #4]
 8005838:	2100      	movs	r1, #0
 800583a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 800583e:	9b01      	ldr	r3, [sp, #4]
 8005840:	3301      	adds	r3, #1
 8005842:	9301      	str	r3, [sp, #4]
 8005844:	9b01      	ldr	r3, [sp, #4]
 8005846:	2b04      	cmp	r3, #4
 8005848:	dde7      	ble.n	800581a <test_wait_threads+0xa>
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}
 800584a:	b003      	add	sp, #12
 800584c:	f85d fb04 	ldr.w	pc, [sp], #4
 8005850:	20001bf8 	.word	0x20001bf8
	...

08005860 <test_wait_tick>:
/**
 * @brief   Delays execution until next system time tick.
 *
 * @return              The system time.
 */
systime_t test_wait_tick(void) {
 8005860:	b508      	push	{r3, lr}

  chThdSleep(1);
 8005862:	2001      	movs	r0, #1
 8005864:	f007 fa5c 	bl	800cd20 <chThdSleep>
  return chVTGetSystemTime();
 8005868:	f7ff fdea 	bl	8005440 <chVTGetSystemTime.lto_priv.227>
 800586c:	4603      	mov	r3, r0
}
 800586e:	4618      	mov	r0, r3
 8005870:	bd08      	pop	{r3, pc}
 8005872:	bf00      	nop
	...

08005880 <tmr>:
 * @brief   Set to @p TRUE when the test timer reaches its deadline.
 */
bool test_timer_done;

static virtual_timer_t vt;
static void tmr(void *p) {
 8005880:	b082      	sub	sp, #8
 8005882:	9001      	str	r0, [sp, #4]
  (void)p;

  test_timer_done = TRUE;
 8005884:	4b02      	ldr	r3, [pc, #8]	; (8005890 <tmr+0x10>)
 8005886:	2201      	movs	r2, #1
 8005888:	701a      	strb	r2, [r3, #0]
}
 800588a:	b002      	add	sp, #8
 800588c:	4770      	bx	lr
 800588e:	bf00      	nop
 8005890:	20001c10 	.word	0x20001c10
	...

080058a0 <test_start_timer>:
/**
 * @brief   Starts the test timer.
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {
 80058a0:	b500      	push	{lr}
 80058a2:	b085      	sub	sp, #20
 80058a4:	9001      	str	r0, [sp, #4]

  systime_t duration = MS2ST(ms);
 80058a6:	9b01      	ldr	r3, [sp, #4]
 80058a8:	f242 7210 	movw	r2, #10000	; 0x2710
 80058ac:	fb02 f303 	mul.w	r3, r2, r3
 80058b0:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
 80058b4:	4a08      	ldr	r2, [pc, #32]	; (80058d8 <test_start_timer+0x38>)
 80058b6:	fba2 2303 	umull	r2, r3, r2, r3
 80058ba:	099b      	lsrs	r3, r3, #6
 80058bc:	9303      	str	r3, [sp, #12]
  test_timer_done = FALSE;
 80058be:	4b07      	ldr	r3, [pc, #28]	; (80058dc <test_start_timer+0x3c>)
 80058c0:	2200      	movs	r2, #0
 80058c2:	701a      	strb	r2, [r3, #0]
  chVTSet(&vt, duration, tmr, NULL);
 80058c4:	4806      	ldr	r0, [pc, #24]	; (80058e0 <test_start_timer+0x40>)
 80058c6:	9903      	ldr	r1, [sp, #12]
 80058c8:	4a06      	ldr	r2, [pc, #24]	; (80058e4 <test_start_timer+0x44>)
 80058ca:	2300      	movs	r3, #0
 80058cc:	f7ff fe30 	bl	8005530 <chVTSet>
}
 80058d0:	b005      	add	sp, #20
 80058d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80058d6:	bf00      	nop
 80058d8:	10624dd3 	.word	0x10624dd3
 80058dc:	20001c10 	.word	0x20001c10
 80058e0:	20001c14 	.word	0x20001c14
 80058e4:	08005881 	.word	0x08005881
	...

080058f0 <execute_test>:

/*
 * Test suite execution.
 */
static void execute_test(const struct testcase *tcp) {
 80058f0:	b500      	push	{lr}
 80058f2:	b085      	sub	sp, #20
 80058f4:	9001      	str	r0, [sp, #4]
  int i;

  /* Initialization */
  clear_tokens();
 80058f6:	f7ff feb3 	bl	8005660 <clear_tokens>
  local_fail = FALSE;
 80058fa:	4b13      	ldr	r3, [pc, #76]	; (8005948 <execute_test+0x58>)
 80058fc:	2200      	movs	r2, #0
 80058fe:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < MAX_THREADS; i++)
 8005900:	2300      	movs	r3, #0
 8005902:	9303      	str	r3, [sp, #12]
 8005904:	e007      	b.n	8005916 <execute_test+0x26>
    threads[i] = NULL;
 8005906:	4a11      	ldr	r2, [pc, #68]	; (800594c <execute_test+0x5c>)
 8005908:	9b03      	ldr	r3, [sp, #12]
 800590a:	2100      	movs	r1, #0
 800590c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
  for (i = 0; i < MAX_THREADS; i++)
 8005910:	9b03      	ldr	r3, [sp, #12]
 8005912:	3301      	adds	r3, #1
 8005914:	9303      	str	r3, [sp, #12]
 8005916:	9b03      	ldr	r3, [sp, #12]
 8005918:	2b04      	cmp	r3, #4
 800591a:	ddf4      	ble.n	8005906 <execute_test+0x16>
    threads[i] = NULL;

  if (tcp->setup != NULL)
 800591c:	9b01      	ldr	r3, [sp, #4]
 800591e:	685b      	ldr	r3, [r3, #4]
 8005920:	2b00      	cmp	r3, #0
 8005922:	d002      	beq.n	800592a <execute_test+0x3a>
    tcp->setup();
 8005924:	9b01      	ldr	r3, [sp, #4]
 8005926:	685b      	ldr	r3, [r3, #4]
 8005928:	4798      	blx	r3
  tcp->execute();
 800592a:	9b01      	ldr	r3, [sp, #4]
 800592c:	68db      	ldr	r3, [r3, #12]
 800592e:	4798      	blx	r3
  if (tcp->teardown != NULL)
 8005930:	9b01      	ldr	r3, [sp, #4]
 8005932:	689b      	ldr	r3, [r3, #8]
 8005934:	2b00      	cmp	r3, #0
 8005936:	d002      	beq.n	800593e <execute_test+0x4e>
    tcp->teardown();
 8005938:	9b01      	ldr	r3, [sp, #4]
 800593a:	689b      	ldr	r3, [r3, #8]
 800593c:	4798      	blx	r3

  test_wait_threads();
 800593e:	f7ff ff67 	bl	8005810 <test_wait_threads>
}
 8005942:	b005      	add	sp, #20
 8005944:	f85d fb04 	ldr.w	pc, [sp], #4
 8005948:	200014d5 	.word	0x200014d5
 800594c:	20001bf8 	.word	0x20001bf8

08005950 <print_line>:

static void print_line(void) {
 8005950:	b500      	push	{lr}
 8005952:	b083      	sub	sp, #12
  unsigned i;

  for (i = 0; i < 76; i++)
 8005954:	2300      	movs	r3, #0
 8005956:	9301      	str	r3, [sp, #4]
 8005958:	e00b      	b.n	8005972 <print_line+0x22>
    chSequentialStreamPut(chp, '-');
 800595a:	4b0e      	ldr	r3, [pc, #56]	; (8005994 <print_line+0x44>)
 800595c:	681b      	ldr	r3, [r3, #0]
 800595e:	681b      	ldr	r3, [r3, #0]
 8005960:	689b      	ldr	r3, [r3, #8]
 8005962:	4a0c      	ldr	r2, [pc, #48]	; (8005994 <print_line+0x44>)
 8005964:	6812      	ldr	r2, [r2, #0]
 8005966:	4610      	mov	r0, r2
 8005968:	212d      	movs	r1, #45	; 0x2d
 800596a:	4798      	blx	r3
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 800596c:	9b01      	ldr	r3, [sp, #4]
 800596e:	3301      	adds	r3, #1
 8005970:	9301      	str	r3, [sp, #4]
 8005972:	9b01      	ldr	r3, [sp, #4]
 8005974:	2b4b      	cmp	r3, #75	; 0x4b
 8005976:	d9f0      	bls.n	800595a <print_line+0xa>
    chSequentialStreamPut(chp, '-');
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 8005978:	4b06      	ldr	r3, [pc, #24]	; (8005994 <print_line+0x44>)
 800597a:	681b      	ldr	r3, [r3, #0]
 800597c:	681b      	ldr	r3, [r3, #0]
 800597e:	681b      	ldr	r3, [r3, #0]
 8005980:	4a04      	ldr	r2, [pc, #16]	; (8005994 <print_line+0x44>)
 8005982:	6812      	ldr	r2, [r2, #0]
 8005984:	4610      	mov	r0, r2
 8005986:	4904      	ldr	r1, [pc, #16]	; (8005998 <print_line+0x48>)
 8005988:	2202      	movs	r2, #2
 800598a:	4798      	blx	r3
}
 800598c:	b003      	add	sp, #12
 800598e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005992:	bf00      	nop
 8005994:	20001c0c 	.word	0x20001c0c
 8005998:	0800d890 	.word	0x0800d890
 800599c:	00000000 	.word	0x00000000

080059a0 <TestThread>:
/**
 * @brief   Test execution thread function.
 *
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
void TestThread(void *p) {
 80059a0:	b500      	push	{lr}
 80059a2:	b085      	sub	sp, #20
 80059a4:	9001      	str	r0, [sp, #4]
  int i, j;

  chp = p;
 80059a6:	4a5f      	ldr	r2, [pc, #380]	; (8005b24 <TestThread+0x184>)
 80059a8:	9b01      	ldr	r3, [sp, #4]
 80059aa:	6013      	str	r3, [r2, #0]
  test_println("");
 80059ac:	485e      	ldr	r0, [pc, #376]	; (8005b28 <TestThread+0x188>)
 80059ae:	f7ff fe3f 	bl	8005630 <test_println>
  test_println("*** ChibiOS/RT test suite");
 80059b2:	485e      	ldr	r0, [pc, #376]	; (8005b2c <TestThread+0x18c>)
 80059b4:	f7ff fe3c 	bl	8005630 <test_println>
  test_println("***");
 80059b8:	485d      	ldr	r0, [pc, #372]	; (8005b30 <TestThread+0x190>)
 80059ba:	f7ff fe39 	bl	8005630 <test_println>
  test_print("*** Kernel:       ");
 80059be:	485d      	ldr	r0, [pc, #372]	; (8005b34 <TestThread+0x194>)
 80059c0:	f7ff fe16 	bl	80055f0 <test_print>
  test_println(CH_KERNEL_VERSION);
 80059c4:	485c      	ldr	r0, [pc, #368]	; (8005b38 <TestThread+0x198>)
 80059c6:	f7ff fe33 	bl	8005630 <test_println>
  test_print("*** Compiled:     ");
 80059ca:	485c      	ldr	r0, [pc, #368]	; (8005b3c <TestThread+0x19c>)
 80059cc:	f7ff fe10 	bl	80055f0 <test_print>
  test_println(__DATE__ " - " __TIME__);
 80059d0:	485b      	ldr	r0, [pc, #364]	; (8005b40 <TestThread+0x1a0>)
 80059d2:	f7ff fe2d 	bl	8005630 <test_println>
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
 80059d6:	485b      	ldr	r0, [pc, #364]	; (8005b44 <TestThread+0x1a4>)
 80059d8:	f7ff fe0a 	bl	80055f0 <test_print>
  test_println(PORT_COMPILER_NAME);
 80059dc:	485a      	ldr	r0, [pc, #360]	; (8005b48 <TestThread+0x1a8>)
 80059de:	f7ff fe27 	bl	8005630 <test_println>
#endif
  test_print("*** Architecture: ");
 80059e2:	485a      	ldr	r0, [pc, #360]	; (8005b4c <TestThread+0x1ac>)
 80059e4:	f7ff fe04 	bl	80055f0 <test_print>
  test_println(PORT_ARCHITECTURE_NAME);
 80059e8:	4859      	ldr	r0, [pc, #356]	; (8005b50 <TestThread+0x1b0>)
 80059ea:	f7ff fe21 	bl	8005630 <test_println>
#ifdef PORT_CORE_VARIANT_NAME
  test_print("*** Core Variant: ");
 80059ee:	4859      	ldr	r0, [pc, #356]	; (8005b54 <TestThread+0x1b4>)
 80059f0:	f7ff fdfe 	bl	80055f0 <test_print>
  test_println(PORT_CORE_VARIANT_NAME);
 80059f4:	4858      	ldr	r0, [pc, #352]	; (8005b58 <TestThread+0x1b8>)
 80059f6:	f7ff fe1b 	bl	8005630 <test_println>
#endif
#ifdef PORT_INFO
  test_print("*** Port Info:    ");
 80059fa:	4858      	ldr	r0, [pc, #352]	; (8005b5c <TestThread+0x1bc>)
 80059fc:	f7ff fdf8 	bl	80055f0 <test_print>
  test_println(PORT_INFO);
 8005a00:	4857      	ldr	r0, [pc, #348]	; (8005b60 <TestThread+0x1c0>)
 8005a02:	f7ff fe15 	bl	8005630 <test_println>
#endif
#ifdef PLATFORM_NAME
  test_print("*** Platform:     ");
 8005a06:	4857      	ldr	r0, [pc, #348]	; (8005b64 <TestThread+0x1c4>)
 8005a08:	f7ff fdf2 	bl	80055f0 <test_print>
  test_println(PLATFORM_NAME);
 8005a0c:	4856      	ldr	r0, [pc, #344]	; (8005b68 <TestThread+0x1c8>)
 8005a0e:	f7ff fe0f 	bl	8005630 <test_println>
#endif
#ifdef BOARD_NAME
  test_print("*** Test Board:   ");
 8005a12:	4856      	ldr	r0, [pc, #344]	; (8005b6c <TestThread+0x1cc>)
 8005a14:	f7ff fdec 	bl	80055f0 <test_print>
  test_println(BOARD_NAME);
 8005a18:	4855      	ldr	r0, [pc, #340]	; (8005b70 <TestThread+0x1d0>)
 8005a1a:	f7ff fe09 	bl	8005630 <test_println>
#endif
  test_println("");
 8005a1e:	4842      	ldr	r0, [pc, #264]	; (8005b28 <TestThread+0x188>)
 8005a20:	f7ff fe06 	bl	8005630 <test_println>

  test_global_fail = FALSE;
 8005a24:	4b53      	ldr	r3, [pc, #332]	; (8005b74 <TestThread+0x1d4>)
 8005a26:	2200      	movs	r2, #0
 8005a28:	701a      	strb	r2, [r3, #0]
  i = 0;
 8005a2a:	2300      	movs	r3, #0
 8005a2c:	9303      	str	r3, [sp, #12]
 8005a2e:	e05d      	b.n	8005aec <TestThread+0x14c>
  while (patterns[i]) {
    j = 0;
 8005a30:	2300      	movs	r3, #0
 8005a32:	9302      	str	r3, [sp, #8]
 8005a34:	e04d      	b.n	8005ad2 <TestThread+0x132>
    while (patterns[i][j]) {
      print_line();
 8005a36:	f7ff ff8b 	bl	8005950 <print_line>
      test_print("--- Test Case ");
 8005a3a:	484f      	ldr	r0, [pc, #316]	; (8005b78 <TestThread+0x1d8>)
 8005a3c:	f7ff fdd8 	bl	80055f0 <test_print>
      test_printn(i + 1);
 8005a40:	9b03      	ldr	r3, [sp, #12]
 8005a42:	3301      	adds	r3, #1
 8005a44:	4618      	mov	r0, r3
 8005a46:	f7ff fd8b 	bl	8005560 <test_printn>
      test_print(".");
 8005a4a:	484c      	ldr	r0, [pc, #304]	; (8005b7c <TestThread+0x1dc>)
 8005a4c:	f7ff fdd0 	bl	80055f0 <test_print>
      test_printn(j + 1);
 8005a50:	9b02      	ldr	r3, [sp, #8]
 8005a52:	3301      	adds	r3, #1
 8005a54:	4618      	mov	r0, r3
 8005a56:	f7ff fd83 	bl	8005560 <test_printn>
      test_print(" (");
 8005a5a:	4849      	ldr	r0, [pc, #292]	; (8005b80 <TestThread+0x1e0>)
 8005a5c:	f7ff fdc8 	bl	80055f0 <test_print>
      test_print(patterns[i][j]->name);
 8005a60:	4a48      	ldr	r2, [pc, #288]	; (8005b84 <TestThread+0x1e4>)
 8005a62:	9b03      	ldr	r3, [sp, #12]
 8005a64:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8005a68:	9b02      	ldr	r3, [sp, #8]
 8005a6a:	009b      	lsls	r3, r3, #2
 8005a6c:	4413      	add	r3, r2
 8005a6e:	681b      	ldr	r3, [r3, #0]
 8005a70:	681b      	ldr	r3, [r3, #0]
 8005a72:	4618      	mov	r0, r3
 8005a74:	f7ff fdbc 	bl	80055f0 <test_print>
      test_println(")");
 8005a78:	4843      	ldr	r0, [pc, #268]	; (8005b88 <TestThread+0x1e8>)
 8005a7a:	f7ff fdd9 	bl	8005630 <test_println>
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
 8005a7e:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8005a82:	f007 f94d 	bl	800cd20 <chThdSleep>
#endif
      execute_test(patterns[i][j]);
 8005a86:	4a3f      	ldr	r2, [pc, #252]	; (8005b84 <TestThread+0x1e4>)
 8005a88:	9b03      	ldr	r3, [sp, #12]
 8005a8a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8005a8e:	9b02      	ldr	r3, [sp, #8]
 8005a90:	009b      	lsls	r3, r3, #2
 8005a92:	4413      	add	r3, r2
 8005a94:	681b      	ldr	r3, [r3, #0]
 8005a96:	4618      	mov	r0, r3
 8005a98:	f7ff ff2a 	bl	80058f0 <execute_test>
      if (local_fail) {
 8005a9c:	4b3b      	ldr	r3, [pc, #236]	; (8005b8c <TestThread+0x1ec>)
 8005a9e:	781b      	ldrb	r3, [r3, #0]
 8005aa0:	2b00      	cmp	r3, #0
 8005aa2:	d010      	beq.n	8005ac6 <TestThread+0x126>
        test_print("--- Result: FAILURE (#");
 8005aa4:	483a      	ldr	r0, [pc, #232]	; (8005b90 <TestThread+0x1f0>)
 8005aa6:	f7ff fda3 	bl	80055f0 <test_print>
        test_printn(failpoint);
 8005aaa:	4b3a      	ldr	r3, [pc, #232]	; (8005b94 <TestThread+0x1f4>)
 8005aac:	681b      	ldr	r3, [r3, #0]
 8005aae:	4618      	mov	r0, r3
 8005ab0:	f7ff fd56 	bl	8005560 <test_printn>
        test_print(" [");
 8005ab4:	4838      	ldr	r0, [pc, #224]	; (8005b98 <TestThread+0x1f8>)
 8005ab6:	f7ff fd9b 	bl	80055f0 <test_print>
        print_tokens();
 8005aba:	f7ff fdd9 	bl	8005670 <print_tokens>
        test_println("])");
 8005abe:	4837      	ldr	r0, [pc, #220]	; (8005b9c <TestThread+0x1fc>)
 8005ac0:	f7ff fdb6 	bl	8005630 <test_println>
 8005ac4:	e002      	b.n	8005acc <TestThread+0x12c>
      }
      else
        test_println("--- Result: SUCCESS");
 8005ac6:	4836      	ldr	r0, [pc, #216]	; (8005ba0 <TestThread+0x200>)
 8005ac8:	f7ff fdb2 	bl	8005630 <test_println>
      j++;
 8005acc:	9b02      	ldr	r3, [sp, #8]
 8005ace:	3301      	adds	r3, #1
 8005ad0:	9302      	str	r3, [sp, #8]

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
 8005ad2:	4a2c      	ldr	r2, [pc, #176]	; (8005b84 <TestThread+0x1e4>)
 8005ad4:	9b03      	ldr	r3, [sp, #12]
 8005ad6:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8005ada:	9b02      	ldr	r3, [sp, #8]
 8005adc:	009b      	lsls	r3, r3, #2
 8005ade:	4413      	add	r3, r2
 8005ae0:	681b      	ldr	r3, [r3, #0]
 8005ae2:	2b00      	cmp	r3, #0
 8005ae4:	d1a7      	bne.n	8005a36 <TestThread+0x96>
      }
      else
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
 8005ae6:	9b03      	ldr	r3, [sp, #12]
 8005ae8:	3301      	adds	r3, #1
 8005aea:	9303      	str	r3, [sp, #12]
#endif
  test_println("");

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
 8005aec:	4a25      	ldr	r2, [pc, #148]	; (8005b84 <TestThread+0x1e4>)
 8005aee:	9b03      	ldr	r3, [sp, #12]
 8005af0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8005af4:	2b00      	cmp	r3, #0
 8005af6:	d19b      	bne.n	8005a30 <TestThread+0x90>
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
  }
  print_line();
 8005af8:	f7ff ff2a 	bl	8005950 <print_line>
  test_println("");
 8005afc:	480a      	ldr	r0, [pc, #40]	; (8005b28 <TestThread+0x188>)
 8005afe:	f7ff fd97 	bl	8005630 <test_println>
  test_print("Final result: ");
 8005b02:	4828      	ldr	r0, [pc, #160]	; (8005ba4 <TestThread+0x204>)
 8005b04:	f7ff fd74 	bl	80055f0 <test_print>
  if (test_global_fail)
 8005b08:	4b1a      	ldr	r3, [pc, #104]	; (8005b74 <TestThread+0x1d4>)
 8005b0a:	781b      	ldrb	r3, [r3, #0]
 8005b0c:	2b00      	cmp	r3, #0
 8005b0e:	d003      	beq.n	8005b18 <TestThread+0x178>
    test_println("FAILURE");
 8005b10:	4825      	ldr	r0, [pc, #148]	; (8005ba8 <TestThread+0x208>)
 8005b12:	f7ff fd8d 	bl	8005630 <test_println>
 8005b16:	e002      	b.n	8005b1e <TestThread+0x17e>
  else
    test_println("SUCCESS");
 8005b18:	4824      	ldr	r0, [pc, #144]	; (8005bac <TestThread+0x20c>)
 8005b1a:	f7ff fd89 	bl	8005630 <test_println>
}
 8005b1e:	b005      	add	sp, #20
 8005b20:	f85d fb04 	ldr.w	pc, [sp], #4
 8005b24:	20001c0c 	.word	0x20001c0c
 8005b28:	0800d894 	.word	0x0800d894
 8005b2c:	0800d898 	.word	0x0800d898
 8005b30:	0800d8b4 	.word	0x0800d8b4
 8005b34:	0800d8b8 	.word	0x0800d8b8
 8005b38:	0800d8cc 	.word	0x0800d8cc
 8005b3c:	0800d8d4 	.word	0x0800d8d4
 8005b40:	0800d8e8 	.word	0x0800d8e8
 8005b44:	0800d900 	.word	0x0800d900
 8005b48:	0800d914 	.word	0x0800d914
 8005b4c:	0800d95c 	.word	0x0800d95c
 8005b50:	0800d970 	.word	0x0800d970
 8005b54:	0800d97c 	.word	0x0800d97c
 8005b58:	0800d990 	.word	0x0800d990
 8005b5c:	0800d99c 	.word	0x0800d99c
 8005b60:	0800d9b0 	.word	0x0800d9b0
 8005b64:	0800d9c8 	.word	0x0800d9c8
 8005b68:	0800d9dc 	.word	0x0800d9dc
 8005b6c:	0800da0c 	.word	0x0800da0c
 8005b70:	0800da20 	.word	0x0800da20
 8005b74:	200014d4 	.word	0x200014d4
 8005b78:	0800da44 	.word	0x0800da44
 8005b7c:	0800da54 	.word	0x0800da54
 8005b80:	0800da58 	.word	0x0800da58
 8005b84:	20000800 	.word	0x20000800
 8005b88:	0800da5c 	.word	0x0800da5c
 8005b8c:	200014d5 	.word	0x200014d5
 8005b90:	0800da60 	.word	0x0800da60
 8005b94:	200014d8 	.word	0x200014d8
 8005b98:	0800da78 	.word	0x0800da78
 8005b9c:	0800da7c 	.word	0x0800da7c
 8005ba0:	0800da80 	.word	0x0800da80
 8005ba4:	0800da94 	.word	0x0800da94
 8005ba8:	0800daa4 	.word	0x0800daa4
 8005bac:	0800daac 	.word	0x0800daac

08005bb0 <port_lock.lto_priv.225>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8005bb0:	b082      	sub	sp, #8
 8005bb2:	2320      	movs	r3, #32
 8005bb4:	9301      	str	r3, [sp, #4]
 8005bb6:	9b01      	ldr	r3, [sp, #4]
 8005bb8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8005bbc:	b002      	add	sp, #8
 8005bbe:	4770      	bx	lr

08005bc0 <port_unlock.lto_priv.222>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8005bc0:	b082      	sub	sp, #8
 8005bc2:	2300      	movs	r3, #0
 8005bc4:	9301      	str	r3, [sp, #4]
 8005bc6:	9b01      	ldr	r3, [sp, #4]
 8005bc8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8005bcc:	b002      	add	sp, #8
 8005bce:	4770      	bx	lr

08005bd0 <st_lld_get_counter.lto_priv.219>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8005bd0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005bd4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8005bd6:	4618      	mov	r0, r3
 8005bd8:	4770      	bx	lr
 8005bda:	bf00      	nop
 8005bdc:	0000      	movs	r0, r0
	...

08005be0 <port_timer_get_time.lto_priv.216>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8005be0:	b508      	push	{r3, lr}

  return stGetCounter();
 8005be2:	f7ff fff5 	bl	8005bd0 <st_lld_get_counter.lto_priv.219>
 8005be6:	4603      	mov	r3, r0
}
 8005be8:	4618      	mov	r0, r3
 8005bea:	bd08      	pop	{r3, pc}
 8005bec:	0000      	movs	r0, r0
	...

08005bf0 <chSysLock.lto_priv.232>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8005bf0:	b508      	push	{r3, lr}

  port_lock();
 8005bf2:	f7ff ffdd 	bl	8005bb0 <port_lock.lto_priv.225>
  _stats_start_measure_crit_thd();
 8005bf6:	f004 fc23 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8005bfa:	f006 f8d1 	bl	800bda0 <_dbg_check_lock>
}
 8005bfe:	bd08      	pop	{r3, pc}

08005c00 <chSysUnlock.lto_priv.230>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8005c00:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8005c02:	f006 f8e5 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8005c06:	f004 fc23 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8005c0a:	4b09      	ldr	r3, [pc, #36]	; (8005c30 <chSysUnlock.lto_priv.230+0x30>)
 8005c0c:	681b      	ldr	r3, [r3, #0]
 8005c0e:	4a08      	ldr	r2, [pc, #32]	; (8005c30 <chSysUnlock.lto_priv.230+0x30>)
 8005c10:	4293      	cmp	r3, r2
 8005c12:	d00a      	beq.n	8005c2a <chSysUnlock.lto_priv.230+0x2a>
 8005c14:	4b06      	ldr	r3, [pc, #24]	; (8005c30 <chSysUnlock.lto_priv.230+0x30>)
 8005c16:	699b      	ldr	r3, [r3, #24]
 8005c18:	689a      	ldr	r2, [r3, #8]
 8005c1a:	4b05      	ldr	r3, [pc, #20]	; (8005c30 <chSysUnlock.lto_priv.230+0x30>)
 8005c1c:	681b      	ldr	r3, [r3, #0]
 8005c1e:	689b      	ldr	r3, [r3, #8]
 8005c20:	429a      	cmp	r2, r3
 8005c22:	d202      	bcs.n	8005c2a <chSysUnlock.lto_priv.230+0x2a>
 8005c24:	4803      	ldr	r0, [pc, #12]	; (8005c34 <chSysUnlock.lto_priv.230+0x34>)
 8005c26:	f005 ff63 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8005c2a:	f7ff ffc9 	bl	8005bc0 <port_unlock.lto_priv.222>
}
 8005c2e:	bd08      	pop	{r3, pc}
 8005c30:	20000d30 	.word	0x20000d30
 8005c34:	0800e4b0 	.word	0x0800e4b0
	...

08005c40 <chVTGetSystemTimeX.lto_priv.213>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8005c40:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8005c42:	f7ff ffcd 	bl	8005be0 <port_timer_get_time.lto_priv.216>
 8005c46:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8005c48:	4618      	mov	r0, r3
 8005c4a:	bd08      	pop	{r3, pc}
 8005c4c:	0000      	movs	r0, r0
	...

08005c50 <chVTGetSystemTime.lto_priv.228>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 8005c50:	b500      	push	{lr}
 8005c52:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 8005c54:	f7ff ffcc 	bl	8005bf0 <chSysLock.lto_priv.232>
  systime = chVTGetSystemTimeX();
 8005c58:	f7ff fff2 	bl	8005c40 <chVTGetSystemTimeX.lto_priv.213>
 8005c5c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 8005c5e:	f7ff ffcf 	bl	8005c00 <chSysUnlock.lto_priv.230>

  return systime;
 8005c62:	9b01      	ldr	r3, [sp, #4]
}
 8005c64:	4618      	mov	r0, r3
 8005c66:	b003      	add	sp, #12
 8005c68:	f85d fb04 	ldr.w	pc, [sp], #4
 8005c6c:	0000      	movs	r0, r0
	...

08005c70 <chThdGetSelfX.lto_priv.210>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8005c70:	4b01      	ldr	r3, [pc, #4]	; (8005c78 <chThdGetSelfX.lto_priv.210+0x8>)
 8005c72:	699b      	ldr	r3, [r3, #24]
}
 8005c74:	4618      	mov	r0, r3
 8005c76:	4770      	bx	lr
 8005c78:	20000d30 	.word	0x20000d30
 8005c7c:	00000000 	.word	0x00000000

08005c80 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 8005c80:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 8005c82:	f7ff fff5 	bl	8005c70 <chThdGetSelfX.lto_priv.210>
 8005c86:	4603      	mov	r3, r0
 8005c88:	689b      	ldr	r3, [r3, #8]
}
 8005c8a:	4618      	mov	r0, r3
 8005c8c:	bd08      	pop	{r3, pc}
 8005c8e:	bf00      	nop

08005c90 <thread>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static THD_FUNCTION(thread, p) {
 8005c90:	b500      	push	{lr}
 8005c92:	b083      	sub	sp, #12
 8005c94:	9001      	str	r0, [sp, #4]

  test_emit_token(*(char *)p);
 8005c96:	9b01      	ldr	r3, [sp, #4]
 8005c98:	781b      	ldrb	r3, [r3, #0]
 8005c9a:	4618      	mov	r0, r3
 8005c9c:	f7ff fd08 	bl	80056b0 <test_emit_token>
}
 8005ca0:	b003      	add	sp, #12
 8005ca2:	f85d fb04 	ldr.w	pc, [sp], #4
 8005ca6:	bf00      	nop
	...

08005cb0 <thd1_execute.lto_priv.102>:

static void thd1_execute(void) {
 8005cb0:	b510      	push	{r4, lr}
 8005cb2:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8005cb4:	4b2e      	ldr	r3, [pc, #184]	; (8005d70 <thd1_execute.lto_priv.102+0xc0>)
 8005cb6:	681c      	ldr	r4, [r3, #0]
 8005cb8:	f7ff ffe2 	bl	8005c80 <chThdGetPriorityX>
 8005cbc:	4603      	mov	r3, r0
 8005cbe:	1f5a      	subs	r2, r3, #5
 8005cc0:	4b2c      	ldr	r3, [pc, #176]	; (8005d74 <thd1_execute.lto_priv.102+0xc4>)
 8005cc2:	9300      	str	r3, [sp, #0]
 8005cc4:	4620      	mov	r0, r4
 8005cc6:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8005cca:	4b2b      	ldr	r3, [pc, #172]	; (8005d78 <thd1_execute.lto_priv.102+0xc8>)
 8005ccc:	f006 ff98 	bl	800cc00 <chThdCreateStatic>
 8005cd0:	4602      	mov	r2, r0
 8005cd2:	4b2a      	ldr	r3, [pc, #168]	; (8005d7c <thd1_execute.lto_priv.102+0xcc>)
 8005cd4:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8005cd6:	4b26      	ldr	r3, [pc, #152]	; (8005d70 <thd1_execute.lto_priv.102+0xc0>)
 8005cd8:	685c      	ldr	r4, [r3, #4]
 8005cda:	f7ff ffd1 	bl	8005c80 <chThdGetPriorityX>
 8005cde:	4603      	mov	r3, r0
 8005ce0:	1f1a      	subs	r2, r3, #4
 8005ce2:	4b27      	ldr	r3, [pc, #156]	; (8005d80 <thd1_execute.lto_priv.102+0xd0>)
 8005ce4:	9300      	str	r3, [sp, #0]
 8005ce6:	4620      	mov	r0, r4
 8005ce8:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8005cec:	4b22      	ldr	r3, [pc, #136]	; (8005d78 <thd1_execute.lto_priv.102+0xc8>)
 8005cee:	f006 ff87 	bl	800cc00 <chThdCreateStatic>
 8005cf2:	4602      	mov	r2, r0
 8005cf4:	4b21      	ldr	r3, [pc, #132]	; (8005d7c <thd1_execute.lto_priv.102+0xcc>)
 8005cf6:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8005cf8:	4b1d      	ldr	r3, [pc, #116]	; (8005d70 <thd1_execute.lto_priv.102+0xc0>)
 8005cfa:	689c      	ldr	r4, [r3, #8]
 8005cfc:	f7ff ffc0 	bl	8005c80 <chThdGetPriorityX>
 8005d00:	4603      	mov	r3, r0
 8005d02:	1eda      	subs	r2, r3, #3
 8005d04:	4b1f      	ldr	r3, [pc, #124]	; (8005d84 <thd1_execute.lto_priv.102+0xd4>)
 8005d06:	9300      	str	r3, [sp, #0]
 8005d08:	4620      	mov	r0, r4
 8005d0a:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8005d0e:	4b1a      	ldr	r3, [pc, #104]	; (8005d78 <thd1_execute.lto_priv.102+0xc8>)
 8005d10:	f006 ff76 	bl	800cc00 <chThdCreateStatic>
 8005d14:	4602      	mov	r2, r0
 8005d16:	4b19      	ldr	r3, [pc, #100]	; (8005d7c <thd1_execute.lto_priv.102+0xcc>)
 8005d18:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8005d1a:	4b15      	ldr	r3, [pc, #84]	; (8005d70 <thd1_execute.lto_priv.102+0xc0>)
 8005d1c:	68dc      	ldr	r4, [r3, #12]
 8005d1e:	f7ff ffaf 	bl	8005c80 <chThdGetPriorityX>
 8005d22:	4603      	mov	r3, r0
 8005d24:	1e9a      	subs	r2, r3, #2
 8005d26:	4b18      	ldr	r3, [pc, #96]	; (8005d88 <thd1_execute.lto_priv.102+0xd8>)
 8005d28:	9300      	str	r3, [sp, #0]
 8005d2a:	4620      	mov	r0, r4
 8005d2c:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8005d30:	4b11      	ldr	r3, [pc, #68]	; (8005d78 <thd1_execute.lto_priv.102+0xc8>)
 8005d32:	f006 ff65 	bl	800cc00 <chThdCreateStatic>
 8005d36:	4602      	mov	r2, r0
 8005d38:	4b10      	ldr	r3, [pc, #64]	; (8005d7c <thd1_execute.lto_priv.102+0xcc>)
 8005d3a:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8005d3c:	4b0c      	ldr	r3, [pc, #48]	; (8005d70 <thd1_execute.lto_priv.102+0xc0>)
 8005d3e:	691c      	ldr	r4, [r3, #16]
 8005d40:	f7ff ff9e 	bl	8005c80 <chThdGetPriorityX>
 8005d44:	4603      	mov	r3, r0
 8005d46:	1e5a      	subs	r2, r3, #1
 8005d48:	4b10      	ldr	r3, [pc, #64]	; (8005d8c <thd1_execute.lto_priv.102+0xdc>)
 8005d4a:	9300      	str	r3, [sp, #0]
 8005d4c:	4620      	mov	r0, r4
 8005d4e:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8005d52:	4b09      	ldr	r3, [pc, #36]	; (8005d78 <thd1_execute.lto_priv.102+0xc8>)
 8005d54:	f006 ff54 	bl	800cc00 <chThdCreateStatic>
 8005d58:	4602      	mov	r2, r0
 8005d5a:	4b08      	ldr	r3, [pc, #32]	; (8005d7c <thd1_execute.lto_priv.102+0xcc>)
 8005d5c:	611a      	str	r2, [r3, #16]
  test_wait_threads();
 8005d5e:	f7ff fd57 	bl	8005810 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8005d62:	2001      	movs	r0, #1
 8005d64:	490a      	ldr	r1, [pc, #40]	; (8005d90 <thd1_execute.lto_priv.102+0xe0>)
 8005d66:	f7ff fceb 	bl	8005740 <_test_assert_sequence>
}
 8005d6a:	b002      	add	sp, #8
 8005d6c:	bd10      	pop	{r4, pc}
 8005d6e:	bf00      	nop
 8005d70:	0800e420 	.word	0x0800e420
 8005d74:	0800dab4 	.word	0x0800dab4
 8005d78:	08005c91 	.word	0x08005c91
 8005d7c:	20001bf8 	.word	0x20001bf8
 8005d80:	0800dab8 	.word	0x0800dab8
 8005d84:	0800dabc 	.word	0x0800dabc
 8005d88:	0800dac0 	.word	0x0800dac0
 8005d8c:	0800dac4 	.word	0x0800dac4
 8005d90:	0800dac8 	.word	0x0800dac8
	...

08005da0 <thd2_execute.lto_priv.101>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 8005da0:	b510      	push	{r4, lr}
 8005da2:	b082      	sub	sp, #8

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8005da4:	4b32      	ldr	r3, [pc, #200]	; (8005e70 <thd2_execute.lto_priv.101+0xd0>)
 8005da6:	685c      	ldr	r4, [r3, #4]
 8005da8:	f7ff ff6a 	bl	8005c80 <chThdGetPriorityX>
 8005dac:	4603      	mov	r3, r0
 8005dae:	1f1a      	subs	r2, r3, #4
 8005db0:	4b30      	ldr	r3, [pc, #192]	; (8005e74 <thd2_execute.lto_priv.101+0xd4>)
 8005db2:	9300      	str	r3, [sp, #0]
 8005db4:	4620      	mov	r0, r4
 8005db6:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8005dba:	4b2f      	ldr	r3, [pc, #188]	; (8005e78 <thd2_execute.lto_priv.101+0xd8>)
 8005dbc:	f006 ff20 	bl	800cc00 <chThdCreateStatic>
 8005dc0:	4602      	mov	r2, r0
 8005dc2:	4b2e      	ldr	r3, [pc, #184]	; (8005e7c <thd2_execute.lto_priv.101+0xdc>)
 8005dc4:	605a      	str	r2, [r3, #4]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8005dc6:	4b2a      	ldr	r3, [pc, #168]	; (8005e70 <thd2_execute.lto_priv.101+0xd0>)
 8005dc8:	681c      	ldr	r4, [r3, #0]
 8005dca:	f7ff ff59 	bl	8005c80 <chThdGetPriorityX>
 8005dce:	4603      	mov	r3, r0
 8005dd0:	1f5a      	subs	r2, r3, #5
 8005dd2:	4b2b      	ldr	r3, [pc, #172]	; (8005e80 <thd2_execute.lto_priv.101+0xe0>)
 8005dd4:	9300      	str	r3, [sp, #0]
 8005dd6:	4620      	mov	r0, r4
 8005dd8:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8005ddc:	4b26      	ldr	r3, [pc, #152]	; (8005e78 <thd2_execute.lto_priv.101+0xd8>)
 8005dde:	f006 ff0f 	bl	800cc00 <chThdCreateStatic>
 8005de2:	4602      	mov	r2, r0
 8005de4:	4b25      	ldr	r3, [pc, #148]	; (8005e7c <thd2_execute.lto_priv.101+0xdc>)
 8005de6:	601a      	str	r2, [r3, #0]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8005de8:	4b21      	ldr	r3, [pc, #132]	; (8005e70 <thd2_execute.lto_priv.101+0xd0>)
 8005dea:	691c      	ldr	r4, [r3, #16]
 8005dec:	f7ff ff48 	bl	8005c80 <chThdGetPriorityX>
 8005df0:	4603      	mov	r3, r0
 8005df2:	1e5a      	subs	r2, r3, #1
 8005df4:	4b23      	ldr	r3, [pc, #140]	; (8005e84 <thd2_execute.lto_priv.101+0xe4>)
 8005df6:	9300      	str	r3, [sp, #0]
 8005df8:	4620      	mov	r0, r4
 8005dfa:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8005dfe:	4b1e      	ldr	r3, [pc, #120]	; (8005e78 <thd2_execute.lto_priv.101+0xd8>)
 8005e00:	f006 fefe 	bl	800cc00 <chThdCreateStatic>
 8005e04:	4602      	mov	r2, r0
 8005e06:	4b1d      	ldr	r3, [pc, #116]	; (8005e7c <thd2_execute.lto_priv.101+0xdc>)
 8005e08:	611a      	str	r2, [r3, #16]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8005e0a:	4b19      	ldr	r3, [pc, #100]	; (8005e70 <thd2_execute.lto_priv.101+0xd0>)
 8005e0c:	68dc      	ldr	r4, [r3, #12]
 8005e0e:	f7ff ff37 	bl	8005c80 <chThdGetPriorityX>
 8005e12:	4603      	mov	r3, r0
 8005e14:	1e9a      	subs	r2, r3, #2
 8005e16:	4b1c      	ldr	r3, [pc, #112]	; (8005e88 <thd2_execute.lto_priv.101+0xe8>)
 8005e18:	9300      	str	r3, [sp, #0]
 8005e1a:	4620      	mov	r0, r4
 8005e1c:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8005e20:	4b15      	ldr	r3, [pc, #84]	; (8005e78 <thd2_execute.lto_priv.101+0xd8>)
 8005e22:	f006 feed 	bl	800cc00 <chThdCreateStatic>
 8005e26:	4602      	mov	r2, r0
 8005e28:	4b14      	ldr	r3, [pc, #80]	; (8005e7c <thd2_execute.lto_priv.101+0xdc>)
 8005e2a:	60da      	str	r2, [r3, #12]
  /* Done this way for coverage of chThdCreateI() and chThdStart().*/
  chSysLock();
 8005e2c:	f7ff fee0 	bl	8005bf0 <chSysLock.lto_priv.232>
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8005e30:	4b0f      	ldr	r3, [pc, #60]	; (8005e70 <thd2_execute.lto_priv.101+0xd0>)
 8005e32:	689c      	ldr	r4, [r3, #8]
 8005e34:	f7ff ff24 	bl	8005c80 <chThdGetPriorityX>
 8005e38:	4603      	mov	r3, r0
 8005e3a:	1eda      	subs	r2, r3, #3
 8005e3c:	4b13      	ldr	r3, [pc, #76]	; (8005e8c <thd2_execute.lto_priv.101+0xec>)
 8005e3e:	9300      	str	r3, [sp, #0]
 8005e40:	4620      	mov	r0, r4
 8005e42:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8005e46:	4b0c      	ldr	r3, [pc, #48]	; (8005e78 <thd2_execute.lto_priv.101+0xd8>)
 8005e48:	f006 fea2 	bl	800cb90 <chThdCreateI>
 8005e4c:	4602      	mov	r2, r0
 8005e4e:	4b0b      	ldr	r3, [pc, #44]	; (8005e7c <thd2_execute.lto_priv.101+0xdc>)
 8005e50:	609a      	str	r2, [r3, #8]
  chSysUnlock();
 8005e52:	f7ff fed5 	bl	8005c00 <chSysUnlock.lto_priv.230>
  chThdStart(threads[2]);
 8005e56:	4b09      	ldr	r3, [pc, #36]	; (8005e7c <thd2_execute.lto_priv.101+0xdc>)
 8005e58:	689b      	ldr	r3, [r3, #8]
 8005e5a:	4618      	mov	r0, r3
 8005e5c:	f006 ff00 	bl	800cc60 <chThdStart>
  test_wait_threads();
 8005e60:	f7ff fcd6 	bl	8005810 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8005e64:	2001      	movs	r0, #1
 8005e66:	490a      	ldr	r1, [pc, #40]	; (8005e90 <thd2_execute.lto_priv.101+0xf0>)
 8005e68:	f7ff fc6a 	bl	8005740 <_test_assert_sequence>
}
 8005e6c:	b002      	add	sp, #8
 8005e6e:	bd10      	pop	{r4, pc}
 8005e70:	0800e420 	.word	0x0800e420
 8005e74:	0800dab8 	.word	0x0800dab8
 8005e78:	08005c91 	.word	0x08005c91
 8005e7c:	20001bf8 	.word	0x20001bf8
 8005e80:	0800dab4 	.word	0x0800dab4
 8005e84:	0800dac4 	.word	0x0800dac4
 8005e88:	0800dac0 	.word	0x0800dac0
 8005e8c:	0800dabc 	.word	0x0800dabc
 8005e90:	0800dac8 	.word	0x0800dac8
	...

08005ea0 <thd3_execute.lto_priv.100>:
 * to verify that the priority change happens as expected.<br>
 * If the @p CH_CFG_USE_MUTEXES option is enabled then the priority changes are
 * also tested under priority inheritance boosted priority state.
 */

static void thd3_execute(void) {
 8005ea0:	b500      	push	{lr}
 8005ea2:	b083      	sub	sp, #12
  tprio_t prio, p1;

  prio = chThdGetPriorityX();
 8005ea4:	f7ff feec 	bl	8005c80 <chThdGetPriorityX>
 8005ea8:	9001      	str	r0, [sp, #4]
  p1 = chThdSetPriority(prio + 1);
 8005eaa:	9b01      	ldr	r3, [sp, #4]
 8005eac:	3301      	adds	r3, #1
 8005eae:	4618      	mov	r0, r3
 8005eb0:	f006 fee6 	bl	800cc80 <chThdSetPriority>
 8005eb4:	9000      	str	r0, [sp, #0]
  test_assert(1, p1 == prio,
 8005eb6:	9a00      	ldr	r2, [sp, #0]
 8005eb8:	9b01      	ldr	r3, [sp, #4]
 8005eba:	429a      	cmp	r2, r3
 8005ebc:	bf0c      	ite	eq
 8005ebe:	2301      	moveq	r3, #1
 8005ec0:	2300      	movne	r3, #0
 8005ec2:	b2db      	uxtb	r3, r3
 8005ec4:	2001      	movs	r0, #1
 8005ec6:	4619      	mov	r1, r3
 8005ec8:	f7ff fc22 	bl	8005710 <_test_assert>
 8005ecc:	4603      	mov	r3, r0
 8005ece:	2b00      	cmp	r3, #0
 8005ed0:	f040 80d1 	bne.w	8006076 <thd3_execute.lto_priv.100+0x1d6>
              "unexpected returned priority level");
  test_assert(2, chThdGetPriorityX() == prio + 1,
 8005ed4:	f7ff fed4 	bl	8005c80 <chThdGetPriorityX>
 8005ed8:	4602      	mov	r2, r0
 8005eda:	9b01      	ldr	r3, [sp, #4]
 8005edc:	3301      	adds	r3, #1
 8005ede:	429a      	cmp	r2, r3
 8005ee0:	bf0c      	ite	eq
 8005ee2:	2301      	moveq	r3, #1
 8005ee4:	2300      	movne	r3, #0
 8005ee6:	b2db      	uxtb	r3, r3
 8005ee8:	2002      	movs	r0, #2
 8005eea:	4619      	mov	r1, r3
 8005eec:	f7ff fc10 	bl	8005710 <_test_assert>
 8005ef0:	4603      	mov	r3, r0
 8005ef2:	2b00      	cmp	r3, #0
 8005ef4:	f040 80bf 	bne.w	8006076 <thd3_execute.lto_priv.100+0x1d6>
              "unexpected priority level");
  p1 = chThdSetPriority(p1);
 8005ef8:	9800      	ldr	r0, [sp, #0]
 8005efa:	f006 fec1 	bl	800cc80 <chThdSetPriority>
 8005efe:	9000      	str	r0, [sp, #0]
  test_assert(3, p1 == prio + 1,
 8005f00:	9b01      	ldr	r3, [sp, #4]
 8005f02:	1c5a      	adds	r2, r3, #1
 8005f04:	9b00      	ldr	r3, [sp, #0]
 8005f06:	429a      	cmp	r2, r3
 8005f08:	bf0c      	ite	eq
 8005f0a:	2301      	moveq	r3, #1
 8005f0c:	2300      	movne	r3, #0
 8005f0e:	b2db      	uxtb	r3, r3
 8005f10:	2003      	movs	r0, #3
 8005f12:	4619      	mov	r1, r3
 8005f14:	f7ff fbfc 	bl	8005710 <_test_assert>
 8005f18:	4603      	mov	r3, r0
 8005f1a:	2b00      	cmp	r3, #0
 8005f1c:	f040 80ab 	bne.w	8006076 <thd3_execute.lto_priv.100+0x1d6>
              "unexpected returned priority level");
  test_assert(4, chThdGetPriorityX() == prio,
 8005f20:	f7ff feae 	bl	8005c80 <chThdGetPriorityX>
 8005f24:	4602      	mov	r2, r0
 8005f26:	9b01      	ldr	r3, [sp, #4]
 8005f28:	429a      	cmp	r2, r3
 8005f2a:	bf0c      	ite	eq
 8005f2c:	2301      	moveq	r3, #1
 8005f2e:	2300      	movne	r3, #0
 8005f30:	b2db      	uxtb	r3, r3
 8005f32:	2004      	movs	r0, #4
 8005f34:	4619      	mov	r1, r3
 8005f36:	f7ff fbeb 	bl	8005710 <_test_assert>
 8005f3a:	4603      	mov	r3, r0
 8005f3c:	2b00      	cmp	r3, #0
 8005f3e:	f040 809a 	bne.w	8006076 <thd3_execute.lto_priv.100+0x1d6>
              "unexpected priority level");

#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  /* Simulates a priority boost situation (p_prio > p_realprio).*/
  chSysLock();
 8005f42:	f7ff fe55 	bl	8005bf0 <chSysLock.lto_priv.232>
  chThdGetSelfX()->p_prio += 2;
 8005f46:	f7ff fe93 	bl	8005c70 <chThdGetSelfX.lto_priv.210>
 8005f4a:	4603      	mov	r3, r0
 8005f4c:	689a      	ldr	r2, [r3, #8]
 8005f4e:	3202      	adds	r2, #2
 8005f50:	609a      	str	r2, [r3, #8]
  chSysUnlock();
 8005f52:	f7ff fe55 	bl	8005c00 <chSysUnlock.lto_priv.230>
  test_assert(5, chThdGetPriorityX() == prio + 2,
 8005f56:	f7ff fe93 	bl	8005c80 <chThdGetPriorityX>
 8005f5a:	4602      	mov	r2, r0
 8005f5c:	9b01      	ldr	r3, [sp, #4]
 8005f5e:	3302      	adds	r3, #2
 8005f60:	429a      	cmp	r2, r3
 8005f62:	bf0c      	ite	eq
 8005f64:	2301      	moveq	r3, #1
 8005f66:	2300      	movne	r3, #0
 8005f68:	b2db      	uxtb	r3, r3
 8005f6a:	2005      	movs	r0, #5
 8005f6c:	4619      	mov	r1, r3
 8005f6e:	f7ff fbcf 	bl	8005710 <_test_assert>
 8005f72:	4603      	mov	r3, r0
 8005f74:	2b00      	cmp	r3, #0
 8005f76:	d17e      	bne.n	8006076 <thd3_execute.lto_priv.100+0x1d6>
              "unexpected priority level");

  /* Tries to raise but below the boost level. */
  p1 = chThdSetPriority(prio + 1);
 8005f78:	9b01      	ldr	r3, [sp, #4]
 8005f7a:	3301      	adds	r3, #1
 8005f7c:	4618      	mov	r0, r3
 8005f7e:	f006 fe7f 	bl	800cc80 <chThdSetPriority>
 8005f82:	9000      	str	r0, [sp, #0]
  test_assert(6, p1 == prio,
 8005f84:	9a00      	ldr	r2, [sp, #0]
 8005f86:	9b01      	ldr	r3, [sp, #4]
 8005f88:	429a      	cmp	r2, r3
 8005f8a:	bf0c      	ite	eq
 8005f8c:	2301      	moveq	r3, #1
 8005f8e:	2300      	movne	r3, #0
 8005f90:	b2db      	uxtb	r3, r3
 8005f92:	2006      	movs	r0, #6
 8005f94:	4619      	mov	r1, r3
 8005f96:	f7ff fbbb 	bl	8005710 <_test_assert>
 8005f9a:	4603      	mov	r3, r0
 8005f9c:	2b00      	cmp	r3, #0
 8005f9e:	d16a      	bne.n	8006076 <thd3_execute.lto_priv.100+0x1d6>
              "unexpected returned priority level");
  test_assert(7, chThdGetSelfX()->p_prio == prio + 2,
 8005fa0:	f7ff fe66 	bl	8005c70 <chThdGetSelfX.lto_priv.210>
 8005fa4:	4603      	mov	r3, r0
 8005fa6:	689a      	ldr	r2, [r3, #8]
 8005fa8:	9b01      	ldr	r3, [sp, #4]
 8005faa:	3302      	adds	r3, #2
 8005fac:	429a      	cmp	r2, r3
 8005fae:	bf0c      	ite	eq
 8005fb0:	2301      	moveq	r3, #1
 8005fb2:	2300      	movne	r3, #0
 8005fb4:	b2db      	uxtb	r3, r3
 8005fb6:	2007      	movs	r0, #7
 8005fb8:	4619      	mov	r1, r3
 8005fba:	f7ff fba9 	bl	8005710 <_test_assert>
 8005fbe:	4603      	mov	r3, r0
 8005fc0:	2b00      	cmp	r3, #0
 8005fc2:	d158      	bne.n	8006076 <thd3_execute.lto_priv.100+0x1d6>
              "unexpected priority level");
  test_assert(8, chThdGetSelfX()->p_realprio == prio + 1,
 8005fc4:	f7ff fe54 	bl	8005c70 <chThdGetSelfX.lto_priv.210>
 8005fc8:	4603      	mov	r3, r0
 8005fca:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8005fcc:	9b01      	ldr	r3, [sp, #4]
 8005fce:	3301      	adds	r3, #1
 8005fd0:	429a      	cmp	r2, r3
 8005fd2:	bf0c      	ite	eq
 8005fd4:	2301      	moveq	r3, #1
 8005fd6:	2300      	movne	r3, #0
 8005fd8:	b2db      	uxtb	r3, r3
 8005fda:	2008      	movs	r0, #8
 8005fdc:	4619      	mov	r1, r3
 8005fde:	f7ff fb97 	bl	8005710 <_test_assert>
 8005fe2:	4603      	mov	r3, r0
 8005fe4:	2b00      	cmp	r3, #0
 8005fe6:	d146      	bne.n	8006076 <thd3_execute.lto_priv.100+0x1d6>
              "unexpected returned real priority level");

  /* Tries to raise above the boost level. */
  p1 = chThdSetPriority(prio + 3);
 8005fe8:	9b01      	ldr	r3, [sp, #4]
 8005fea:	3303      	adds	r3, #3
 8005fec:	4618      	mov	r0, r3
 8005fee:	f006 fe47 	bl	800cc80 <chThdSetPriority>
 8005ff2:	9000      	str	r0, [sp, #0]
  test_assert(9, p1 == prio + 1,
 8005ff4:	9b01      	ldr	r3, [sp, #4]
 8005ff6:	1c5a      	adds	r2, r3, #1
 8005ff8:	9b00      	ldr	r3, [sp, #0]
 8005ffa:	429a      	cmp	r2, r3
 8005ffc:	bf0c      	ite	eq
 8005ffe:	2301      	moveq	r3, #1
 8006000:	2300      	movne	r3, #0
 8006002:	b2db      	uxtb	r3, r3
 8006004:	2009      	movs	r0, #9
 8006006:	4619      	mov	r1, r3
 8006008:	f7ff fb82 	bl	8005710 <_test_assert>
 800600c:	4603      	mov	r3, r0
 800600e:	2b00      	cmp	r3, #0
 8006010:	d131      	bne.n	8006076 <thd3_execute.lto_priv.100+0x1d6>
              "unexpected returned priority level");
  test_assert(10, chThdGetSelfX()->p_prio == prio + 3,
 8006012:	f7ff fe2d 	bl	8005c70 <chThdGetSelfX.lto_priv.210>
 8006016:	4603      	mov	r3, r0
 8006018:	689a      	ldr	r2, [r3, #8]
 800601a:	9b01      	ldr	r3, [sp, #4]
 800601c:	3303      	adds	r3, #3
 800601e:	429a      	cmp	r2, r3
 8006020:	bf0c      	ite	eq
 8006022:	2301      	moveq	r3, #1
 8006024:	2300      	movne	r3, #0
 8006026:	b2db      	uxtb	r3, r3
 8006028:	200a      	movs	r0, #10
 800602a:	4619      	mov	r1, r3
 800602c:	f7ff fb70 	bl	8005710 <_test_assert>
 8006030:	4603      	mov	r3, r0
 8006032:	2b00      	cmp	r3, #0
 8006034:	d11f      	bne.n	8006076 <thd3_execute.lto_priv.100+0x1d6>
              "unexpected priority level");
  test_assert(11, chThdGetSelfX()->p_realprio == prio + 3,
 8006036:	f7ff fe1b 	bl	8005c70 <chThdGetSelfX.lto_priv.210>
 800603a:	4603      	mov	r3, r0
 800603c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800603e:	9b01      	ldr	r3, [sp, #4]
 8006040:	3303      	adds	r3, #3
 8006042:	429a      	cmp	r2, r3
 8006044:	bf0c      	ite	eq
 8006046:	2301      	moveq	r3, #1
 8006048:	2300      	movne	r3, #0
 800604a:	b2db      	uxtb	r3, r3
 800604c:	200b      	movs	r0, #11
 800604e:	4619      	mov	r1, r3
 8006050:	f7ff fb5e 	bl	8005710 <_test_assert>
 8006054:	4603      	mov	r3, r0
 8006056:	2b00      	cmp	r3, #0
 8006058:	d10d      	bne.n	8006076 <thd3_execute.lto_priv.100+0x1d6>
              "unexpected real priority level");

  chSysLock();
 800605a:	f7ff fdc9 	bl	8005bf0 <chSysLock.lto_priv.232>
  chThdGetSelfX()->p_prio = prio;
 800605e:	f7ff fe07 	bl	8005c70 <chThdGetSelfX.lto_priv.210>
 8006062:	4602      	mov	r2, r0
 8006064:	9b01      	ldr	r3, [sp, #4]
 8006066:	6093      	str	r3, [r2, #8]
  chThdGetSelfX()->p_realprio = prio;
 8006068:	f7ff fe02 	bl	8005c70 <chThdGetSelfX.lto_priv.210>
 800606c:	4602      	mov	r2, r0
 800606e:	9b01      	ldr	r3, [sp, #4]
 8006070:	6413      	str	r3, [r2, #64]	; 0x40
  chSysUnlock();
 8006072:	f7ff fdc5 	bl	8005c00 <chSysUnlock.lto_priv.230>
#endif
}
 8006076:	b003      	add	sp, #12
 8006078:	f85d fb04 	ldr.w	pc, [sp], #4
 800607c:	0000      	movs	r0, r0
	...

08006080 <thd4_execute.lto_priv.99>:
 * <h2>Description</h2>
 * Delay APIs and associated macros are tested, the invoking thread is verified
 * to wake up at the exact expected time.
 */

static void thd4_execute(void) {
 8006080:	b500      	push	{lr}
 8006082:	b083      	sub	sp, #12
  systime_t time;

  test_wait_tick();
 8006084:	f7ff fbec 	bl	8005860 <test_wait_tick>

  /* Timeouts in microseconds.*/
  time = chVTGetSystemTime();
 8006088:	f7ff fde2 	bl	8005c50 <chVTGetSystemTime.lto_priv.228>
 800608c:	9001      	str	r0, [sp, #4]
  chThdSleepMicroseconds(100000);
 800608e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006092:	f006 fe45 	bl	800cd20 <chThdSleep>
  test_assert_time_window(1,
 8006096:	9b01      	ldr	r3, [sp, #4]
 8006098:	f503 727a 	add.w	r2, r3, #1000	; 0x3e8
 800609c:	9b01      	ldr	r3, [sp, #4]
 800609e:	f203 33eb 	addw	r3, r3, #1003	; 0x3eb
 80060a2:	2001      	movs	r0, #1
 80060a4:	4611      	mov	r1, r2
 80060a6:	461a      	mov	r2, r3
 80060a8:	f7ff fb7a 	bl	80057a0 <_test_assert_time_window>
 80060ac:	4603      	mov	r3, r0
 80060ae:	2b00      	cmp	r3, #0
 80060b0:	d13b      	bne.n	800612a <thd4_execute.lto_priv.99+0xaa>
                          time + US2ST(100000),
                          time + US2ST(100000) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in milliseconds.*/
  time = chVTGetSystemTime();
 80060b2:	f7ff fdcd 	bl	8005c50 <chVTGetSystemTime.lto_priv.228>
 80060b6:	9001      	str	r0, [sp, #4]
  chThdSleepMilliseconds(100);
 80060b8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80060bc:	f006 fe30 	bl	800cd20 <chThdSleep>
  test_assert_time_window(2,
 80060c0:	9b01      	ldr	r3, [sp, #4]
 80060c2:	f503 727a 	add.w	r2, r3, #1000	; 0x3e8
 80060c6:	9b01      	ldr	r3, [sp, #4]
 80060c8:	f203 33eb 	addw	r3, r3, #1003	; 0x3eb
 80060cc:	2002      	movs	r0, #2
 80060ce:	4611      	mov	r1, r2
 80060d0:	461a      	mov	r2, r3
 80060d2:	f7ff fb65 	bl	80057a0 <_test_assert_time_window>
 80060d6:	4603      	mov	r3, r0
 80060d8:	2b00      	cmp	r3, #0
 80060da:	d126      	bne.n	800612a <thd4_execute.lto_priv.99+0xaa>
                          time + MS2ST(100),
                          time + MS2ST(100) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in seconds.*/
  time = chVTGetSystemTime();
 80060dc:	f7ff fdb8 	bl	8005c50 <chVTGetSystemTime.lto_priv.228>
 80060e0:	9001      	str	r0, [sp, #4]
  chThdSleepSeconds(1);
 80060e2:	f242 7010 	movw	r0, #10000	; 0x2710
 80060e6:	f006 fe1b 	bl	800cd20 <chThdSleep>
  test_assert_time_window(3,
 80060ea:	9b01      	ldr	r3, [sp, #4]
 80060ec:	f503 521c 	add.w	r2, r3, #9984	; 0x2700
 80060f0:	3210      	adds	r2, #16
 80060f2:	9b01      	ldr	r3, [sp, #4]
 80060f4:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 80060f8:	3313      	adds	r3, #19
 80060fa:	2003      	movs	r0, #3
 80060fc:	4611      	mov	r1, r2
 80060fe:	461a      	mov	r2, r3
 8006100:	f7ff fb4e 	bl	80057a0 <_test_assert_time_window>
 8006104:	4603      	mov	r3, r0
 8006106:	2b00      	cmp	r3, #0
 8006108:	d10f      	bne.n	800612a <thd4_execute.lto_priv.99+0xaa>
                          time + S2ST(1),
                          time + S2ST(1) + CH_CFG_ST_TIMEDELTA + 1);

  /* Absolute timelines.*/
  time = chVTGetSystemTime() + MS2ST(100);
 800610a:	f7ff fda1 	bl	8005c50 <chVTGetSystemTime.lto_priv.228>
 800610e:	4603      	mov	r3, r0
 8006110:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 8006114:	9301      	str	r3, [sp, #4]
  chThdSleepUntil(time);
 8006116:	9801      	ldr	r0, [sp, #4]
 8006118:	f006 fe12 	bl	800cd40 <chThdSleepUntil>
  test_assert_time_window(4,
 800611c:	9b01      	ldr	r3, [sp, #4]
 800611e:	3303      	adds	r3, #3
 8006120:	2004      	movs	r0, #4
 8006122:	9901      	ldr	r1, [sp, #4]
 8006124:	461a      	mov	r2, r3
 8006126:	f7ff fb3b 	bl	80057a0 <_test_assert_time_window>
                          time,
                          time + CH_CFG_ST_TIMEDELTA + 1);
}
 800612a:	b003      	add	sp, #12
 800612c:	f85d fb04 	ldr.w	pc, [sp], #4

08006130 <port_lock.lto_priv.226>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8006130:	b082      	sub	sp, #8
 8006132:	2320      	movs	r3, #32
 8006134:	9301      	str	r3, [sp, #4]
 8006136:	9b01      	ldr	r3, [sp, #4]
 8006138:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800613c:	b002      	add	sp, #8
 800613e:	4770      	bx	lr

08006140 <port_unlock.lto_priv.223>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006140:	b082      	sub	sp, #8
 8006142:	2300      	movs	r3, #0
 8006144:	9301      	str	r3, [sp, #4]
 8006146:	9b01      	ldr	r3, [sp, #4]
 8006148:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800614c:	b002      	add	sp, #8
 800614e:	4770      	bx	lr

08006150 <st_lld_get_counter.lto_priv.220>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8006150:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006154:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8006156:	4618      	mov	r0, r3
 8006158:	4770      	bx	lr
 800615a:	bf00      	nop
 800615c:	0000      	movs	r0, r0
	...

08006160 <port_timer_get_time.lto_priv.217>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8006160:	b508      	push	{r3, lr}

  return stGetCounter();
 8006162:	f7ff fff5 	bl	8006150 <st_lld_get_counter.lto_priv.220>
 8006166:	4603      	mov	r3, r0
}
 8006168:	4618      	mov	r0, r3
 800616a:	bd08      	pop	{r3, pc}
 800616c:	0000      	movs	r0, r0
	...

08006170 <queue_isempty.lto_priv.202>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
 8006170:	b082      	sub	sp, #8
 8006172:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 8006174:	9b01      	ldr	r3, [sp, #4]
 8006176:	681a      	ldr	r2, [r3, #0]
 8006178:	9b01      	ldr	r3, [sp, #4]
 800617a:	429a      	cmp	r2, r3
 800617c:	bf0c      	ite	eq
 800617e:	2301      	moveq	r3, #1
 8006180:	2300      	movne	r3, #0
 8006182:	b2db      	uxtb	r3, r3
}
 8006184:	4618      	mov	r0, r3
 8006186:	b002      	add	sp, #8
 8006188:	4770      	bx	lr
 800618a:	bf00      	nop
 800618c:	0000      	movs	r0, r0
	...

08006190 <chSysLock.lto_priv.200>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8006190:	b508      	push	{r3, lr}

  port_lock();
 8006192:	f7ff ffcd 	bl	8006130 <port_lock.lto_priv.226>
  _stats_start_measure_crit_thd();
 8006196:	f004 f953 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800619a:	f005 fe01 	bl	800bda0 <_dbg_check_lock>
}
 800619e:	bd08      	pop	{r3, pc}

080061a0 <chSysUnlock.lto_priv.198>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80061a0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 80061a2:	f005 fe15 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80061a6:	f004 f953 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80061aa:	4b09      	ldr	r3, [pc, #36]	; (80061d0 <chSysUnlock.lto_priv.198+0x30>)
 80061ac:	681b      	ldr	r3, [r3, #0]
 80061ae:	4a08      	ldr	r2, [pc, #32]	; (80061d0 <chSysUnlock.lto_priv.198+0x30>)
 80061b0:	4293      	cmp	r3, r2
 80061b2:	d00a      	beq.n	80061ca <chSysUnlock.lto_priv.198+0x2a>
 80061b4:	4b06      	ldr	r3, [pc, #24]	; (80061d0 <chSysUnlock.lto_priv.198+0x30>)
 80061b6:	699b      	ldr	r3, [r3, #24]
 80061b8:	689a      	ldr	r2, [r3, #8]
 80061ba:	4b05      	ldr	r3, [pc, #20]	; (80061d0 <chSysUnlock.lto_priv.198+0x30>)
 80061bc:	681b      	ldr	r3, [r3, #0]
 80061be:	689b      	ldr	r3, [r3, #8]
 80061c0:	429a      	cmp	r2, r3
 80061c2:	d202      	bcs.n	80061ca <chSysUnlock.lto_priv.198+0x2a>
 80061c4:	4803      	ldr	r0, [pc, #12]	; (80061d4 <chSysUnlock.lto_priv.198+0x34>)
 80061c6:	f005 fc93 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80061ca:	f7ff ffb9 	bl	8006140 <port_unlock.lto_priv.223>
}
 80061ce:	bd08      	pop	{r3, pc}
 80061d0:	20000d30 	.word	0x20000d30
 80061d4:	0800e520 	.word	0x0800e520
	...

080061e0 <chVTGetSystemTimeX.lto_priv.214>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 80061e0:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 80061e2:	f7ff ffbd 	bl	8006160 <port_timer_get_time.lto_priv.217>
 80061e6:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80061e8:	4618      	mov	r0, r3
 80061ea:	bd08      	pop	{r3, pc}
 80061ec:	0000      	movs	r0, r0
	...

080061f0 <chVTGetSystemTime.lto_priv.209>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 80061f0:	b500      	push	{lr}
 80061f2:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 80061f4:	f7ff ffcc 	bl	8006190 <chSysLock.lto_priv.200>
  systime = chVTGetSystemTimeX();
 80061f8:	f7ff fff2 	bl	80061e0 <chVTGetSystemTimeX.lto_priv.214>
 80061fc:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 80061fe:	f7ff ffcf 	bl	80061a0 <chSysUnlock.lto_priv.198>

  return systime;
 8006202:	9b01      	ldr	r3, [sp, #4]
}
 8006204:	4618      	mov	r0, r3
 8006206:	b003      	add	sp, #12
 8006208:	f85d fb04 	ldr.w	pc, [sp], #4
 800620c:	0000      	movs	r0, r0
	...

08006210 <chThdGetSelfX.lto_priv.211>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8006210:	4b01      	ldr	r3, [pc, #4]	; (8006218 <chThdGetSelfX.lto_priv.211+0x8>)
 8006212:	699b      	ldr	r3, [r3, #24]
}
 8006214:	4618      	mov	r0, r3
 8006216:	4770      	bx	lr
 8006218:	20000d30 	.word	0x20000d30
 800621c:	00000000 	.word	0x00000000

08006220 <chThdGetPriorityX.lto_priv.188>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 8006220:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 8006222:	f7ff fff5 	bl	8006210 <chThdGetSelfX.lto_priv.211>
 8006226:	4603      	mov	r3, r0
 8006228:	689b      	ldr	r3, [r3, #8]
}
 800622a:	4618      	mov	r0, r3
 800622c:	bd08      	pop	{r3, pc}
 800622e:	bf00      	nop

08006230 <chSemGetCounterI.lto_priv.182>:
 * @param[in] sp        pointer to a @p semaphore_t structure
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {
 8006230:	b500      	push	{lr}
 8006232:	b083      	sub	sp, #12
 8006234:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8006236:	f005 fe53 	bl	800bee0 <chDbgCheckClassI>

  return sp->s_cnt;
 800623a:	9b01      	ldr	r3, [sp, #4]
 800623c:	689b      	ldr	r3, [r3, #8]
}
 800623e:	4618      	mov	r0, r3
 8006240:	b003      	add	sp, #12
 8006242:	f85d fb04 	ldr.w	pc, [sp], #4
 8006246:	bf00      	nop
	...

08006250 <chBSemObjectInit.lto_priv.208>:
 *                      - @a true, the initial state is taken.
 *                      .
 *
 * @init
 */
static inline void chBSemObjectInit(binary_semaphore_t *bsp, bool taken) {
 8006250:	b500      	push	{lr}
 8006252:	b083      	sub	sp, #12
 8006254:	9001      	str	r0, [sp, #4]
 8006256:	460b      	mov	r3, r1
 8006258:	f88d 3003 	strb.w	r3, [sp, #3]

  chSemObjectInit(&bsp->bs_sem, taken ? (cnt_t)0 : (cnt_t)1);
 800625c:	9a01      	ldr	r2, [sp, #4]
 800625e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006262:	2b00      	cmp	r3, #0
 8006264:	d001      	beq.n	800626a <chBSemObjectInit.lto_priv.208+0x1a>
 8006266:	2300      	movs	r3, #0
 8006268:	e000      	b.n	800626c <chBSemObjectInit.lto_priv.208+0x1c>
 800626a:	2301      	movs	r3, #1
 800626c:	4610      	mov	r0, r2
 800626e:	4619      	mov	r1, r3
 8006270:	f004 fb76 	bl	800a960 <chSemObjectInit>
}
 8006274:	b003      	add	sp, #12
 8006276:	f85d fb04 	ldr.w	pc, [sp], #4
 800627a:	bf00      	nop
 800627c:	0000      	movs	r0, r0
	...

08006280 <chBSemWait.lto_priv.206>:
 * @retval MSG_RESET    if the binary semaphore has been reset using
 *                      @p bsemReset().
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {
 8006280:	b500      	push	{lr}
 8006282:	b083      	sub	sp, #12
 8006284:	9001      	str	r0, [sp, #4]

  return chSemWait(&bsp->bs_sem);
 8006286:	9b01      	ldr	r3, [sp, #4]
 8006288:	4618      	mov	r0, r3
 800628a:	f004 fbf1 	bl	800aa70 <chSemWait>
 800628e:	4603      	mov	r3, r0
}
 8006290:	4618      	mov	r0, r3
 8006292:	b003      	add	sp, #12
 8006294:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080062a0 <chBSemReset.lto_priv.207>:
 *                      - @a true, the new state is taken.
 *                      .
 *
 * @api
 */
static inline void chBSemReset(binary_semaphore_t *bsp, bool taken) {
 80062a0:	b500      	push	{lr}
 80062a2:	b083      	sub	sp, #12
 80062a4:	9001      	str	r0, [sp, #4]
 80062a6:	460b      	mov	r3, r1
 80062a8:	f88d 3003 	strb.w	r3, [sp, #3]

  chSemReset(&bsp->bs_sem, taken ? (cnt_t)0 : (cnt_t)1);
 80062ac:	9a01      	ldr	r2, [sp, #4]
 80062ae:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80062b2:	2b00      	cmp	r3, #0
 80062b4:	d001      	beq.n	80062ba <chBSemReset.lto_priv.207+0x1a>
 80062b6:	2300      	movs	r3, #0
 80062b8:	e000      	b.n	80062bc <chBSemReset.lto_priv.207+0x1c>
 80062ba:	2301      	movs	r3, #1
 80062bc:	4610      	mov	r0, r2
 80062be:	4619      	mov	r1, r3
 80062c0:	f004 fb6e 	bl	800a9a0 <chSemReset>
}
 80062c4:	b003      	add	sp, #12
 80062c6:	f85d fb04 	ldr.w	pc, [sp], #4
 80062ca:	bf00      	nop
 80062cc:	0000      	movs	r0, r0
	...

080062d0 <chBSemSignalI>:
 *
 * @param[in] bsp       pointer to a @p binary_semaphore_t structure
 *
 * @iclass
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {
 80062d0:	b500      	push	{lr}
 80062d2:	b083      	sub	sp, #12
 80062d4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 80062d6:	f005 fe03 	bl	800bee0 <chDbgCheckClassI>

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 80062da:	9b01      	ldr	r3, [sp, #4]
 80062dc:	689b      	ldr	r3, [r3, #8]
 80062de:	2b00      	cmp	r3, #0
 80062e0:	dc03      	bgt.n	80062ea <chBSemSignalI+0x1a>
    chSemSignalI(&bsp->bs_sem);
 80062e2:	9b01      	ldr	r3, [sp, #4]
 80062e4:	4618      	mov	r0, r3
 80062e6:	f004 fce3 	bl	800acb0 <chSemSignalI>
  }
}
 80062ea:	b003      	add	sp, #12
 80062ec:	f85d fb04 	ldr.w	pc, [sp], #4

080062f0 <chBSemSignal.lto_priv.205>:
 *
 * @param[in] bsp       pointer to a @p binary_semaphore_t structure
 *
 * @api
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {
 80062f0:	b500      	push	{lr}
 80062f2:	b083      	sub	sp, #12
 80062f4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80062f6:	f7ff ff4b 	bl	8006190 <chSysLock.lto_priv.200>
  chBSemSignalI(bsp);
 80062fa:	9801      	ldr	r0, [sp, #4]
 80062fc:	f7ff ffe8 	bl	80062d0 <chBSemSignalI>
  chSchRescheduleS();
 8006300:	f006 f9c6 	bl	800c690 <chSchRescheduleS>
  chSysUnlock();
 8006304:	f7ff ff4c 	bl	80061a0 <chSysUnlock.lto_priv.198>
}
 8006308:	b003      	add	sp, #12
 800630a:	f85d fb04 	ldr.w	pc, [sp], #4
 800630e:	bf00      	nop

08006310 <chBSemGetStateI.lto_priv.204>:
 * @retval false        if the binary semaphore is not taken.
 * @retval true         if the binary semaphore is taken.
 *
 * @iclass
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {
 8006310:	b500      	push	{lr}
 8006312:	b083      	sub	sp, #12
 8006314:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8006316:	f005 fde3 	bl	800bee0 <chDbgCheckClassI>

  return (bsp->bs_sem.s_cnt > (cnt_t)0) ? false : true;
 800631a:	9b01      	ldr	r3, [sp, #4]
 800631c:	689b      	ldr	r3, [r3, #8]
 800631e:	2b00      	cmp	r3, #0
 8006320:	bfd4      	ite	le
 8006322:	2301      	movle	r3, #1
 8006324:	2300      	movgt	r3, #0
 8006326:	b2db      	uxtb	r3, r3
}
 8006328:	4618      	mov	r0, r3
 800632a:	b003      	add	sp, #12
 800632c:	f85d fb04 	ldr.w	pc, [sp], #4

08006330 <sem1_setup.lto_priv.97>:
 * The test expects that the threads reach their goal in FIFO order or
 * priority order depending on the CH_CFG_USE_SEMAPHORES_PRIORITY configuration
 * setting.
 */

static void sem1_setup(void) {
 8006330:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 8006332:	4802      	ldr	r0, [pc, #8]	; (800633c <sem1_setup.lto_priv.97+0xc>)
 8006334:	2100      	movs	r1, #0
 8006336:	f004 fb13 	bl	800a960 <chSemObjectInit>
}
 800633a:	bd08      	pop	{r3, pc}
 800633c:	20000834 	.word	0x20000834

08006340 <thread1.lto_priv.196>:

static THD_FUNCTION(thread1, p) {
 8006340:	b500      	push	{lr}
 8006342:	b083      	sub	sp, #12
 8006344:	9001      	str	r0, [sp, #4]

  chSemWait(&sem1);
 8006346:	4805      	ldr	r0, [pc, #20]	; (800635c <thread1.lto_priv.196+0x1c>)
 8006348:	f004 fb92 	bl	800aa70 <chSemWait>
  test_emit_token(*(char *)p);
 800634c:	9b01      	ldr	r3, [sp, #4]
 800634e:	781b      	ldrb	r3, [r3, #0]
 8006350:	4618      	mov	r0, r3
 8006352:	f7ff f9ad 	bl	80056b0 <test_emit_token>
}
 8006356:	b003      	add	sp, #12
 8006358:	f85d fb04 	ldr.w	pc, [sp], #4
 800635c:	20000834 	.word	0x20000834

08006360 <chSysLockFromISR.lto_priv.251>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8006360:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8006362:	f002 f8c5 	bl	80084f0 <port_lock_from_isr.lto_priv.257>
  _stats_start_measure_crit_isr();
 8006366:	f004 f87b 	bl	800a460 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 800636a:	f005 fd49 	bl	800be00 <_dbg_check_lock_from_isr>
}
 800636e:	bd08      	pop	{r3, pc}

08006370 <chSysUnlockFromISR.lto_priv.248>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8006370:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 8006372:	f005 fd5d 	bl	800be30 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8006376:	f004 f87b 	bl	800a470 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 800637a:	f002 f8c1 	bl	8008500 <port_unlock_from_isr.lto_priv.254>
}
 800637e:	bd08      	pop	{r3, pc}

08006380 <osalSysLockFromISR.lto_priv.268>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8006380:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8006382:	f7ff ffed 	bl	8006360 <chSysLockFromISR.lto_priv.251>
}
 8006386:	bd08      	pop	{r3, pc}
	...

08006390 <osalSysUnlockFromISR.lto_priv.266>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8006390:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8006392:	f7ff ffed 	bl	8006370 <chSysUnlockFromISR.lto_priv.248>
}
 8006396:	bd08      	pop	{r3, pc}
	...

080063a0 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 80063a0:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
 80063a2:	f005 fc3d 	bl	800bc20 <chSysTimerHandlerI>
}
 80063a6:	bd08      	pop	{r3, pc}
	...

080063b0 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 80063b0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 80063b2:	f004 f815 	bl	800a3e0 <_stats_increase_irq>
 80063b6:	f005 fd53 	bl	800be60 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80063ba:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80063be:	691b      	ldr	r3, [r3, #16]
 80063c0:	f003 0302 	and.w	r3, r3, #2
 80063c4:	2b00      	cmp	r3, #0
 80063c6:	d009      	beq.n	80063dc <VectorB0+0x2c>
    STM32_ST_TIM->SR = 0U;
 80063c8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80063cc:	2200      	movs	r2, #0
 80063ce:	611a      	str	r2, [r3, #16]

    osalSysLockFromISR();
 80063d0:	f7ff ffd6 	bl	8006380 <osalSysLockFromISR.lto_priv.268>
    osalOsTimerHandlerI();
 80063d4:	f7ff ffe4 	bl	80063a0 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 80063d8:	f7ff ffda 	bl	8006390 <osalSysUnlockFromISR.lto_priv.266>
  }

  OSAL_IRQ_EPILOGUE();
 80063dc:	f005 fd60 	bl	800bea0 <_dbg_check_leave_isr>
 80063e0:	f002 fcd6 	bl	8008d90 <_port_irq_epilogue>
}
 80063e4:	bd08      	pop	{r3, pc}
 80063e6:	bf00      	nop
	...

080063f0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 80063f0:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80063f2:	4a19      	ldr	r2, [pc, #100]	; (8006458 <st_lld_init+0x68>)
 80063f4:	4b18      	ldr	r3, [pc, #96]	; (8006458 <st_lld_init+0x68>)
 80063f6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80063f8:	f043 0301 	orr.w	r3, r3, #1
 80063fc:	6413      	str	r3, [r2, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80063fe:	4a17      	ldr	r2, [pc, #92]	; (800645c <st_lld_init+0x6c>)
 8006400:	4b16      	ldr	r3, [pc, #88]	; (800645c <st_lld_init+0x6c>)
 8006402:	689b      	ldr	r3, [r3, #8]
 8006404:	f043 0301 	orr.w	r3, r3, #1
 8006408:	6093      	str	r3, [r2, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 800640a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800640e:	f242 02cf 	movw	r2, #8399	; 0x20cf
 8006412:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8006414:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006418:	f04f 32ff 	mov.w	r2, #4294967295
 800641c:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 800641e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006422:	2200      	movs	r2, #0
 8006424:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8006426:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800642a:	2200      	movs	r2, #0
 800642c:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 800642e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006432:	2200      	movs	r2, #0
 8006434:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8006436:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800643a:	2200      	movs	r2, #0
 800643c:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800643e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006442:	2201      	movs	r2, #1
 8006444:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8006446:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800644a:	2201      	movs	r2, #1
 800644c:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 800644e:	201c      	movs	r0, #28
 8006450:	2108      	movs	r1, #8
 8006452:	f001 fc05 	bl	8007c60 <nvicEnableVector>
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8006456:	bd08      	pop	{r3, pc}
 8006458:	40023800 	.word	0x40023800
 800645c:	e0042000 	.word	0xe0042000

08006460 <initgpio>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 8006460:	b082      	sub	sp, #8
 8006462:	9001      	str	r0, [sp, #4]
 8006464:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8006466:	9b00      	ldr	r3, [sp, #0]
 8006468:	685a      	ldr	r2, [r3, #4]
 800646a:	9b01      	ldr	r3, [sp, #4]
 800646c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800646e:	9b00      	ldr	r3, [sp, #0]
 8006470:	689a      	ldr	r2, [r3, #8]
 8006472:	9b01      	ldr	r3, [sp, #4]
 8006474:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8006476:	9b00      	ldr	r3, [sp, #0]
 8006478:	68da      	ldr	r2, [r3, #12]
 800647a:	9b01      	ldr	r3, [sp, #4]
 800647c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 800647e:	9b00      	ldr	r3, [sp, #0]
 8006480:	691a      	ldr	r2, [r3, #16]
 8006482:	9b01      	ldr	r3, [sp, #4]
 8006484:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8006486:	9b00      	ldr	r3, [sp, #0]
 8006488:	695a      	ldr	r2, [r3, #20]
 800648a:	9b01      	ldr	r3, [sp, #4]
 800648c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800648e:	9b00      	ldr	r3, [sp, #0]
 8006490:	699a      	ldr	r2, [r3, #24]
 8006492:	9b01      	ldr	r3, [sp, #4]
 8006494:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8006496:	9b00      	ldr	r3, [sp, #0]
 8006498:	681a      	ldr	r2, [r3, #0]
 800649a:	9b01      	ldr	r3, [sp, #4]
 800649c:	601a      	str	r2, [r3, #0]
}
 800649e:	b002      	add	sp, #8
 80064a0:	4770      	bx	lr
 80064a2:	bf00      	nop
	...

080064b0 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 80064b0:	b500      	push	{lr}
 80064b2:	b083      	sub	sp, #12
 80064b4:	9001      	str	r0, [sp, #4]
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 80064b6:	4a19      	ldr	r2, [pc, #100]	; (800651c <_pal_lld_init+0x6c>)
 80064b8:	4b18      	ldr	r3, [pc, #96]	; (800651c <_pal_lld_init+0x6c>)
 80064ba:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80064bc:	f043 031f 	orr.w	r3, r3, #31
 80064c0:	6313      	str	r3, [r2, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 80064c2:	4a16      	ldr	r2, [pc, #88]	; (800651c <_pal_lld_init+0x6c>)
 80064c4:	4b15      	ldr	r3, [pc, #84]	; (800651c <_pal_lld_init+0x6c>)
 80064c6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80064c8:	f043 031f 	orr.w	r3, r3, #31
 80064cc:	6513      	str	r3, [r2, #80]	; 0x50

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 80064ce:	9b01      	ldr	r3, [sp, #4]
 80064d0:	4813      	ldr	r0, [pc, #76]	; (8006520 <_pal_lld_init+0x70>)
 80064d2:	4619      	mov	r1, r3
 80064d4:	f7ff ffc4 	bl	8006460 <initgpio>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 80064d8:	9b01      	ldr	r3, [sp, #4]
 80064da:	331c      	adds	r3, #28
 80064dc:	4811      	ldr	r0, [pc, #68]	; (8006524 <_pal_lld_init+0x74>)
 80064de:	4619      	mov	r1, r3
 80064e0:	f7ff ffbe 	bl	8006460 <initgpio>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 80064e4:	9b01      	ldr	r3, [sp, #4]
 80064e6:	3338      	adds	r3, #56	; 0x38
 80064e8:	480f      	ldr	r0, [pc, #60]	; (8006528 <_pal_lld_init+0x78>)
 80064ea:	4619      	mov	r1, r3
 80064ec:	f7ff ffb8 	bl	8006460 <initgpio>
#endif
#if STM32_HAS_GPIOD
  initgpio(GPIOD, &config->PDData);
 80064f0:	9b01      	ldr	r3, [sp, #4]
 80064f2:	3354      	adds	r3, #84	; 0x54
 80064f4:	480d      	ldr	r0, [pc, #52]	; (800652c <_pal_lld_init+0x7c>)
 80064f6:	4619      	mov	r1, r3
 80064f8:	f7ff ffb2 	bl	8006460 <initgpio>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
 80064fc:	9b01      	ldr	r3, [sp, #4]
 80064fe:	3370      	adds	r3, #112	; 0x70
 8006500:	480b      	ldr	r0, [pc, #44]	; (8006530 <_pal_lld_init+0x80>)
 8006502:	4619      	mov	r1, r3
 8006504:	f7ff ffac 	bl	8006460 <initgpio>
#endif
#if STM32_HAS_GPIOG
  initgpio(GPIOG, &config->PGData);
#endif
#if STM32_HAS_GPIOH
  initgpio(GPIOH, &config->PHData);
 8006508:	9b01      	ldr	r3, [sp, #4]
 800650a:	338c      	adds	r3, #140	; 0x8c
 800650c:	4809      	ldr	r0, [pc, #36]	; (8006534 <_pal_lld_init+0x84>)
 800650e:	4619      	mov	r1, r3
 8006510:	f7ff ffa6 	bl	8006460 <initgpio>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 8006514:	b003      	add	sp, #12
 8006516:	f85d fb04 	ldr.w	pc, [sp], #4
 800651a:	bf00      	nop
 800651c:	40023800 	.word	0x40023800
 8006520:	40020000 	.word	0x40020000
 8006524:	40020400 	.word	0x40020400
 8006528:	40020800 	.word	0x40020800
 800652c:	40020c00 	.word	0x40020c00
 8006530:	40021000 	.word	0x40021000
 8006534:	40021c00 	.word	0x40021c00
	...

08006540 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8006540:	b08e      	sub	sp, #56	; 0x38
 8006542:	9003      	str	r0, [sp, #12]
 8006544:	9102      	str	r1, [sp, #8]
 8006546:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8006548:	9b01      	ldr	r3, [sp, #4]
 800654a:	f003 0303 	and.w	r3, r3, #3
 800654e:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8006550:	9b01      	ldr	r3, [sp, #4]
 8006552:	f003 0304 	and.w	r3, r3, #4
 8006556:	089b      	lsrs	r3, r3, #2
 8006558:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800655a:	9b01      	ldr	r3, [sp, #4]
 800655c:	f003 0318 	and.w	r3, r3, #24
 8006560:	08db      	lsrs	r3, r3, #3
 8006562:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8006564:	9b01      	ldr	r3, [sp, #4]
 8006566:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800656a:	095b      	lsrs	r3, r3, #5
 800656c:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800656e:	9b01      	ldr	r3, [sp, #4]
 8006570:	f403 63f0 	and.w	r3, r3, #1920	; 0x780
 8006574:	09db      	lsrs	r3, r3, #7
 8006576:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 8006578:	2300      	movs	r3, #0
 800657a:	9309      	str	r3, [sp, #36]	; 0x24
  while (true) {
    if ((mask & 1) != 0) {
 800657c:	9b02      	ldr	r3, [sp, #8]
 800657e:	f003 0301 	and.w	r3, r3, #1
 8006582:	2b00      	cmp	r3, #0
 8006584:	d077      	beq.n	8006676 <_pal_lld_setgroupmode+0x136>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8006586:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8006588:	f003 0307 	and.w	r3, r3, #7
 800658c:	009b      	lsls	r3, r3, #2
 800658e:	461a      	mov	r2, r3
 8006590:	9b08      	ldr	r3, [sp, #32]
 8006592:	4093      	lsls	r3, r2
 8006594:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 8006596:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8006598:	2201      	movs	r2, #1
 800659a:	fa02 f303 	lsl.w	r3, r2, r3
 800659e:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 80065a0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80065a2:	005b      	lsls	r3, r3, #1
 80065a4:	461a      	mov	r2, r3
 80065a6:	2303      	movs	r3, #3
 80065a8:	4093      	lsls	r3, r2
 80065aa:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 80065ac:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80065ae:	f003 0307 	and.w	r3, r3, #7
 80065b2:	009b      	lsls	r3, r3, #2
 80065b4:	461a      	mov	r2, r3
 80065b6:	230f      	movs	r3, #15
 80065b8:	4093      	lsls	r3, r2
 80065ba:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80065bc:	9b03      	ldr	r3, [sp, #12]
 80065be:	685a      	ldr	r2, [r3, #4]
 80065c0:	9b06      	ldr	r3, [sp, #24]
 80065c2:	43db      	mvns	r3, r3
 80065c4:	401a      	ands	r2, r3
 80065c6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80065c8:	431a      	orrs	r2, r3
 80065ca:	9b03      	ldr	r3, [sp, #12]
 80065cc:	605a      	str	r2, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80065ce:	9b03      	ldr	r3, [sp, #12]
 80065d0:	689a      	ldr	r2, [r3, #8]
 80065d2:	9b05      	ldr	r3, [sp, #20]
 80065d4:	43db      	mvns	r3, r3
 80065d6:	401a      	ands	r2, r3
 80065d8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80065da:	431a      	orrs	r2, r3
 80065dc:	9b03      	ldr	r3, [sp, #12]
 80065de:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80065e0:	9b03      	ldr	r3, [sp, #12]
 80065e2:	68da      	ldr	r2, [r3, #12]
 80065e4:	9b05      	ldr	r3, [sp, #20]
 80065e6:	43db      	mvns	r3, r3
 80065e8:	401a      	ands	r2, r3
 80065ea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80065ec:	431a      	orrs	r2, r3
 80065ee:	9b03      	ldr	r3, [sp, #12]
 80065f0:	60da      	str	r2, [r3, #12]
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 80065f2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80065f4:	2b02      	cmp	r3, #2
 80065f6:	d11f      	bne.n	8006638 <_pal_lld_setgroupmode+0xf8>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 80065f8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80065fa:	2b07      	cmp	r3, #7
 80065fc:	d809      	bhi.n	8006612 <_pal_lld_setgroupmode+0xd2>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80065fe:	9b03      	ldr	r3, [sp, #12]
 8006600:	6a1a      	ldr	r2, [r3, #32]
 8006602:	9b04      	ldr	r3, [sp, #16]
 8006604:	43db      	mvns	r3, r3
 8006606:	401a      	ands	r2, r3
 8006608:	9b07      	ldr	r3, [sp, #28]
 800660a:	431a      	orrs	r2, r3
 800660c:	9b03      	ldr	r3, [sp, #12]
 800660e:	621a      	str	r2, [r3, #32]
 8006610:	e008      	b.n	8006624 <_pal_lld_setgroupmode+0xe4>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8006612:	9b03      	ldr	r3, [sp, #12]
 8006614:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8006616:	9b04      	ldr	r3, [sp, #16]
 8006618:	43db      	mvns	r3, r3
 800661a:	401a      	ands	r2, r3
 800661c:	9b07      	ldr	r3, [sp, #28]
 800661e:	431a      	orrs	r2, r3
 8006620:	9b03      	ldr	r3, [sp, #12]
 8006622:	625a      	str	r2, [r3, #36]	; 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 8006624:	9b03      	ldr	r3, [sp, #12]
 8006626:	681a      	ldr	r2, [r3, #0]
 8006628:	9b05      	ldr	r3, [sp, #20]
 800662a:	43db      	mvns	r3, r3
 800662c:	401a      	ands	r2, r3
 800662e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8006630:	431a      	orrs	r2, r3
 8006632:	9b03      	ldr	r3, [sp, #12]
 8006634:	601a      	str	r2, [r3, #0]
 8006636:	e01e      	b.n	8006676 <_pal_lld_setgroupmode+0x136>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8006638:	9b03      	ldr	r3, [sp, #12]
 800663a:	681a      	ldr	r2, [r3, #0]
 800663c:	9b05      	ldr	r3, [sp, #20]
 800663e:	43db      	mvns	r3, r3
 8006640:	401a      	ands	r2, r3
 8006642:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8006644:	431a      	orrs	r2, r3
 8006646:	9b03      	ldr	r3, [sp, #12]
 8006648:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 800664a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800664c:	2b07      	cmp	r3, #7
 800664e:	d809      	bhi.n	8006664 <_pal_lld_setgroupmode+0x124>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8006650:	9b03      	ldr	r3, [sp, #12]
 8006652:	6a1a      	ldr	r2, [r3, #32]
 8006654:	9b04      	ldr	r3, [sp, #16]
 8006656:	43db      	mvns	r3, r3
 8006658:	401a      	ands	r2, r3
 800665a:	9b07      	ldr	r3, [sp, #28]
 800665c:	431a      	orrs	r2, r3
 800665e:	9b03      	ldr	r3, [sp, #12]
 8006660:	621a      	str	r2, [r3, #32]
 8006662:	e008      	b.n	8006676 <_pal_lld_setgroupmode+0x136>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8006664:	9b03      	ldr	r3, [sp, #12]
 8006666:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8006668:	9b04      	ldr	r3, [sp, #16]
 800666a:	43db      	mvns	r3, r3
 800666c:	401a      	ands	r2, r3
 800666e:	9b07      	ldr	r3, [sp, #28]
 8006670:	431a      	orrs	r2, r3
 8006672:	9b03      	ldr	r3, [sp, #12]
 8006674:	625a      	str	r2, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
 8006676:	9b02      	ldr	r3, [sp, #8]
 8006678:	085b      	lsrs	r3, r3, #1
 800667a:	9302      	str	r3, [sp, #8]
    if (!mask)
 800667c:	9b02      	ldr	r3, [sp, #8]
 800667e:	2b00      	cmp	r3, #0
 8006680:	d00f      	beq.n	80066a2 <_pal_lld_setgroupmode+0x162>
      return;
    otyper <<= 1;
 8006682:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8006684:	005b      	lsls	r3, r3, #1
 8006686:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
 8006688:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800668a:	009b      	lsls	r3, r3, #2
 800668c:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
 800668e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8006690:	009b      	lsls	r3, r3, #2
 8006692:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
 8006694:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8006696:	009b      	lsls	r3, r3, #2
 8006698:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
 800669a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800669c:	3301      	adds	r3, #1
 800669e:	9309      	str	r3, [sp, #36]	; 0x24
 80066a0:	e76c      	b.n	800657c <_pal_lld_setgroupmode+0x3c>
  }
}
 80066a2:	b00e      	add	sp, #56	; 0x38
 80066a4:	4770      	bx	lr
 80066a6:	bf00      	nop
	...

080066b0 <port_lock.lto_priv.262>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80066b0:	b082      	sub	sp, #8
 80066b2:	2320      	movs	r3, #32
 80066b4:	9301      	str	r3, [sp, #4]
 80066b6:	9b01      	ldr	r3, [sp, #4]
 80066b8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80066bc:	b002      	add	sp, #8
 80066be:	4770      	bx	lr

080066c0 <port_unlock.lto_priv.260>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80066c0:	b082      	sub	sp, #8
 80066c2:	2300      	movs	r3, #0
 80066c4:	9301      	str	r3, [sp, #4]
 80066c6:	9b01      	ldr	r3, [sp, #4]
 80066c8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80066cc:	b002      	add	sp, #8
 80066ce:	4770      	bx	lr

080066d0 <port_lock_from_isr.lto_priv.258>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80066d0:	b508      	push	{r3, lr}

  port_lock();
 80066d2:	f7ff ffed 	bl	80066b0 <port_lock.lto_priv.262>
}
 80066d6:	bd08      	pop	{r3, pc}
	...

080066e0 <port_unlock_from_isr.lto_priv.255>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 80066e0:	b508      	push	{r3, lr}

  port_unlock();
 80066e2:	f7ff ffed 	bl	80066c0 <port_unlock.lto_priv.260>
}
 80066e6:	bd08      	pop	{r3, pc}
	...

080066f0 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80066f0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80066f4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 80066f6:	4618      	mov	r0, r3
 80066f8:	4770      	bx	lr
 80066fa:	bf00      	nop
 80066fc:	0000      	movs	r0, r0
	...

08006700 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8006700:	b508      	push	{r3, lr}

  return stGetCounter();
 8006702:	f7ff fff5 	bl	80066f0 <st_lld_get_counter>
 8006706:	4603      	mov	r3, r0
}
 8006708:	4618      	mov	r0, r3
 800670a:	bd08      	pop	{r3, pc}
 800670c:	0000      	movs	r0, r0
	...

08006710 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8006710:	b508      	push	{r3, lr}

  port_lock();
 8006712:	f7ff ffcd 	bl	80066b0 <port_lock.lto_priv.262>
  _stats_start_measure_crit_thd();
 8006716:	f003 fe93 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800671a:	f005 fb41 	bl	800bda0 <_dbg_check_lock>
}
 800671e:	bd08      	pop	{r3, pc}

08006720 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8006720:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8006722:	f005 fb55 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8006726:	f003 fe93 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800672a:	4b09      	ldr	r3, [pc, #36]	; (8006750 <chSysUnlock+0x30>)
 800672c:	681b      	ldr	r3, [r3, #0]
 800672e:	4a08      	ldr	r2, [pc, #32]	; (8006750 <chSysUnlock+0x30>)
 8006730:	4293      	cmp	r3, r2
 8006732:	d00a      	beq.n	800674a <chSysUnlock+0x2a>
 8006734:	4b06      	ldr	r3, [pc, #24]	; (8006750 <chSysUnlock+0x30>)
 8006736:	699b      	ldr	r3, [r3, #24]
 8006738:	689a      	ldr	r2, [r3, #8]
 800673a:	4b05      	ldr	r3, [pc, #20]	; (8006750 <chSysUnlock+0x30>)
 800673c:	681b      	ldr	r3, [r3, #0]
 800673e:	689b      	ldr	r3, [r3, #8]
 8006740:	429a      	cmp	r2, r3
 8006742:	d202      	bcs.n	800674a <chSysUnlock+0x2a>
 8006744:	4803      	ldr	r0, [pc, #12]	; (8006754 <chSysUnlock+0x34>)
 8006746:	f005 f9d3 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800674a:	f7ff ffb9 	bl	80066c0 <port_unlock.lto_priv.260>
}
 800674e:	bd08      	pop	{r3, pc}
 8006750:	20000d30 	.word	0x20000d30
 8006754:	0800e350 	.word	0x0800e350
	...

08006760 <chSysLockFromISR.lto_priv.252>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8006760:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8006762:	f7ff ffb5 	bl	80066d0 <port_lock_from_isr.lto_priv.258>
  _stats_start_measure_crit_isr();
 8006766:	f003 fe7b 	bl	800a460 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 800676a:	f005 fb49 	bl	800be00 <_dbg_check_lock_from_isr>
}
 800676e:	bd08      	pop	{r3, pc}

08006770 <chSysUnlockFromISR.lto_priv.249>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8006770:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 8006772:	f005 fb5d 	bl	800be30 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8006776:	f003 fe7b 	bl	800a470 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 800677a:	f7ff ffb1 	bl	80066e0 <port_unlock_from_isr.lto_priv.255>
}
 800677e:	bd08      	pop	{r3, pc}

08006780 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8006780:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8006782:	f7ff ffbd 	bl	8006700 <port_timer_get_time>
 8006786:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8006788:	4618      	mov	r0, r3
 800678a:	bd08      	pop	{r3, pc}
 800678c:	0000      	movs	r0, r0
	...

08006790 <chVTIsTimeWithinX>:
 *
 * @xclass
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {
 8006790:	b084      	sub	sp, #16
 8006792:	9003      	str	r0, [sp, #12]
 8006794:	9102      	str	r1, [sp, #8]
 8006796:	9201      	str	r2, [sp, #4]

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8006798:	9a03      	ldr	r2, [sp, #12]
 800679a:	9b02      	ldr	r3, [sp, #8]
 800679c:	1ad2      	subs	r2, r2, r3
 800679e:	9901      	ldr	r1, [sp, #4]
 80067a0:	9b02      	ldr	r3, [sp, #8]
 80067a2:	1acb      	subs	r3, r1, r3
 80067a4:	429a      	cmp	r2, r3
 80067a6:	bf34      	ite	cc
 80067a8:	2301      	movcc	r3, #1
 80067aa:	2300      	movcs	r3, #0
 80067ac:	b2db      	uxtb	r3, r3
}
 80067ae:	4618      	mov	r0, r3
 80067b0:	b004      	add	sp, #16
 80067b2:	4770      	bx	lr
	...

080067c0 <osalSysHalt>:
 *
 * @param[in] reason    the halt message pointer
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {
 80067c0:	b500      	push	{lr}
 80067c2:	b083      	sub	sp, #12
 80067c4:	9001      	str	r0, [sp, #4]

  chSysHalt(reason);
 80067c6:	9801      	ldr	r0, [sp, #4]
 80067c8:	f005 f992 	bl	800baf0 <chSysHalt>
}
 80067cc:	b003      	add	sp, #12
 80067ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80067d2:	bf00      	nop
	...

080067e0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 80067e0:	b508      	push	{r3, lr}

  chSysLock();
 80067e2:	f7ff ff95 	bl	8006710 <chSysLock>
}
 80067e6:	bd08      	pop	{r3, pc}
	...

080067f0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80067f0:	b508      	push	{r3, lr}

  chSysUnlock();
 80067f2:	f7ff ff95 	bl	8006720 <chSysUnlock>
}
 80067f6:	bd08      	pop	{r3, pc}
	...

08006800 <osalSysLockFromISR.lto_priv.269>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8006800:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8006802:	f7ff ffad 	bl	8006760 <chSysLockFromISR.lto_priv.252>
}
 8006806:	bd08      	pop	{r3, pc}
	...

08006810 <osalSysUnlockFromISR.lto_priv.267>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8006810:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8006812:	f7ff ffad 	bl	8006770 <chSysUnlockFromISR.lto_priv.249>
}
 8006816:	bd08      	pop	{r3, pc}
	...

08006820 <osalOsGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {
 8006820:	b508      	push	{r3, lr}

  return chVTGetSystemTimeX();
 8006822:	f7ff ffad 	bl	8006780 <chVTGetSystemTimeX>
 8006826:	4603      	mov	r3, r0
}
 8006828:	4618      	mov	r0, r3
 800682a:	bd08      	pop	{r3, pc}
 800682c:	0000      	movs	r0, r0
	...

08006830 <osalOsIsTimeWithinX>:
 *
 * @xclass
 */
static inline bool osalOsIsTimeWithinX(systime_t time,
                                       systime_t start,
                                       systime_t end) {
 8006830:	b500      	push	{lr}
 8006832:	b085      	sub	sp, #20
 8006834:	9003      	str	r0, [sp, #12]
 8006836:	9102      	str	r1, [sp, #8]
 8006838:	9201      	str	r2, [sp, #4]

  return chVTIsTimeWithinX(time, start, end);
 800683a:	9803      	ldr	r0, [sp, #12]
 800683c:	9902      	ldr	r1, [sp, #8]
 800683e:	9a01      	ldr	r2, [sp, #4]
 8006840:	f7ff ffa6 	bl	8006790 <chVTIsTimeWithinX>
 8006844:	4603      	mov	r3, r0
}
 8006846:	4618      	mov	r0, r3
 8006848:	b005      	add	sp, #20
 800684a:	f85d fb04 	ldr.w	pc, [sp], #4
 800684e:	bf00      	nop

08006850 <osalThreadSuspendTimeoutS>:
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendTimeoutS(thread_reference_t *trp,
                                              systime_t timeout) {
 8006850:	b500      	push	{lr}
 8006852:	b083      	sub	sp, #12
 8006854:	9001      	str	r0, [sp, #4]
 8006856:	9100      	str	r1, [sp, #0]

  return chThdSuspendTimeoutS(trp, timeout);
 8006858:	9801      	ldr	r0, [sp, #4]
 800685a:	9900      	ldr	r1, [sp, #0]
 800685c:	f006 fb20 	bl	800cea0 <chThdSuspendTimeoutS>
 8006860:	4603      	mov	r3, r0
}
 8006862:	4618      	mov	r0, r3
 8006864:	b003      	add	sp, #12
 8006866:	f85d fb04 	ldr.w	pc, [sp], #4
 800686a:	bf00      	nop
 800686c:	0000      	movs	r0, r0
	...

08006870 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 8006870:	b500      	push	{lr}
 8006872:	b083      	sub	sp, #12
 8006874:	9001      	str	r0, [sp, #4]
 8006876:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 8006878:	9801      	ldr	r0, [sp, #4]
 800687a:	9900      	ldr	r1, [sp, #0]
 800687c:	f006 fb38 	bl	800cef0 <chThdResumeI>
}
 8006880:	b003      	add	sp, #12
 8006882:	f85d fb04 	ldr.w	pc, [sp], #4
 8006886:	bf00      	nop
	...

08006890 <i2c_lld_set_clock>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_set_clock(I2CDriver *i2cp) {
 8006890:	b500      	push	{lr}
 8006892:	b087      	sub	sp, #28
 8006894:	9001      	str	r0, [sp, #4]
  I2C_TypeDef *dp = i2cp->i2c;
 8006896:	9b01      	ldr	r3, [sp, #4]
 8006898:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800689a:	9304      	str	r3, [sp, #16]
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
 800689c:	9b01      	ldr	r3, [sp, #4]
 800689e:	685b      	ldr	r3, [r3, #4]
 80068a0:	685b      	ldr	r3, [r3, #4]
 80068a2:	9303      	str	r3, [sp, #12]
  i2cdutycycle_t duty = i2cp->config->duty_cycle;
 80068a4:	9b01      	ldr	r3, [sp, #4]
 80068a6:	685b      	ldr	r3, [r3, #4]
 80068a8:	7a1b      	ldrb	r3, [r3, #8]
 80068aa:	f88d 300b 	strb.w	r3, [sp, #11]

  osalDbgCheck((i2cp != NULL) &&
 80068ae:	9b01      	ldr	r3, [sp, #4]
 80068b0:	2b00      	cmp	r3, #0
 80068b2:	d006      	beq.n	80068c2 <i2c_lld_set_clock+0x32>
 80068b4:	9b03      	ldr	r3, [sp, #12]
 80068b6:	2b00      	cmp	r3, #0
 80068b8:	dd03      	ble.n	80068c2 <i2c_lld_set_clock+0x32>
 80068ba:	9b03      	ldr	r3, [sp, #12]
 80068bc:	4a63      	ldr	r2, [pc, #396]	; (8006a4c <i2c_lld_set_clock+0x1bc>)
 80068be:	4293      	cmp	r3, r2
 80068c0:	dd02      	ble.n	80068c8 <i2c_lld_set_clock+0x38>
 80068c2:	4863      	ldr	r0, [pc, #396]	; (8006a50 <i2c_lld_set_clock+0x1c0>)
 80068c4:	f005 f914 	bl	800baf0 <chSysHalt>
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 80068c8:	9b04      	ldr	r3, [sp, #16]
 80068ca:	685a      	ldr	r2, [r3, #4]
 80068cc:	f64f 73c0 	movw	r3, #65472	; 0xffc0
 80068d0:	4013      	ands	r3, r2
 80068d2:	9a04      	ldr	r2, [sp, #16]
 80068d4:	6053      	str	r3, [r2, #4]
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 80068d6:	9b04      	ldr	r3, [sp, #16]
 80068d8:	685b      	ldr	r3, [r3, #4]
 80068da:	f043 022a 	orr.w	r2, r3, #42	; 0x2a
 80068de:	9b04      	ldr	r3, [sp, #16]
 80068e0:	605a      	str	r2, [r3, #4]

  /* CCR Configuration.*/
  regCCR = 0;
 80068e2:	2300      	movs	r3, #0
 80068e4:	f8ad 3016 	strh.w	r3, [sp, #22]
  clock_div = I2C_CCR_CCR;
 80068e8:	f640 73ff 	movw	r3, #4095	; 0xfff
 80068ec:	f8ad 3014 	strh.w	r3, [sp, #20]

  if (clock_speed <= 100000) {
 80068f0:	9b03      	ldr	r3, [sp, #12]
 80068f2:	4a58      	ldr	r2, [pc, #352]	; (8006a54 <i2c_lld_set_clock+0x1c4>)
 80068f4:	4293      	cmp	r3, r2
 80068f6:	dc2f      	bgt.n	8006958 <i2c_lld_set_clock+0xc8>
    /* Configure clock_div in standard mode.*/
    osalDbgAssert(duty == STD_DUTY_CYCLE, "invalid standard mode duty cycle");
 80068f8:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80068fc:	2b01      	cmp	r3, #1
 80068fe:	d002      	beq.n	8006906 <i2c_lld_set_clock+0x76>
 8006900:	4853      	ldr	r0, [pc, #332]	; (8006a50 <i2c_lld_set_clock+0x1c0>)
 8006902:	f005 f8f5 	bl	800baf0 <chSysHalt>

    /* Standard mode clock_div calculate: Tlow/Thigh = 1/1.*/
    osalDbgAssert((STM32_PCLK1 % (clock_speed * 2)) == 0,
 8006906:	9b03      	ldr	r3, [sp, #12]
 8006908:	005b      	lsls	r3, r3, #1
 800690a:	4a53      	ldr	r2, [pc, #332]	; (8006a58 <i2c_lld_set_clock+0x1c8>)
 800690c:	fb92 f1f3 	sdiv	r1, r2, r3
 8006910:	fb03 f301 	mul.w	r3, r3, r1
 8006914:	1ad3      	subs	r3, r2, r3
 8006916:	2b00      	cmp	r3, #0
 8006918:	d002      	beq.n	8006920 <i2c_lld_set_clock+0x90>
 800691a:	484d      	ldr	r0, [pc, #308]	; (8006a50 <i2c_lld_set_clock+0x1c0>)
 800691c:	f005 f8e8 	bl	800baf0 <chSysHalt>
                  "PCLK1 must be divisible without remainder");
    clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 2));
 8006920:	9b03      	ldr	r3, [sp, #12]
 8006922:	005b      	lsls	r3, r3, #1
 8006924:	4a4c      	ldr	r2, [pc, #304]	; (8006a58 <i2c_lld_set_clock+0x1c8>)
 8006926:	fb92 f3f3 	sdiv	r3, r2, r3
 800692a:	f8ad 3014 	strh.w	r3, [sp, #20]

    osalDbgAssert(clock_div >= 0x04,
 800692e:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 8006932:	2b03      	cmp	r3, #3
 8006934:	d802      	bhi.n	800693c <i2c_lld_set_clock+0xac>
 8006936:	4846      	ldr	r0, [pc, #280]	; (8006a50 <i2c_lld_set_clock+0x1c0>)
 8006938:	f005 f8da 	bl	800baf0 <chSysHalt>
                  "clock divider less then 0x04 not allowed");
    regCCR |= (clock_div & I2C_CCR_CCR);
 800693c:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 8006940:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8006944:	b29a      	uxth	r2, r3
 8006946:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 800694a:	4313      	orrs	r3, r2
 800694c:	f8ad 3016 	strh.w	r3, [sp, #22]

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
 8006950:	9b04      	ldr	r3, [sp, #16]
 8006952:	222b      	movs	r2, #43	; 0x2b
 8006954:	621a      	str	r2, [r3, #32]
 8006956:	e06a      	b.n	8006a2e <i2c_lld_set_clock+0x19e>
  }
  else if (clock_speed <= 400000) {
 8006958:	9b03      	ldr	r3, [sp, #12]
 800695a:	4a40      	ldr	r2, [pc, #256]	; (8006a5c <i2c_lld_set_clock+0x1cc>)
 800695c:	4293      	cmp	r3, r2
 800695e:	dc66      	bgt.n	8006a2e <i2c_lld_set_clock+0x19e>
    /* Configure clock_div in fast mode.*/
    osalDbgAssert((duty == FAST_DUTY_CYCLE_2) ||
 8006960:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006964:	2b02      	cmp	r3, #2
 8006966:	d006      	beq.n	8006976 <i2c_lld_set_clock+0xe6>
 8006968:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800696c:	2b03      	cmp	r3, #3
 800696e:	d002      	beq.n	8006976 <i2c_lld_set_clock+0xe6>
 8006970:	4837      	ldr	r0, [pc, #220]	; (8006a50 <i2c_lld_set_clock+0x1c0>)
 8006972:	f005 f8bd 	bl	800baf0 <chSysHalt>
                  (duty == FAST_DUTY_CYCLE_16_9),
                  "invalid fast mode duty cycle");

    if (duty == FAST_DUTY_CYCLE_2) {
 8006976:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800697a:	2b02      	cmp	r3, #2
 800697c:	d118      	bne.n	80069b0 <i2c_lld_set_clock+0x120>
      /* Fast mode clock_div calculate: Tlow/Thigh = 2/1.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 3)) == 0,
 800697e:	9a03      	ldr	r2, [sp, #12]
 8006980:	4613      	mov	r3, r2
 8006982:	005b      	lsls	r3, r3, #1
 8006984:	4413      	add	r3, r2
 8006986:	4a34      	ldr	r2, [pc, #208]	; (8006a58 <i2c_lld_set_clock+0x1c8>)
 8006988:	fb92 f1f3 	sdiv	r1, r2, r3
 800698c:	fb03 f301 	mul.w	r3, r3, r1
 8006990:	1ad3      	subs	r3, r2, r3
 8006992:	2b00      	cmp	r3, #0
 8006994:	d002      	beq.n	800699c <i2c_lld_set_clock+0x10c>
 8006996:	482e      	ldr	r0, [pc, #184]	; (8006a50 <i2c_lld_set_clock+0x1c0>)
 8006998:	f005 f8aa 	bl	800baf0 <chSysHalt>
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
 800699c:	9a03      	ldr	r2, [sp, #12]
 800699e:	4613      	mov	r3, r2
 80069a0:	005b      	lsls	r3, r3, #1
 80069a2:	4413      	add	r3, r2
 80069a4:	4a2c      	ldr	r2, [pc, #176]	; (8006a58 <i2c_lld_set_clock+0x1c8>)
 80069a6:	fb92 f3f3 	sdiv	r3, r2, r3
 80069aa:	f8ad 3014 	strh.w	r3, [sp, #20]
 80069ae:	e025      	b.n	80069fc <i2c_lld_set_clock+0x16c>
    }
    else if (duty == FAST_DUTY_CYCLE_16_9) {
 80069b0:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80069b4:	2b03      	cmp	r3, #3
 80069b6:	d121      	bne.n	80069fc <i2c_lld_set_clock+0x16c>
      /* Fast mode clock_div calculate: Tlow/Thigh = 16/9.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 25)) == 0,
 80069b8:	9a03      	ldr	r2, [sp, #12]
 80069ba:	4613      	mov	r3, r2
 80069bc:	009b      	lsls	r3, r3, #2
 80069be:	4413      	add	r3, r2
 80069c0:	009a      	lsls	r2, r3, #2
 80069c2:	4413      	add	r3, r2
 80069c4:	4a24      	ldr	r2, [pc, #144]	; (8006a58 <i2c_lld_set_clock+0x1c8>)
 80069c6:	fb92 f1f3 	sdiv	r1, r2, r3
 80069ca:	fb03 f301 	mul.w	r3, r3, r1
 80069ce:	1ad3      	subs	r3, r2, r3
 80069d0:	2b00      	cmp	r3, #0
 80069d2:	d002      	beq.n	80069da <i2c_lld_set_clock+0x14a>
 80069d4:	481e      	ldr	r0, [pc, #120]	; (8006a50 <i2c_lld_set_clock+0x1c0>)
 80069d6:	f005 f88b 	bl	800baf0 <chSysHalt>
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 25));
 80069da:	9a03      	ldr	r2, [sp, #12]
 80069dc:	4613      	mov	r3, r2
 80069de:	009b      	lsls	r3, r3, #2
 80069e0:	4413      	add	r3, r2
 80069e2:	009a      	lsls	r2, r3, #2
 80069e4:	4413      	add	r3, r2
 80069e6:	4a1c      	ldr	r2, [pc, #112]	; (8006a58 <i2c_lld_set_clock+0x1c8>)
 80069e8:	fb92 f3f3 	sdiv	r3, r2, r3
 80069ec:	f8ad 3014 	strh.w	r3, [sp, #20]
      regCCR |= I2C_CCR_DUTY;
 80069f0:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 80069f4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80069f8:	f8ad 3016 	strh.w	r3, [sp, #22]
    }

    osalDbgAssert(clock_div >= 0x01,
 80069fc:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 8006a00:	2b00      	cmp	r3, #0
 8006a02:	d102      	bne.n	8006a0a <i2c_lld_set_clock+0x17a>
 8006a04:	4812      	ldr	r0, [pc, #72]	; (8006a50 <i2c_lld_set_clock+0x1c0>)
 8006a06:	f005 f873 	bl	800baf0 <chSysHalt>
                  "clock divider less then 0x04 not allowed");
    regCCR |= (I2C_CCR_FS | (clock_div & I2C_CCR_CCR));
 8006a0a:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 8006a0e:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8006a12:	b29a      	uxth	r2, r3
 8006a14:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8006a18:	4313      	orrs	r3, r2
 8006a1a:	b29b      	uxth	r3, r3
 8006a1c:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8006a20:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8006a24:	f8ad 3016 	strh.w	r3, [sp, #22]

    /* Sets the Maximum Rise Time for fast mode.*/
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
 8006a28:	9b04      	ldr	r3, [sp, #16]
 8006a2a:	220d      	movs	r2, #13
 8006a2c:	621a      	str	r2, [r3, #32]
  }

  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");
 8006a2e:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 8006a32:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8006a36:	d302      	bcc.n	8006a3e <i2c_lld_set_clock+0x1ae>
 8006a38:	4805      	ldr	r0, [pc, #20]	; (8006a50 <i2c_lld_set_clock+0x1c0>)
 8006a3a:	f005 f859 	bl	800baf0 <chSysHalt>

  dp->CCR = regCCR;
 8006a3e:	f8bd 2016 	ldrh.w	r2, [sp, #22]
 8006a42:	9b04      	ldr	r3, [sp, #16]
 8006a44:	61da      	str	r2, [r3, #28]
}
 8006a46:	b007      	add	sp, #28
 8006a48:	f85d fb04 	ldr.w	pc, [sp], #4
 8006a4c:	003d0900 	.word	0x003d0900
 8006a50:	0800e320 	.word	0x0800e320
 8006a54:	000186a0 	.word	0x000186a0
 8006a58:	0280de80 	.word	0x0280de80
 8006a5c:	00061a80 	.word	0x00061a80

08006a60 <i2c_lld_set_opmode>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_set_opmode(I2CDriver *i2cp) {
 8006a60:	b086      	sub	sp, #24
 8006a62:	9001      	str	r0, [sp, #4]
  I2C_TypeDef *dp = i2cp->i2c;
 8006a64:	9b01      	ldr	r3, [sp, #4]
 8006a66:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006a68:	9304      	str	r3, [sp, #16]
  i2copmode_t opmode = i2cp->config->op_mode;
 8006a6a:	9b01      	ldr	r3, [sp, #4]
 8006a6c:	685b      	ldr	r3, [r3, #4]
 8006a6e:	781b      	ldrb	r3, [r3, #0]
 8006a70:	f88d 300f 	strb.w	r3, [sp, #15]
  uint16_t regCR1;

  regCR1 = dp->CR1;
 8006a74:	9b04      	ldr	r3, [sp, #16]
 8006a76:	681b      	ldr	r3, [r3, #0]
 8006a78:	f8ad 3016 	strh.w	r3, [sp, #22]
  switch (opmode) {
 8006a7c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8006a80:	2b02      	cmp	r3, #2
 8006a82:	d00a      	beq.n	8006a9a <i2c_lld_set_opmode+0x3a>
 8006a84:	2b03      	cmp	r3, #3
 8006a86:	d015      	beq.n	8006ab4 <i2c_lld_set_opmode+0x54>
 8006a88:	2b01      	cmp	r3, #1
 8006a8a:	d119      	bne.n	8006ac0 <i2c_lld_set_opmode+0x60>
  case OPMODE_I2C:
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 8006a8c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8006a90:	f023 030a 	bic.w	r3, r3, #10
 8006a94:	f8ad 3016 	strh.w	r3, [sp, #22]
 8006a98:	e012      	b.n	8006ac0 <i2c_lld_set_opmode+0x60>
    break;
  case OPMODE_SMBUS_DEVICE:
    regCR1 |= I2C_CR1_SMBUS;
 8006a9a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8006a9e:	f043 0302 	orr.w	r3, r3, #2
 8006aa2:	f8ad 3016 	strh.w	r3, [sp, #22]
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
 8006aa6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8006aaa:	f023 0308 	bic.w	r3, r3, #8
 8006aae:	f8ad 3016 	strh.w	r3, [sp, #22]
 8006ab2:	e005      	b.n	8006ac0 <i2c_lld_set_opmode+0x60>
    break;
  case OPMODE_SMBUS_HOST:
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 8006ab4:	f8bd 3016 	ldrh.w	r3, [sp, #22]
 8006ab8:	f043 030a 	orr.w	r3, r3, #10
 8006abc:	f8ad 3016 	strh.w	r3, [sp, #22]
    break;
  }
  dp->CR1 = regCR1;
 8006ac0:	f8bd 2016 	ldrh.w	r2, [sp, #22]
 8006ac4:	9b04      	ldr	r3, [sp, #16]
 8006ac6:	601a      	str	r2, [r3, #0]
}
 8006ac8:	b006      	add	sp, #24
 8006aca:	4770      	bx	lr
 8006acc:	0000      	movs	r0, r0
	...

08006ad0 <i2c_lld_serve_event_interrupt>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
 8006ad0:	b500      	push	{lr}
 8006ad2:	b087      	sub	sp, #28
 8006ad4:	9001      	str	r0, [sp, #4]
  I2C_TypeDef *dp = i2cp->i2c;
 8006ad6:	9b01      	ldr	r3, [sp, #4]
 8006ad8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006ada:	9305      	str	r3, [sp, #20]
  uint32_t regSR2 = dp->SR2;
 8006adc:	9b05      	ldr	r3, [sp, #20]
 8006ade:	699b      	ldr	r3, [r3, #24]
 8006ae0:	9304      	str	r3, [sp, #16]
  uint32_t event = dp->SR1;
 8006ae2:	9b05      	ldr	r3, [sp, #20]
 8006ae4:	695b      	ldr	r3, [r3, #20]
 8006ae6:	9303      	str	r3, [sp, #12]

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 8006ae8:	9b04      	ldr	r3, [sp, #16]
 8006aea:	041a      	lsls	r2, r3, #16
 8006aec:	9b03      	ldr	r3, [sp, #12]
 8006aee:	4313      	orrs	r3, r2
 8006af0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8006af4:	4a52      	ldr	r2, [pc, #328]	; (8006c40 <i2c_lld_serve_event_interrupt+0x170>)
 8006af6:	4293      	cmp	r3, r2
 8006af8:	d031      	beq.n	8006b5e <i2c_lld_serve_event_interrupt+0x8e>
 8006afa:	4a51      	ldr	r2, [pc, #324]	; (8006c40 <i2c_lld_serve_event_interrupt+0x170>)
 8006afc:	4293      	cmp	r3, r2
 8006afe:	d806      	bhi.n	8006b0e <i2c_lld_serve_event_interrupt+0x3e>
 8006b00:	4a50      	ldr	r2, [pc, #320]	; (8006c44 <i2c_lld_serve_event_interrupt+0x174>)
 8006b02:	4293      	cmp	r3, r2
 8006b04:	d00a      	beq.n	8006b1c <i2c_lld_serve_event_interrupt+0x4c>
 8006b06:	4a50      	ldr	r2, [pc, #320]	; (8006c48 <i2c_lld_serve_event_interrupt+0x178>)
 8006b08:	4293      	cmp	r3, r2
 8006b0a:	d030      	beq.n	8006b6e <i2c_lld_serve_event_interrupt+0x9e>
 8006b0c:	e08d      	b.n	8006c2a <i2c_lld_serve_event_interrupt+0x15a>
 8006b0e:	4a4f      	ldr	r2, [pc, #316]	; (8006c4c <i2c_lld_serve_event_interrupt+0x17c>)
 8006b10:	4293      	cmp	r3, r2
 8006b12:	d04f      	beq.n	8006bb4 <i2c_lld_serve_event_interrupt+0xe4>
 8006b14:	4a4e      	ldr	r2, [pc, #312]	; (8006c50 <i2c_lld_serve_event_interrupt+0x180>)
 8006b16:	4293      	cmp	r3, r2
 8006b18:	d05d      	beq.n	8006bd6 <i2c_lld_serve_event_interrupt+0x106>
 8006b1a:	e086      	b.n	8006c2a <i2c_lld_serve_event_interrupt+0x15a>
  case I2C_EV5_MASTER_MODE_SELECT:
    if ((i2cp->addr >> 8) > 0) { 
 8006b1c:	9b01      	ldr	r3, [sp, #4]
 8006b1e:	8c1b      	ldrh	r3, [r3, #32]
 8006b20:	0a1b      	lsrs	r3, r3, #8
 8006b22:	b29b      	uxth	r3, r3
 8006b24:	2b00      	cmp	r3, #0
 8006b26:	d014      	beq.n	8006b52 <i2c_lld_serve_event_interrupt+0x82>
      /* 10-bit address: 1 1 1 1 0 X X R/W */
      dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
 8006b28:	9b01      	ldr	r3, [sp, #4]
 8006b2a:	8c1b      	ldrh	r3, [r3, #32]
 8006b2c:	0a1b      	lsrs	r3, r3, #8
 8006b2e:	b29b      	uxth	r3, r3
 8006b30:	f003 0306 	and.w	r3, r3, #6
 8006b34:	b29a      	uxth	r2, r3
 8006b36:	9b01      	ldr	r3, [sp, #4]
 8006b38:	8c1b      	ldrh	r3, [r3, #32]
 8006b3a:	f003 0301 	and.w	r3, r3, #1
 8006b3e:	b29b      	uxth	r3, r3
 8006b40:	4313      	orrs	r3, r2
 8006b42:	b29b      	uxth	r3, r3
 8006b44:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8006b48:	b29b      	uxth	r3, r3
 8006b4a:	461a      	mov	r2, r3
 8006b4c:	9b05      	ldr	r3, [sp, #20]
 8006b4e:	611a      	str	r2, [r3, #16]
 8006b50:	e06b      	b.n	8006c2a <i2c_lld_serve_event_interrupt+0x15a>
    } else {
      dp->DR = i2cp->addr;
 8006b52:	9b01      	ldr	r3, [sp, #4]
 8006b54:	8c1b      	ldrh	r3, [r3, #32]
 8006b56:	461a      	mov	r2, r3
 8006b58:	9b05      	ldr	r3, [sp, #20]
 8006b5a:	611a      	str	r2, [r3, #16]
 8006b5c:	e065      	b.n	8006c2a <i2c_lld_serve_event_interrupt+0x15a>
    }
    break;
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
 8006b5e:	9b01      	ldr	r3, [sp, #4]
 8006b60:	8c1b      	ldrh	r3, [r3, #32]
 8006b62:	085b      	lsrs	r3, r3, #1
 8006b64:	b29b      	uxth	r3, r3
 8006b66:	b2da      	uxtb	r2, r3
 8006b68:	9b05      	ldr	r3, [sp, #20]
 8006b6a:	611a      	str	r2, [r3, #16]
 8006b6c:	e05d      	b.n	8006c2a <i2c_lld_serve_event_interrupt+0x15a>
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8006b6e:	9b05      	ldr	r3, [sp, #20]
 8006b70:	685b      	ldr	r3, [r3, #4]
 8006b72:	f423 7200 	bic.w	r2, r3, #512	; 0x200
 8006b76:	9b05      	ldr	r3, [sp, #20]
 8006b78:	605a      	str	r2, [r3, #4]
    dmaStreamEnable(i2cp->dmarx);
 8006b7a:	9b01      	ldr	r3, [sp, #4]
 8006b7c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006b7e:	681b      	ldr	r3, [r3, #0]
 8006b80:	9a01      	ldr	r2, [sp, #4]
 8006b82:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8006b84:	6812      	ldr	r2, [r2, #0]
 8006b86:	6812      	ldr	r2, [r2, #0]
 8006b88:	f042 0201 	orr.w	r2, r2, #1
 8006b8c:	601a      	str	r2, [r3, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
 8006b8e:	9b05      	ldr	r3, [sp, #20]
 8006b90:	685b      	ldr	r3, [r3, #4]
 8006b92:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
 8006b96:	9b05      	ldr	r3, [sp, #20]
 8006b98:	605a      	str	r2, [r3, #4]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
 8006b9a:	9b01      	ldr	r3, [sp, #4]
 8006b9c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006b9e:	681b      	ldr	r3, [r3, #0]
 8006ba0:	685b      	ldr	r3, [r3, #4]
 8006ba2:	2b01      	cmp	r3, #1
 8006ba4:	d841      	bhi.n	8006c2a <i2c_lld_serve_event_interrupt+0x15a>
      dp->CR1 &= ~I2C_CR1_ACK;
 8006ba6:	9b05      	ldr	r3, [sp, #20]
 8006ba8:	681b      	ldr	r3, [r3, #0]
 8006baa:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
 8006bae:	9b05      	ldr	r3, [sp, #20]
 8006bb0:	601a      	str	r2, [r3, #0]
 8006bb2:	e03a      	b.n	8006c2a <i2c_lld_serve_event_interrupt+0x15a>
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8006bb4:	9b05      	ldr	r3, [sp, #20]
 8006bb6:	685b      	ldr	r3, [r3, #4]
 8006bb8:	f423 7200 	bic.w	r2, r3, #512	; 0x200
 8006bbc:	9b05      	ldr	r3, [sp, #20]
 8006bbe:	605a      	str	r2, [r3, #4]
    dmaStreamEnable(i2cp->dmatx);
 8006bc0:	9b01      	ldr	r3, [sp, #4]
 8006bc2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006bc4:	681b      	ldr	r3, [r3, #0]
 8006bc6:	9a01      	ldr	r2, [sp, #4]
 8006bc8:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8006bca:	6812      	ldr	r2, [r2, #0]
 8006bcc:	6812      	ldr	r2, [r2, #0]
 8006bce:	f042 0201 	orr.w	r2, r2, #1
 8006bd2:	601a      	str	r2, [r3, #0]
 8006bd4:	e029      	b.n	8006c2a <i2c_lld_serve_event_interrupt+0x15a>
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
 8006bd6:	9b01      	ldr	r3, [sp, #4]
 8006bd8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006bda:	681b      	ldr	r3, [r3, #0]
 8006bdc:	685b      	ldr	r3, [r3, #4]
 8006bde:	2b00      	cmp	r3, #0
 8006be0:	d00d      	beq.n	8006bfe <i2c_lld_serve_event_interrupt+0x12e>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 8006be2:	9b01      	ldr	r3, [sp, #4]
 8006be4:	8c1b      	ldrh	r3, [r3, #32]
 8006be6:	f043 0301 	orr.w	r3, r3, #1
 8006bea:	b29a      	uxth	r2, r3
 8006bec:	9b01      	ldr	r3, [sp, #4]
 8006bee:	841a      	strh	r2, [r3, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8006bf0:	9b05      	ldr	r3, [sp, #20]
 8006bf2:	681b      	ldr	r3, [r3, #0]
 8006bf4:	f443 62a0 	orr.w	r2, r3, #1280	; 0x500
 8006bf8:	9b05      	ldr	r3, [sp, #20]
 8006bfa:	601a      	str	r2, [r3, #0]
 8006bfc:	e01c      	b.n	8006c38 <i2c_lld_serve_event_interrupt+0x168>
      return;
    }
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8006bfe:	9b05      	ldr	r3, [sp, #20]
 8006c00:	685b      	ldr	r3, [r3, #4]
 8006c02:	f423 7200 	bic.w	r2, r3, #512	; 0x200
 8006c06:	9b05      	ldr	r3, [sp, #20]
 8006c08:	605a      	str	r2, [r3, #4]
    dp->CR1 |= I2C_CR1_STOP;
 8006c0a:	9b05      	ldr	r3, [sp, #20]
 8006c0c:	681b      	ldr	r3, [r3, #0]
 8006c0e:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 8006c12:	9b05      	ldr	r3, [sp, #20]
 8006c14:	601a      	str	r2, [r3, #0]
    _i2c_wakeup_isr(i2cp);
 8006c16:	f7ff fdf3 	bl	8006800 <osalSysLockFromISR.lto_priv.269>
 8006c1a:	9b01      	ldr	r3, [sp, #4]
 8006c1c:	331c      	adds	r3, #28
 8006c1e:	4618      	mov	r0, r3
 8006c20:	2100      	movs	r1, #0
 8006c22:	f7ff fe25 	bl	8006870 <osalThreadResumeI>
 8006c26:	f7ff fdf3 	bl	8006810 <osalSysUnlockFromISR.lto_priv.267>
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 8006c2a:	9b03      	ldr	r3, [sp, #12]
 8006c2c:	f003 030a 	and.w	r3, r3, #10
 8006c30:	2b00      	cmp	r3, #0
 8006c32:	d001      	beq.n	8006c38 <i2c_lld_serve_event_interrupt+0x168>
    (void)dp->SR2;
 8006c34:	9b05      	ldr	r3, [sp, #20]
 8006c36:	699b      	ldr	r3, [r3, #24]
}
 8006c38:	b007      	add	sp, #28
 8006c3a:	f85d fb04 	ldr.w	pc, [sp], #4
 8006c3e:	bf00      	nop
 8006c40:	00030008 	.word	0x00030008
 8006c44:	00030001 	.word	0x00030001
 8006c48:	00030002 	.word	0x00030002
 8006c4c:	00070082 	.word	0x00070082
 8006c50:	00070084 	.word	0x00070084
	...

08006c60 <i2c_lld_serve_rx_end_irq>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 *
 * @notapi
 */
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 8006c60:	b500      	push	{lr}
 8006c62:	b085      	sub	sp, #20
 8006c64:	9001      	str	r0, [sp, #4]
 8006c66:	9100      	str	r1, [sp, #0]
  I2C_TypeDef *dp = i2cp->i2c;
 8006c68:	9b01      	ldr	r3, [sp, #4]
 8006c6a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006c6c:	9303      	str	r3, [sp, #12]

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8006c6e:	9b00      	ldr	r3, [sp, #0]
 8006c70:	f003 030c 	and.w	r3, r3, #12
 8006c74:	2b00      	cmp	r3, #0
 8006c76:	d002      	beq.n	8006c7e <i2c_lld_serve_rx_end_irq+0x1e>
    STM32_I2C_DMA_ERROR_HOOK(i2cp);
 8006c78:	481e      	ldr	r0, [pc, #120]	; (8006cf4 <i2c_lld_serve_rx_end_irq+0x94>)
 8006c7a:	f7ff fda1 	bl	80067c0 <osalSysHalt>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmarx);
 8006c7e:	9b01      	ldr	r3, [sp, #4]
 8006c80:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006c82:	681b      	ldr	r3, [r3, #0]
 8006c84:	9a01      	ldr	r2, [sp, #4]
 8006c86:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8006c88:	6812      	ldr	r2, [r2, #0]
 8006c8a:	6812      	ldr	r2, [r2, #0]
 8006c8c:	f022 021f 	bic.w	r2, r2, #31
 8006c90:	601a      	str	r2, [r3, #0]
 8006c92:	9b01      	ldr	r3, [sp, #4]
 8006c94:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006c96:	681b      	ldr	r3, [r3, #0]
 8006c98:	681b      	ldr	r3, [r3, #0]
 8006c9a:	f003 0301 	and.w	r3, r3, #1
 8006c9e:	2b00      	cmp	r3, #0
 8006ca0:	d1f7      	bne.n	8006c92 <i2c_lld_serve_rx_end_irq+0x32>
 8006ca2:	9b01      	ldr	r3, [sp, #4]
 8006ca4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006ca6:	685b      	ldr	r3, [r3, #4]
 8006ca8:	9a01      	ldr	r2, [sp, #4]
 8006caa:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8006cac:	7a12      	ldrb	r2, [r2, #8]
 8006cae:	4611      	mov	r1, r2
 8006cb0:	223d      	movs	r2, #61	; 0x3d
 8006cb2:	408a      	lsls	r2, r1
 8006cb4:	601a      	str	r2, [r3, #0]

  dp->CR2 &= ~I2C_CR2_LAST;
 8006cb6:	9b03      	ldr	r3, [sp, #12]
 8006cb8:	685b      	ldr	r3, [r3, #4]
 8006cba:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 8006cbe:	9b03      	ldr	r3, [sp, #12]
 8006cc0:	605a      	str	r2, [r3, #4]
  dp->CR1 &= ~I2C_CR1_ACK;
 8006cc2:	9b03      	ldr	r3, [sp, #12]
 8006cc4:	681b      	ldr	r3, [r3, #0]
 8006cc6:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
 8006cca:	9b03      	ldr	r3, [sp, #12]
 8006ccc:	601a      	str	r2, [r3, #0]
  dp->CR1 |= I2C_CR1_STOP;
 8006cce:	9b03      	ldr	r3, [sp, #12]
 8006cd0:	681b      	ldr	r3, [r3, #0]
 8006cd2:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 8006cd6:	9b03      	ldr	r3, [sp, #12]
 8006cd8:	601a      	str	r2, [r3, #0]
  _i2c_wakeup_isr(i2cp);
 8006cda:	f7ff fd91 	bl	8006800 <osalSysLockFromISR.lto_priv.269>
 8006cde:	9b01      	ldr	r3, [sp, #4]
 8006ce0:	331c      	adds	r3, #28
 8006ce2:	4618      	mov	r0, r3
 8006ce4:	2100      	movs	r1, #0
 8006ce6:	f7ff fdc3 	bl	8006870 <osalThreadResumeI>
 8006cea:	f7ff fd91 	bl	8006810 <osalSysUnlockFromISR.lto_priv.267>
}
 8006cee:	b005      	add	sp, #20
 8006cf0:	f85d fb04 	ldr.w	pc, [sp], #4
 8006cf4:	0800dad0 	.word	0x0800dad0
	...

08006d00 <i2c_lld_serve_tx_end_irq>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 8006d00:	b500      	push	{lr}
 8006d02:	b085      	sub	sp, #20
 8006d04:	9001      	str	r0, [sp, #4]
 8006d06:	9100      	str	r1, [sp, #0]
  I2C_TypeDef *dp = i2cp->i2c;
 8006d08:	9b01      	ldr	r3, [sp, #4]
 8006d0a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006d0c:	9303      	str	r3, [sp, #12]

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8006d0e:	9b00      	ldr	r3, [sp, #0]
 8006d10:	f003 030c 	and.w	r3, r3, #12
 8006d14:	2b00      	cmp	r3, #0
 8006d16:	d002      	beq.n	8006d1e <i2c_lld_serve_tx_end_irq+0x1e>
    STM32_I2C_DMA_ERROR_HOOK(i2cp);
 8006d18:	4813      	ldr	r0, [pc, #76]	; (8006d68 <i2c_lld_serve_tx_end_irq+0x68>)
 8006d1a:	f7ff fd51 	bl	80067c0 <osalSysHalt>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmatx);
 8006d1e:	9b01      	ldr	r3, [sp, #4]
 8006d20:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006d22:	681b      	ldr	r3, [r3, #0]
 8006d24:	9a01      	ldr	r2, [sp, #4]
 8006d26:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8006d28:	6812      	ldr	r2, [r2, #0]
 8006d2a:	6812      	ldr	r2, [r2, #0]
 8006d2c:	f022 021f 	bic.w	r2, r2, #31
 8006d30:	601a      	str	r2, [r3, #0]
 8006d32:	9b01      	ldr	r3, [sp, #4]
 8006d34:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006d36:	681b      	ldr	r3, [r3, #0]
 8006d38:	681b      	ldr	r3, [r3, #0]
 8006d3a:	f003 0301 	and.w	r3, r3, #1
 8006d3e:	2b00      	cmp	r3, #0
 8006d40:	d1f7      	bne.n	8006d32 <i2c_lld_serve_tx_end_irq+0x32>
 8006d42:	9b01      	ldr	r3, [sp, #4]
 8006d44:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006d46:	685b      	ldr	r3, [r3, #4]
 8006d48:	9a01      	ldr	r2, [sp, #4]
 8006d4a:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8006d4c:	7a12      	ldrb	r2, [r2, #8]
 8006d4e:	4611      	mov	r1, r2
 8006d50:	223d      	movs	r2, #61	; 0x3d
 8006d52:	408a      	lsls	r2, r1
 8006d54:	601a      	str	r2, [r3, #0]
  /* Enables interrupts to catch BTF event meaning transmission part complete.
     Interrupt handler will decide to generate STOP or to begin receiving part
     of R/W transaction itself.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8006d56:	9b03      	ldr	r3, [sp, #12]
 8006d58:	685b      	ldr	r3, [r3, #4]
 8006d5a:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 8006d5e:	9b03      	ldr	r3, [sp, #12]
 8006d60:	605a      	str	r2, [r3, #4]
}
 8006d62:	b005      	add	sp, #20
 8006d64:	f85d fb04 	ldr.w	pc, [sp], #4
 8006d68:	0800dad0 	.word	0x0800dad0
 8006d6c:	00000000 	.word	0x00000000

08006d70 <i2c_lld_serve_error_interrupt>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in]  sr       content of the SR1 register to be decoded
 *
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {
 8006d70:	b500      	push	{lr}
 8006d72:	b083      	sub	sp, #12
 8006d74:	9001      	str	r0, [sp, #4]
 8006d76:	460b      	mov	r3, r1
 8006d78:	f8ad 3002 	strh.w	r3, [sp, #2]

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8006d7c:	9b01      	ldr	r3, [sp, #4]
 8006d7e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006d80:	681b      	ldr	r3, [r3, #0]
 8006d82:	9a01      	ldr	r2, [sp, #4]
 8006d84:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8006d86:	6812      	ldr	r2, [r2, #0]
 8006d88:	6812      	ldr	r2, [r2, #0]
 8006d8a:	f022 021f 	bic.w	r2, r2, #31
 8006d8e:	601a      	str	r2, [r3, #0]
 8006d90:	9b01      	ldr	r3, [sp, #4]
 8006d92:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006d94:	681b      	ldr	r3, [r3, #0]
 8006d96:	681b      	ldr	r3, [r3, #0]
 8006d98:	f003 0301 	and.w	r3, r3, #1
 8006d9c:	2b00      	cmp	r3, #0
 8006d9e:	d1f7      	bne.n	8006d90 <i2c_lld_serve_error_interrupt+0x20>
 8006da0:	9b01      	ldr	r3, [sp, #4]
 8006da2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006da4:	685b      	ldr	r3, [r3, #4]
 8006da6:	9a01      	ldr	r2, [sp, #4]
 8006da8:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8006daa:	7a12      	ldrb	r2, [r2, #8]
 8006dac:	4611      	mov	r1, r2
 8006dae:	223d      	movs	r2, #61	; 0x3d
 8006db0:	408a      	lsls	r2, r1
 8006db2:	601a      	str	r2, [r3, #0]
  dmaStreamDisable(i2cp->dmarx);
 8006db4:	9b01      	ldr	r3, [sp, #4]
 8006db6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006db8:	681b      	ldr	r3, [r3, #0]
 8006dba:	9a01      	ldr	r2, [sp, #4]
 8006dbc:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8006dbe:	6812      	ldr	r2, [r2, #0]
 8006dc0:	6812      	ldr	r2, [r2, #0]
 8006dc2:	f022 021f 	bic.w	r2, r2, #31
 8006dc6:	601a      	str	r2, [r3, #0]
 8006dc8:	9b01      	ldr	r3, [sp, #4]
 8006dca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006dcc:	681b      	ldr	r3, [r3, #0]
 8006dce:	681b      	ldr	r3, [r3, #0]
 8006dd0:	f003 0301 	and.w	r3, r3, #1
 8006dd4:	2b00      	cmp	r3, #0
 8006dd6:	d1f7      	bne.n	8006dc8 <i2c_lld_serve_error_interrupt+0x58>
 8006dd8:	9b01      	ldr	r3, [sp, #4]
 8006dda:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006ddc:	685b      	ldr	r3, [r3, #4]
 8006dde:	9a01      	ldr	r2, [sp, #4]
 8006de0:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8006de2:	7a12      	ldrb	r2, [r2, #8]
 8006de4:	4611      	mov	r1, r2
 8006de6:	223d      	movs	r2, #61	; 0x3d
 8006de8:	408a      	lsls	r2, r1
 8006dea:	601a      	str	r2, [r3, #0]

  i2cp->errors = I2C_NO_ERROR;
 8006dec:	9b01      	ldr	r3, [sp, #4]
 8006dee:	2200      	movs	r2, #0
 8006df0:	609a      	str	r2, [r3, #8]

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 8006df2:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8006df6:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8006dfa:	2b00      	cmp	r3, #0
 8006dfc:	d005      	beq.n	8006e0a <i2c_lld_serve_error_interrupt+0x9a>
    i2cp->errors |= I2C_BUS_ERROR;
 8006dfe:	9b01      	ldr	r3, [sp, #4]
 8006e00:	689b      	ldr	r3, [r3, #8]
 8006e02:	f043 0201 	orr.w	r2, r3, #1
 8006e06:	9b01      	ldr	r3, [sp, #4]
 8006e08:	609a      	str	r2, [r3, #8]

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
 8006e0a:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8006e0e:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8006e12:	2b00      	cmp	r3, #0
 8006e14:	d005      	beq.n	8006e22 <i2c_lld_serve_error_interrupt+0xb2>
    i2cp->errors |= I2C_ARBITRATION_LOST;
 8006e16:	9b01      	ldr	r3, [sp, #4]
 8006e18:	689b      	ldr	r3, [r3, #8]
 8006e1a:	f043 0202 	orr.w	r2, r3, #2
 8006e1e:	9b01      	ldr	r3, [sp, #4]
 8006e20:	609a      	str	r2, [r3, #8]

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
 8006e22:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8006e26:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8006e2a:	2b00      	cmp	r3, #0
 8006e2c:	d015      	beq.n	8006e5a <i2c_lld_serve_error_interrupt+0xea>
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 8006e2e:	9b01      	ldr	r3, [sp, #4]
 8006e30:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006e32:	9a01      	ldr	r2, [sp, #4]
 8006e34:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8006e36:	6852      	ldr	r2, [r2, #4]
 8006e38:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8006e3c:	605a      	str	r2, [r3, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 8006e3e:	9b01      	ldr	r3, [sp, #4]
 8006e40:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006e42:	9a01      	ldr	r2, [sp, #4]
 8006e44:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8006e46:	6812      	ldr	r2, [r2, #0]
 8006e48:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8006e4c:	601a      	str	r2, [r3, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8006e4e:	9b01      	ldr	r3, [sp, #4]
 8006e50:	689b      	ldr	r3, [r3, #8]
 8006e52:	f043 0204 	orr.w	r2, r3, #4
 8006e56:	9b01      	ldr	r3, [sp, #4]
 8006e58:	609a      	str	r2, [r3, #8]
  }

  if (sr & I2C_SR1_OVR)                             /* Overrun.             */
 8006e5a:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8006e5e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8006e62:	2b00      	cmp	r3, #0
 8006e64:	d005      	beq.n	8006e72 <i2c_lld_serve_error_interrupt+0x102>
    i2cp->errors |= I2C_OVERRUN;
 8006e66:	9b01      	ldr	r3, [sp, #4]
 8006e68:	689b      	ldr	r3, [r3, #8]
 8006e6a:	f043 0208 	orr.w	r2, r3, #8
 8006e6e:	9b01      	ldr	r3, [sp, #4]
 8006e70:	609a      	str	r2, [r3, #8]

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
 8006e72:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8006e76:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8006e7a:	2b00      	cmp	r3, #0
 8006e7c:	d005      	beq.n	8006e8a <i2c_lld_serve_error_interrupt+0x11a>
    i2cp->errors |= I2C_TIMEOUT;
 8006e7e:	9b01      	ldr	r3, [sp, #4]
 8006e80:	689b      	ldr	r3, [r3, #8]
 8006e82:	f043 0220 	orr.w	r2, r3, #32
 8006e86:	9b01      	ldr	r3, [sp, #4]
 8006e88:	609a      	str	r2, [r3, #8]

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
 8006e8a:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8006e8e:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8006e92:	2b00      	cmp	r3, #0
 8006e94:	d005      	beq.n	8006ea2 <i2c_lld_serve_error_interrupt+0x132>
    i2cp->errors |= I2C_PEC_ERROR;
 8006e96:	9b01      	ldr	r3, [sp, #4]
 8006e98:	689b      	ldr	r3, [r3, #8]
 8006e9a:	f043 0210 	orr.w	r2, r3, #16
 8006e9e:	9b01      	ldr	r3, [sp, #4]
 8006ea0:	609a      	str	r2, [r3, #8]

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8006ea2:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8006ea6:	b21b      	sxth	r3, r3
 8006ea8:	2b00      	cmp	r3, #0
 8006eaa:	da05      	bge.n	8006eb8 <i2c_lld_serve_error_interrupt+0x148>
    i2cp->errors |= I2C_SMB_ALERT;
 8006eac:	9b01      	ldr	r3, [sp, #4]
 8006eae:	689b      	ldr	r3, [r3, #8]
 8006eb0:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8006eb4:	9b01      	ldr	r3, [sp, #4]
 8006eb6:	609a      	str	r2, [r3, #8]

  /* If some error has been identified then sends wakes the waiting thread.*/
  if (i2cp->errors != I2C_NO_ERROR)
 8006eb8:	9b01      	ldr	r3, [sp, #4]
 8006eba:	689b      	ldr	r3, [r3, #8]
 8006ebc:	2b00      	cmp	r3, #0
 8006ebe:	d00a      	beq.n	8006ed6 <i2c_lld_serve_error_interrupt+0x166>
    _i2c_wakeup_error_isr(i2cp);
 8006ec0:	f7ff fc9e 	bl	8006800 <osalSysLockFromISR.lto_priv.269>
 8006ec4:	9b01      	ldr	r3, [sp, #4]
 8006ec6:	331c      	adds	r3, #28
 8006ec8:	4618      	mov	r0, r3
 8006eca:	f06f 0101 	mvn.w	r1, #1
 8006ece:	f7ff fccf 	bl	8006870 <osalThreadResumeI>
 8006ed2:	f7ff fc9d 	bl	8006810 <osalSysUnlockFromISR.lto_priv.267>
}
 8006ed6:	b003      	add	sp, #12
 8006ed8:	f85d fb04 	ldr.w	pc, [sp], #4
 8006edc:	0000      	movs	r0, r0
	...

08006ee0 <VectorBC>:
/**
 * @brief   I2C1 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {
 8006ee0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8006ee2:	f003 fa7d 	bl	800a3e0 <_stats_increase_irq>
 8006ee6:	f004 ffbb 	bl	800be60 <_dbg_check_enter_isr>

  i2c_lld_serve_event_interrupt(&I2CD1);
 8006eea:	4804      	ldr	r0, [pc, #16]	; (8006efc <VectorBC+0x1c>)
 8006eec:	f7ff fdf0 	bl	8006ad0 <i2c_lld_serve_event_interrupt>

  OSAL_IRQ_EPILOGUE();
 8006ef0:	f004 ffd6 	bl	800bea0 <_dbg_check_leave_isr>
 8006ef4:	f001 ff4c 	bl	8008d90 <_port_irq_epilogue>
}
 8006ef8:	bd08      	pop	{r3, pc}
 8006efa:	bf00      	nop
 8006efc:	200013b4 	.word	0x200013b4

08006f00 <VectorC0>:

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
 8006f00:	b500      	push	{lr}
 8006f02:	b083      	sub	sp, #12
  uint16_t sr = I2CD1.i2c->SR1;
 8006f04:	4b0e      	ldr	r3, [pc, #56]	; (8006f40 <VectorC0+0x40>)
 8006f06:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006f08:	695b      	ldr	r3, [r3, #20]
 8006f0a:	f8ad 3006 	strh.w	r3, [sp, #6]

  OSAL_IRQ_PROLOGUE();
 8006f0e:	f003 fa67 	bl	800a3e0 <_stats_increase_irq>
 8006f12:	f004 ffa5 	bl	800be60 <_dbg_check_enter_isr>

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 8006f16:	4b0a      	ldr	r3, [pc, #40]	; (8006f40 <VectorC0+0x40>)
 8006f18:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006f1a:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 8006f1e:	f402 425f 	and.w	r2, r2, #57088	; 0xdf00
 8006f22:	43d2      	mvns	r2, r2
 8006f24:	615a      	str	r2, [r3, #20]
  i2c_lld_serve_error_interrupt(&I2CD1, sr);
 8006f26:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8006f2a:	4805      	ldr	r0, [pc, #20]	; (8006f40 <VectorC0+0x40>)
 8006f2c:	4619      	mov	r1, r3
 8006f2e:	f7ff ff1f 	bl	8006d70 <i2c_lld_serve_error_interrupt>

  OSAL_IRQ_EPILOGUE();
 8006f32:	f004 ffb5 	bl	800bea0 <_dbg_check_leave_isr>
 8006f36:	f001 ff2b 	bl	8008d90 <_port_irq_epilogue>
}
 8006f3a:	b003      	add	sp, #12
 8006f3c:	f85d fb04 	ldr.w	pc, [sp], #4
 8006f40:	200013b4 	.word	0x200013b4
	...

08006f50 <VectorC4>:
/**
 * @brief   I2C2 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_EVENT_HANDLER) {
 8006f50:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8006f52:	f003 fa45 	bl	800a3e0 <_stats_increase_irq>
 8006f56:	f004 ff83 	bl	800be60 <_dbg_check_enter_isr>

  i2c_lld_serve_event_interrupt(&I2CD2);
 8006f5a:	4804      	ldr	r0, [pc, #16]	; (8006f6c <VectorC4+0x1c>)
 8006f5c:	f7ff fdb8 	bl	8006ad0 <i2c_lld_serve_event_interrupt>

  OSAL_IRQ_EPILOGUE();
 8006f60:	f004 ff9e 	bl	800bea0 <_dbg_check_leave_isr>
 8006f64:	f001 ff14 	bl	8008d90 <_port_irq_epilogue>
}
 8006f68:	bd08      	pop	{r3, pc}
 8006f6a:	bf00      	nop
 8006f6c:	200013ec 	.word	0x200013ec

08006f70 <VectorC8>:
/**
 * @brief   I2C2 error interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
 8006f70:	b500      	push	{lr}
 8006f72:	b083      	sub	sp, #12
  uint16_t sr = I2CD2.i2c->SR1;
 8006f74:	4b0e      	ldr	r3, [pc, #56]	; (8006fb0 <VectorC8+0x40>)
 8006f76:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006f78:	695b      	ldr	r3, [r3, #20]
 8006f7a:	f8ad 3006 	strh.w	r3, [sp, #6]

  OSAL_IRQ_PROLOGUE();
 8006f7e:	f003 fa2f 	bl	800a3e0 <_stats_increase_irq>
 8006f82:	f004 ff6d 	bl	800be60 <_dbg_check_enter_isr>

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 8006f86:	4b0a      	ldr	r3, [pc, #40]	; (8006fb0 <VectorC8+0x40>)
 8006f88:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006f8a:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 8006f8e:	f402 425f 	and.w	r2, r2, #57088	; 0xdf00
 8006f92:	43d2      	mvns	r2, r2
 8006f94:	615a      	str	r2, [r3, #20]
  i2c_lld_serve_error_interrupt(&I2CD2, sr);
 8006f96:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8006f9a:	4805      	ldr	r0, [pc, #20]	; (8006fb0 <VectorC8+0x40>)
 8006f9c:	4619      	mov	r1, r3
 8006f9e:	f7ff fee7 	bl	8006d70 <i2c_lld_serve_error_interrupt>

  OSAL_IRQ_EPILOGUE();
 8006fa2:	f004 ff7d 	bl	800bea0 <_dbg_check_leave_isr>
 8006fa6:	f001 fef3 	bl	8008d90 <_port_irq_epilogue>
}
 8006faa:	b003      	add	sp, #12
 8006fac:	f85d fb04 	ldr.w	pc, [sp], #4
 8006fb0:	200013ec 	.word	0x200013ec
	...

08006fc0 <Vector160>:
/**
 * @brief   I2C3 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C3_EVENT_HANDLER) {
 8006fc0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8006fc2:	f003 fa0d 	bl	800a3e0 <_stats_increase_irq>
 8006fc6:	f004 ff4b 	bl	800be60 <_dbg_check_enter_isr>

  i2c_lld_serve_event_interrupt(&I2CD3);
 8006fca:	4804      	ldr	r0, [pc, #16]	; (8006fdc <Vector160+0x1c>)
 8006fcc:	f7ff fd80 	bl	8006ad0 <i2c_lld_serve_event_interrupt>

  OSAL_IRQ_EPILOGUE();
 8006fd0:	f004 ff66 	bl	800bea0 <_dbg_check_leave_isr>
 8006fd4:	f001 fedc 	bl	8008d90 <_port_irq_epilogue>
}
 8006fd8:	bd08      	pop	{r3, pc}
 8006fda:	bf00      	nop
 8006fdc:	20001424 	.word	0x20001424

08006fe0 <Vector164>:
/**
 * @brief   I2C3 error interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C3_ERROR_HANDLER) {
 8006fe0:	b500      	push	{lr}
 8006fe2:	b083      	sub	sp, #12
  uint16_t sr = I2CD3.i2c->SR1;
 8006fe4:	4b0e      	ldr	r3, [pc, #56]	; (8007020 <Vector164+0x40>)
 8006fe6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006fe8:	695b      	ldr	r3, [r3, #20]
 8006fea:	f8ad 3006 	strh.w	r3, [sp, #6]

  OSAL_IRQ_PROLOGUE();
 8006fee:	f003 f9f7 	bl	800a3e0 <_stats_increase_irq>
 8006ff2:	f004 ff35 	bl	800be60 <_dbg_check_enter_isr>

  I2CD3.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 8006ff6:	4b0a      	ldr	r3, [pc, #40]	; (8007020 <Vector164+0x40>)
 8006ff8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006ffa:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 8006ffe:	f402 425f 	and.w	r2, r2, #57088	; 0xdf00
 8007002:	43d2      	mvns	r2, r2
 8007004:	615a      	str	r2, [r3, #20]
  i2c_lld_serve_error_interrupt(&I2CD3, sr);
 8007006:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800700a:	4805      	ldr	r0, [pc, #20]	; (8007020 <Vector164+0x40>)
 800700c:	4619      	mov	r1, r3
 800700e:	f7ff feaf 	bl	8006d70 <i2c_lld_serve_error_interrupt>

  OSAL_IRQ_EPILOGUE();
 8007012:	f004 ff45 	bl	800bea0 <_dbg_check_leave_isr>
 8007016:	f001 febb 	bl	8008d90 <_port_irq_epilogue>
}
 800701a:	b003      	add	sp, #12
 800701c:	f85d fb04 	ldr.w	pc, [sp], #4
 8007020:	20001424 	.word	0x20001424
	...

08007030 <i2c_lld_init>:
/**
 * @brief   Low level I2C driver initialization.
 *
 * @notapi
 */
void i2c_lld_init(void) {
 8007030:	b508      	push	{r3, lr}

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
 8007032:	4817      	ldr	r0, [pc, #92]	; (8007090 <i2c_lld_init+0x60>)
 8007034:	f000 fb74 	bl	8007720 <i2cObjectInit>
  I2CD1.thread = NULL;
 8007038:	4b15      	ldr	r3, [pc, #84]	; (8007090 <i2c_lld_init+0x60>)
 800703a:	2200      	movs	r2, #0
 800703c:	61da      	str	r2, [r3, #28]
  I2CD1.i2c    = I2C1;
 800703e:	4b14      	ldr	r3, [pc, #80]	; (8007090 <i2c_lld_init+0x60>)
 8007040:	4a14      	ldr	r2, [pc, #80]	; (8007094 <i2c_lld_init+0x64>)
 8007042:	635a      	str	r2, [r3, #52]	; 0x34
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 8007044:	4b12      	ldr	r3, [pc, #72]	; (8007090 <i2c_lld_init+0x60>)
 8007046:	4a14      	ldr	r2, [pc, #80]	; (8007098 <i2c_lld_init+0x68>)
 8007048:	62da      	str	r2, [r3, #44]	; 0x2c
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 800704a:	4b11      	ldr	r3, [pc, #68]	; (8007090 <i2c_lld_init+0x60>)
 800704c:	4a13      	ldr	r2, [pc, #76]	; (800709c <i2c_lld_init+0x6c>)
 800704e:	631a      	str	r2, [r3, #48]	; 0x30
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
 8007050:	4813      	ldr	r0, [pc, #76]	; (80070a0 <i2c_lld_init+0x70>)
 8007052:	f000 fb65 	bl	8007720 <i2cObjectInit>
  I2CD2.thread = NULL;
 8007056:	4b12      	ldr	r3, [pc, #72]	; (80070a0 <i2c_lld_init+0x70>)
 8007058:	2200      	movs	r2, #0
 800705a:	61da      	str	r2, [r3, #28]
  I2CD2.i2c    = I2C2;
 800705c:	4b10      	ldr	r3, [pc, #64]	; (80070a0 <i2c_lld_init+0x70>)
 800705e:	4a11      	ldr	r2, [pc, #68]	; (80070a4 <i2c_lld_init+0x74>)
 8007060:	635a      	str	r2, [r3, #52]	; 0x34
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
 8007062:	4b0f      	ldr	r3, [pc, #60]	; (80070a0 <i2c_lld_init+0x70>)
 8007064:	4a10      	ldr	r2, [pc, #64]	; (80070a8 <i2c_lld_init+0x78>)
 8007066:	62da      	str	r2, [r3, #44]	; 0x2c
  I2CD2.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C2_TX_DMA_STREAM);
 8007068:	4b0d      	ldr	r3, [pc, #52]	; (80070a0 <i2c_lld_init+0x70>)
 800706a:	4a10      	ldr	r2, [pc, #64]	; (80070ac <i2c_lld_init+0x7c>)
 800706c:	631a      	str	r2, [r3, #48]	; 0x30
#endif /* STM32_I2C_USE_I2C2 */

#if STM32_I2C_USE_I2C3
  i2cObjectInit(&I2CD3);
 800706e:	4810      	ldr	r0, [pc, #64]	; (80070b0 <i2c_lld_init+0x80>)
 8007070:	f000 fb56 	bl	8007720 <i2cObjectInit>
  I2CD3.thread = NULL;
 8007074:	4b0e      	ldr	r3, [pc, #56]	; (80070b0 <i2c_lld_init+0x80>)
 8007076:	2200      	movs	r2, #0
 8007078:	61da      	str	r2, [r3, #28]
  I2CD3.i2c    = I2C3;
 800707a:	4b0d      	ldr	r3, [pc, #52]	; (80070b0 <i2c_lld_init+0x80>)
 800707c:	4a0d      	ldr	r2, [pc, #52]	; (80070b4 <i2c_lld_init+0x84>)
 800707e:	635a      	str	r2, [r3, #52]	; 0x34
  I2CD3.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C3_RX_DMA_STREAM);
 8007080:	4b0b      	ldr	r3, [pc, #44]	; (80070b0 <i2c_lld_init+0x80>)
 8007082:	4a09      	ldr	r2, [pc, #36]	; (80070a8 <i2c_lld_init+0x78>)
 8007084:	62da      	str	r2, [r3, #44]	; 0x2c
  I2CD3.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C3_TX_DMA_STREAM);
 8007086:	4b0a      	ldr	r3, [pc, #40]	; (80070b0 <i2c_lld_init+0x80>)
 8007088:	4a0b      	ldr	r2, [pc, #44]	; (80070b8 <i2c_lld_init+0x88>)
 800708a:	631a      	str	r2, [r3, #48]	; 0x30
#endif /* STM32_I2C_USE_I2C3 */
}
 800708c:	bd08      	pop	{r3, pc}
 800708e:	bf00      	nop
 8007090:	200013b4 	.word	0x200013b4
 8007094:	40005400 	.word	0x40005400
 8007098:	0800e240 	.word	0x0800e240
 800709c:	0800e288 	.word	0x0800e288
 80070a0:	200013ec 	.word	0x200013ec
 80070a4:	40005800 	.word	0x40005800
 80070a8:	0800e258 	.word	0x0800e258
 80070ac:	0800e294 	.word	0x0800e294
 80070b0:	20001424 	.word	0x20001424
 80070b4:	40005c00 	.word	0x40005c00
 80070b8:	0800e270 	.word	0x0800e270
 80070bc:	00000000 	.word	0x00000000

080070c0 <i2c_lld_start>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
 80070c0:	b500      	push	{lr}
 80070c2:	b085      	sub	sp, #20
 80070c4:	9001      	str	r0, [sp, #4]
  I2C_TypeDef *dp = i2cp->i2c;
 80070c6:	9b01      	ldr	r3, [sp, #4]
 80070c8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80070ca:	9303      	str	r3, [sp, #12]

  i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 80070cc:	9b01      	ldr	r3, [sp, #4]
 80070ce:	f240 4256 	movw	r2, #1110	; 0x456
 80070d2:	629a      	str	r2, [r3, #40]	; 0x28
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_M2P;
  i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 80070d4:	9b01      	ldr	r3, [sp, #4]
 80070d6:	f240 4216 	movw	r2, #1046	; 0x416
 80070da:	625a      	str	r2, [r3, #36]	; 0x24
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 80070dc:	9b01      	ldr	r3, [sp, #4]
 80070de:	781b      	ldrb	r3, [r3, #0]
 80070e0:	2b01      	cmp	r3, #1
 80070e2:	f040 80ed 	bne.w	80072c0 <i2c_lld_start+0x200>

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
 80070e6:	9b01      	ldr	r3, [sp, #4]
 80070e8:	4a88      	ldr	r2, [pc, #544]	; (800730c <i2c_lld_start+0x24c>)
 80070ea:	4293      	cmp	r3, r2
 80070ec:	d14a      	bne.n	8007184 <i2c_lld_start+0xc4>
      bool b;

      rccResetI2C1();
 80070ee:	4a88      	ldr	r2, [pc, #544]	; (8007310 <i2c_lld_start+0x250>)
 80070f0:	4b87      	ldr	r3, [pc, #540]	; (8007310 <i2c_lld_start+0x250>)
 80070f2:	6a1b      	ldr	r3, [r3, #32]
 80070f4:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80070f8:	6213      	str	r3, [r2, #32]
 80070fa:	4b85      	ldr	r3, [pc, #532]	; (8007310 <i2c_lld_start+0x250>)
 80070fc:	2200      	movs	r2, #0
 80070fe:	621a      	str	r2, [r3, #32]
      b = dmaStreamAllocate(i2cp->dmarx,
 8007100:	9b01      	ldr	r3, [sp, #4]
 8007102:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007104:	4618      	mov	r0, r3
 8007106:	2105      	movs	r1, #5
 8007108:	4a82      	ldr	r2, [pc, #520]	; (8007314 <i2c_lld_start+0x254>)
 800710a:	9b01      	ldr	r3, [sp, #4]
 800710c:	f001 f960 	bl	80083d0 <dmaStreamAllocate>
 8007110:	4603      	mov	r3, r0
 8007112:	f88d 300b 	strb.w	r3, [sp, #11]
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
 8007116:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800711a:	2b00      	cmp	r3, #0
 800711c:	d002      	beq.n	8007124 <i2c_lld_start+0x64>
 800711e:	487e      	ldr	r0, [pc, #504]	; (8007318 <i2c_lld_start+0x258>)
 8007120:	f004 fce6 	bl	800baf0 <chSysHalt>
      b = dmaStreamAllocate(i2cp->dmatx,
 8007124:	9b01      	ldr	r3, [sp, #4]
 8007126:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007128:	4618      	mov	r0, r3
 800712a:	2105      	movs	r1, #5
 800712c:	4a7b      	ldr	r2, [pc, #492]	; (800731c <i2c_lld_start+0x25c>)
 800712e:	9b01      	ldr	r3, [sp, #4]
 8007130:	f001 f94e 	bl	80083d0 <dmaStreamAllocate>
 8007134:	4603      	mov	r3, r0
 8007136:	f88d 300b 	strb.w	r3, [sp, #11]
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
 800713a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 800713e:	2b00      	cmp	r3, #0
 8007140:	d002      	beq.n	8007148 <i2c_lld_start+0x88>
 8007142:	4875      	ldr	r0, [pc, #468]	; (8007318 <i2c_lld_start+0x258>)
 8007144:	f004 fcd4 	bl	800baf0 <chSysHalt>
      rccEnableI2C1(FALSE);
 8007148:	4a71      	ldr	r2, [pc, #452]	; (8007310 <i2c_lld_start+0x250>)
 800714a:	4b71      	ldr	r3, [pc, #452]	; (8007310 <i2c_lld_start+0x250>)
 800714c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800714e:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8007152:	6413      	str	r3, [r2, #64]	; 0x40
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
 8007154:	201f      	movs	r0, #31
 8007156:	2105      	movs	r1, #5
 8007158:	f000 fd82 	bl	8007c60 <nvicEnableVector>
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
 800715c:	2020      	movs	r0, #32
 800715e:	2105      	movs	r1, #5
 8007160:	f000 fd7e 	bl	8007c60 <nvicEnableVector>

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 8007164:	9b01      	ldr	r3, [sp, #4]
 8007166:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007168:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800716c:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
 8007170:	9a01      	ldr	r2, [sp, #4]
 8007172:	6253      	str	r3, [r2, #36]	; 0x24
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 8007174:	9b01      	ldr	r3, [sp, #4]
 8007176:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8007178:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800717c:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
 8007180:	9a01      	ldr	r2, [sp, #4]
 8007182:	6293      	str	r3, [r2, #40]	; 0x28
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
    }
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
    if (&I2CD2 == i2cp) {
 8007184:	9b01      	ldr	r3, [sp, #4]
 8007186:	4a66      	ldr	r2, [pc, #408]	; (8007320 <i2c_lld_start+0x260>)
 8007188:	4293      	cmp	r3, r2
 800718a:	d14a      	bne.n	8007222 <i2c_lld_start+0x162>
      bool b;

      rccResetI2C2();
 800718c:	4a60      	ldr	r2, [pc, #384]	; (8007310 <i2c_lld_start+0x250>)
 800718e:	4b60      	ldr	r3, [pc, #384]	; (8007310 <i2c_lld_start+0x250>)
 8007190:	6a1b      	ldr	r3, [r3, #32]
 8007192:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8007196:	6213      	str	r3, [r2, #32]
 8007198:	4b5d      	ldr	r3, [pc, #372]	; (8007310 <i2c_lld_start+0x250>)
 800719a:	2200      	movs	r2, #0
 800719c:	621a      	str	r2, [r3, #32]
      b = dmaStreamAllocate(i2cp->dmarx,
 800719e:	9b01      	ldr	r3, [sp, #4]
 80071a0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80071a2:	4618      	mov	r0, r3
 80071a4:	2105      	movs	r1, #5
 80071a6:	4a5b      	ldr	r2, [pc, #364]	; (8007314 <i2c_lld_start+0x254>)
 80071a8:	9b01      	ldr	r3, [sp, #4]
 80071aa:	f001 f911 	bl	80083d0 <dmaStreamAllocate>
 80071ae:	4603      	mov	r3, r0
 80071b0:	f88d 300a 	strb.w	r3, [sp, #10]
                            STM32_I2C_I2C2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
 80071b4:	f89d 300a 	ldrb.w	r3, [sp, #10]
 80071b8:	2b00      	cmp	r3, #0
 80071ba:	d002      	beq.n	80071c2 <i2c_lld_start+0x102>
 80071bc:	4856      	ldr	r0, [pc, #344]	; (8007318 <i2c_lld_start+0x258>)
 80071be:	f004 fc97 	bl	800baf0 <chSysHalt>
      b = dmaStreamAllocate(i2cp->dmatx,
 80071c2:	9b01      	ldr	r3, [sp, #4]
 80071c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80071c6:	4618      	mov	r0, r3
 80071c8:	2105      	movs	r1, #5
 80071ca:	4a54      	ldr	r2, [pc, #336]	; (800731c <i2c_lld_start+0x25c>)
 80071cc:	9b01      	ldr	r3, [sp, #4]
 80071ce:	f001 f8ff 	bl	80083d0 <dmaStreamAllocate>
 80071d2:	4603      	mov	r3, r0
 80071d4:	f88d 300a 	strb.w	r3, [sp, #10]
                            STM32_I2C_I2C2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
 80071d8:	f89d 300a 	ldrb.w	r3, [sp, #10]
 80071dc:	2b00      	cmp	r3, #0
 80071de:	d002      	beq.n	80071e6 <i2c_lld_start+0x126>
 80071e0:	484d      	ldr	r0, [pc, #308]	; (8007318 <i2c_lld_start+0x258>)
 80071e2:	f004 fc85 	bl	800baf0 <chSysHalt>
      rccEnableI2C2(FALSE);
 80071e6:	4a4a      	ldr	r2, [pc, #296]	; (8007310 <i2c_lld_start+0x250>)
 80071e8:	4b49      	ldr	r3, [pc, #292]	; (8007310 <i2c_lld_start+0x250>)
 80071ea:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80071ec:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80071f0:	6413      	str	r3, [r2, #64]	; 0x40
      nvicEnableVector(I2C2_EV_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);
 80071f2:	2021      	movs	r0, #33	; 0x21
 80071f4:	2105      	movs	r1, #5
 80071f6:	f000 fd33 	bl	8007c60 <nvicEnableVector>
      nvicEnableVector(I2C2_ER_IRQn, STM32_I2C_I2C2_IRQ_PRIORITY);
 80071fa:	2022      	movs	r0, #34	; 0x22
 80071fc:	2105      	movs	r1, #5
 80071fe:	f000 fd2f 	bl	8007c60 <nvicEnableVector>

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C2_RX_DMA_CHANNEL) |
 8007202:	9b01      	ldr	r3, [sp, #4]
 8007204:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007206:	f043 6360 	orr.w	r3, r3, #234881024	; 0xe000000
 800720a:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
 800720e:	9a01      	ldr	r2, [sp, #4]
 8007210:	6253      	str	r3, [r2, #36]	; 0x24
                       STM32_DMA_CR_PL(STM32_I2C_I2C2_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C2_TX_DMA_CHANNEL) |
 8007212:	9b01      	ldr	r3, [sp, #4]
 8007214:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8007216:	f043 6360 	orr.w	r3, r3, #234881024	; 0xe000000
 800721a:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
 800721e:	9a01      	ldr	r2, [sp, #4]
 8007220:	6293      	str	r3, [r2, #40]	; 0x28
                       STM32_DMA_CR_PL(STM32_I2C_I2C2_DMA_PRIORITY);
    }
#endif /* STM32_I2C_USE_I2C2 */

#if STM32_I2C_USE_I2C3
    if (&I2CD3 == i2cp) {
 8007222:	9b01      	ldr	r3, [sp, #4]
 8007224:	4a3f      	ldr	r2, [pc, #252]	; (8007324 <i2c_lld_start+0x264>)
 8007226:	4293      	cmp	r3, r2
 8007228:	d14a      	bne.n	80072c0 <i2c_lld_start+0x200>
      bool b;

      rccResetI2C3();
 800722a:	4a39      	ldr	r2, [pc, #228]	; (8007310 <i2c_lld_start+0x250>)
 800722c:	4b38      	ldr	r3, [pc, #224]	; (8007310 <i2c_lld_start+0x250>)
 800722e:	6a1b      	ldr	r3, [r3, #32]
 8007230:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8007234:	6213      	str	r3, [r2, #32]
 8007236:	4b36      	ldr	r3, [pc, #216]	; (8007310 <i2c_lld_start+0x250>)
 8007238:	2200      	movs	r2, #0
 800723a:	621a      	str	r2, [r3, #32]
      b = dmaStreamAllocate(i2cp->dmarx,
 800723c:	9b01      	ldr	r3, [sp, #4]
 800723e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007240:	4618      	mov	r0, r3
 8007242:	2105      	movs	r1, #5
 8007244:	4a33      	ldr	r2, [pc, #204]	; (8007314 <i2c_lld_start+0x254>)
 8007246:	9b01      	ldr	r3, [sp, #4]
 8007248:	f001 f8c2 	bl	80083d0 <dmaStreamAllocate>
 800724c:	4603      	mov	r3, r0
 800724e:	f88d 3009 	strb.w	r3, [sp, #9]
                            STM32_I2C_I2C3_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
 8007252:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8007256:	2b00      	cmp	r3, #0
 8007258:	d002      	beq.n	8007260 <i2c_lld_start+0x1a0>
 800725a:	482f      	ldr	r0, [pc, #188]	; (8007318 <i2c_lld_start+0x258>)
 800725c:	f004 fc48 	bl	800baf0 <chSysHalt>
      b = dmaStreamAllocate(i2cp->dmatx,
 8007260:	9b01      	ldr	r3, [sp, #4]
 8007262:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007264:	4618      	mov	r0, r3
 8007266:	2105      	movs	r1, #5
 8007268:	4a2c      	ldr	r2, [pc, #176]	; (800731c <i2c_lld_start+0x25c>)
 800726a:	9b01      	ldr	r3, [sp, #4]
 800726c:	f001 f8b0 	bl	80083d0 <dmaStreamAllocate>
 8007270:	4603      	mov	r3, r0
 8007272:	f88d 3009 	strb.w	r3, [sp, #9]
                            STM32_I2C_I2C3_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
 8007276:	f89d 3009 	ldrb.w	r3, [sp, #9]
 800727a:	2b00      	cmp	r3, #0
 800727c:	d002      	beq.n	8007284 <i2c_lld_start+0x1c4>
 800727e:	4826      	ldr	r0, [pc, #152]	; (8007318 <i2c_lld_start+0x258>)
 8007280:	f004 fc36 	bl	800baf0 <chSysHalt>
      rccEnableI2C3(FALSE);
 8007284:	4a22      	ldr	r2, [pc, #136]	; (8007310 <i2c_lld_start+0x250>)
 8007286:	4b22      	ldr	r3, [pc, #136]	; (8007310 <i2c_lld_start+0x250>)
 8007288:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800728a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800728e:	6413      	str	r3, [r2, #64]	; 0x40
      nvicEnableVector(I2C3_EV_IRQn, STM32_I2C_I2C3_IRQ_PRIORITY);
 8007290:	2048      	movs	r0, #72	; 0x48
 8007292:	2105      	movs	r1, #5
 8007294:	f000 fce4 	bl	8007c60 <nvicEnableVector>
      nvicEnableVector(I2C3_ER_IRQn, STM32_I2C_I2C3_IRQ_PRIORITY);
 8007298:	2049      	movs	r0, #73	; 0x49
 800729a:	2105      	movs	r1, #5
 800729c:	f000 fce0 	bl	8007c60 <nvicEnableVector>

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C3_RX_DMA_CHANNEL) |
 80072a0:	9b01      	ldr	r3, [sp, #4]
 80072a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80072a4:	f043 63c0 	orr.w	r3, r3, #100663296	; 0x6000000
 80072a8:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
 80072ac:	9a01      	ldr	r2, [sp, #4]
 80072ae:	6253      	str	r3, [r2, #36]	; 0x24
                       STM32_DMA_CR_PL(STM32_I2C_I2C3_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C3_TX_DMA_CHANNEL) |
 80072b0:	9b01      	ldr	r3, [sp, #4]
 80072b2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80072b4:	f043 63c0 	orr.w	r3, r3, #100663296	; 0x6000000
 80072b8:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
 80072bc:	9a01      	ldr	r2, [sp, #4]
 80072be:	6293      	str	r3, [r2, #40]	; 0x28
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 80072c0:	9b01      	ldr	r3, [sp, #4]
 80072c2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80072c4:	681b      	ldr	r3, [r3, #0]
 80072c6:	9a03      	ldr	r2, [sp, #12]
 80072c8:	3210      	adds	r2, #16
 80072ca:	609a      	str	r2, [r3, #8]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 80072cc:	9b01      	ldr	r3, [sp, #4]
 80072ce:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80072d0:	681b      	ldr	r3, [r3, #0]
 80072d2:	9a03      	ldr	r2, [sp, #12]
 80072d4:	3210      	adds	r2, #16
 80072d6:	609a      	str	r2, [r3, #8]

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 80072d8:	9b03      	ldr	r3, [sp, #12]
 80072da:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80072de:	601a      	str	r2, [r3, #0]
  dp->CR1 = 0;
 80072e0:	9b03      	ldr	r3, [sp, #12]
 80072e2:	2200      	movs	r2, #0
 80072e4:	601a      	str	r2, [r3, #0]
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 80072e6:	9b03      	ldr	r3, [sp, #12]
 80072e8:	f44f 6210 	mov.w	r2, #2304	; 0x900
 80072ec:	605a      	str	r2, [r3, #4]

  /* Setup I2C parameters.*/
  i2c_lld_set_clock(i2cp);
 80072ee:	9801      	ldr	r0, [sp, #4]
 80072f0:	f7ff face 	bl	8006890 <i2c_lld_set_clock>
  i2c_lld_set_opmode(i2cp);
 80072f4:	9801      	ldr	r0, [sp, #4]
 80072f6:	f7ff fbb3 	bl	8006a60 <i2c_lld_set_opmode>

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 80072fa:	9b03      	ldr	r3, [sp, #12]
 80072fc:	681b      	ldr	r3, [r3, #0]
 80072fe:	f043 0201 	orr.w	r2, r3, #1
 8007302:	9b03      	ldr	r3, [sp, #12]
 8007304:	601a      	str	r2, [r3, #0]
}
 8007306:	b005      	add	sp, #20
 8007308:	f85d fb04 	ldr.w	pc, [sp], #4
 800730c:	200013b4 	.word	0x200013b4
 8007310:	40023800 	.word	0x40023800
 8007314:	08006c61 	.word	0x08006c61
 8007318:	0800e340 	.word	0x0800e340
 800731c:	08006d01 	.word	0x08006d01
 8007320:	200013ec 	.word	0x200013ec
 8007324:	20001424 	.word	0x20001424
	...

08007330 <i2c_lld_master_transmit_timeout>:
 * @notapi
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
 8007330:	b500      	push	{lr}
 8007332:	b089      	sub	sp, #36	; 0x24
 8007334:	9003      	str	r0, [sp, #12]
 8007336:	9201      	str	r2, [sp, #4]
 8007338:	9300      	str	r3, [sp, #0]
 800733a:	460b      	mov	r3, r1
 800733c:	f8ad 300a 	strh.w	r3, [sp, #10]
  I2C_TypeDef *dp = i2cp->i2c;
 8007340:	9b03      	ldr	r3, [sp, #12]
 8007342:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007344:	9307      	str	r3, [sp, #28]
#if defined(STM32F1XX_I2C)
  osalDbgCheck((rxbytes == 0) || ((rxbytes > 1) && (rxbuf != NULL)));
#endif

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;
 8007346:	9b03      	ldr	r3, [sp, #12]
 8007348:	2200      	movs	r2, #0
 800734a:	609a      	str	r2, [r3, #8]

  /* Initializes driver fields, LSB = 0 -> transmit.*/
  i2cp->addr = (addr << 1);
 800734c:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 8007350:	005b      	lsls	r3, r3, #1
 8007352:	b29a      	uxth	r2, r3
 8007354:	9b03      	ldr	r3, [sp, #12]
 8007356:	841a      	strh	r2, [r3, #32]

  /* Releases the lock from high level driver.*/
  osalSysUnlock();
 8007358:	f7ff fa4a 	bl	80067f0 <osalSysUnlock>

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 800735c:	9b03      	ldr	r3, [sp, #12]
 800735e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007360:	681b      	ldr	r3, [r3, #0]
 8007362:	9a03      	ldr	r2, [sp, #12]
 8007364:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8007366:	601a      	str	r2, [r3, #0]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
 8007368:	9b03      	ldr	r3, [sp, #12]
 800736a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800736c:	681b      	ldr	r3, [r3, #0]
 800736e:	9a01      	ldr	r2, [sp, #4]
 8007370:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 8007372:	9b03      	ldr	r3, [sp, #12]
 8007374:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007376:	681b      	ldr	r3, [r3, #0]
 8007378:	9a00      	ldr	r2, [sp, #0]
 800737a:	605a      	str	r2, [r3, #4]

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 800737c:	9b03      	ldr	r3, [sp, #12]
 800737e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007380:	681b      	ldr	r3, [r3, #0]
 8007382:	9a03      	ldr	r2, [sp, #12]
 8007384:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8007386:	601a      	str	r2, [r3, #0]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 8007388:	9b03      	ldr	r3, [sp, #12]
 800738a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800738c:	681b      	ldr	r3, [r3, #0]
 800738e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8007390:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 8007392:	9b03      	ldr	r3, [sp, #12]
 8007394:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007396:	681b      	ldr	r3, [r3, #0]
 8007398:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800739a:	605a      	str	r2, [r3, #4]

  /* Calculating the time window for the timeout on the busy bus condition.*/
  start = osalOsGetSystemTimeX();
 800739c:	f7ff fa40 	bl	8006820 <osalOsGetSystemTimeX>
 80073a0:	9006      	str	r0, [sp, #24]
  end = start + OSAL_MS2ST(STM32_I2C_BUSY_TIMEOUT);
 80073a2:	9b06      	ldr	r3, [sp, #24]
 80073a4:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 80073a8:	9305      	str	r3, [sp, #20]

  /* Waits until BUSY flag is reset or, alternatively, for a timeout
     condition.*/
  while (true) {
    osalSysLock();
 80073aa:	f7ff fa19 	bl	80067e0 <osalSysLock>

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
 80073ae:	9b07      	ldr	r3, [sp, #28]
 80073b0:	699b      	ldr	r3, [r3, #24]
 80073b2:	f003 0302 	and.w	r3, r3, #2
 80073b6:	2b00      	cmp	r3, #0
 80073b8:	d105      	bne.n	80073c6 <i2c_lld_master_transmit_timeout+0x96>
 80073ba:	9b07      	ldr	r3, [sp, #28]
 80073bc:	681b      	ldr	r3, [r3, #0]
 80073be:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80073c2:	2b00      	cmp	r3, #0
 80073c4:	d013      	beq.n	80073ee <i2c_lld_master_transmit_timeout+0xbe>
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end))
 80073c6:	f7ff fa2b 	bl	8006820 <osalOsGetSystemTimeX>
 80073ca:	4603      	mov	r3, r0
 80073cc:	4618      	mov	r0, r3
 80073ce:	9906      	ldr	r1, [sp, #24]
 80073d0:	9a05      	ldr	r2, [sp, #20]
 80073d2:	f7ff fa2d 	bl	8006830 <osalOsIsTimeWithinX>
 80073d6:	4603      	mov	r3, r0
 80073d8:	f083 0301 	eor.w	r3, r3, #1
 80073dc:	b2db      	uxtb	r3, r3
 80073de:	2b00      	cmp	r3, #0
 80073e0:	d002      	beq.n	80073e8 <i2c_lld_master_transmit_timeout+0xb8>
      return MSG_TIMEOUT;
 80073e2:	f04f 33ff 	mov.w	r3, #4294967295
 80073e6:	e015      	b.n	8007414 <i2c_lld_master_transmit_timeout+0xe4>

    osalSysUnlock();
 80073e8:	f7ff fa02 	bl	80067f0 <osalSysUnlock>
 80073ec:	e7dd      	b.n	80073aa <i2c_lld_master_transmit_timeout+0x7a>
  }

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 80073ee:	9b07      	ldr	r3, [sp, #28]
 80073f0:	685b      	ldr	r3, [r3, #4]
 80073f2:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 80073f6:	9b07      	ldr	r3, [sp, #28]
 80073f8:	605a      	str	r2, [r3, #4]
  dp->CR1 |= I2C_CR1_START;
 80073fa:	9b07      	ldr	r3, [sp, #28]
 80073fc:	681b      	ldr	r3, [r3, #0]
 80073fe:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 8007402:	9b07      	ldr	r3, [sp, #28]
 8007404:	601a      	str	r2, [r3, #0]

  /* Waits for the operation completion or a timeout.*/
  return osalThreadSuspendTimeoutS(&i2cp->thread, timeout);
 8007406:	9b03      	ldr	r3, [sp, #12]
 8007408:	331c      	adds	r3, #28
 800740a:	4618      	mov	r0, r3
 800740c:	990c      	ldr	r1, [sp, #48]	; 0x30
 800740e:	f7ff fa1f 	bl	8006850 <osalThreadSuspendTimeoutS>
 8007412:	4603      	mov	r3, r0
}
 8007414:	4618      	mov	r0, r3
 8007416:	b009      	add	sp, #36	; 0x24
 8007418:	f85d fb04 	ldr.w	pc, [sp], #4
 800741c:	0000      	movs	r0, r0
	...

08007420 <port_lock.lto_priv.263>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8007420:	b082      	sub	sp, #8
 8007422:	2320      	movs	r3, #32
 8007424:	9301      	str	r3, [sp, #4]
 8007426:	9b01      	ldr	r3, [sp, #4]
 8007428:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800742c:	b002      	add	sp, #8
 800742e:	4770      	bx	lr

08007430 <port_unlock.lto_priv.261>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8007430:	b082      	sub	sp, #8
 8007432:	2300      	movs	r3, #0
 8007434:	9301      	str	r3, [sp, #4]
 8007436:	9b01      	ldr	r3, [sp, #4]
 8007438:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800743c:	b002      	add	sp, #8
 800743e:	4770      	bx	lr

08007440 <port_lock_from_isr.lto_priv.259>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8007440:	b508      	push	{r3, lr}

  port_lock();
 8007442:	f7ff ffed 	bl	8007420 <port_lock.lto_priv.263>
}
 8007446:	bd08      	pop	{r3, pc}
	...

08007450 <port_unlock_from_isr.lto_priv.256>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8007450:	b508      	push	{r3, lr}

  port_unlock();
 8007452:	f7ff ffed 	bl	8007430 <port_unlock.lto_priv.261>
}
 8007456:	bd08      	pop	{r3, pc}
	...

08007460 <chSysLockFromISR.lto_priv.253>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8007460:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8007462:	f7ff ffed 	bl	8007440 <port_lock_from_isr.lto_priv.259>
  _stats_start_measure_crit_isr();
 8007466:	f002 fffb 	bl	800a460 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 800746a:	f004 fcc9 	bl	800be00 <_dbg_check_lock_from_isr>
}
 800746e:	bd08      	pop	{r3, pc}

08007470 <chSysUnlockFromISR.lto_priv.250>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8007470:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 8007472:	f004 fcdd 	bl	800be30 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 8007476:	f002 fffb 	bl	800a470 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 800747a:	f7ff ffe9 	bl	8007450 <port_unlock_from_isr.lto_priv.256>
}
 800747e:	bd08      	pop	{r3, pc}

08007480 <chOQIsEmptyI.lto_priv.245>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 8007480:	b500      	push	{lr}
 8007482:	b083      	sub	sp, #12
 8007484:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8007486:	f004 fd2b 	bl	800bee0 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 800748a:	9b01      	ldr	r3, [sp, #4]
 800748c:	695a      	ldr	r2, [r3, #20]
 800748e:	9b01      	ldr	r3, [sp, #4]
 8007490:	699b      	ldr	r3, [r3, #24]
 8007492:	429a      	cmp	r2, r3
 8007494:	d105      	bne.n	80074a2 <chOQIsEmptyI.lto_priv.245+0x22>
 8007496:	9b01      	ldr	r3, [sp, #4]
 8007498:	689b      	ldr	r3, [r3, #8]
 800749a:	2b00      	cmp	r3, #0
 800749c:	d001      	beq.n	80074a2 <chOQIsEmptyI.lto_priv.245+0x22>
 800749e:	2301      	movs	r3, #1
 80074a0:	e000      	b.n	80074a4 <chOQIsEmptyI.lto_priv.245+0x24>
 80074a2:	2300      	movs	r3, #0
 80074a4:	f003 0301 	and.w	r3, r3, #1
 80074a8:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 80074aa:	4618      	mov	r0, r3
 80074ac:	b003      	add	sp, #12
 80074ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80074b2:	bf00      	nop
	...

080074c0 <osalSysLockFromISR.lto_priv.246>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 80074c0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 80074c2:	f7ff ffcd 	bl	8007460 <chSysLockFromISR.lto_priv.253>
}
 80074c6:	bd08      	pop	{r3, pc}
	...

080074d0 <osalSysUnlockFromISR.lto_priv.243>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 80074d0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 80074d2:	f7ff ffcd 	bl	8007470 <chSysUnlockFromISR.lto_priv.250>
}
 80074d6:	bd08      	pop	{r3, pc}
	...

080074e0 <osalEventBroadcastFlagsI.lto_priv.244>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 80074e0:	b500      	push	{lr}
 80074e2:	b083      	sub	sp, #12
 80074e4:	9001      	str	r0, [sp, #4]
 80074e6:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 80074e8:	9801      	ldr	r0, [sp, #4]
 80074ea:	9900      	ldr	r1, [sp, #0]
 80074ec:	f001 ff30 	bl	8009350 <chEvtBroadcastFlagsI>
}
 80074f0:	b003      	add	sp, #12
 80074f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80074f6:	bf00      	nop
	...

08007500 <usart_init.lto_priv.242>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 8007500:	b084      	sub	sp, #16
 8007502:	9001      	str	r0, [sp, #4]
 8007504:	9100      	str	r1, [sp, #0]
  USART_TypeDef *u = sdp->usart;
 8007506:	9b01      	ldr	r3, [sp, #4]
 8007508:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800750a:	9303      	str	r3, [sp, #12]

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 800750c:	9b01      	ldr	r3, [sp, #4]
 800750e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8007510:	4a1c      	ldr	r2, [pc, #112]	; (8007584 <usart_init.lto_priv.242+0x84>)
 8007512:	4293      	cmp	r3, r2
 8007514:	d004      	beq.n	8007520 <usart_init.lto_priv.242+0x20>
 8007516:	9b01      	ldr	r3, [sp, #4]
 8007518:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800751a:	4a1b      	ldr	r2, [pc, #108]	; (8007588 <usart_init.lto_priv.242+0x88>)
 800751c:	4293      	cmp	r3, r2
 800751e:	d107      	bne.n	8007530 <usart_init.lto_priv.242+0x30>
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8007520:	9b00      	ldr	r3, [sp, #0]
 8007522:	681b      	ldr	r3, [r3, #0]
 8007524:	4a19      	ldr	r2, [pc, #100]	; (800758c <usart_init.lto_priv.242+0x8c>)
 8007526:	fbb2 f2f3 	udiv	r2, r2, r3
 800752a:	9b03      	ldr	r3, [sp, #12]
 800752c:	609a      	str	r2, [r3, #8]
 800752e:	e006      	b.n	800753e <usart_init.lto_priv.242+0x3e>
  else
    u->BRR = STM32_PCLK1 / config->speed;
 8007530:	9b00      	ldr	r3, [sp, #0]
 8007532:	681b      	ldr	r3, [r3, #0]
 8007534:	4a16      	ldr	r2, [pc, #88]	; (8007590 <usart_init.lto_priv.242+0x90>)
 8007536:	fbb2 f2f3 	udiv	r2, r2, r3
 800753a:	9b03      	ldr	r3, [sp, #12]
 800753c:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800753e:	9b00      	ldr	r3, [sp, #0]
 8007540:	88db      	ldrh	r3, [r3, #6]
 8007542:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8007546:	b29b      	uxth	r3, r3
 8007548:	461a      	mov	r2, r3
 800754a:	9b03      	ldr	r3, [sp, #12]
 800754c:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800754e:	9b00      	ldr	r3, [sp, #0]
 8007550:	891b      	ldrh	r3, [r3, #8]
 8007552:	f043 0301 	orr.w	r3, r3, #1
 8007556:	b29b      	uxth	r3, r3
 8007558:	461a      	mov	r2, r3
 800755a:	9b03      	ldr	r3, [sp, #12]
 800755c:	615a      	str	r2, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800755e:	9b00      	ldr	r3, [sp, #0]
 8007560:	889b      	ldrh	r3, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8007562:	f443 5304 	orr.w	r3, r3, #8448	; 0x2100
 8007566:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
 800756a:	b29b      	uxth	r3, r3
 800756c:	461a      	mov	r2, r3
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800756e:	9b03      	ldr	r3, [sp, #12]
 8007570:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8007572:	9b03      	ldr	r3, [sp, #12]
 8007574:	2200      	movs	r2, #0
 8007576:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8007578:	9b03      	ldr	r3, [sp, #12]
 800757a:	681b      	ldr	r3, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 800757c:	9b03      	ldr	r3, [sp, #12]
 800757e:	685b      	ldr	r3, [r3, #4]
}
 8007580:	b004      	add	sp, #16
 8007582:	4770      	bx	lr
 8007584:	40011000 	.word	0x40011000
 8007588:	40011400 	.word	0x40011400
 800758c:	0501bd00 	.word	0x0501bd00
 8007590:	0280de80 	.word	0x0280de80
	...

080075a0 <set_error.lto_priv.247>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
 80075a0:	b500      	push	{lr}
 80075a2:	b085      	sub	sp, #20
 80075a4:	9001      	str	r0, [sp, #4]
 80075a6:	460b      	mov	r3, r1
 80075a8:	f8ad 3002 	strh.w	r3, [sp, #2]
  eventflags_t sts = 0;
 80075ac:	2300      	movs	r3, #0
 80075ae:	9303      	str	r3, [sp, #12]

  if (sr & USART_SR_ORE)
 80075b0:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 80075b4:	f003 0308 	and.w	r3, r3, #8
 80075b8:	2b00      	cmp	r3, #0
 80075ba:	d003      	beq.n	80075c4 <set_error.lto_priv.247+0x24>
    sts |= SD_OVERRUN_ERROR;
 80075bc:	9b03      	ldr	r3, [sp, #12]
 80075be:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80075c2:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_PE)
 80075c4:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 80075c8:	f003 0301 	and.w	r3, r3, #1
 80075cc:	2b00      	cmp	r3, #0
 80075ce:	d003      	beq.n	80075d8 <set_error.lto_priv.247+0x38>
    sts |= SD_PARITY_ERROR;
 80075d0:	9b03      	ldr	r3, [sp, #12]
 80075d2:	f043 0320 	orr.w	r3, r3, #32
 80075d6:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_FE)
 80075d8:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 80075dc:	f003 0302 	and.w	r3, r3, #2
 80075e0:	2b00      	cmp	r3, #0
 80075e2:	d003      	beq.n	80075ec <set_error.lto_priv.247+0x4c>
    sts |= SD_FRAMING_ERROR;
 80075e4:	9b03      	ldr	r3, [sp, #12]
 80075e6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80075ea:	9303      	str	r3, [sp, #12]
  if (sr & USART_SR_NE)
 80075ec:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 80075f0:	f003 0304 	and.w	r3, r3, #4
 80075f4:	2b00      	cmp	r3, #0
 80075f6:	d003      	beq.n	8007600 <set_error.lto_priv.247+0x60>
    sts |= SD_NOISE_ERROR;
 80075f8:	9b03      	ldr	r3, [sp, #12]
 80075fa:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80075fe:	9303      	str	r3, [sp, #12]
  chnAddFlagsI(sdp, sts);
 8007600:	9b01      	ldr	r3, [sp, #4]
 8007602:	3304      	adds	r3, #4
 8007604:	4618      	mov	r0, r3
 8007606:	9903      	ldr	r1, [sp, #12]
 8007608:	f7ff ff6a 	bl	80074e0 <osalEventBroadcastFlagsI.lto_priv.244>
}
 800760c:	b005      	add	sp, #20
 800760e:	f85d fb04 	ldr.w	pc, [sp], #4
 8007612:	bf00      	nop
	...

08007620 <port_lock.lto_priv.273>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8007620:	b082      	sub	sp, #8
 8007622:	2320      	movs	r3, #32
 8007624:	9301      	str	r3, [sp, #4]
 8007626:	9b01      	ldr	r3, [sp, #4]
 8007628:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800762c:	b002      	add	sp, #8
 800762e:	4770      	bx	lr

08007630 <port_unlock.lto_priv.270>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8007630:	b082      	sub	sp, #8
 8007632:	2300      	movs	r3, #0
 8007634:	9301      	str	r3, [sp, #4]
 8007636:	9b01      	ldr	r3, [sp, #4]
 8007638:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800763c:	b002      	add	sp, #8
 800763e:	4770      	bx	lr

08007640 <chSysLock.lto_priv.293>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8007640:	b508      	push	{r3, lr}

  port_lock();
 8007642:	f7ff ffed 	bl	8007620 <port_lock.lto_priv.273>
  _stats_start_measure_crit_thd();
 8007646:	f002 fefb 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800764a:	f004 fba9 	bl	800bda0 <_dbg_check_lock>
}
 800764e:	bd08      	pop	{r3, pc}

08007650 <chSysUnlock.lto_priv.291>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8007650:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8007652:	f004 fbbd 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8007656:	f002 fefb 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800765a:	4b09      	ldr	r3, [pc, #36]	; (8007680 <chSysUnlock.lto_priv.291+0x30>)
 800765c:	681b      	ldr	r3, [r3, #0]
 800765e:	4a08      	ldr	r2, [pc, #32]	; (8007680 <chSysUnlock.lto_priv.291+0x30>)
 8007660:	4293      	cmp	r3, r2
 8007662:	d00a      	beq.n	800767a <chSysUnlock.lto_priv.291+0x2a>
 8007664:	4b06      	ldr	r3, [pc, #24]	; (8007680 <chSysUnlock.lto_priv.291+0x30>)
 8007666:	699b      	ldr	r3, [r3, #24]
 8007668:	689a      	ldr	r2, [r3, #8]
 800766a:	4b05      	ldr	r3, [pc, #20]	; (8007680 <chSysUnlock.lto_priv.291+0x30>)
 800766c:	681b      	ldr	r3, [r3, #0]
 800766e:	689b      	ldr	r3, [r3, #8]
 8007670:	429a      	cmp	r2, r3
 8007672:	d202      	bcs.n	800767a <chSysUnlock.lto_priv.291+0x2a>
 8007674:	4803      	ldr	r0, [pc, #12]	; (8007684 <chSysUnlock.lto_priv.291+0x34>)
 8007676:	f004 fa3b 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800767a:	f7ff ffd9 	bl	8007630 <port_unlock.lto_priv.270>
}
 800767e:	bd08      	pop	{r3, pc}
 8007680:	20000d30 	.word	0x20000d30
 8007684:	0800e1a0 	.word	0x0800e1a0
	...

08007690 <osalSysLock.lto_priv.289>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8007690:	b508      	push	{r3, lr}

  chSysLock();
 8007692:	f7ff ffd5 	bl	8007640 <chSysLock.lto_priv.293>
}
 8007696:	bd08      	pop	{r3, pc}
	...

080076a0 <osalSysUnlock.lto_priv.286>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80076a0:	b508      	push	{r3, lr}

  chSysUnlock();
 80076a2:	f7ff ffd5 	bl	8007650 <chSysUnlock.lto_priv.291>
}
 80076a6:	bd08      	pop	{r3, pc}
	...

080076b0 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 80076b0:	b500      	push	{lr}
 80076b2:	b083      	sub	sp, #12
 80076b4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 80076b6:	9801      	ldr	r0, [sp, #4]
 80076b8:	f003 fcda 	bl	800b070 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 80076bc:	b003      	add	sp, #12
 80076be:	f85d fb04 	ldr.w	pc, [sp], #4
 80076c2:	bf00      	nop
	...

080076d0 <osalMutexLock>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {
 80076d0:	b500      	push	{lr}
 80076d2:	b083      	sub	sp, #12
 80076d4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 80076d6:	9801      	ldr	r0, [sp, #4]
 80076d8:	f003 fce2 	bl	800b0a0 <chMtxLock>
#elif CH_CFG_USE_SEMAPHORES
  chSemWait((semaphore_t *)mp);
#else
  *mp = 1;
#endif
}
 80076dc:	b003      	add	sp, #12
 80076de:	f85d fb04 	ldr.w	pc, [sp], #4
 80076e2:	bf00      	nop
	...

080076f0 <osalMutexUnlock>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {
 80076f0:	b500      	push	{lr}
 80076f2:	b083      	sub	sp, #12
 80076f4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 80076f6:	9801      	ldr	r0, [sp, #4]
 80076f8:	f003 fda2 	bl	800b240 <chMtxUnlock>
#elif CH_CFG_USE_SEMAPHORES
  chSemSignal((semaphore_t *)mp);
#else
  *mp = 0;
#endif
}
 80076fc:	b003      	add	sp, #12
 80076fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8007702:	bf00      	nop
	...

08007710 <i2cInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void i2cInit(void) {
 8007710:	b508      	push	{r3, lr}

  i2c_lld_init();
 8007712:	f7ff fc8d 	bl	8007030 <i2c_lld_init>
}
 8007716:	bd08      	pop	{r3, pc}
	...

08007720 <i2cObjectInit>:
 *
 * @param[out] i2cp     pointer to the @p I2CDriver object
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {
 8007720:	b500      	push	{lr}
 8007722:	b083      	sub	sp, #12
 8007724:	9001      	str	r0, [sp, #4]

  i2cp->state  = I2C_STOP;
 8007726:	9b01      	ldr	r3, [sp, #4]
 8007728:	2201      	movs	r2, #1
 800772a:	701a      	strb	r2, [r3, #0]
  i2cp->config = NULL;
 800772c:	9b01      	ldr	r3, [sp, #4]
 800772e:	2200      	movs	r2, #0
 8007730:	605a      	str	r2, [r3, #4]

#if I2C_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&i2cp->mutex);
 8007732:	9b01      	ldr	r3, [sp, #4]
 8007734:	330c      	adds	r3, #12
 8007736:	4618      	mov	r0, r3
 8007738:	f7ff ffba 	bl	80076b0 <osalMutexObjectInit>
#endif

#if defined(I2C_DRIVER_EXT_INIT_HOOK)
  I2C_DRIVER_EXT_INIT_HOOK(i2cp);
#endif
}
 800773c:	b003      	add	sp, #12
 800773e:	f85d fb04 	ldr.w	pc, [sp], #4
 8007742:	bf00      	nop
	...

08007750 <i2cStart>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] config    pointer to the @p I2CConfig object
 *
 * @api
 */
void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {
 8007750:	b500      	push	{lr}
 8007752:	b083      	sub	sp, #12
 8007754:	9001      	str	r0, [sp, #4]
 8007756:	9100      	str	r1, [sp, #0]

  osalDbgCheck((i2cp != NULL) && (config != NULL));
 8007758:	9b01      	ldr	r3, [sp, #4]
 800775a:	2b00      	cmp	r3, #0
 800775c:	d002      	beq.n	8007764 <i2cStart+0x14>
 800775e:	9b00      	ldr	r3, [sp, #0]
 8007760:	2b00      	cmp	r3, #0
 8007762:	d102      	bne.n	800776a <i2cStart+0x1a>
 8007764:	4810      	ldr	r0, [pc, #64]	; (80077a8 <i2cStart+0x58>)
 8007766:	f004 f9c3 	bl	800baf0 <chSysHalt>
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
 800776a:	9b01      	ldr	r3, [sp, #4]
 800776c:	781b      	ldrb	r3, [r3, #0]
 800776e:	2b01      	cmp	r3, #1
 8007770:	d00a      	beq.n	8007788 <i2cStart+0x38>
 8007772:	9b01      	ldr	r3, [sp, #4]
 8007774:	781b      	ldrb	r3, [r3, #0]
 8007776:	2b02      	cmp	r3, #2
 8007778:	d006      	beq.n	8007788 <i2cStart+0x38>
 800777a:	9b01      	ldr	r3, [sp, #4]
 800777c:	781b      	ldrb	r3, [r3, #0]
 800777e:	2b05      	cmp	r3, #5
 8007780:	d002      	beq.n	8007788 <i2cStart+0x38>
 8007782:	4809      	ldr	r0, [pc, #36]	; (80077a8 <i2cStart+0x58>)
 8007784:	f004 f9b4 	bl	800baf0 <chSysHalt>
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
 8007788:	f7ff ff82 	bl	8007690 <osalSysLock.lto_priv.289>
  i2cp->config = config;
 800778c:	9b01      	ldr	r3, [sp, #4]
 800778e:	9a00      	ldr	r2, [sp, #0]
 8007790:	605a      	str	r2, [r3, #4]
  i2c_lld_start(i2cp);
 8007792:	9801      	ldr	r0, [sp, #4]
 8007794:	f7ff fc94 	bl	80070c0 <i2c_lld_start>
  i2cp->state = I2C_READY;
 8007798:	9b01      	ldr	r3, [sp, #4]
 800779a:	2202      	movs	r2, #2
 800779c:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 800779e:	f7ff ff7f 	bl	80076a0 <osalSysUnlock.lto_priv.286>
}
 80077a2:	b003      	add	sp, #12
 80077a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80077a8:	0800e190 	.word	0x0800e190
 80077ac:	00000000 	.word	0x00000000

080077b0 <i2cMasterTransmitTimeout>:
                               i2caddr_t addr,
                               const uint8_t *txbuf,
                               size_t txbytes,
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               systime_t timeout) {
 80077b0:	b500      	push	{lr}
 80077b2:	b08b      	sub	sp, #44	; 0x2c
 80077b4:	9007      	str	r0, [sp, #28]
 80077b6:	9205      	str	r2, [sp, #20]
 80077b8:	9304      	str	r3, [sp, #16]
 80077ba:	460b      	mov	r3, r1
 80077bc:	f8ad 301a 	strh.w	r3, [sp, #26]
  msg_t rdymsg;

  osalDbgCheck((i2cp != NULL) && (addr != 0U) &&
 80077c0:	9b07      	ldr	r3, [sp, #28]
 80077c2:	2b00      	cmp	r3, #0
 80077c4:	d015      	beq.n	80077f2 <i2cMasterTransmitTimeout+0x42>
 80077c6:	f8bd 301a 	ldrh.w	r3, [sp, #26]
 80077ca:	2b00      	cmp	r3, #0
 80077cc:	d011      	beq.n	80077f2 <i2cMasterTransmitTimeout+0x42>
 80077ce:	9b04      	ldr	r3, [sp, #16]
 80077d0:	2b00      	cmp	r3, #0
 80077d2:	d00e      	beq.n	80077f2 <i2cMasterTransmitTimeout+0x42>
 80077d4:	9b05      	ldr	r3, [sp, #20]
 80077d6:	2b00      	cmp	r3, #0
 80077d8:	d00b      	beq.n	80077f2 <i2cMasterTransmitTimeout+0x42>
 80077da:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80077dc:	2b00      	cmp	r3, #0
 80077de:	d005      	beq.n	80077ec <i2cMasterTransmitTimeout+0x3c>
 80077e0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80077e2:	2b00      	cmp	r3, #0
 80077e4:	d005      	beq.n	80077f2 <i2cMasterTransmitTimeout+0x42>
 80077e6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80077e8:	2b00      	cmp	r3, #0
 80077ea:	d002      	beq.n	80077f2 <i2cMasterTransmitTimeout+0x42>
 80077ec:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80077ee:	2b00      	cmp	r3, #0
 80077f0:	d102      	bne.n	80077f8 <i2cMasterTransmitTimeout+0x48>
 80077f2:	4819      	ldr	r0, [pc, #100]	; (8007858 <i2cMasterTransmitTimeout+0xa8>)
 80077f4:	f004 f97c 	bl	800baf0 <chSysHalt>
               (txbytes > 0U) && (txbuf != NULL) &&
               ((rxbytes == 0U) || ((rxbytes > 0U) && (rxbuf != NULL))) &&
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");
 80077f8:	9b07      	ldr	r3, [sp, #28]
 80077fa:	781b      	ldrb	r3, [r3, #0]
 80077fc:	2b02      	cmp	r3, #2
 80077fe:	d002      	beq.n	8007806 <i2cMasterTransmitTimeout+0x56>
 8007800:	4815      	ldr	r0, [pc, #84]	; (8007858 <i2cMasterTransmitTimeout+0xa8>)
 8007802:	f004 f975 	bl	800baf0 <chSysHalt>

  osalSysLock();
 8007806:	f7ff ff43 	bl	8007690 <osalSysLock.lto_priv.289>
  i2cp->errors = I2C_NO_ERROR;
 800780a:	9b07      	ldr	r3, [sp, #28]
 800780c:	2200      	movs	r2, #0
 800780e:	609a      	str	r2, [r3, #8]
  i2cp->state = I2C_ACTIVE_TX;
 8007810:	9b07      	ldr	r3, [sp, #28]
 8007812:	2203      	movs	r2, #3
 8007814:	701a      	strb	r2, [r3, #0]
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
 8007816:	f8bd 201a 	ldrh.w	r2, [sp, #26]
 800781a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800781c:	9300      	str	r3, [sp, #0]
 800781e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007820:	9301      	str	r3, [sp, #4]
 8007822:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8007824:	9302      	str	r3, [sp, #8]
 8007826:	9807      	ldr	r0, [sp, #28]
 8007828:	4611      	mov	r1, r2
 800782a:	9a05      	ldr	r2, [sp, #20]
 800782c:	9b04      	ldr	r3, [sp, #16]
 800782e:	f7ff fd7f 	bl	8007330 <i2c_lld_master_transmit_timeout>
 8007832:	9009      	str	r0, [sp, #36]	; 0x24
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
 8007834:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007836:	f1b3 3fff 	cmp.w	r3, #4294967295
 800783a:	d103      	bne.n	8007844 <i2cMasterTransmitTimeout+0x94>
    i2cp->state = I2C_LOCKED;
 800783c:	9b07      	ldr	r3, [sp, #28]
 800783e:	2205      	movs	r2, #5
 8007840:	701a      	strb	r2, [r3, #0]
 8007842:	e002      	b.n	800784a <i2cMasterTransmitTimeout+0x9a>
  }
  else {
    i2cp->state = I2C_READY;
 8007844:	9b07      	ldr	r3, [sp, #28]
 8007846:	2202      	movs	r2, #2
 8007848:	701a      	strb	r2, [r3, #0]
  }
  osalSysUnlock();
 800784a:	f7ff ff29 	bl	80076a0 <osalSysUnlock.lto_priv.286>
  return rdymsg;
 800784e:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
 8007850:	4618      	mov	r0, r3
 8007852:	b00b      	add	sp, #44	; 0x2c
 8007854:	f85d fb04 	ldr.w	pc, [sp], #4
 8007858:	0800e1b0 	.word	0x0800e1b0
 800785c:	00000000 	.word	0x00000000

08007860 <i2cAcquireBus>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @api
 */
void i2cAcquireBus(I2CDriver *i2cp) {
 8007860:	b500      	push	{lr}
 8007862:	b083      	sub	sp, #12
 8007864:	9001      	str	r0, [sp, #4]

  osalDbgCheck(i2cp != NULL);
 8007866:	9b01      	ldr	r3, [sp, #4]
 8007868:	2b00      	cmp	r3, #0
 800786a:	d102      	bne.n	8007872 <i2cAcquireBus+0x12>
 800786c:	4805      	ldr	r0, [pc, #20]	; (8007884 <i2cAcquireBus+0x24>)
 800786e:	f004 f93f 	bl	800baf0 <chSysHalt>

  osalMutexLock(&i2cp->mutex);
 8007872:	9b01      	ldr	r3, [sp, #4]
 8007874:	330c      	adds	r3, #12
 8007876:	4618      	mov	r0, r3
 8007878:	f7ff ff2a 	bl	80076d0 <osalMutexLock>
}
 800787c:	b003      	add	sp, #12
 800787e:	f85d fb04 	ldr.w	pc, [sp], #4
 8007882:	bf00      	nop
 8007884:	0800e1d0 	.word	0x0800e1d0
	...

08007890 <i2cReleaseBus>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @api
 */
void i2cReleaseBus(I2CDriver *i2cp) {
 8007890:	b500      	push	{lr}
 8007892:	b083      	sub	sp, #12
 8007894:	9001      	str	r0, [sp, #4]

  osalDbgCheck(i2cp != NULL);
 8007896:	9b01      	ldr	r3, [sp, #4]
 8007898:	2b00      	cmp	r3, #0
 800789a:	d102      	bne.n	80078a2 <i2cReleaseBus+0x12>
 800789c:	4805      	ldr	r0, [pc, #20]	; (80078b4 <i2cReleaseBus+0x24>)
 800789e:	f004 f927 	bl	800baf0 <chSysHalt>

  osalMutexUnlock(&i2cp->mutex);
 80078a2:	9b01      	ldr	r3, [sp, #4]
 80078a4:	330c      	adds	r3, #12
 80078a6:	4618      	mov	r0, r3
 80078a8:	f7ff ff22 	bl	80076f0 <osalMutexUnlock>
}
 80078ac:	b003      	add	sp, #12
 80078ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80078b2:	bf00      	nop
 80078b4:	0800e1e0 	.word	0x0800e1e0
	...

080078c0 <port_lock.lto_priv.274>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80078c0:	b082      	sub	sp, #8
 80078c2:	2320      	movs	r3, #32
 80078c4:	9301      	str	r3, [sp, #4]
 80078c6:	9b01      	ldr	r3, [sp, #4]
 80078c8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80078cc:	b002      	add	sp, #8
 80078ce:	4770      	bx	lr

080078d0 <port_unlock.lto_priv.271>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80078d0:	b082      	sub	sp, #8
 80078d2:	2300      	movs	r3, #0
 80078d4:	9301      	str	r3, [sp, #4]
 80078d6:	9b01      	ldr	r3, [sp, #4]
 80078d8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80078dc:	b002      	add	sp, #8
 80078de:	4770      	bx	lr

080078e0 <chSysLock.lto_priv.294>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80078e0:	b508      	push	{r3, lr}

  port_lock();
 80078e2:	f7ff ffed 	bl	80078c0 <port_lock.lto_priv.274>
  _stats_start_measure_crit_thd();
 80078e6:	f002 fdab 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 80078ea:	f004 fa59 	bl	800bda0 <_dbg_check_lock>
}
 80078ee:	bd08      	pop	{r3, pc}

080078f0 <chSysUnlock.lto_priv.292>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80078f0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 80078f2:	f004 fa6d 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80078f6:	f002 fdab 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80078fa:	4b09      	ldr	r3, [pc, #36]	; (8007920 <chSysUnlock.lto_priv.292+0x30>)
 80078fc:	681b      	ldr	r3, [r3, #0]
 80078fe:	4a08      	ldr	r2, [pc, #32]	; (8007920 <chSysUnlock.lto_priv.292+0x30>)
 8007900:	4293      	cmp	r3, r2
 8007902:	d00a      	beq.n	800791a <chSysUnlock.lto_priv.292+0x2a>
 8007904:	4b06      	ldr	r3, [pc, #24]	; (8007920 <chSysUnlock.lto_priv.292+0x30>)
 8007906:	699b      	ldr	r3, [r3, #24]
 8007908:	689a      	ldr	r2, [r3, #8]
 800790a:	4b05      	ldr	r3, [pc, #20]	; (8007920 <chSysUnlock.lto_priv.292+0x30>)
 800790c:	681b      	ldr	r3, [r3, #0]
 800790e:	689b      	ldr	r3, [r3, #8]
 8007910:	429a      	cmp	r2, r3
 8007912:	d202      	bcs.n	800791a <chSysUnlock.lto_priv.292+0x2a>
 8007914:	4803      	ldr	r0, [pc, #12]	; (8007924 <chSysUnlock.lto_priv.292+0x34>)
 8007916:	f004 f8eb 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800791a:	f7ff ffd9 	bl	80078d0 <port_unlock.lto_priv.271>
}
 800791e:	bd08      	pop	{r3, pc}
 8007920:	20000d30 	.word	0x20000d30
 8007924:	0800e220 	.word	0x0800e220
	...

08007930 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8007930:	b082      	sub	sp, #8
 8007932:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 8007934:	9b01      	ldr	r3, [sp, #4]
 8007936:	9a01      	ldr	r2, [sp, #4]
 8007938:	601a      	str	r2, [r3, #0]
}
 800793a:	b002      	add	sp, #8
 800793c:	4770      	bx	lr
 800793e:	bf00      	nop

08007940 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 8007940:	b500      	push	{lr}
 8007942:	b083      	sub	sp, #12
 8007944:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8007946:	f004 facb 	bl	800bee0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 800794a:	9b01      	ldr	r3, [sp, #4]
 800794c:	689b      	ldr	r3, [r3, #8]
 800794e:	2b00      	cmp	r3, #0
 8007950:	bf0c      	ite	eq
 8007952:	2301      	moveq	r3, #1
 8007954:	2300      	movne	r3, #0
 8007956:	b2db      	uxtb	r3, r3
}
 8007958:	4618      	mov	r0, r3
 800795a:	b003      	add	sp, #12
 800795c:	f85d fb04 	ldr.w	pc, [sp], #4

08007960 <osalSysLock.lto_priv.290>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8007960:	b508      	push	{r3, lr}

  chSysLock();
 8007962:	f7ff ffbd 	bl	80078e0 <chSysLock.lto_priv.294>
}
 8007966:	bd08      	pop	{r3, pc}
	...

08007970 <osalSysUnlock.lto_priv.287>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8007970:	b508      	push	{r3, lr}

  chSysUnlock();
 8007972:	f7ff ffbd 	bl	80078f0 <chSysUnlock.lto_priv.292>
}
 8007976:	bd08      	pop	{r3, pc}
	...

08007980 <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
 8007980:	b500      	push	{lr}
 8007982:	b083      	sub	sp, #12
 8007984:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
 8007986:	9801      	ldr	r0, [sp, #4]
 8007988:	f7ff ffd2 	bl	8007930 <chEvtObjectInit>
}
 800798c:	b003      	add	sp, #12
 800798e:	f85d fb04 	ldr.w	pc, [sp], #4
 8007992:	bf00      	nop
	...

080079a0 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 80079a0:	b500      	push	{lr}
 80079a2:	b083      	sub	sp, #12
 80079a4:	9001      	str	r0, [sp, #4]
 80079a6:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 80079a8:	9801      	ldr	r0, [sp, #4]
 80079aa:	9900      	ldr	r1, [sp, #0]
 80079ac:	f001 fcd0 	bl	8009350 <chEvtBroadcastFlagsI>
}
 80079b0:	b003      	add	sp, #12
 80079b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80079b6:	bf00      	nop
	...

080079c0 <write.lto_priv.103>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 80079c0:	b500      	push	{lr}
 80079c2:	b085      	sub	sp, #20
 80079c4:	9003      	str	r0, [sp, #12]
 80079c6:	9102      	str	r1, [sp, #8]
 80079c8:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 80079ca:	9b03      	ldr	r3, [sp, #12]
 80079cc:	3330      	adds	r3, #48	; 0x30
 80079ce:	4618      	mov	r0, r3
 80079d0:	9902      	ldr	r1, [sp, #8]
 80079d2:	9a01      	ldr	r2, [sp, #4]
 80079d4:	f04f 33ff 	mov.w	r3, #4294967295
 80079d8:	f000 fe32 	bl	8008640 <chOQWriteTimeout>
 80079dc:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 80079de:	4618      	mov	r0, r3
 80079e0:	b005      	add	sp, #20
 80079e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80079e6:	bf00      	nop
	...

080079f0 <read.lto_priv.104>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
 80079f0:	b500      	push	{lr}
 80079f2:	b085      	sub	sp, #20
 80079f4:	9003      	str	r0, [sp, #12]
 80079f6:	9102      	str	r1, [sp, #8]
 80079f8:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 80079fa:	9b03      	ldr	r3, [sp, #12]
 80079fc:	330c      	adds	r3, #12
 80079fe:	4618      	mov	r0, r3
 8007a00:	9902      	ldr	r1, [sp, #8]
 8007a02:	9a01      	ldr	r2, [sp, #4]
 8007a04:	f04f 33ff 	mov.w	r3, #4294967295
 8007a08:	f002 fbea 	bl	800a1e0 <chIQReadTimeout>
 8007a0c:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
 8007a0e:	4618      	mov	r0, r3
 8007a10:	b005      	add	sp, #20
 8007a12:	f85d fb04 	ldr.w	pc, [sp], #4
 8007a16:	bf00      	nop
	...

08007a20 <put.lto_priv.4>:

static msg_t put(void *ip, uint8_t b) {
 8007a20:	b500      	push	{lr}
 8007a22:	b083      	sub	sp, #12
 8007a24:	9001      	str	r0, [sp, #4]
 8007a26:	460b      	mov	r3, r1
 8007a28:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8007a2c:	9b01      	ldr	r3, [sp, #4]
 8007a2e:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8007a32:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007a36:	4610      	mov	r0, r2
 8007a38:	4619      	mov	r1, r3
 8007a3a:	f04f 32ff 	mov.w	r2, #4294967295
 8007a3e:	f000 fd87 	bl	8008550 <chOQPutTimeout>
 8007a42:	4603      	mov	r3, r0
}
 8007a44:	4618      	mov	r0, r3
 8007a46:	b003      	add	sp, #12
 8007a48:	f85d fb04 	ldr.w	pc, [sp], #4
 8007a4c:	0000      	movs	r0, r0
	...

08007a50 <get.lto_priv.2>:

static msg_t get(void *ip) {
 8007a50:	b500      	push	{lr}
 8007a52:	b083      	sub	sp, #12
 8007a54:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8007a56:	9b01      	ldr	r3, [sp, #4]
 8007a58:	330c      	adds	r3, #12
 8007a5a:	4618      	mov	r0, r3
 8007a5c:	f04f 31ff 	mov.w	r1, #4294967295
 8007a60:	f002 fb76 	bl	800a150 <chIQGetTimeout>
 8007a64:	4603      	mov	r3, r0
}
 8007a66:	4618      	mov	r0, r3
 8007a68:	b003      	add	sp, #12
 8007a6a:	f85d fb04 	ldr.w	pc, [sp], #4
 8007a6e:	bf00      	nop

08007a70 <putt.lto_priv.105>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 8007a70:	b500      	push	{lr}
 8007a72:	b085      	sub	sp, #20
 8007a74:	9003      	str	r0, [sp, #12]
 8007a76:	460b      	mov	r3, r1
 8007a78:	9201      	str	r2, [sp, #4]
 8007a7a:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8007a7e:	9b03      	ldr	r3, [sp, #12]
 8007a80:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8007a84:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8007a88:	4610      	mov	r0, r2
 8007a8a:	4619      	mov	r1, r3
 8007a8c:	9a01      	ldr	r2, [sp, #4]
 8007a8e:	f000 fd5f 	bl	8008550 <chOQPutTimeout>
 8007a92:	4603      	mov	r3, r0
}
 8007a94:	4618      	mov	r0, r3
 8007a96:	b005      	add	sp, #20
 8007a98:	f85d fb04 	ldr.w	pc, [sp], #4
 8007a9c:	0000      	movs	r0, r0
	...

08007aa0 <gett.lto_priv.106>:

static msg_t gett(void *ip, systime_t timeout) {
 8007aa0:	b500      	push	{lr}
 8007aa2:	b083      	sub	sp, #12
 8007aa4:	9001      	str	r0, [sp, #4]
 8007aa6:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8007aa8:	9b01      	ldr	r3, [sp, #4]
 8007aaa:	330c      	adds	r3, #12
 8007aac:	4618      	mov	r0, r3
 8007aae:	9900      	ldr	r1, [sp, #0]
 8007ab0:	f002 fb4e 	bl	800a150 <chIQGetTimeout>
 8007ab4:	4603      	mov	r3, r0
}
 8007ab6:	4618      	mov	r0, r3
 8007ab8:	b003      	add	sp, #12
 8007aba:	f85d fb04 	ldr.w	pc, [sp], #4
 8007abe:	bf00      	nop

08007ac0 <writet.lto_priv.107>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8007ac0:	b500      	push	{lr}
 8007ac2:	b085      	sub	sp, #20
 8007ac4:	9003      	str	r0, [sp, #12]
 8007ac6:	9102      	str	r1, [sp, #8]
 8007ac8:	9201      	str	r2, [sp, #4]
 8007aca:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8007acc:	9b03      	ldr	r3, [sp, #12]
 8007ace:	3330      	adds	r3, #48	; 0x30
 8007ad0:	4618      	mov	r0, r3
 8007ad2:	9902      	ldr	r1, [sp, #8]
 8007ad4:	9a01      	ldr	r2, [sp, #4]
 8007ad6:	9b00      	ldr	r3, [sp, #0]
 8007ad8:	f000 fdb2 	bl	8008640 <chOQWriteTimeout>
 8007adc:	4603      	mov	r3, r0
}
 8007ade:	4618      	mov	r0, r3
 8007ae0:	b005      	add	sp, #20
 8007ae2:	f85d fb04 	ldr.w	pc, [sp], #4
 8007ae6:	bf00      	nop
	...

08007af0 <readt.lto_priv.108>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8007af0:	b500      	push	{lr}
 8007af2:	b085      	sub	sp, #20
 8007af4:	9003      	str	r0, [sp, #12]
 8007af6:	9102      	str	r1, [sp, #8]
 8007af8:	9201      	str	r2, [sp, #4]
 8007afa:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8007afc:	9b03      	ldr	r3, [sp, #12]
 8007afe:	330c      	adds	r3, #12
 8007b00:	4618      	mov	r0, r3
 8007b02:	9902      	ldr	r1, [sp, #8]
 8007b04:	9a01      	ldr	r2, [sp, #4]
 8007b06:	9b00      	ldr	r3, [sp, #0]
 8007b08:	f002 fb6a 	bl	800a1e0 <chIQReadTimeout>
 8007b0c:	4603      	mov	r3, r0
}
 8007b0e:	4618      	mov	r0, r3
 8007b10:	b005      	add	sp, #20
 8007b12:	f85d fb04 	ldr.w	pc, [sp], #4
 8007b16:	bf00      	nop
	...

08007b20 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 8007b20:	b508      	push	{r3, lr}

  sd_lld_init();
 8007b22:	f7fd fbf5 	bl	8005310 <sd_lld_init>
}
 8007b26:	bd08      	pop	{r3, pc}
	...

08007b30 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8007b30:	b500      	push	{lr}
 8007b32:	b087      	sub	sp, #28
 8007b34:	9005      	str	r0, [sp, #20]
 8007b36:	9104      	str	r1, [sp, #16]
 8007b38:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
 8007b3a:	9b05      	ldr	r3, [sp, #20]
 8007b3c:	4a14      	ldr	r2, [pc, #80]	; (8007b90 <sdObjectInit+0x60>)
 8007b3e:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 8007b40:	9b05      	ldr	r3, [sp, #20]
 8007b42:	3304      	adds	r3, #4
 8007b44:	4618      	mov	r0, r3
 8007b46:	f7ff ff1b 	bl	8007980 <osalEventObjectInit>
  sdp->state = SD_STOP;
 8007b4a:	9b05      	ldr	r3, [sp, #20]
 8007b4c:	2201      	movs	r2, #1
 8007b4e:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8007b50:	9b05      	ldr	r3, [sp, #20]
 8007b52:	f103 010c 	add.w	r1, r3, #12
 8007b56:	9b05      	ldr	r3, [sp, #20]
 8007b58:	f103 0254 	add.w	r2, r3, #84	; 0x54
 8007b5c:	9b05      	ldr	r3, [sp, #20]
 8007b5e:	9300      	str	r3, [sp, #0]
 8007b60:	4608      	mov	r0, r1
 8007b62:	4611      	mov	r1, r2
 8007b64:	2210      	movs	r2, #16
 8007b66:	9b04      	ldr	r3, [sp, #16]
 8007b68:	f002 fa72 	bl	800a050 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8007b6c:	9b05      	ldr	r3, [sp, #20]
 8007b6e:	f103 0130 	add.w	r1, r3, #48	; 0x30
 8007b72:	9b05      	ldr	r3, [sp, #20]
 8007b74:	f103 0264 	add.w	r2, r3, #100	; 0x64
 8007b78:	9b05      	ldr	r3, [sp, #20]
 8007b7a:	9300      	str	r3, [sp, #0]
 8007b7c:	4608      	mov	r0, r1
 8007b7e:	4611      	mov	r1, r2
 8007b80:	2210      	movs	r2, #16
 8007b82:	9b03      	ldr	r3, [sp, #12]
 8007b84:	f002 fb8c 	bl	800a2a0 <chOQObjectInit>
}
 8007b88:	b007      	add	sp, #28
 8007b8a:	f85d fb04 	ldr.w	pc, [sp], #4
 8007b8e:	bf00      	nop
 8007b90:	0800e1f0 	.word	0x0800e1f0
	...

08007ba0 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8007ba0:	b500      	push	{lr}
 8007ba2:	b083      	sub	sp, #12
 8007ba4:	9001      	str	r0, [sp, #4]
 8007ba6:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);
 8007ba8:	9b01      	ldr	r3, [sp, #4]
 8007baa:	2b00      	cmp	r3, #0
 8007bac:	d102      	bne.n	8007bb4 <sdStart+0x14>
 8007bae:	480e      	ldr	r0, [pc, #56]	; (8007be8 <sdStart+0x48>)
 8007bb0:	f003 ff9e 	bl	800baf0 <chSysHalt>

  osalSysLock();
 8007bb4:	f7ff fed4 	bl	8007960 <osalSysLock.lto_priv.290>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 8007bb8:	9b01      	ldr	r3, [sp, #4]
 8007bba:	7a1b      	ldrb	r3, [r3, #8]
 8007bbc:	2b01      	cmp	r3, #1
 8007bbe:	d006      	beq.n	8007bce <sdStart+0x2e>
 8007bc0:	9b01      	ldr	r3, [sp, #4]
 8007bc2:	7a1b      	ldrb	r3, [r3, #8]
 8007bc4:	2b02      	cmp	r3, #2
 8007bc6:	d002      	beq.n	8007bce <sdStart+0x2e>
 8007bc8:	4807      	ldr	r0, [pc, #28]	; (8007be8 <sdStart+0x48>)
 8007bca:	f003 ff91 	bl	800baf0 <chSysHalt>
                "invalid state");
  sd_lld_start(sdp, config);
 8007bce:	9801      	ldr	r0, [sp, #4]
 8007bd0:	9900      	ldr	r1, [sp, #0]
 8007bd2:	f7fd fbad 	bl	8005330 <sd_lld_start>
  sdp->state = SD_READY;
 8007bd6:	9b01      	ldr	r3, [sp, #4]
 8007bd8:	2202      	movs	r2, #2
 8007bda:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 8007bdc:	f7ff fec8 	bl	8007970 <osalSysUnlock.lto_priv.287>
}
 8007be0:	b003      	add	sp, #12
 8007be2:	f85d fb04 	ldr.w	pc, [sp], #4
 8007be6:	bf00      	nop
 8007be8:	0800e210 	.word	0x0800e210
 8007bec:	00000000 	.word	0x00000000

08007bf0 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8007bf0:	b500      	push	{lr}
 8007bf2:	b083      	sub	sp, #12
 8007bf4:	9001      	str	r0, [sp, #4]
 8007bf6:	460b      	mov	r3, r1
 8007bf8:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
 8007bfc:	f004 f970 	bl	800bee0 <chDbgCheckClassI>
  osalDbgCheck(sdp != NULL);
 8007c00:	9b01      	ldr	r3, [sp, #4]
 8007c02:	2b00      	cmp	r3, #0
 8007c04:	d102      	bne.n	8007c0c <sdIncomingDataI+0x1c>
 8007c06:	4813      	ldr	r0, [pc, #76]	; (8007c54 <sdIncomingDataI+0x64>)
 8007c08:	f003 ff72 	bl	800baf0 <chSysHalt>

  if (iqIsEmptyI(&sdp->iqueue))
 8007c0c:	9b01      	ldr	r3, [sp, #4]
 8007c0e:	330c      	adds	r3, #12
 8007c10:	4618      	mov	r0, r3
 8007c12:	f7ff fe95 	bl	8007940 <chIQIsEmptyI>
 8007c16:	4603      	mov	r3, r0
 8007c18:	2b00      	cmp	r3, #0
 8007c1a:	d005      	beq.n	8007c28 <sdIncomingDataI+0x38>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 8007c1c:	9b01      	ldr	r3, [sp, #4]
 8007c1e:	3304      	adds	r3, #4
 8007c20:	4618      	mov	r0, r3
 8007c22:	2104      	movs	r1, #4
 8007c24:	f7ff febc 	bl	80079a0 <osalEventBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 8007c28:	9b01      	ldr	r3, [sp, #4]
 8007c2a:	f103 020c 	add.w	r2, r3, #12
 8007c2e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8007c32:	4610      	mov	r0, r2
 8007c34:	4619      	mov	r1, r3
 8007c36:	f002 fa53 	bl	800a0e0 <chIQPutI>
 8007c3a:	4603      	mov	r3, r0
 8007c3c:	2b00      	cmp	r3, #0
 8007c3e:	da05      	bge.n	8007c4c <sdIncomingDataI+0x5c>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
 8007c40:	9b01      	ldr	r3, [sp, #4]
 8007c42:	3304      	adds	r3, #4
 8007c44:	4618      	mov	r0, r3
 8007c46:	2180      	movs	r1, #128	; 0x80
 8007c48:	f7ff feaa 	bl	80079a0 <osalEventBroadcastFlagsI>
}
 8007c4c:	b003      	add	sp, #12
 8007c4e:	f85d fb04 	ldr.w	pc, [sp], #4
 8007c52:	bf00      	nop
 8007c54:	0800e230 	.word	0x0800e230
	...

08007c60 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8007c60:	b082      	sub	sp, #8
 8007c62:	9001      	str	r0, [sp, #4]
 8007c64:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8007c66:	4a12      	ldr	r2, [pc, #72]	; (8007cb0 <nvicEnableVector+0x50>)
 8007c68:	9b00      	ldr	r3, [sp, #0]
 8007c6a:	b2db      	uxtb	r3, r3
 8007c6c:	011b      	lsls	r3, r3, #4
 8007c6e:	b2d9      	uxtb	r1, r3
 8007c70:	9b01      	ldr	r3, [sp, #4]
 8007c72:	4413      	add	r3, r2
 8007c74:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8007c78:	460a      	mov	r2, r1
 8007c7a:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8007c7c:	490c      	ldr	r1, [pc, #48]	; (8007cb0 <nvicEnableVector+0x50>)
 8007c7e:	9b01      	ldr	r3, [sp, #4]
 8007c80:	095b      	lsrs	r3, r3, #5
 8007c82:	9a01      	ldr	r2, [sp, #4]
 8007c84:	f002 021f 	and.w	r2, r2, #31
 8007c88:	2001      	movs	r0, #1
 8007c8a:	fa00 f202 	lsl.w	r2, r0, r2
 8007c8e:	3360      	adds	r3, #96	; 0x60
 8007c90:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8007c94:	4906      	ldr	r1, [pc, #24]	; (8007cb0 <nvicEnableVector+0x50>)
 8007c96:	9b01      	ldr	r3, [sp, #4]
 8007c98:	095b      	lsrs	r3, r3, #5
 8007c9a:	9a01      	ldr	r2, [sp, #4]
 8007c9c:	f002 021f 	and.w	r2, r2, #31
 8007ca0:	2001      	movs	r0, #1
 8007ca2:	fa00 f202 	lsl.w	r2, r0, r2
 8007ca6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8007caa:	b002      	add	sp, #8
 8007cac:	4770      	bx	lr
 8007cae:	bf00      	nop
 8007cb0:	e000e100 	.word	0xe000e100
	...

08007cc0 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8007cc0:	4a0d      	ldr	r2, [pc, #52]	; (8007cf8 <hal_lld_backup_domain_init+0x38>)
 8007cc2:	4b0d      	ldr	r3, [pc, #52]	; (8007cf8 <hal_lld_backup_domain_init+0x38>)
 8007cc4:	681b      	ldr	r3, [r3, #0]
 8007cc6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8007cca:	6013      	str	r3, [r2, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8007ccc:	4b0b      	ldr	r3, [pc, #44]	; (8007cfc <hal_lld_backup_domain_init+0x3c>)
 8007cce:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8007cd0:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8007cd4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8007cd8:	d006      	beq.n	8007ce8 <hal_lld_backup_domain_init+0x28>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8007cda:	4b08      	ldr	r3, [pc, #32]	; (8007cfc <hal_lld_backup_domain_init+0x3c>)
 8007cdc:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8007ce0:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8007ce2:	4b06      	ldr	r3, [pc, #24]	; (8007cfc <hal_lld_backup_domain_init+0x3c>)
 8007ce4:	2200      	movs	r2, #0
 8007ce6:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8007ce8:	4a03      	ldr	r2, [pc, #12]	; (8007cf8 <hal_lld_backup_domain_init+0x38>)
 8007cea:	4b03      	ldr	r3, [pc, #12]	; (8007cf8 <hal_lld_backup_domain_init+0x38>)
 8007cec:	685b      	ldr	r3, [r3, #4]
 8007cee:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8007cf2:	6053      	str	r3, [r2, #4]
#endif /* STM32_BKPRAM_ENABLE */
}
 8007cf4:	4770      	bx	lr
 8007cf6:	bf00      	nop
 8007cf8:	40007000 	.word	0x40007000
 8007cfc:	40023800 	.word	0x40023800

08007d00 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8007d00:	b508      	push	{r3, lr}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 8007d02:	4b17      	ldr	r3, [pc, #92]	; (8007d60 <hal_lld_init+0x60>)
 8007d04:	691b      	ldr	r3, [r3, #16]
 8007d06:	4b16      	ldr	r3, [pc, #88]	; (8007d60 <hal_lld_init+0x60>)
 8007d08:	f04f 32ff 	mov.w	r2, #4294967295
 8007d0c:	611a      	str	r2, [r3, #16]
 8007d0e:	4b14      	ldr	r3, [pc, #80]	; (8007d60 <hal_lld_init+0x60>)
 8007d10:	2200      	movs	r2, #0
 8007d12:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 8007d14:	4b12      	ldr	r3, [pc, #72]	; (8007d60 <hal_lld_init+0x60>)
 8007d16:	695b      	ldr	r3, [r3, #20]
 8007d18:	4b11      	ldr	r3, [pc, #68]	; (8007d60 <hal_lld_init+0x60>)
 8007d1a:	f04f 32ff 	mov.w	r2, #4294967295
 8007d1e:	615a      	str	r2, [r3, #20]
 8007d20:	4b0f      	ldr	r3, [pc, #60]	; (8007d60 <hal_lld_init+0x60>)
 8007d22:	2200      	movs	r2, #0
 8007d24:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8007d26:	4a0e      	ldr	r2, [pc, #56]	; (8007d60 <hal_lld_init+0x60>)
 8007d28:	4b0d      	ldr	r3, [pc, #52]	; (8007d60 <hal_lld_init+0x60>)
 8007d2a:	6a1b      	ldr	r3, [r3, #32]
 8007d2c:	f063 5380 	orn	r3, r3, #268435456	; 0x10000000
 8007d30:	6213      	str	r3, [r2, #32]
 8007d32:	4b0b      	ldr	r3, [pc, #44]	; (8007d60 <hal_lld_init+0x60>)
 8007d34:	2200      	movs	r2, #0
 8007d36:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 8007d38:	4b09      	ldr	r3, [pc, #36]	; (8007d60 <hal_lld_init+0x60>)
 8007d3a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007d3c:	4b08      	ldr	r3, [pc, #32]	; (8007d60 <hal_lld_init+0x60>)
 8007d3e:	f04f 32ff 	mov.w	r2, #4294967295
 8007d42:	625a      	str	r2, [r3, #36]	; 0x24
 8007d44:	4b06      	ldr	r3, [pc, #24]	; (8007d60 <hal_lld_init+0x60>)
 8007d46:	2200      	movs	r2, #0
 8007d48:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8007d4a:	4a05      	ldr	r2, [pc, #20]	; (8007d60 <hal_lld_init+0x60>)
 8007d4c:	4b04      	ldr	r3, [pc, #16]	; (8007d60 <hal_lld_init+0x60>)
 8007d4e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007d50:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8007d54:	6413      	str	r3, [r2, #64]	; 0x40

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 8007d56:	f7ff ffb3 	bl	8007cc0 <hal_lld_backup_domain_init>

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8007d5a:	f000 fb01 	bl	8008360 <dmaInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 8007d5e:	bd08      	pop	{r3, pc}
 8007d60:	40023800 	.word	0x40023800
	...

08007d70 <stm32_clock_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8007d70:	4b36      	ldr	r3, [pc, #216]	; (8007e4c <stm32_clock_init+0xdc>)
 8007d72:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8007d76:	641a      	str	r2, [r3, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8007d78:	4b35      	ldr	r3, [pc, #212]	; (8007e50 <stm32_clock_init+0xe0>)
 8007d7a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8007d7e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8007d80:	4a32      	ldr	r2, [pc, #200]	; (8007e4c <stm32_clock_init+0xdc>)
 8007d82:	4b32      	ldr	r3, [pc, #200]	; (8007e4c <stm32_clock_init+0xdc>)
 8007d84:	681b      	ldr	r3, [r3, #0]
 8007d86:	f043 0301 	orr.w	r3, r3, #1
 8007d8a:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8007d8c:	4b2f      	ldr	r3, [pc, #188]	; (8007e4c <stm32_clock_init+0xdc>)
 8007d8e:	681b      	ldr	r3, [r3, #0]
 8007d90:	f003 0302 	and.w	r3, r3, #2
 8007d94:	2b00      	cmp	r3, #0
 8007d96:	d0f9      	beq.n	8007d8c <stm32_clock_init+0x1c>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8007d98:	4a2c      	ldr	r2, [pc, #176]	; (8007e4c <stm32_clock_init+0xdc>)
 8007d9a:	4b2c      	ldr	r3, [pc, #176]	; (8007e4c <stm32_clock_init+0xdc>)
 8007d9c:	689b      	ldr	r3, [r3, #8]
 8007d9e:	f023 0303 	bic.w	r3, r3, #3
 8007da2:	6093      	str	r3, [r2, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8007da4:	4a29      	ldr	r2, [pc, #164]	; (8007e4c <stm32_clock_init+0xdc>)
 8007da6:	4b29      	ldr	r3, [pc, #164]	; (8007e4c <stm32_clock_init+0xdc>)
 8007da8:	689b      	ldr	r3, [r3, #8]
 8007daa:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8007dac:	4b27      	ldr	r3, [pc, #156]	; (8007e4c <stm32_clock_init+0xdc>)
 8007dae:	689b      	ldr	r3, [r3, #8]
 8007db0:	f003 030c 	and.w	r3, r3, #12
 8007db4:	2b00      	cmp	r3, #0
 8007db6:	d1f9      	bne.n	8007dac <stm32_clock_init+0x3c>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8007db8:	4a24      	ldr	r2, [pc, #144]	; (8007e4c <stm32_clock_init+0xdc>)
 8007dba:	4b24      	ldr	r3, [pc, #144]	; (8007e4c <stm32_clock_init+0xdc>)
 8007dbc:	681b      	ldr	r3, [r3, #0]
 8007dbe:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 8007dc2:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8007dc4:	4b21      	ldr	r3, [pc, #132]	; (8007e4c <stm32_clock_init+0xdc>)
 8007dc6:	2200      	movs	r2, #0
 8007dc8:	609a      	str	r2, [r3, #8]
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8007dca:	4a20      	ldr	r2, [pc, #128]	; (8007e4c <stm32_clock_init+0xdc>)
 8007dcc:	4b1f      	ldr	r3, [pc, #124]	; (8007e4c <stm32_clock_init+0xdc>)
 8007dce:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8007dd0:	f043 0301 	orr.w	r3, r3, #1
 8007dd4:	6753      	str	r3, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8007dd6:	4b1d      	ldr	r3, [pc, #116]	; (8007e4c <stm32_clock_init+0xdc>)
 8007dd8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8007dda:	f003 0302 	and.w	r3, r3, #2
 8007dde:	2b00      	cmp	r3, #0
 8007de0:	d0f9      	beq.n	8007dd6 <stm32_clock_init+0x66>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8007de2:	4b1a      	ldr	r3, [pc, #104]	; (8007e4c <stm32_clock_init+0xdc>)
 8007de4:	4a1b      	ldr	r2, [pc, #108]	; (8007e54 <stm32_clock_init+0xe4>)
 8007de6:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8007de8:	4a18      	ldr	r2, [pc, #96]	; (8007e4c <stm32_clock_init+0xdc>)
 8007dea:	4b18      	ldr	r3, [pc, #96]	; (8007e4c <stm32_clock_init+0xdc>)
 8007dec:	681b      	ldr	r3, [r3, #0]
 8007dee:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8007df2:	6013      	str	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8007df4:	4b16      	ldr	r3, [pc, #88]	; (8007e50 <stm32_clock_init+0xe0>)
 8007df6:	685b      	ldr	r3, [r3, #4]
 8007df8:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8007dfc:	2b00      	cmp	r3, #0
 8007dfe:	d0f9      	beq.n	8007df4 <stm32_clock_init+0x84>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8007e00:	4b12      	ldr	r3, [pc, #72]	; (8007e4c <stm32_clock_init+0xdc>)
 8007e02:	681b      	ldr	r3, [r3, #0]
 8007e04:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8007e08:	2b00      	cmp	r3, #0
 8007e0a:	d0f9      	beq.n	8007e00 <stm32_clock_init+0x90>
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8007e0c:	4b0f      	ldr	r3, [pc, #60]	; (8007e4c <stm32_clock_init+0xdc>)
 8007e0e:	4a12      	ldr	r2, [pc, #72]	; (8007e58 <stm32_clock_init+0xe8>)
 8007e10:	609a      	str	r2, [r3, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8007e12:	4b12      	ldr	r3, [pc, #72]	; (8007e5c <stm32_clock_init+0xec>)
 8007e14:	f240 7202 	movw	r2, #1794	; 0x702
 8007e18:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8007e1a:	4a0c      	ldr	r2, [pc, #48]	; (8007e4c <stm32_clock_init+0xdc>)
 8007e1c:	4b0b      	ldr	r3, [pc, #44]	; (8007e4c <stm32_clock_init+0xdc>)
 8007e1e:	689b      	ldr	r3, [r3, #8]
 8007e20:	f043 0302 	orr.w	r3, r3, #2
 8007e24:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8007e26:	4b09      	ldr	r3, [pc, #36]	; (8007e4c <stm32_clock_init+0xdc>)
 8007e28:	689b      	ldr	r3, [r3, #8]
 8007e2a:	f003 030c 	and.w	r3, r3, #12
 8007e2e:	2b08      	cmp	r3, #8
 8007e30:	d1f9      	bne.n	8007e26 <stm32_clock_init+0xb6>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8007e32:	4a06      	ldr	r2, [pc, #24]	; (8007e4c <stm32_clock_init+0xdc>)
 8007e34:	4b05      	ldr	r3, [pc, #20]	; (8007e4c <stm32_clock_init+0xdc>)
 8007e36:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8007e38:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8007e3c:	6453      	str	r3, [r2, #68]	; 0x44
 8007e3e:	4a03      	ldr	r2, [pc, #12]	; (8007e4c <stm32_clock_init+0xdc>)
 8007e40:	4b02      	ldr	r3, [pc, #8]	; (8007e4c <stm32_clock_init+0xdc>)
 8007e42:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8007e44:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8007e48:	6653      	str	r3, [r2, #100]	; 0x64
}
 8007e4a:	4770      	bx	lr
 8007e4c:	40023800 	.word	0x40023800
 8007e50:	40007000 	.word	0x40007000
 8007e54:	07015410 	.word	0x07015410
 8007e58:	38881000 	.word	0x38881000
 8007e5c:	40023c00 	.word	0x40023c00

08007e60 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8007e60:	b500      	push	{lr}
 8007e62:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8007e64:	f002 fabc 	bl	800a3e0 <_stats_increase_irq>
 8007e68:	f003 fffa 	bl	800be60 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8007e6c:	4b0c      	ldr	r3, [pc, #48]	; (8007ea0 <Vector6C+0x40>)
 8007e6e:	681b      	ldr	r3, [r3, #0]
 8007e70:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8007e74:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 0U;
 8007e76:	4a0a      	ldr	r2, [pc, #40]	; (8007ea0 <Vector6C+0x40>)
 8007e78:	9b01      	ldr	r3, [sp, #4]
 8007e7a:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[0].dma_func)
 8007e7c:	4b09      	ldr	r3, [pc, #36]	; (8007ea4 <Vector6C+0x44>)
 8007e7e:	681b      	ldr	r3, [r3, #0]
 8007e80:	2b00      	cmp	r3, #0
 8007e82:	d006      	beq.n	8007e92 <Vector6C+0x32>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 8007e84:	4b07      	ldr	r3, [pc, #28]	; (8007ea4 <Vector6C+0x44>)
 8007e86:	681b      	ldr	r3, [r3, #0]
 8007e88:	4a06      	ldr	r2, [pc, #24]	; (8007ea4 <Vector6C+0x44>)
 8007e8a:	6852      	ldr	r2, [r2, #4]
 8007e8c:	4610      	mov	r0, r2
 8007e8e:	9901      	ldr	r1, [sp, #4]
 8007e90:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8007e92:	f004 f805 	bl	800bea0 <_dbg_check_leave_isr>
 8007e96:	f000 ff7b 	bl	8008d90 <_port_irq_epilogue>
}
 8007e9a:	b003      	add	sp, #12
 8007e9c:	f85d fb04 	ldr.w	pc, [sp], #4
 8007ea0:	40026000 	.word	0x40026000
 8007ea4:	20001334 	.word	0x20001334
	...

08007eb0 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8007eb0:	b500      	push	{lr}
 8007eb2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8007eb4:	f002 fa94 	bl	800a3e0 <_stats_increase_irq>
 8007eb8:	f003 ffd2 	bl	800be60 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8007ebc:	4b0d      	ldr	r3, [pc, #52]	; (8007ef4 <Vector70+0x44>)
 8007ebe:	681b      	ldr	r3, [r3, #0]
 8007ec0:	099b      	lsrs	r3, r3, #6
 8007ec2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8007ec6:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 6U;
 8007ec8:	4a0a      	ldr	r2, [pc, #40]	; (8007ef4 <Vector70+0x44>)
 8007eca:	9b01      	ldr	r3, [sp, #4]
 8007ecc:	019b      	lsls	r3, r3, #6
 8007ece:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[1].dma_func)
 8007ed0:	4b09      	ldr	r3, [pc, #36]	; (8007ef8 <Vector70+0x48>)
 8007ed2:	689b      	ldr	r3, [r3, #8]
 8007ed4:	2b00      	cmp	r3, #0
 8007ed6:	d006      	beq.n	8007ee6 <Vector70+0x36>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 8007ed8:	4b07      	ldr	r3, [pc, #28]	; (8007ef8 <Vector70+0x48>)
 8007eda:	689b      	ldr	r3, [r3, #8]
 8007edc:	4a06      	ldr	r2, [pc, #24]	; (8007ef8 <Vector70+0x48>)
 8007ede:	68d2      	ldr	r2, [r2, #12]
 8007ee0:	4610      	mov	r0, r2
 8007ee2:	9901      	ldr	r1, [sp, #4]
 8007ee4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8007ee6:	f003 ffdb 	bl	800bea0 <_dbg_check_leave_isr>
 8007eea:	f000 ff51 	bl	8008d90 <_port_irq_epilogue>
}
 8007eee:	b003      	add	sp, #12
 8007ef0:	f85d fb04 	ldr.w	pc, [sp], #4
 8007ef4:	40026000 	.word	0x40026000
 8007ef8:	20001334 	.word	0x20001334
 8007efc:	00000000 	.word	0x00000000

08007f00 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8007f00:	b500      	push	{lr}
 8007f02:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8007f04:	f002 fa6c 	bl	800a3e0 <_stats_increase_irq>
 8007f08:	f003 ffaa 	bl	800be60 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8007f0c:	4b0d      	ldr	r3, [pc, #52]	; (8007f44 <Vector74+0x44>)
 8007f0e:	681b      	ldr	r3, [r3, #0]
 8007f10:	0c1b      	lsrs	r3, r3, #16
 8007f12:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8007f16:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 16U;
 8007f18:	4a0a      	ldr	r2, [pc, #40]	; (8007f44 <Vector74+0x44>)
 8007f1a:	9b01      	ldr	r3, [sp, #4]
 8007f1c:	041b      	lsls	r3, r3, #16
 8007f1e:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[2].dma_func)
 8007f20:	4b09      	ldr	r3, [pc, #36]	; (8007f48 <Vector74+0x48>)
 8007f22:	691b      	ldr	r3, [r3, #16]
 8007f24:	2b00      	cmp	r3, #0
 8007f26:	d006      	beq.n	8007f36 <Vector74+0x36>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 8007f28:	4b07      	ldr	r3, [pc, #28]	; (8007f48 <Vector74+0x48>)
 8007f2a:	691b      	ldr	r3, [r3, #16]
 8007f2c:	4a06      	ldr	r2, [pc, #24]	; (8007f48 <Vector74+0x48>)
 8007f2e:	6952      	ldr	r2, [r2, #20]
 8007f30:	4610      	mov	r0, r2
 8007f32:	9901      	ldr	r1, [sp, #4]
 8007f34:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8007f36:	f003 ffb3 	bl	800bea0 <_dbg_check_leave_isr>
 8007f3a:	f000 ff29 	bl	8008d90 <_port_irq_epilogue>
}
 8007f3e:	b003      	add	sp, #12
 8007f40:	f85d fb04 	ldr.w	pc, [sp], #4
 8007f44:	40026000 	.word	0x40026000
 8007f48:	20001334 	.word	0x20001334
 8007f4c:	00000000 	.word	0x00000000

08007f50 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8007f50:	b500      	push	{lr}
 8007f52:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8007f54:	f002 fa44 	bl	800a3e0 <_stats_increase_irq>
 8007f58:	f003 ff82 	bl	800be60 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8007f5c:	4b0d      	ldr	r3, [pc, #52]	; (8007f94 <Vector78+0x44>)
 8007f5e:	681b      	ldr	r3, [r3, #0]
 8007f60:	0d9b      	lsrs	r3, r3, #22
 8007f62:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8007f66:	9301      	str	r3, [sp, #4]
  DMA1->LIFCR = flags << 22U;
 8007f68:	4a0a      	ldr	r2, [pc, #40]	; (8007f94 <Vector78+0x44>)
 8007f6a:	9b01      	ldr	r3, [sp, #4]
 8007f6c:	059b      	lsls	r3, r3, #22
 8007f6e:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[3].dma_func)
 8007f70:	4b09      	ldr	r3, [pc, #36]	; (8007f98 <Vector78+0x48>)
 8007f72:	699b      	ldr	r3, [r3, #24]
 8007f74:	2b00      	cmp	r3, #0
 8007f76:	d006      	beq.n	8007f86 <Vector78+0x36>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 8007f78:	4b07      	ldr	r3, [pc, #28]	; (8007f98 <Vector78+0x48>)
 8007f7a:	699b      	ldr	r3, [r3, #24]
 8007f7c:	4a06      	ldr	r2, [pc, #24]	; (8007f98 <Vector78+0x48>)
 8007f7e:	69d2      	ldr	r2, [r2, #28]
 8007f80:	4610      	mov	r0, r2
 8007f82:	9901      	ldr	r1, [sp, #4]
 8007f84:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8007f86:	f003 ff8b 	bl	800bea0 <_dbg_check_leave_isr>
 8007f8a:	f000 ff01 	bl	8008d90 <_port_irq_epilogue>
}
 8007f8e:	b003      	add	sp, #12
 8007f90:	f85d fb04 	ldr.w	pc, [sp], #4
 8007f94:	40026000 	.word	0x40026000
 8007f98:	20001334 	.word	0x20001334
 8007f9c:	00000000 	.word	0x00000000

08007fa0 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8007fa0:	b500      	push	{lr}
 8007fa2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8007fa4:	f002 fa1c 	bl	800a3e0 <_stats_increase_irq>
 8007fa8:	f003 ff5a 	bl	800be60 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8007fac:	4b0c      	ldr	r3, [pc, #48]	; (8007fe0 <Vector7C+0x40>)
 8007fae:	685b      	ldr	r3, [r3, #4]
 8007fb0:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8007fb4:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 0U;
 8007fb6:	4a0a      	ldr	r2, [pc, #40]	; (8007fe0 <Vector7C+0x40>)
 8007fb8:	9b01      	ldr	r3, [sp, #4]
 8007fba:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[4].dma_func)
 8007fbc:	4b09      	ldr	r3, [pc, #36]	; (8007fe4 <Vector7C+0x44>)
 8007fbe:	6a1b      	ldr	r3, [r3, #32]
 8007fc0:	2b00      	cmp	r3, #0
 8007fc2:	d006      	beq.n	8007fd2 <Vector7C+0x32>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 8007fc4:	4b07      	ldr	r3, [pc, #28]	; (8007fe4 <Vector7C+0x44>)
 8007fc6:	6a1b      	ldr	r3, [r3, #32]
 8007fc8:	4a06      	ldr	r2, [pc, #24]	; (8007fe4 <Vector7C+0x44>)
 8007fca:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8007fcc:	4610      	mov	r0, r2
 8007fce:	9901      	ldr	r1, [sp, #4]
 8007fd0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8007fd2:	f003 ff65 	bl	800bea0 <_dbg_check_leave_isr>
 8007fd6:	f000 fedb 	bl	8008d90 <_port_irq_epilogue>
}
 8007fda:	b003      	add	sp, #12
 8007fdc:	f85d fb04 	ldr.w	pc, [sp], #4
 8007fe0:	40026000 	.word	0x40026000
 8007fe4:	20001334 	.word	0x20001334
	...

08007ff0 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8007ff0:	b500      	push	{lr}
 8007ff2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8007ff4:	f002 f9f4 	bl	800a3e0 <_stats_increase_irq>
 8007ff8:	f003 ff32 	bl	800be60 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8007ffc:	4b0d      	ldr	r3, [pc, #52]	; (8008034 <Vector80+0x44>)
 8007ffe:	685b      	ldr	r3, [r3, #4]
 8008000:	099b      	lsrs	r3, r3, #6
 8008002:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8008006:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 6U;
 8008008:	4a0a      	ldr	r2, [pc, #40]	; (8008034 <Vector80+0x44>)
 800800a:	9b01      	ldr	r3, [sp, #4]
 800800c:	019b      	lsls	r3, r3, #6
 800800e:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[5].dma_func)
 8008010:	4b09      	ldr	r3, [pc, #36]	; (8008038 <Vector80+0x48>)
 8008012:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008014:	2b00      	cmp	r3, #0
 8008016:	d006      	beq.n	8008026 <Vector80+0x36>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 8008018:	4b07      	ldr	r3, [pc, #28]	; (8008038 <Vector80+0x48>)
 800801a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800801c:	4a06      	ldr	r2, [pc, #24]	; (8008038 <Vector80+0x48>)
 800801e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8008020:	4610      	mov	r0, r2
 8008022:	9901      	ldr	r1, [sp, #4]
 8008024:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8008026:	f003 ff3b 	bl	800bea0 <_dbg_check_leave_isr>
 800802a:	f000 feb1 	bl	8008d90 <_port_irq_epilogue>
}
 800802e:	b003      	add	sp, #12
 8008030:	f85d fb04 	ldr.w	pc, [sp], #4
 8008034:	40026000 	.word	0x40026000
 8008038:	20001334 	.word	0x20001334
 800803c:	00000000 	.word	0x00000000

08008040 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8008040:	b500      	push	{lr}
 8008042:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8008044:	f002 f9cc 	bl	800a3e0 <_stats_increase_irq>
 8008048:	f003 ff0a 	bl	800be60 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800804c:	4b0d      	ldr	r3, [pc, #52]	; (8008084 <Vector84+0x44>)
 800804e:	685b      	ldr	r3, [r3, #4]
 8008050:	0c1b      	lsrs	r3, r3, #16
 8008052:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8008056:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 16U;
 8008058:	4a0a      	ldr	r2, [pc, #40]	; (8008084 <Vector84+0x44>)
 800805a:	9b01      	ldr	r3, [sp, #4]
 800805c:	041b      	lsls	r3, r3, #16
 800805e:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[6].dma_func)
 8008060:	4b09      	ldr	r3, [pc, #36]	; (8008088 <Vector84+0x48>)
 8008062:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008064:	2b00      	cmp	r3, #0
 8008066:	d006      	beq.n	8008076 <Vector84+0x36>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 8008068:	4b07      	ldr	r3, [pc, #28]	; (8008088 <Vector84+0x48>)
 800806a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800806c:	4a06      	ldr	r2, [pc, #24]	; (8008088 <Vector84+0x48>)
 800806e:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8008070:	4610      	mov	r0, r2
 8008072:	9901      	ldr	r1, [sp, #4]
 8008074:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8008076:	f003 ff13 	bl	800bea0 <_dbg_check_leave_isr>
 800807a:	f000 fe89 	bl	8008d90 <_port_irq_epilogue>
}
 800807e:	b003      	add	sp, #12
 8008080:	f85d fb04 	ldr.w	pc, [sp], #4
 8008084:	40026000 	.word	0x40026000
 8008088:	20001334 	.word	0x20001334
 800808c:	00000000 	.word	0x00000000

08008090 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8008090:	b500      	push	{lr}
 8008092:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8008094:	f002 f9a4 	bl	800a3e0 <_stats_increase_irq>
 8008098:	f003 fee2 	bl	800be60 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800809c:	4b0d      	ldr	r3, [pc, #52]	; (80080d4 <VectorFC+0x44>)
 800809e:	685b      	ldr	r3, [r3, #4]
 80080a0:	0d9b      	lsrs	r3, r3, #22
 80080a2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80080a6:	9301      	str	r3, [sp, #4]
  DMA1->HIFCR = flags << 22U;
 80080a8:	4a0a      	ldr	r2, [pc, #40]	; (80080d4 <VectorFC+0x44>)
 80080aa:	9b01      	ldr	r3, [sp, #4]
 80080ac:	059b      	lsls	r3, r3, #22
 80080ae:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[7].dma_func)
 80080b0:	4b09      	ldr	r3, [pc, #36]	; (80080d8 <VectorFC+0x48>)
 80080b2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80080b4:	2b00      	cmp	r3, #0
 80080b6:	d006      	beq.n	80080c6 <VectorFC+0x36>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 80080b8:	4b07      	ldr	r3, [pc, #28]	; (80080d8 <VectorFC+0x48>)
 80080ba:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80080bc:	4a06      	ldr	r2, [pc, #24]	; (80080d8 <VectorFC+0x48>)
 80080be:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 80080c0:	4610      	mov	r0, r2
 80080c2:	9901      	ldr	r1, [sp, #4]
 80080c4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80080c6:	f003 feeb 	bl	800bea0 <_dbg_check_leave_isr>
 80080ca:	f000 fe61 	bl	8008d90 <_port_irq_epilogue>
}
 80080ce:	b003      	add	sp, #12
 80080d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80080d4:	40026000 	.word	0x40026000
 80080d8:	20001334 	.word	0x20001334
 80080dc:	00000000 	.word	0x00000000

080080e0 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 80080e0:	b500      	push	{lr}
 80080e2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80080e4:	f002 f97c 	bl	800a3e0 <_stats_increase_irq>
 80080e8:	f003 feba 	bl	800be60 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 80080ec:	4b0c      	ldr	r3, [pc, #48]	; (8008120 <Vector120+0x40>)
 80080ee:	681b      	ldr	r3, [r3, #0]
 80080f0:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80080f4:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 0U;
 80080f6:	4a0a      	ldr	r2, [pc, #40]	; (8008120 <Vector120+0x40>)
 80080f8:	9b01      	ldr	r3, [sp, #4]
 80080fa:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[8].dma_func)
 80080fc:	4b09      	ldr	r3, [pc, #36]	; (8008124 <Vector120+0x44>)
 80080fe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008100:	2b00      	cmp	r3, #0
 8008102:	d006      	beq.n	8008112 <Vector120+0x32>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 8008104:	4b07      	ldr	r3, [pc, #28]	; (8008124 <Vector120+0x44>)
 8008106:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008108:	4a06      	ldr	r2, [pc, #24]	; (8008124 <Vector120+0x44>)
 800810a:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800810c:	4610      	mov	r0, r2
 800810e:	9901      	ldr	r1, [sp, #4]
 8008110:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8008112:	f003 fec5 	bl	800bea0 <_dbg_check_leave_isr>
 8008116:	f000 fe3b 	bl	8008d90 <_port_irq_epilogue>
}
 800811a:	b003      	add	sp, #12
 800811c:	f85d fb04 	ldr.w	pc, [sp], #4
 8008120:	40026400 	.word	0x40026400
 8008124:	20001334 	.word	0x20001334
	...

08008130 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8008130:	b500      	push	{lr}
 8008132:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8008134:	f002 f954 	bl	800a3e0 <_stats_increase_irq>
 8008138:	f003 fe92 	bl	800be60 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 800813c:	4b0d      	ldr	r3, [pc, #52]	; (8008174 <Vector124+0x44>)
 800813e:	681b      	ldr	r3, [r3, #0]
 8008140:	099b      	lsrs	r3, r3, #6
 8008142:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8008146:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 6U;
 8008148:	4a0a      	ldr	r2, [pc, #40]	; (8008174 <Vector124+0x44>)
 800814a:	9b01      	ldr	r3, [sp, #4]
 800814c:	019b      	lsls	r3, r3, #6
 800814e:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[9].dma_func)
 8008150:	4b09      	ldr	r3, [pc, #36]	; (8008178 <Vector124+0x48>)
 8008152:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8008154:	2b00      	cmp	r3, #0
 8008156:	d006      	beq.n	8008166 <Vector124+0x36>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 8008158:	4b07      	ldr	r3, [pc, #28]	; (8008178 <Vector124+0x48>)
 800815a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800815c:	4a06      	ldr	r2, [pc, #24]	; (8008178 <Vector124+0x48>)
 800815e:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8008160:	4610      	mov	r0, r2
 8008162:	9901      	ldr	r1, [sp, #4]
 8008164:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8008166:	f003 fe9b 	bl	800bea0 <_dbg_check_leave_isr>
 800816a:	f000 fe11 	bl	8008d90 <_port_irq_epilogue>
}
 800816e:	b003      	add	sp, #12
 8008170:	f85d fb04 	ldr.w	pc, [sp], #4
 8008174:	40026400 	.word	0x40026400
 8008178:	20001334 	.word	0x20001334
 800817c:	00000000 	.word	0x00000000

08008180 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8008180:	b500      	push	{lr}
 8008182:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8008184:	f002 f92c 	bl	800a3e0 <_stats_increase_irq>
 8008188:	f003 fe6a 	bl	800be60 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 800818c:	4b0d      	ldr	r3, [pc, #52]	; (80081c4 <Vector128+0x44>)
 800818e:	681b      	ldr	r3, [r3, #0]
 8008190:	0c1b      	lsrs	r3, r3, #16
 8008192:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8008196:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 16U;
 8008198:	4a0a      	ldr	r2, [pc, #40]	; (80081c4 <Vector128+0x44>)
 800819a:	9b01      	ldr	r3, [sp, #4]
 800819c:	041b      	lsls	r3, r3, #16
 800819e:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[10].dma_func)
 80081a0:	4b09      	ldr	r3, [pc, #36]	; (80081c8 <Vector128+0x48>)
 80081a2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80081a4:	2b00      	cmp	r3, #0
 80081a6:	d006      	beq.n	80081b6 <Vector128+0x36>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 80081a8:	4b07      	ldr	r3, [pc, #28]	; (80081c8 <Vector128+0x48>)
 80081aa:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80081ac:	4a06      	ldr	r2, [pc, #24]	; (80081c8 <Vector128+0x48>)
 80081ae:	6d52      	ldr	r2, [r2, #84]	; 0x54
 80081b0:	4610      	mov	r0, r2
 80081b2:	9901      	ldr	r1, [sp, #4]
 80081b4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80081b6:	f003 fe73 	bl	800bea0 <_dbg_check_leave_isr>
 80081ba:	f000 fde9 	bl	8008d90 <_port_irq_epilogue>
}
 80081be:	b003      	add	sp, #12
 80081c0:	f85d fb04 	ldr.w	pc, [sp], #4
 80081c4:	40026400 	.word	0x40026400
 80081c8:	20001334 	.word	0x20001334
 80081cc:	00000000 	.word	0x00000000

080081d0 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 80081d0:	b500      	push	{lr}
 80081d2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80081d4:	f002 f904 	bl	800a3e0 <_stats_increase_irq>
 80081d8:	f003 fe42 	bl	800be60 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80081dc:	4b0d      	ldr	r3, [pc, #52]	; (8008214 <Vector12C+0x44>)
 80081de:	681b      	ldr	r3, [r3, #0]
 80081e0:	0d9b      	lsrs	r3, r3, #22
 80081e2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80081e6:	9301      	str	r3, [sp, #4]
  DMA2->LIFCR = flags << 22U;
 80081e8:	4a0a      	ldr	r2, [pc, #40]	; (8008214 <Vector12C+0x44>)
 80081ea:	9b01      	ldr	r3, [sp, #4]
 80081ec:	059b      	lsls	r3, r3, #22
 80081ee:	6093      	str	r3, [r2, #8]
  if (dma_isr_redir[11].dma_func)
 80081f0:	4b09      	ldr	r3, [pc, #36]	; (8008218 <Vector12C+0x48>)
 80081f2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80081f4:	2b00      	cmp	r3, #0
 80081f6:	d006      	beq.n	8008206 <Vector12C+0x36>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 80081f8:	4b07      	ldr	r3, [pc, #28]	; (8008218 <Vector12C+0x48>)
 80081fa:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80081fc:	4a06      	ldr	r2, [pc, #24]	; (8008218 <Vector12C+0x48>)
 80081fe:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 8008200:	4610      	mov	r0, r2
 8008202:	9901      	ldr	r1, [sp, #4]
 8008204:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8008206:	f003 fe4b 	bl	800bea0 <_dbg_check_leave_isr>
 800820a:	f000 fdc1 	bl	8008d90 <_port_irq_epilogue>
}
 800820e:	b003      	add	sp, #12
 8008210:	f85d fb04 	ldr.w	pc, [sp], #4
 8008214:	40026400 	.word	0x40026400
 8008218:	20001334 	.word	0x20001334
 800821c:	00000000 	.word	0x00000000

08008220 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8008220:	b500      	push	{lr}
 8008222:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8008224:	f002 f8dc 	bl	800a3e0 <_stats_increase_irq>
 8008228:	f003 fe1a 	bl	800be60 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800822c:	4b0c      	ldr	r3, [pc, #48]	; (8008260 <Vector130+0x40>)
 800822e:	685b      	ldr	r3, [r3, #4]
 8008230:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8008234:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 0U;
 8008236:	4a0a      	ldr	r2, [pc, #40]	; (8008260 <Vector130+0x40>)
 8008238:	9b01      	ldr	r3, [sp, #4]
 800823a:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[12].dma_func)
 800823c:	4b09      	ldr	r3, [pc, #36]	; (8008264 <Vector130+0x44>)
 800823e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8008240:	2b00      	cmp	r3, #0
 8008242:	d006      	beq.n	8008252 <Vector130+0x32>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 8008244:	4b07      	ldr	r3, [pc, #28]	; (8008264 <Vector130+0x44>)
 8008246:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8008248:	4a06      	ldr	r2, [pc, #24]	; (8008264 <Vector130+0x44>)
 800824a:	6e52      	ldr	r2, [r2, #100]	; 0x64
 800824c:	4610      	mov	r0, r2
 800824e:	9901      	ldr	r1, [sp, #4]
 8008250:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8008252:	f003 fe25 	bl	800bea0 <_dbg_check_leave_isr>
 8008256:	f000 fd9b 	bl	8008d90 <_port_irq_epilogue>
}
 800825a:	b003      	add	sp, #12
 800825c:	f85d fb04 	ldr.w	pc, [sp], #4
 8008260:	40026400 	.word	0x40026400
 8008264:	20001334 	.word	0x20001334
	...

08008270 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8008270:	b500      	push	{lr}
 8008272:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8008274:	f002 f8b4 	bl	800a3e0 <_stats_increase_irq>
 8008278:	f003 fdf2 	bl	800be60 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800827c:	4b0d      	ldr	r3, [pc, #52]	; (80082b4 <Vector150+0x44>)
 800827e:	685b      	ldr	r3, [r3, #4]
 8008280:	099b      	lsrs	r3, r3, #6
 8008282:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8008286:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 6U;
 8008288:	4a0a      	ldr	r2, [pc, #40]	; (80082b4 <Vector150+0x44>)
 800828a:	9b01      	ldr	r3, [sp, #4]
 800828c:	019b      	lsls	r3, r3, #6
 800828e:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[13].dma_func)
 8008290:	4b09      	ldr	r3, [pc, #36]	; (80082b8 <Vector150+0x48>)
 8008292:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8008294:	2b00      	cmp	r3, #0
 8008296:	d006      	beq.n	80082a6 <Vector150+0x36>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 8008298:	4b07      	ldr	r3, [pc, #28]	; (80082b8 <Vector150+0x48>)
 800829a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 800829c:	4a06      	ldr	r2, [pc, #24]	; (80082b8 <Vector150+0x48>)
 800829e:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
 80082a0:	4610      	mov	r0, r2
 80082a2:	9901      	ldr	r1, [sp, #4]
 80082a4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80082a6:	f003 fdfb 	bl	800bea0 <_dbg_check_leave_isr>
 80082aa:	f000 fd71 	bl	8008d90 <_port_irq_epilogue>
}
 80082ae:	b003      	add	sp, #12
 80082b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80082b4:	40026400 	.word	0x40026400
 80082b8:	20001334 	.word	0x20001334
 80082bc:	00000000 	.word	0x00000000

080082c0 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 80082c0:	b500      	push	{lr}
 80082c2:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80082c4:	f002 f88c 	bl	800a3e0 <_stats_increase_irq>
 80082c8:	f003 fdca 	bl	800be60 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80082cc:	4b0d      	ldr	r3, [pc, #52]	; (8008304 <Vector154+0x44>)
 80082ce:	685b      	ldr	r3, [r3, #4]
 80082d0:	0c1b      	lsrs	r3, r3, #16
 80082d2:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80082d6:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 16U;
 80082d8:	4a0a      	ldr	r2, [pc, #40]	; (8008304 <Vector154+0x44>)
 80082da:	9b01      	ldr	r3, [sp, #4]
 80082dc:	041b      	lsls	r3, r3, #16
 80082de:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[14].dma_func)
 80082e0:	4b09      	ldr	r3, [pc, #36]	; (8008308 <Vector154+0x48>)
 80082e2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80082e4:	2b00      	cmp	r3, #0
 80082e6:	d006      	beq.n	80082f6 <Vector154+0x36>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 80082e8:	4b07      	ldr	r3, [pc, #28]	; (8008308 <Vector154+0x48>)
 80082ea:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80082ec:	4a06      	ldr	r2, [pc, #24]	; (8008308 <Vector154+0x48>)
 80082ee:	6f52      	ldr	r2, [r2, #116]	; 0x74
 80082f0:	4610      	mov	r0, r2
 80082f2:	9901      	ldr	r1, [sp, #4]
 80082f4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80082f6:	f003 fdd3 	bl	800bea0 <_dbg_check_leave_isr>
 80082fa:	f000 fd49 	bl	8008d90 <_port_irq_epilogue>
}
 80082fe:	b003      	add	sp, #12
 8008300:	f85d fb04 	ldr.w	pc, [sp], #4
 8008304:	40026400 	.word	0x40026400
 8008308:	20001334 	.word	0x20001334
 800830c:	00000000 	.word	0x00000000

08008310 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8008310:	b500      	push	{lr}
 8008312:	b083      	sub	sp, #12
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8008314:	f002 f864 	bl	800a3e0 <_stats_increase_irq>
 8008318:	f003 fda2 	bl	800be60 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800831c:	4b0d      	ldr	r3, [pc, #52]	; (8008354 <Vector158+0x44>)
 800831e:	685b      	ldr	r3, [r3, #4]
 8008320:	0d9b      	lsrs	r3, r3, #22
 8008322:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8008326:	9301      	str	r3, [sp, #4]
  DMA2->HIFCR = flags << 22U;
 8008328:	4a0a      	ldr	r2, [pc, #40]	; (8008354 <Vector158+0x44>)
 800832a:	9b01      	ldr	r3, [sp, #4]
 800832c:	059b      	lsls	r3, r3, #22
 800832e:	60d3      	str	r3, [r2, #12]
  if (dma_isr_redir[15].dma_func)
 8008330:	4b09      	ldr	r3, [pc, #36]	; (8008358 <Vector158+0x48>)
 8008332:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8008334:	2b00      	cmp	r3, #0
 8008336:	d006      	beq.n	8008346 <Vector158+0x36>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 8008338:	4b07      	ldr	r3, [pc, #28]	; (8008358 <Vector158+0x48>)
 800833a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800833c:	4a06      	ldr	r2, [pc, #24]	; (8008358 <Vector158+0x48>)
 800833e:	6fd2      	ldr	r2, [r2, #124]	; 0x7c
 8008340:	4610      	mov	r0, r2
 8008342:	9901      	ldr	r1, [sp, #4]
 8008344:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8008346:	f003 fdab 	bl	800bea0 <_dbg_check_leave_isr>
 800834a:	f000 fd21 	bl	8008d90 <_port_irq_epilogue>
}
 800834e:	b003      	add	sp, #12
 8008350:	f85d fb04 	ldr.w	pc, [sp], #4
 8008354:	40026400 	.word	0x40026400
 8008358:	20001334 	.word	0x20001334
 800835c:	00000000 	.word	0x00000000

08008360 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8008360:	b082      	sub	sp, #8
  unsigned i;

  dma_streams_mask = 0U;
 8008362:	4b16      	ldr	r3, [pc, #88]	; (80083bc <dmaInit+0x5c>)
 8008364:	2200      	movs	r2, #0
 8008366:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8008368:	2300      	movs	r3, #0
 800836a:	9301      	str	r3, [sp, #4]
 800836c:	e011      	b.n	8008392 <dmaInit+0x32>
    _stm32_dma_streams[i].stream->CR = 0U;
 800836e:	4914      	ldr	r1, [pc, #80]	; (80083c0 <dmaInit+0x60>)
 8008370:	9a01      	ldr	r2, [sp, #4]
 8008372:	4613      	mov	r3, r2
 8008374:	005b      	lsls	r3, r3, #1
 8008376:	4413      	add	r3, r2
 8008378:	009b      	lsls	r3, r3, #2
 800837a:	440b      	add	r3, r1
 800837c:	681b      	ldr	r3, [r3, #0]
 800837e:	2200      	movs	r2, #0
 8008380:	601a      	str	r2, [r3, #0]
    dma_isr_redir[i].dma_func = NULL;
 8008382:	4a10      	ldr	r2, [pc, #64]	; (80083c4 <dmaInit+0x64>)
 8008384:	9b01      	ldr	r3, [sp, #4]
 8008386:	2100      	movs	r1, #0
 8008388:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 800838c:	9b01      	ldr	r3, [sp, #4]
 800838e:	3301      	adds	r3, #1
 8008390:	9301      	str	r3, [sp, #4]
 8008392:	9b01      	ldr	r3, [sp, #4]
 8008394:	2b0f      	cmp	r3, #15
 8008396:	d9ea      	bls.n	800836e <dmaInit+0xe>
    _stm32_dma_streams[i].stream->CR = 0U;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 8008398:	4b0b      	ldr	r3, [pc, #44]	; (80083c8 <dmaInit+0x68>)
 800839a:	f04f 32ff 	mov.w	r2, #4294967295
 800839e:	609a      	str	r2, [r3, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
 80083a0:	4b09      	ldr	r3, [pc, #36]	; (80083c8 <dmaInit+0x68>)
 80083a2:	f04f 32ff 	mov.w	r2, #4294967295
 80083a6:	60da      	str	r2, [r3, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 80083a8:	4b08      	ldr	r3, [pc, #32]	; (80083cc <dmaInit+0x6c>)
 80083aa:	f04f 32ff 	mov.w	r2, #4294967295
 80083ae:	609a      	str	r2, [r3, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
 80083b0:	4b06      	ldr	r3, [pc, #24]	; (80083cc <dmaInit+0x6c>)
 80083b2:	f04f 32ff 	mov.w	r2, #4294967295
 80083b6:	60da      	str	r2, [r3, #12]
}
 80083b8:	b002      	add	sp, #8
 80083ba:	4770      	bx	lr
 80083bc:	20001330 	.word	0x20001330
 80083c0:	0800e240 	.word	0x0800e240
 80083c4:	20001334 	.word	0x20001334
 80083c8:	40026000 	.word	0x40026000
 80083cc:	40026400 	.word	0x40026400

080083d0 <dmaStreamAllocate>:
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 80083d0:	b500      	push	{lr}
 80083d2:	b085      	sub	sp, #20
 80083d4:	9003      	str	r0, [sp, #12]
 80083d6:	9102      	str	r1, [sp, #8]
 80083d8:	9201      	str	r2, [sp, #4]
 80083da:	9300      	str	r3, [sp, #0]

  osalDbgCheck(dmastp != NULL);
 80083dc:	9b03      	ldr	r3, [sp, #12]
 80083de:	2b00      	cmp	r3, #0
 80083e0:	d102      	bne.n	80083e8 <dmaStreamAllocate+0x18>
 80083e2:	4836      	ldr	r0, [pc, #216]	; (80084bc <dmaStreamAllocate+0xec>)
 80083e4:	f003 fb84 	bl	800baf0 <chSysHalt>

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 80083e8:	9b03      	ldr	r3, [sp, #12]
 80083ea:	7a5b      	ldrb	r3, [r3, #9]
 80083ec:	461a      	mov	r2, r3
 80083ee:	2301      	movs	r3, #1
 80083f0:	fa03 f202 	lsl.w	r2, r3, r2
 80083f4:	4b32      	ldr	r3, [pc, #200]	; (80084c0 <dmaStreamAllocate+0xf0>)
 80083f6:	681b      	ldr	r3, [r3, #0]
 80083f8:	4013      	ands	r3, r2
 80083fa:	2b00      	cmp	r3, #0
 80083fc:	d001      	beq.n	8008402 <dmaStreamAllocate+0x32>
    return true;
 80083fe:	2301      	movs	r3, #1
 8008400:	e058      	b.n	80084b4 <dmaStreamAllocate+0xe4>

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8008402:	9b03      	ldr	r3, [sp, #12]
 8008404:	7a5b      	ldrb	r3, [r3, #9]
 8008406:	4619      	mov	r1, r3
 8008408:	4a2e      	ldr	r2, [pc, #184]	; (80084c4 <dmaStreamAllocate+0xf4>)
 800840a:	9b01      	ldr	r3, [sp, #4]
 800840c:	f842 3031 	str.w	r3, [r2, r1, lsl #3]
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8008410:	9b03      	ldr	r3, [sp, #12]
 8008412:	7a5b      	ldrb	r3, [r3, #9]
 8008414:	4a2b      	ldr	r2, [pc, #172]	; (80084c4 <dmaStreamAllocate+0xf4>)
 8008416:	00db      	lsls	r3, r3, #3
 8008418:	4413      	add	r3, r2
 800841a:	9a00      	ldr	r2, [sp, #0]
 800841c:	605a      	str	r2, [r3, #4]
  dma_streams_mask |= (1U << dmastp->selfindex);
 800841e:	9b03      	ldr	r3, [sp, #12]
 8008420:	7a5b      	ldrb	r3, [r3, #9]
 8008422:	461a      	mov	r2, r3
 8008424:	2301      	movs	r3, #1
 8008426:	fa03 f202 	lsl.w	r2, r3, r2
 800842a:	4b25      	ldr	r3, [pc, #148]	; (80084c0 <dmaStreamAllocate+0xf0>)
 800842c:	681b      	ldr	r3, [r3, #0]
 800842e:	4313      	orrs	r3, r2
 8008430:	4a23      	ldr	r2, [pc, #140]	; (80084c0 <dmaStreamAllocate+0xf0>)
 8008432:	6013      	str	r3, [r2, #0]

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
 8008434:	4b22      	ldr	r3, [pc, #136]	; (80084c0 <dmaStreamAllocate+0xf0>)
 8008436:	681b      	ldr	r3, [r3, #0]
 8008438:	b2db      	uxtb	r3, r3
 800843a:	2b00      	cmp	r3, #0
 800843c:	d005      	beq.n	800844a <dmaStreamAllocate+0x7a>
    rccEnableDMA1(false);
 800843e:	4a22      	ldr	r2, [pc, #136]	; (80084c8 <dmaStreamAllocate+0xf8>)
 8008440:	4b21      	ldr	r3, [pc, #132]	; (80084c8 <dmaStreamAllocate+0xf8>)
 8008442:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008444:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8008448:	6313      	str	r3, [r2, #48]	; 0x30
  }
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
 800844a:	4b1d      	ldr	r3, [pc, #116]	; (80084c0 <dmaStreamAllocate+0xf0>)
 800844c:	681b      	ldr	r3, [r3, #0]
 800844e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8008452:	2b00      	cmp	r3, #0
 8008454:	d005      	beq.n	8008462 <dmaStreamAllocate+0x92>
    rccEnableDMA2(false);
 8008456:	4a1c      	ldr	r2, [pc, #112]	; (80084c8 <dmaStreamAllocate+0xf8>)
 8008458:	4b1b      	ldr	r3, [pc, #108]	; (80084c8 <dmaStreamAllocate+0xf8>)
 800845a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800845c:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8008460:	6313      	str	r3, [r2, #48]	; 0x30
  }

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8008462:	9b03      	ldr	r3, [sp, #12]
 8008464:	681b      	ldr	r3, [r3, #0]
 8008466:	9a03      	ldr	r2, [sp, #12]
 8008468:	6812      	ldr	r2, [r2, #0]
 800846a:	6812      	ldr	r2, [r2, #0]
 800846c:	f022 021f 	bic.w	r2, r2, #31
 8008470:	601a      	str	r2, [r3, #0]
 8008472:	9b03      	ldr	r3, [sp, #12]
 8008474:	681b      	ldr	r3, [r3, #0]
 8008476:	681b      	ldr	r3, [r3, #0]
 8008478:	f003 0301 	and.w	r3, r3, #1
 800847c:	2b00      	cmp	r3, #0
 800847e:	d1f8      	bne.n	8008472 <dmaStreamAllocate+0xa2>
 8008480:	9b03      	ldr	r3, [sp, #12]
 8008482:	685b      	ldr	r3, [r3, #4]
 8008484:	9a03      	ldr	r2, [sp, #12]
 8008486:	7a12      	ldrb	r2, [r2, #8]
 8008488:	4611      	mov	r1, r2
 800848a:	223d      	movs	r2, #61	; 0x3d
 800848c:	408a      	lsls	r2, r1
 800848e:	601a      	str	r2, [r3, #0]
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 8008490:	9b03      	ldr	r3, [sp, #12]
 8008492:	681b      	ldr	r3, [r3, #0]
 8008494:	2200      	movs	r2, #0
 8008496:	601a      	str	r2, [r3, #0]
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 8008498:	9b03      	ldr	r3, [sp, #12]
 800849a:	681b      	ldr	r3, [r3, #0]
 800849c:	2221      	movs	r2, #33	; 0x21
 800849e:	615a      	str	r2, [r3, #20]

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL) {
 80084a0:	9b01      	ldr	r3, [sp, #4]
 80084a2:	2b00      	cmp	r3, #0
 80084a4:	d005      	beq.n	80084b2 <dmaStreamAllocate+0xe2>
    nvicEnableVector(dmastp->vector, priority);
 80084a6:	9b03      	ldr	r3, [sp, #12]
 80084a8:	7a9b      	ldrb	r3, [r3, #10]
 80084aa:	4618      	mov	r0, r3
 80084ac:	9902      	ldr	r1, [sp, #8]
 80084ae:	f7ff fbd7 	bl	8007c60 <nvicEnableVector>
  }

  return false;
 80084b2:	2300      	movs	r3, #0
}
 80084b4:	4618      	mov	r0, r3
 80084b6:	b005      	add	sp, #20
 80084b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80084bc:	0800e300 	.word	0x0800e300
 80084c0:	20001330 	.word	0x20001330
 80084c4:	20001334 	.word	0x20001334
 80084c8:	40023800 	.word	0x40023800
 80084cc:	00000000 	.word	0x00000000

080084d0 <port_lock.lto_priv.275>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80084d0:	b082      	sub	sp, #8
 80084d2:	2320      	movs	r3, #32
 80084d4:	9301      	str	r3, [sp, #4]
 80084d6:	9b01      	ldr	r3, [sp, #4]
 80084d8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80084dc:	b002      	add	sp, #8
 80084de:	4770      	bx	lr

080084e0 <port_unlock.lto_priv.272>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80084e0:	b082      	sub	sp, #8
 80084e2:	2300      	movs	r3, #0
 80084e4:	9301      	str	r3, [sp, #4]
 80084e6:	9b01      	ldr	r3, [sp, #4]
 80084e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80084ec:	b002      	add	sp, #8
 80084ee:	4770      	bx	lr

080084f0 <port_lock_from_isr.lto_priv.257>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80084f0:	b508      	push	{r3, lr}

  port_lock();
 80084f2:	f7ff ffed 	bl	80084d0 <port_lock.lto_priv.275>
}
 80084f6:	bd08      	pop	{r3, pc}
	...

08008500 <port_unlock_from_isr.lto_priv.254>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8008500:	b508      	push	{r3, lr}

  port_unlock();
 8008502:	f7ff ffed 	bl	80084e0 <port_unlock.lto_priv.272>
}
 8008506:	bd08      	pop	{r3, pc}
	...

08008510 <chOQResetI>:
 *
 * @param[in] oqp       pointer to an @p output_queue_t structure
 *
 * @iclass
 */
void chOQResetI(output_queue_t *oqp) {
 8008510:	b500      	push	{lr}
 8008512:	b083      	sub	sp, #12
 8008514:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8008516:	f003 fce3 	bl	800bee0 <chDbgCheckClassI>

  oqp->q_rdptr = oqp->q_buffer;
 800851a:	9b01      	ldr	r3, [sp, #4]
 800851c:	68da      	ldr	r2, [r3, #12]
 800851e:	9b01      	ldr	r3, [sp, #4]
 8008520:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr = oqp->q_buffer;
 8008522:	9b01      	ldr	r3, [sp, #4]
 8008524:	68da      	ldr	r2, [r3, #12]
 8008526:	9b01      	ldr	r3, [sp, #4]
 8008528:	615a      	str	r2, [r3, #20]
  oqp->q_counter = chQSizeX(oqp);
 800852a:	9b01      	ldr	r3, [sp, #4]
 800852c:	691b      	ldr	r3, [r3, #16]
 800852e:	461a      	mov	r2, r3
 8008530:	9b01      	ldr	r3, [sp, #4]
 8008532:	68db      	ldr	r3, [r3, #12]
 8008534:	1ad3      	subs	r3, r2, r3
 8008536:	461a      	mov	r2, r3
 8008538:	9b01      	ldr	r3, [sp, #4]
 800853a:	609a      	str	r2, [r3, #8]
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
 800853c:	9b01      	ldr	r3, [sp, #4]
 800853e:	4618      	mov	r0, r3
 8008540:	f06f 0101 	mvn.w	r1, #1
 8008544:	f004 fd34 	bl	800cfb0 <chThdDequeueAllI>
}
 8008548:	b003      	add	sp, #12
 800854a:	f85d fb04 	ldr.w	pc, [sp], #4
 800854e:	bf00      	nop

08008550 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8008550:	b500      	push	{lr}
 8008552:	b087      	sub	sp, #28
 8008554:	9003      	str	r0, [sp, #12]
 8008556:	460b      	mov	r3, r1
 8008558:	9201      	str	r2, [sp, #4]
 800855a:	f88d 300b 	strb.w	r3, [sp, #11]

  chSysLock();
 800855e:	f001 fcdf 	bl	8009f20 <chSysLock.lto_priv.317>
 8008562:	e00c      	b.n	800857e <chOQPutTimeout+0x2e>
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8008564:	9b03      	ldr	r3, [sp, #12]
 8008566:	4618      	mov	r0, r3
 8008568:	9901      	ldr	r1, [sp, #4]
 800856a:	f004 fce9 	bl	800cf40 <chThdEnqueueTimeoutS>
 800856e:	9005      	str	r0, [sp, #20]
    if (msg < Q_OK) {
 8008570:	9b05      	ldr	r3, [sp, #20]
 8008572:	2b00      	cmp	r3, #0
 8008574:	da03      	bge.n	800857e <chOQPutTimeout+0x2e>
      chSysUnlock();
 8008576:	f001 fcdb 	bl	8009f30 <chSysUnlock.lto_priv.312>
      return msg;
 800857a:	9b05      	ldr	r3, [sp, #20]
 800857c:	e027      	b.n	80085ce <chOQPutTimeout+0x7e>
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 800857e:	9803      	ldr	r0, [sp, #12]
 8008580:	f001 fd56 	bl	800a030 <chOQIsFullI.lto_priv.338>
 8008584:	4603      	mov	r3, r0
 8008586:	2b00      	cmp	r3, #0
 8008588:	d1ec      	bne.n	8008564 <chOQPutTimeout+0x14>
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 800858a:	9b03      	ldr	r3, [sp, #12]
 800858c:	689b      	ldr	r3, [r3, #8]
 800858e:	1e5a      	subs	r2, r3, #1
 8008590:	9b03      	ldr	r3, [sp, #12]
 8008592:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 8008594:	9b03      	ldr	r3, [sp, #12]
 8008596:	695b      	ldr	r3, [r3, #20]
 8008598:	1c59      	adds	r1, r3, #1
 800859a:	9a03      	ldr	r2, [sp, #12]
 800859c:	6151      	str	r1, [r2, #20]
 800859e:	f89d 200b 	ldrb.w	r2, [sp, #11]
 80085a2:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80085a4:	9b03      	ldr	r3, [sp, #12]
 80085a6:	695a      	ldr	r2, [r3, #20]
 80085a8:	9b03      	ldr	r3, [sp, #12]
 80085aa:	691b      	ldr	r3, [r3, #16]
 80085ac:	429a      	cmp	r2, r3
 80085ae:	d303      	bcc.n	80085b8 <chOQPutTimeout+0x68>
    oqp->q_wrptr = oqp->q_buffer;
 80085b0:	9b03      	ldr	r3, [sp, #12]
 80085b2:	68da      	ldr	r2, [r3, #12]
 80085b4:	9b03      	ldr	r3, [sp, #12]
 80085b6:	615a      	str	r2, [r3, #20]
  }

  if (oqp->q_notify != NULL) {
 80085b8:	9b03      	ldr	r3, [sp, #12]
 80085ba:	69db      	ldr	r3, [r3, #28]
 80085bc:	2b00      	cmp	r3, #0
 80085be:	d003      	beq.n	80085c8 <chOQPutTimeout+0x78>
    oqp->q_notify(oqp);
 80085c0:	9b03      	ldr	r3, [sp, #12]
 80085c2:	69db      	ldr	r3, [r3, #28]
 80085c4:	9803      	ldr	r0, [sp, #12]
 80085c6:	4798      	blx	r3
  }
  chSysUnlock();
 80085c8:	f001 fcb2 	bl	8009f30 <chSysUnlock.lto_priv.312>

  return Q_OK;
 80085cc:	2300      	movs	r3, #0
}
 80085ce:	4618      	mov	r0, r3
 80085d0:	b007      	add	sp, #28
 80085d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80085d6:	bf00      	nop
	...

080085e0 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 80085e0:	b500      	push	{lr}
 80085e2:	b085      	sub	sp, #20
 80085e4:	9001      	str	r0, [sp, #4]
  uint8_t b;

  chDbgCheckClassI();
 80085e6:	f003 fc7b 	bl	800bee0 <chDbgCheckClassI>

  if (chOQIsEmptyI(oqp)) {
 80085ea:	9801      	ldr	r0, [sp, #4]
 80085ec:	f001 fd00 	bl	8009ff0 <chOQIsEmptyI.lto_priv.339>
 80085f0:	4603      	mov	r3, r0
 80085f2:	2b00      	cmp	r3, #0
 80085f4:	d002      	beq.n	80085fc <chOQGetI+0x1c>
    return Q_EMPTY;
 80085f6:	f06f 0302 	mvn.w	r3, #2
 80085fa:	e01d      	b.n	8008638 <chOQGetI+0x58>
  }

  oqp->q_counter++;
 80085fc:	9b01      	ldr	r3, [sp, #4]
 80085fe:	689b      	ldr	r3, [r3, #8]
 8008600:	1c5a      	adds	r2, r3, #1
 8008602:	9b01      	ldr	r3, [sp, #4]
 8008604:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
 8008606:	9b01      	ldr	r3, [sp, #4]
 8008608:	699b      	ldr	r3, [r3, #24]
 800860a:	1c59      	adds	r1, r3, #1
 800860c:	9a01      	ldr	r2, [sp, #4]
 800860e:	6191      	str	r1, [r2, #24]
 8008610:	781b      	ldrb	r3, [r3, #0]
 8008612:	f88d 300f 	strb.w	r3, [sp, #15]
  if (oqp->q_rdptr >= oqp->q_top) {
 8008616:	9b01      	ldr	r3, [sp, #4]
 8008618:	699a      	ldr	r2, [r3, #24]
 800861a:	9b01      	ldr	r3, [sp, #4]
 800861c:	691b      	ldr	r3, [r3, #16]
 800861e:	429a      	cmp	r2, r3
 8008620:	d303      	bcc.n	800862a <chOQGetI+0x4a>
    oqp->q_rdptr = oqp->q_buffer;
 8008622:	9b01      	ldr	r3, [sp, #4]
 8008624:	68da      	ldr	r2, [r3, #12]
 8008626:	9b01      	ldr	r3, [sp, #4]
 8008628:	619a      	str	r2, [r3, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 800862a:	9b01      	ldr	r3, [sp, #4]
 800862c:	4618      	mov	r0, r3
 800862e:	2100      	movs	r1, #0
 8008630:	f004 fca6 	bl	800cf80 <chThdDequeueNextI>

  return (msg_t)b;
 8008634:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8008638:	4618      	mov	r0, r3
 800863a:	b005      	add	sp, #20
 800863c:	f85d fb04 	ldr.w	pc, [sp], #4

08008640 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8008640:	b500      	push	{lr}
 8008642:	b087      	sub	sp, #28
 8008644:	9003      	str	r0, [sp, #12]
 8008646:	9102      	str	r1, [sp, #8]
 8008648:	9201      	str	r2, [sp, #4]
 800864a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
 800864c:	9b03      	ldr	r3, [sp, #12]
 800864e:	69db      	ldr	r3, [r3, #28]
 8008650:	9304      	str	r3, [sp, #16]
  size_t w = 0;
 8008652:	2300      	movs	r3, #0
 8008654:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);
 8008656:	9b01      	ldr	r3, [sp, #4]
 8008658:	2b00      	cmp	r3, #0
 800865a:	d102      	bne.n	8008662 <chOQWriteTimeout+0x22>
 800865c:	4825      	ldr	r0, [pc, #148]	; (80086f4 <chOQWriteTimeout+0xb4>)
 800865e:	f003 fa47 	bl	800baf0 <chSysHalt>

  chSysLock();
 8008662:	f001 fc5d 	bl	8009f20 <chSysLock.lto_priv.317>
 8008666:	e00b      	b.n	8008680 <chOQWriteTimeout+0x40>
  while (true) {
    while (chOQIsFullI(oqp)) {
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 8008668:	9b03      	ldr	r3, [sp, #12]
 800866a:	4618      	mov	r0, r3
 800866c:	9900      	ldr	r1, [sp, #0]
 800866e:	f004 fc67 	bl	800cf40 <chThdEnqueueTimeoutS>
 8008672:	4603      	mov	r3, r0
 8008674:	2b00      	cmp	r3, #0
 8008676:	d003      	beq.n	8008680 <chOQWriteTimeout+0x40>
        chSysUnlock();
 8008678:	f001 fc5a 	bl	8009f30 <chSysUnlock.lto_priv.312>
        return w;
 800867c:	9b05      	ldr	r3, [sp, #20]
 800867e:	e034      	b.n	80086ea <chOQWriteTimeout+0xaa>

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8008680:	9803      	ldr	r0, [sp, #12]
 8008682:	f001 fcd5 	bl	800a030 <chOQIsFullI.lto_priv.338>
 8008686:	4603      	mov	r3, r0
 8008688:	2b00      	cmp	r3, #0
 800868a:	d1ed      	bne.n	8008668 <chOQWriteTimeout+0x28>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 800868c:	9b03      	ldr	r3, [sp, #12]
 800868e:	689b      	ldr	r3, [r3, #8]
 8008690:	1e5a      	subs	r2, r3, #1
 8008692:	9b03      	ldr	r3, [sp, #12]
 8008694:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
 8008696:	9b03      	ldr	r3, [sp, #12]
 8008698:	695b      	ldr	r3, [r3, #20]
 800869a:	1c59      	adds	r1, r3, #1
 800869c:	9a03      	ldr	r2, [sp, #12]
 800869e:	6151      	str	r1, [r2, #20]
 80086a0:	9a02      	ldr	r2, [sp, #8]
 80086a2:	1c51      	adds	r1, r2, #1
 80086a4:	9102      	str	r1, [sp, #8]
 80086a6:	7812      	ldrb	r2, [r2, #0]
 80086a8:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 80086aa:	9b03      	ldr	r3, [sp, #12]
 80086ac:	695a      	ldr	r2, [r3, #20]
 80086ae:	9b03      	ldr	r3, [sp, #12]
 80086b0:	691b      	ldr	r3, [r3, #16]
 80086b2:	429a      	cmp	r2, r3
 80086b4:	d303      	bcc.n	80086be <chOQWriteTimeout+0x7e>
      oqp->q_wrptr = oqp->q_buffer;
 80086b6:	9b03      	ldr	r3, [sp, #12]
 80086b8:	68da      	ldr	r2, [r3, #12]
 80086ba:	9b03      	ldr	r3, [sp, #12]
 80086bc:	615a      	str	r2, [r3, #20]
    }

    if (nfy != NULL) {
 80086be:	9b04      	ldr	r3, [sp, #16]
 80086c0:	2b00      	cmp	r3, #0
 80086c2:	d002      	beq.n	80086ca <chOQWriteTimeout+0x8a>
      nfy(oqp);
 80086c4:	9b04      	ldr	r3, [sp, #16]
 80086c6:	9803      	ldr	r0, [sp, #12]
 80086c8:	4798      	blx	r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 80086ca:	f001 fc31 	bl	8009f30 <chSysUnlock.lto_priv.312>

    w++;
 80086ce:	9b05      	ldr	r3, [sp, #20]
 80086d0:	3301      	adds	r3, #1
 80086d2:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 80086d4:	9b01      	ldr	r3, [sp, #4]
 80086d6:	3b01      	subs	r3, #1
 80086d8:	9301      	str	r3, [sp, #4]
 80086da:	9b01      	ldr	r3, [sp, #4]
 80086dc:	2b00      	cmp	r3, #0
 80086de:	d101      	bne.n	80086e4 <chOQWriteTimeout+0xa4>
      return w;
 80086e0:	9b05      	ldr	r3, [sp, #20]
 80086e2:	e002      	b.n	80086ea <chOQWriteTimeout+0xaa>
    }
    chSysLock();
 80086e4:	f001 fc1c 	bl	8009f20 <chSysLock.lto_priv.317>
 80086e8:	e7ca      	b.n	8008680 <chOQWriteTimeout+0x40>
  }
}
 80086ea:	4618      	mov	r0, r3
 80086ec:	b007      	add	sp, #28
 80086ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80086f2:	bf00      	nop
 80086f4:	0800e0b0 	.word	0x0800e0b0
	...

08008700 <port_lock.lto_priv.325>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8008700:	b082      	sub	sp, #8
 8008702:	2320      	movs	r3, #32
 8008704:	9301      	str	r3, [sp, #4]
 8008706:	9b01      	ldr	r3, [sp, #4]
 8008708:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800870c:	b002      	add	sp, #8
 800870e:	4770      	bx	lr

08008710 <port_unlock.lto_priv.321>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8008710:	b082      	sub	sp, #8
 8008712:	2300      	movs	r3, #0
 8008714:	9301      	str	r3, [sp, #4]
 8008716:	9b01      	ldr	r3, [sp, #4]
 8008718:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800871c:	b002      	add	sp, #8
 800871e:	4770      	bx	lr

08008720 <chSysLock.lto_priv.318>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8008720:	b508      	push	{r3, lr}

  port_lock();
 8008722:	f7ff ffed 	bl	8008700 <port_lock.lto_priv.325>
  _stats_start_measure_crit_thd();
 8008726:	f001 fe8b 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800872a:	f003 fb39 	bl	800bda0 <_dbg_check_lock>
}
 800872e:	bd08      	pop	{r3, pc}

08008730 <chSysUnlock.lto_priv.313>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8008730:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8008732:	f003 fb4d 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8008736:	f001 fe8b 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800873a:	4b09      	ldr	r3, [pc, #36]	; (8008760 <chSysUnlock.lto_priv.313+0x30>)
 800873c:	681b      	ldr	r3, [r3, #0]
 800873e:	4a08      	ldr	r2, [pc, #32]	; (8008760 <chSysUnlock.lto_priv.313+0x30>)
 8008740:	4293      	cmp	r3, r2
 8008742:	d00a      	beq.n	800875a <chSysUnlock.lto_priv.313+0x2a>
 8008744:	4b06      	ldr	r3, [pc, #24]	; (8008760 <chSysUnlock.lto_priv.313+0x30>)
 8008746:	699b      	ldr	r3, [r3, #24]
 8008748:	689a      	ldr	r2, [r3, #8]
 800874a:	4b05      	ldr	r3, [pc, #20]	; (8008760 <chSysUnlock.lto_priv.313+0x30>)
 800874c:	681b      	ldr	r3, [r3, #0]
 800874e:	689b      	ldr	r3, [r3, #8]
 8008750:	429a      	cmp	r2, r3
 8008752:	d202      	bcs.n	800875a <chSysUnlock.lto_priv.313+0x2a>
 8008754:	4803      	ldr	r0, [pc, #12]	; (8008764 <chSysUnlock.lto_priv.313+0x34>)
 8008756:	f003 f9cb 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800875a:	f7ff ffd9 	bl	8008710 <port_unlock.lto_priv.321>
}
 800875e:	bd08      	pop	{r3, pc}
 8008760:	20000d30 	.word	0x20000d30
 8008764:	0800e0d0 	.word	0x0800e0d0
	...

08008770 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8008770:	4b06      	ldr	r3, [pc, #24]	; (800878c <_core_init+0x1c>)
 8008772:	3307      	adds	r3, #7
 8008774:	f023 0307 	bic.w	r3, r3, #7
 8008778:	461a      	mov	r2, r3
 800877a:	4b05      	ldr	r3, [pc, #20]	; (8008790 <_core_init+0x20>)
 800877c:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800877e:	4b05      	ldr	r3, [pc, #20]	; (8008794 <_core_init+0x24>)
 8008780:	f023 0307 	bic.w	r3, r3, #7
 8008784:	461a      	mov	r2, r3
 8008786:	4b04      	ldr	r3, [pc, #16]	; (8008798 <_core_init+0x28>)
 8008788:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
 800878a:	4770      	bx	lr
 800878c:	200025d8 	.word	0x200025d8
 8008790:	20001308 	.word	0x20001308
 8008794:	20018000 	.word	0x20018000
 8008798:	2000130c 	.word	0x2000130c
 800879c:	00000000 	.word	0x00000000

080087a0 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 80087a0:	b500      	push	{lr}
 80087a2:	b085      	sub	sp, #20
 80087a4:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
 80087a6:	f7ff ffbb 	bl	8008720 <chSysLock.lto_priv.318>
  p = chCoreAllocI(size);
 80087aa:	9801      	ldr	r0, [sp, #4]
 80087ac:	f000 f808 	bl	80087c0 <chCoreAllocI>
 80087b0:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 80087b2:	f7ff ffbd 	bl	8008730 <chSysUnlock.lto_priv.313>

  return p;
 80087b6:	9b03      	ldr	r3, [sp, #12]
}
 80087b8:	4618      	mov	r0, r3
 80087ba:	b005      	add	sp, #20
 80087bc:	f85d fb04 	ldr.w	pc, [sp], #4

080087c0 <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
 80087c0:	b500      	push	{lr}
 80087c2:	b085      	sub	sp, #20
 80087c4:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();
 80087c6:	f003 fb8b 	bl	800bee0 <chDbgCheckClassI>

  size = MEM_ALIGN_NEXT(size);
 80087ca:	9b01      	ldr	r3, [sp, #4]
 80087cc:	3307      	adds	r3, #7
 80087ce:	f023 0307 	bic.w	r3, r3, #7
 80087d2:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 80087d4:	4b0c      	ldr	r3, [pc, #48]	; (8008808 <chCoreAllocI+0x48>)
 80087d6:	681b      	ldr	r3, [r3, #0]
 80087d8:	461a      	mov	r2, r3
 80087da:	4b0c      	ldr	r3, [pc, #48]	; (800880c <chCoreAllocI+0x4c>)
 80087dc:	681b      	ldr	r3, [r3, #0]
 80087de:	1ad3      	subs	r3, r2, r3
 80087e0:	461a      	mov	r2, r3
 80087e2:	9b01      	ldr	r3, [sp, #4]
 80087e4:	429a      	cmp	r2, r3
 80087e6:	d201      	bcs.n	80087ec <chCoreAllocI+0x2c>
  /*lint -restore*/
    return NULL;
 80087e8:	2300      	movs	r3, #0
 80087ea:	e009      	b.n	8008800 <chCoreAllocI+0x40>
  }
  p = nextmem;
 80087ec:	4b07      	ldr	r3, [pc, #28]	; (800880c <chCoreAllocI+0x4c>)
 80087ee:	681b      	ldr	r3, [r3, #0]
 80087f0:	9303      	str	r3, [sp, #12]
  nextmem += size;
 80087f2:	4b06      	ldr	r3, [pc, #24]	; (800880c <chCoreAllocI+0x4c>)
 80087f4:	681a      	ldr	r2, [r3, #0]
 80087f6:	9b01      	ldr	r3, [sp, #4]
 80087f8:	4413      	add	r3, r2
 80087fa:	4a04      	ldr	r2, [pc, #16]	; (800880c <chCoreAllocI+0x4c>)
 80087fc:	6013      	str	r3, [r2, #0]

  return p;
 80087fe:	9b03      	ldr	r3, [sp, #12]
}
 8008800:	4618      	mov	r0, r3
 8008802:	b005      	add	sp, #20
 8008804:	f85d fb04 	ldr.w	pc, [sp], #4
 8008808:	2000130c 	.word	0x2000130c
 800880c:	20001308 	.word	0x20001308

08008810 <chCoreGetStatusX>:
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(endmem - nextmem);
 8008810:	4b03      	ldr	r3, [pc, #12]	; (8008820 <chCoreGetStatusX+0x10>)
 8008812:	681b      	ldr	r3, [r3, #0]
 8008814:	461a      	mov	r2, r3
 8008816:	4b03      	ldr	r3, [pc, #12]	; (8008824 <chCoreGetStatusX+0x14>)
 8008818:	681b      	ldr	r3, [r3, #0]
 800881a:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 800881c:	4618      	mov	r0, r3
 800881e:	4770      	bx	lr
 8008820:	2000130c 	.word	0x2000130c
 8008824:	20001308 	.word	0x20001308
	...

08008830 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 8008830:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
 8008832:	4b06      	ldr	r3, [pc, #24]	; (800884c <_heap_init+0x1c>)
 8008834:	4a06      	ldr	r2, [pc, #24]	; (8008850 <_heap_init+0x20>)
 8008836:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
 8008838:	4b04      	ldr	r3, [pc, #16]	; (800884c <_heap_init+0x1c>)
 800883a:	2200      	movs	r2, #0
 800883c:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 800883e:	4b03      	ldr	r3, [pc, #12]	; (800884c <_heap_init+0x1c>)
 8008840:	2200      	movs	r2, #0
 8008842:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8008844:	4803      	ldr	r0, [pc, #12]	; (8008854 <_heap_init+0x24>)
 8008846:	f002 fc13 	bl	800b070 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
 800884a:	bd08      	pop	{r3, pc}
 800884c:	20001310 	.word	0x20001310
 8008850:	080087a1 	.word	0x080087a1
 8008854:	20001320 	.word	0x20001320
	...

08008860 <chHeapObjectInit>:
 * @param[in] buf       heap buffer base
 * @param[in] size      heap size
 *
 * @init
 */
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
 8008860:	b500      	push	{lr}
 8008862:	b087      	sub	sp, #28
 8008864:	9003      	str	r0, [sp, #12]
 8008866:	9102      	str	r1, [sp, #8]
 8008868:	9201      	str	r2, [sp, #4]
  union heap_header *hp = buf;
 800886a:	9b02      	ldr	r3, [sp, #8]
 800886c:	9305      	str	r3, [sp, #20]

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));
 800886e:	9b02      	ldr	r3, [sp, #8]
 8008870:	f003 0307 	and.w	r3, r3, #7
 8008874:	2b00      	cmp	r3, #0
 8008876:	d104      	bne.n	8008882 <chHeapObjectInit+0x22>
 8008878:	9b01      	ldr	r3, [sp, #4]
 800887a:	f003 0307 	and.w	r3, r3, #7
 800887e:	2b00      	cmp	r3, #0
 8008880:	d002      	beq.n	8008888 <chHeapObjectInit+0x28>
 8008882:	480e      	ldr	r0, [pc, #56]	; (80088bc <chHeapObjectInit+0x5c>)
 8008884:	f003 f934 	bl	800baf0 <chSysHalt>

  heapp->h_provider = NULL;
 8008888:	9b03      	ldr	r3, [sp, #12]
 800888a:	2200      	movs	r2, #0
 800888c:	601a      	str	r2, [r3, #0]
  heapp->h_free.h.u.next = hp;
 800888e:	9b03      	ldr	r3, [sp, #12]
 8008890:	9a05      	ldr	r2, [sp, #20]
 8008892:	609a      	str	r2, [r3, #8]
  heapp->h_free.h.size = 0;
 8008894:	9b03      	ldr	r3, [sp, #12]
 8008896:	2200      	movs	r2, #0
 8008898:	60da      	str	r2, [r3, #12]
  hp->h.u.next = NULL;
 800889a:	9b05      	ldr	r3, [sp, #20]
 800889c:	2200      	movs	r2, #0
 800889e:	601a      	str	r2, [r3, #0]
  hp->h.size = size - sizeof(union heap_header);
 80088a0:	9b01      	ldr	r3, [sp, #4]
 80088a2:	f1a3 0208 	sub.w	r2, r3, #8
 80088a6:	9b05      	ldr	r3, [sp, #20]
 80088a8:	605a      	str	r2, [r3, #4]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&heapp->h_mtx);
 80088aa:	9b03      	ldr	r3, [sp, #12]
 80088ac:	3310      	adds	r3, #16
 80088ae:	4618      	mov	r0, r3
 80088b0:	f002 fbde 	bl	800b070 <chMtxObjectInit>
#else
  chSemObjectInit(&heapp->h_sem, (cnt_t)1);
#endif
}
 80088b4:	b007      	add	sp, #28
 80088b6:	f85d fb04 	ldr.w	pc, [sp], #4
 80088ba:	bf00      	nop
 80088bc:	0800e0e0 	.word	0x0800e0e0

080088c0 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 80088c0:	b500      	push	{lr}
 80088c2:	b087      	sub	sp, #28
 80088c4:	9001      	str	r0, [sp, #4]
 80088c6:	9100      	str	r1, [sp, #0]
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL) {
 80088c8:	9b01      	ldr	r3, [sp, #4]
 80088ca:	2b00      	cmp	r3, #0
 80088cc:	d101      	bne.n	80088d2 <chHeapAlloc+0x12>
    heapp = &default_heap;
 80088ce:	4b37      	ldr	r3, [pc, #220]	; (80089ac <chHeapAlloc+0xec>)
 80088d0:	9301      	str	r3, [sp, #4]
  }

  size = MEM_ALIGN_NEXT(size);
 80088d2:	9b00      	ldr	r3, [sp, #0]
 80088d4:	3307      	adds	r3, #7
 80088d6:	f023 0307 	bic.w	r3, r3, #7
 80088da:	9300      	str	r3, [sp, #0]
  qp = &heapp->h_free;
 80088dc:	9b01      	ldr	r3, [sp, #4]
 80088de:	3308      	adds	r3, #8
 80088e0:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
 80088e2:	9b01      	ldr	r3, [sp, #4]
 80088e4:	3310      	adds	r3, #16
 80088e6:	4618      	mov	r0, r3
 80088e8:	f002 fbda 	bl	800b0a0 <chMtxLock>
 80088ec:	e036      	b.n	800895c <chHeapAlloc+0x9c>
  while (qp->h.u.next != NULL) {
    hp = qp->h.u.next;
 80088ee:	9b05      	ldr	r3, [sp, #20]
 80088f0:	681b      	ldr	r3, [r3, #0]
 80088f2:	9304      	str	r3, [sp, #16]
    if (hp->h.size >= size) {
 80088f4:	9b04      	ldr	r3, [sp, #16]
 80088f6:	685a      	ldr	r2, [r3, #4]
 80088f8:	9b00      	ldr	r3, [sp, #0]
 80088fa:	429a      	cmp	r2, r3
 80088fc:	d32c      	bcc.n	8008958 <chHeapAlloc+0x98>
      if (hp->h.size < (size + sizeof(union heap_header))) {
 80088fe:	9b04      	ldr	r3, [sp, #16]
 8008900:	685a      	ldr	r2, [r3, #4]
 8008902:	9b00      	ldr	r3, [sp, #0]
 8008904:	3308      	adds	r3, #8
 8008906:	429a      	cmp	r2, r3
 8008908:	d204      	bcs.n	8008914 <chHeapAlloc+0x54>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
 800890a:	9b04      	ldr	r3, [sp, #16]
 800890c:	681a      	ldr	r2, [r3, #0]
 800890e:	9b05      	ldr	r3, [sp, #20]
 8008910:	601a      	str	r2, [r3, #0]
 8008912:	e016      	b.n	8008942 <chHeapAlloc+0x82>
      }
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
 8008914:	9b00      	ldr	r3, [sp, #0]
 8008916:	3308      	adds	r3, #8
 8008918:	9a04      	ldr	r2, [sp, #16]
 800891a:	4413      	add	r3, r2
 800891c:	9303      	str	r3, [sp, #12]
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 800891e:	9b04      	ldr	r3, [sp, #16]
 8008920:	681a      	ldr	r2, [r3, #0]
 8008922:	9b03      	ldr	r3, [sp, #12]
 8008924:	601a      	str	r2, [r3, #0]
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 8008926:	9b04      	ldr	r3, [sp, #16]
 8008928:	685a      	ldr	r2, [r3, #4]
 800892a:	9b00      	ldr	r3, [sp, #0]
 800892c:	1ad3      	subs	r3, r2, r3
 800892e:	f1a3 0208 	sub.w	r2, r3, #8
 8008932:	9b03      	ldr	r3, [sp, #12]
 8008934:	605a      	str	r2, [r3, #4]
        qp->h.u.next = fp;
 8008936:	9b05      	ldr	r3, [sp, #20]
 8008938:	9a03      	ldr	r2, [sp, #12]
 800893a:	601a      	str	r2, [r3, #0]
        hp->h.size = size;
 800893c:	9b04      	ldr	r3, [sp, #16]
 800893e:	9a00      	ldr	r2, [sp, #0]
 8008940:	605a      	str	r2, [r3, #4]
      }
      hp->h.u.heap = heapp;
 8008942:	9b04      	ldr	r3, [sp, #16]
 8008944:	9a01      	ldr	r2, [sp, #4]
 8008946:	601a      	str	r2, [r3, #0]
      H_UNLOCK(heapp);
 8008948:	9b01      	ldr	r3, [sp, #4]
 800894a:	3310      	adds	r3, #16
 800894c:	4618      	mov	r0, r3
 800894e:	f002 fc77 	bl	800b240 <chMtxUnlock>

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)(hp + 1);
 8008952:	9b04      	ldr	r3, [sp, #16]
 8008954:	3308      	adds	r3, #8
 8008956:	e024      	b.n	80089a2 <chHeapAlloc+0xe2>
      /*lint -restore*/
    }
    qp = hp;
 8008958:	9b04      	ldr	r3, [sp, #16]
 800895a:	9305      	str	r3, [sp, #20]

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
 800895c:	9b05      	ldr	r3, [sp, #20]
 800895e:	681b      	ldr	r3, [r3, #0]
 8008960:	2b00      	cmp	r3, #0
 8008962:	d1c4      	bne.n	80088ee <chHeapAlloc+0x2e>
      return (void *)(hp + 1);
      /*lint -restore*/
    }
    qp = hp;
  }
  H_UNLOCK(heapp);
 8008964:	9b01      	ldr	r3, [sp, #4]
 8008966:	3310      	adds	r3, #16
 8008968:	4618      	mov	r0, r3
 800896a:	f002 fc69 	bl	800b240 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider != NULL) {
 800896e:	9b01      	ldr	r3, [sp, #4]
 8008970:	681b      	ldr	r3, [r3, #0]
 8008972:	2b00      	cmp	r3, #0
 8008974:	d014      	beq.n	80089a0 <chHeapAlloc+0xe0>
    hp = heapp->h_provider(size + sizeof(union heap_header));
 8008976:	9b01      	ldr	r3, [sp, #4]
 8008978:	681b      	ldr	r3, [r3, #0]
 800897a:	9a00      	ldr	r2, [sp, #0]
 800897c:	3208      	adds	r2, #8
 800897e:	4610      	mov	r0, r2
 8008980:	4798      	blx	r3
 8008982:	9004      	str	r0, [sp, #16]
    if (hp != NULL) {
 8008984:	9b04      	ldr	r3, [sp, #16]
 8008986:	2b00      	cmp	r3, #0
 8008988:	d00a      	beq.n	80089a0 <chHeapAlloc+0xe0>
      hp->h.u.heap = heapp;
 800898a:	9b04      	ldr	r3, [sp, #16]
 800898c:	9a01      	ldr	r2, [sp, #4]
 800898e:	601a      	str	r2, [r3, #0]
      hp->h.size = size;
 8008990:	9b04      	ldr	r3, [sp, #16]
 8008992:	9a00      	ldr	r2, [sp, #0]
 8008994:	605a      	str	r2, [r3, #4]
      hp++;
 8008996:	9b04      	ldr	r3, [sp, #16]
 8008998:	3308      	adds	r3, #8
 800899a:	9304      	str	r3, [sp, #16]

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)hp;
 800899c:	9b04      	ldr	r3, [sp, #16]
 800899e:	e000      	b.n	80089a2 <chHeapAlloc+0xe2>
      /*lint -restore*/
    }
  }

  return NULL;
 80089a0:	2300      	movs	r3, #0
}
 80089a2:	4618      	mov	r0, r3
 80089a4:	b007      	add	sp, #28
 80089a6:	f85d fb04 	ldr.w	pc, [sp], #4
 80089aa:	bf00      	nop
 80089ac:	20001310 	.word	0x20001310

080089b0 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 80089b0:	b500      	push	{lr}
 80089b2:	b087      	sub	sp, #28
 80089b4:	9001      	str	r0, [sp, #4]
  union heap_header *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);
 80089b6:	9b01      	ldr	r3, [sp, #4]
 80089b8:	2b00      	cmp	r3, #0
 80089ba:	d102      	bne.n	80089c2 <chHeapFree+0x12>
 80089bc:	4839      	ldr	r0, [pc, #228]	; (8008aa4 <chHeapFree+0xf4>)
 80089be:	f003 f897 	bl	800baf0 <chSysHalt>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
 80089c2:	9b01      	ldr	r3, [sp, #4]
 80089c4:	3b08      	subs	r3, #8
 80089c6:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = hp->h.u.heap;
 80089c8:	9b04      	ldr	r3, [sp, #16]
 80089ca:	681b      	ldr	r3, [r3, #0]
 80089cc:	9303      	str	r3, [sp, #12]
  qp = &heapp->h_free;
 80089ce:	9b03      	ldr	r3, [sp, #12]
 80089d0:	3308      	adds	r3, #8
 80089d2:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
 80089d4:	9b03      	ldr	r3, [sp, #12]
 80089d6:	3310      	adds	r3, #16
 80089d8:	4618      	mov	r0, r3
 80089da:	f002 fb61 	bl	800b0a0 <chMtxLock>
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");
 80089de:	9a04      	ldr	r2, [sp, #16]
 80089e0:	9b05      	ldr	r3, [sp, #20]
 80089e2:	429a      	cmp	r2, r3
 80089e4:	d30a      	bcc.n	80089fc <chHeapFree+0x4c>
 80089e6:	9b05      	ldr	r3, [sp, #20]
 80089e8:	685b      	ldr	r3, [r3, #4]
 80089ea:	3308      	adds	r3, #8
 80089ec:	9a05      	ldr	r2, [sp, #20]
 80089ee:	441a      	add	r2, r3
 80089f0:	9b04      	ldr	r3, [sp, #16]
 80089f2:	429a      	cmp	r2, r3
 80089f4:	d902      	bls.n	80089fc <chHeapFree+0x4c>
 80089f6:	482b      	ldr	r0, [pc, #172]	; (8008aa4 <chHeapFree+0xf4>)
 80089f8:	f003 f87a 	bl	800baf0 <chSysHalt>

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 80089fc:	9b03      	ldr	r3, [sp, #12]
 80089fe:	f103 0208 	add.w	r2, r3, #8
 8008a02:	9b05      	ldr	r3, [sp, #20]
 8008a04:	429a      	cmp	r2, r3
 8008a06:	d003      	beq.n	8008a10 <chHeapFree+0x60>
 8008a08:	9a04      	ldr	r2, [sp, #16]
 8008a0a:	9b05      	ldr	r3, [sp, #20]
 8008a0c:	429a      	cmp	r2, r3
 8008a0e:	d93d      	bls.n	8008a8c <chHeapFree+0xdc>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8008a10:	9b05      	ldr	r3, [sp, #20]
 8008a12:	681b      	ldr	r3, [r3, #0]

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 8008a14:	2b00      	cmp	r3, #0
 8008a16:	d004      	beq.n	8008a22 <chHeapFree+0x72>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8008a18:	9b05      	ldr	r3, [sp, #20]
 8008a1a:	681a      	ldr	r2, [r3, #0]
 8008a1c:	9b04      	ldr	r3, [sp, #16]
 8008a1e:	429a      	cmp	r2, r3
 8008a20:	d934      	bls.n	8008a8c <chHeapFree+0xdc>
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
 8008a22:	9b05      	ldr	r3, [sp, #20]
 8008a24:	681a      	ldr	r2, [r3, #0]
 8008a26:	9b04      	ldr	r3, [sp, #16]
 8008a28:	601a      	str	r2, [r3, #0]
      qp->h.u.next = hp;
 8008a2a:	9b05      	ldr	r3, [sp, #20]
 8008a2c:	9a04      	ldr	r2, [sp, #16]
 8008a2e:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 8008a30:	9b04      	ldr	r3, [sp, #16]
 8008a32:	685b      	ldr	r3, [r3, #4]
 8008a34:	3308      	adds	r3, #8
 8008a36:	9a04      	ldr	r2, [sp, #16]
 8008a38:	441a      	add	r2, r3
 8008a3a:	9b04      	ldr	r3, [sp, #16]
 8008a3c:	681b      	ldr	r3, [r3, #0]
 8008a3e:	429a      	cmp	r2, r3
 8008a40:	d10e      	bne.n	8008a60 <chHeapFree+0xb0>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 8008a42:	9b04      	ldr	r3, [sp, #16]
 8008a44:	685a      	ldr	r2, [r3, #4]
 8008a46:	9b04      	ldr	r3, [sp, #16]
 8008a48:	681b      	ldr	r3, [r3, #0]
 8008a4a:	685b      	ldr	r3, [r3, #4]
 8008a4c:	4413      	add	r3, r2
 8008a4e:	f103 0208 	add.w	r2, r3, #8
 8008a52:	9b04      	ldr	r3, [sp, #16]
 8008a54:	605a      	str	r2, [r3, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
 8008a56:	9b04      	ldr	r3, [sp, #16]
 8008a58:	681b      	ldr	r3, [r3, #0]
 8008a5a:	681a      	ldr	r2, [r3, #0]
 8008a5c:	9b04      	ldr	r3, [sp, #16]
 8008a5e:	601a      	str	r2, [r3, #0]
      }
      if ((LIMIT(qp) == hp)) {
 8008a60:	9b05      	ldr	r3, [sp, #20]
 8008a62:	685b      	ldr	r3, [r3, #4]
 8008a64:	3308      	adds	r3, #8
 8008a66:	9a05      	ldr	r2, [sp, #20]
 8008a68:	441a      	add	r2, r3
 8008a6a:	9b04      	ldr	r3, [sp, #16]
 8008a6c:	429a      	cmp	r2, r3
 8008a6e:	d111      	bne.n	8008a94 <chHeapFree+0xe4>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 8008a70:	9b05      	ldr	r3, [sp, #20]
 8008a72:	685a      	ldr	r2, [r3, #4]
 8008a74:	9b04      	ldr	r3, [sp, #16]
 8008a76:	685b      	ldr	r3, [r3, #4]
 8008a78:	4413      	add	r3, r2
 8008a7a:	f103 0208 	add.w	r2, r3, #8
 8008a7e:	9b05      	ldr	r3, [sp, #20]
 8008a80:	605a      	str	r2, [r3, #4]
        qp->h.u.next = hp->h.u.next;
 8008a82:	9b04      	ldr	r3, [sp, #16]
 8008a84:	681a      	ldr	r2, [r3, #0]
 8008a86:	9b05      	ldr	r3, [sp, #20]
 8008a88:	601a      	str	r2, [r3, #0]
 8008a8a:	e003      	b.n	8008a94 <chHeapFree+0xe4>
      }
      break;
    }
    qp = qp->h.u.next;
 8008a8c:	9b05      	ldr	r3, [sp, #20]
 8008a8e:	681b      	ldr	r3, [r3, #0]
 8008a90:	9305      	str	r3, [sp, #20]
 8008a92:	e7a4      	b.n	80089de <chHeapFree+0x2e>
  }
  H_UNLOCK(heapp);
 8008a94:	9b03      	ldr	r3, [sp, #12]
 8008a96:	3310      	adds	r3, #16
 8008a98:	4618      	mov	r0, r3
 8008a9a:	f002 fbd1 	bl	800b240 <chMtxUnlock>

  return;
}
 8008a9e:	b007      	add	sp, #28
 8008aa0:	f85d fb04 	ldr.w	pc, [sp], #4
 8008aa4:	0800e100 	.word	0x0800e100
	...

08008ab0 <chHeapStatus>:
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
 8008ab0:	b500      	push	{lr}
 8008ab2:	b087      	sub	sp, #28
 8008ab4:	9001      	str	r0, [sp, #4]
 8008ab6:	9100      	str	r1, [sp, #0]
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL) {
 8008ab8:	9b01      	ldr	r3, [sp, #4]
 8008aba:	2b00      	cmp	r3, #0
 8008abc:	d101      	bne.n	8008ac2 <chHeapStatus+0x12>
    heapp = &default_heap;
 8008abe:	4b17      	ldr	r3, [pc, #92]	; (8008b1c <chHeapStatus+0x6c>)
 8008ac0:	9301      	str	r3, [sp, #4]
  }

  H_LOCK(heapp);
 8008ac2:	9b01      	ldr	r3, [sp, #4]
 8008ac4:	3310      	adds	r3, #16
 8008ac6:	4618      	mov	r0, r3
 8008ac8:	f002 faea 	bl	800b0a0 <chMtxLock>
  sz = 0;
 8008acc:	2300      	movs	r3, #0
 8008ace:	9303      	str	r3, [sp, #12]
  n = 0;
 8008ad0:	2300      	movs	r3, #0
 8008ad2:	9304      	str	r3, [sp, #16]
  qp = &heapp->h_free;
 8008ad4:	9b01      	ldr	r3, [sp, #4]
 8008ad6:	3308      	adds	r3, #8
 8008ad8:	9305      	str	r3, [sp, #20]
 8008ada:	e00b      	b.n	8008af4 <chHeapStatus+0x44>
  while (qp->h.u.next != NULL) {
    sz += qp->h.u.next->h.size;
 8008adc:	9b05      	ldr	r3, [sp, #20]
 8008ade:	681b      	ldr	r3, [r3, #0]
 8008ae0:	685b      	ldr	r3, [r3, #4]
 8008ae2:	9a03      	ldr	r2, [sp, #12]
 8008ae4:	4413      	add	r3, r2
 8008ae6:	9303      	str	r3, [sp, #12]
    n++;
 8008ae8:	9b04      	ldr	r3, [sp, #16]
 8008aea:	3301      	adds	r3, #1
 8008aec:	9304      	str	r3, [sp, #16]
    qp = qp->h.u.next;
 8008aee:	9b05      	ldr	r3, [sp, #20]
 8008af0:	681b      	ldr	r3, [r3, #0]
 8008af2:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8008af4:	9b05      	ldr	r3, [sp, #20]
 8008af6:	681b      	ldr	r3, [r3, #0]
 8008af8:	2b00      	cmp	r3, #0
 8008afa:	d1ef      	bne.n	8008adc <chHeapStatus+0x2c>
    sz += qp->h.u.next->h.size;
    n++;
    qp = qp->h.u.next;
  }
  if (sizep != NULL) {
 8008afc:	9b00      	ldr	r3, [sp, #0]
 8008afe:	2b00      	cmp	r3, #0
 8008b00:	d002      	beq.n	8008b08 <chHeapStatus+0x58>
    *sizep = sz;
 8008b02:	9b00      	ldr	r3, [sp, #0]
 8008b04:	9a03      	ldr	r2, [sp, #12]
 8008b06:	601a      	str	r2, [r3, #0]
  }
  H_UNLOCK(heapp);
 8008b08:	9b01      	ldr	r3, [sp, #4]
 8008b0a:	3310      	adds	r3, #16
 8008b0c:	4618      	mov	r0, r3
 8008b0e:	f002 fb97 	bl	800b240 <chMtxUnlock>

  return n;
 8008b12:	9b04      	ldr	r3, [sp, #16]
}
 8008b14:	4618      	mov	r0, r3
 8008b16:	b007      	add	sp, #28
 8008b18:	f85d fb04 	ldr.w	pc, [sp], #4
 8008b1c:	20001310 	.word	0x20001310

08008b20 <port_lock.lto_priv.326>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8008b20:	b082      	sub	sp, #8
 8008b22:	2320      	movs	r3, #32
 8008b24:	9301      	str	r3, [sp, #4]
 8008b26:	9b01      	ldr	r3, [sp, #4]
 8008b28:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8008b2c:	b002      	add	sp, #8
 8008b2e:	4770      	bx	lr

08008b30 <port_unlock.lto_priv.322>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8008b30:	b082      	sub	sp, #8
 8008b32:	2300      	movs	r3, #0
 8008b34:	9301      	str	r3, [sp, #4]
 8008b36:	9b01      	ldr	r3, [sp, #4]
 8008b38:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8008b3c:	b002      	add	sp, #8
 8008b3e:	4770      	bx	lr

08008b40 <chSysLock.lto_priv.319>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8008b40:	b508      	push	{r3, lr}

  port_lock();
 8008b42:	f7ff ffed 	bl	8008b20 <port_lock.lto_priv.326>
  _stats_start_measure_crit_thd();
 8008b46:	f001 fc7b 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8008b4a:	f003 f929 	bl	800bda0 <_dbg_check_lock>
}
 8008b4e:	bd08      	pop	{r3, pc}

08008b50 <chSysUnlock.lto_priv.314>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8008b50:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8008b52:	f003 f93d 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8008b56:	f001 fc7b 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8008b5a:	4b09      	ldr	r3, [pc, #36]	; (8008b80 <chSysUnlock.lto_priv.314+0x30>)
 8008b5c:	681b      	ldr	r3, [r3, #0]
 8008b5e:	4a08      	ldr	r2, [pc, #32]	; (8008b80 <chSysUnlock.lto_priv.314+0x30>)
 8008b60:	4293      	cmp	r3, r2
 8008b62:	d00a      	beq.n	8008b7a <chSysUnlock.lto_priv.314+0x2a>
 8008b64:	4b06      	ldr	r3, [pc, #24]	; (8008b80 <chSysUnlock.lto_priv.314+0x30>)
 8008b66:	699b      	ldr	r3, [r3, #24]
 8008b68:	689a      	ldr	r2, [r3, #8]
 8008b6a:	4b05      	ldr	r3, [pc, #20]	; (8008b80 <chSysUnlock.lto_priv.314+0x30>)
 8008b6c:	681b      	ldr	r3, [r3, #0]
 8008b6e:	689b      	ldr	r3, [r3, #8]
 8008b70:	429a      	cmp	r2, r3
 8008b72:	d202      	bcs.n	8008b7a <chSysUnlock.lto_priv.314+0x2a>
 8008b74:	4803      	ldr	r0, [pc, #12]	; (8008b84 <chSysUnlock.lto_priv.314+0x34>)
 8008b76:	f002 ffbb 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8008b7a:	f7ff ffd9 	bl	8008b30 <port_unlock.lto_priv.322>
}
 8008b7e:	bd08      	pop	{r3, pc}
 8008b80:	20000d30 	.word	0x20000d30
 8008b84:	0800e150 	.word	0x0800e150
	...

08008b90 <chPoolAdd>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be added
 *
 * @api
 */
static inline void chPoolAdd(memory_pool_t *mp, void *objp) {
 8008b90:	b500      	push	{lr}
 8008b92:	b083      	sub	sp, #12
 8008b94:	9001      	str	r0, [sp, #4]
 8008b96:	9100      	str	r1, [sp, #0]

  chPoolFree(mp, objp);
 8008b98:	9801      	ldr	r0, [sp, #4]
 8008b9a:	9900      	ldr	r1, [sp, #0]
 8008b9c:	f000 f8b0 	bl	8008d00 <chPoolFree>
}
 8008ba0:	b003      	add	sp, #12
 8008ba2:	f85d fb04 	ldr.w	pc, [sp], #4
 8008ba6:	bf00      	nop
	...

08008bb0 <chPoolObjectInit>:
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {
 8008bb0:	b500      	push	{lr}
 8008bb2:	b085      	sub	sp, #20
 8008bb4:	9003      	str	r0, [sp, #12]
 8008bb6:	9102      	str	r1, [sp, #8]
 8008bb8:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));
 8008bba:	9b03      	ldr	r3, [sp, #12]
 8008bbc:	2b00      	cmp	r3, #0
 8008bbe:	d002      	beq.n	8008bc6 <chPoolObjectInit+0x16>
 8008bc0:	9b02      	ldr	r3, [sp, #8]
 8008bc2:	2b03      	cmp	r3, #3
 8008bc4:	d802      	bhi.n	8008bcc <chPoolObjectInit+0x1c>
 8008bc6:	4807      	ldr	r0, [pc, #28]	; (8008be4 <chPoolObjectInit+0x34>)
 8008bc8:	f002 ff92 	bl	800baf0 <chSysHalt>

  mp->mp_next = NULL;
 8008bcc:	9b03      	ldr	r3, [sp, #12]
 8008bce:	2200      	movs	r2, #0
 8008bd0:	601a      	str	r2, [r3, #0]
  mp->mp_object_size = size;
 8008bd2:	9b03      	ldr	r3, [sp, #12]
 8008bd4:	9a02      	ldr	r2, [sp, #8]
 8008bd6:	605a      	str	r2, [r3, #4]
  mp->mp_provider = provider;
 8008bd8:	9b03      	ldr	r3, [sp, #12]
 8008bda:	9a01      	ldr	r2, [sp, #4]
 8008bdc:	609a      	str	r2, [r3, #8]
}
 8008bde:	b005      	add	sp, #20
 8008be0:	f85d fb04 	ldr.w	pc, [sp], #4
 8008be4:	0800e110 	.word	0x0800e110
	...

08008bf0 <chPoolLoadArray>:
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {
 8008bf0:	b500      	push	{lr}
 8008bf2:	b085      	sub	sp, #20
 8008bf4:	9003      	str	r0, [sp, #12]
 8008bf6:	9102      	str	r1, [sp, #8]
 8008bf8:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (n != 0U));
 8008bfa:	9b03      	ldr	r3, [sp, #12]
 8008bfc:	2b00      	cmp	r3, #0
 8008bfe:	d002      	beq.n	8008c06 <chPoolLoadArray+0x16>
 8008c00:	9b01      	ldr	r3, [sp, #4]
 8008c02:	2b00      	cmp	r3, #0
 8008c04:	d10f      	bne.n	8008c26 <chPoolLoadArray+0x36>
 8008c06:	480b      	ldr	r0, [pc, #44]	; (8008c34 <chPoolLoadArray+0x44>)
 8008c08:	f002 ff72 	bl	800baf0 <chSysHalt>
 8008c0c:	e00b      	b.n	8008c26 <chPoolLoadArray+0x36>

  while (n != 0U) {
    chPoolAdd(mp, p);
 8008c0e:	9803      	ldr	r0, [sp, #12]
 8008c10:	9902      	ldr	r1, [sp, #8]
 8008c12:	f7ff ffbd 	bl	8008b90 <chPoolAdd>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 8008c16:	9b03      	ldr	r3, [sp, #12]
 8008c18:	685b      	ldr	r3, [r3, #4]
 8008c1a:	9a02      	ldr	r2, [sp, #8]
 8008c1c:	4413      	add	r3, r2
 8008c1e:	9302      	str	r3, [sp, #8]
    /*lint -restore*/
    n--;
 8008c20:	9b01      	ldr	r3, [sp, #4]
 8008c22:	3b01      	subs	r3, #1
 8008c24:	9301      	str	r3, [sp, #4]
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8008c26:	9b01      	ldr	r3, [sp, #4]
 8008c28:	2b00      	cmp	r3, #0
 8008c2a:	d1f0      	bne.n	8008c0e <chPoolLoadArray+0x1e>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
    /*lint -restore*/
    n--;
  }
}
 8008c2c:	b005      	add	sp, #20
 8008c2e:	f85d fb04 	ldr.w	pc, [sp], #4
 8008c32:	bf00      	nop
 8008c34:	0800e130 	.word	0x0800e130
	...

08008c40 <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
 8008c40:	b500      	push	{lr}
 8008c42:	b085      	sub	sp, #20
 8008c44:	9001      	str	r0, [sp, #4]
  void *objp;

  chDbgCheckClassI();
 8008c46:	f003 f94b 	bl	800bee0 <chDbgCheckClassI>
  chDbgCheck(mp != NULL);
 8008c4a:	9b01      	ldr	r3, [sp, #4]
 8008c4c:	2b00      	cmp	r3, #0
 8008c4e:	d102      	bne.n	8008c56 <chPoolAllocI+0x16>
 8008c50:	480f      	ldr	r0, [pc, #60]	; (8008c90 <chPoolAllocI+0x50>)
 8008c52:	f002 ff4d 	bl	800baf0 <chSysHalt>

  objp = mp->mp_next;
 8008c56:	9b01      	ldr	r3, [sp, #4]
 8008c58:	681b      	ldr	r3, [r3, #0]
 8008c5a:	9303      	str	r3, [sp, #12]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 8008c5c:	9b03      	ldr	r3, [sp, #12]
 8008c5e:	2b00      	cmp	r3, #0
 8008c60:	d005      	beq.n	8008c6e <chPoolAllocI+0x2e>
    mp->mp_next = mp->mp_next->ph_next;
 8008c62:	9b01      	ldr	r3, [sp, #4]
 8008c64:	681b      	ldr	r3, [r3, #0]
 8008c66:	681a      	ldr	r2, [r3, #0]
 8008c68:	9b01      	ldr	r3, [sp, #4]
 8008c6a:	601a      	str	r2, [r3, #0]
 8008c6c:	e00a      	b.n	8008c84 <chPoolAllocI+0x44>
  }
  else if (mp->mp_provider != NULL) {
 8008c6e:	9b01      	ldr	r3, [sp, #4]
 8008c70:	689b      	ldr	r3, [r3, #8]
 8008c72:	2b00      	cmp	r3, #0
 8008c74:	d006      	beq.n	8008c84 <chPoolAllocI+0x44>
    objp = mp->mp_provider(mp->mp_object_size);
 8008c76:	9b01      	ldr	r3, [sp, #4]
 8008c78:	689b      	ldr	r3, [r3, #8]
 8008c7a:	9a01      	ldr	r2, [sp, #4]
 8008c7c:	6852      	ldr	r2, [r2, #4]
 8008c7e:	4610      	mov	r0, r2
 8008c80:	4798      	blx	r3
 8008c82:	9003      	str	r0, [sp, #12]
  }
  /*lint -restore*/

  return objp;
 8008c84:	9b03      	ldr	r3, [sp, #12]
}
 8008c86:	4618      	mov	r0, r3
 8008c88:	b005      	add	sp, #20
 8008c8a:	f85d fb04 	ldr.w	pc, [sp], #4
 8008c8e:	bf00      	nop
 8008c90:	0800e140 	.word	0x0800e140
	...

08008ca0 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 8008ca0:	b500      	push	{lr}
 8008ca2:	b085      	sub	sp, #20
 8008ca4:	9001      	str	r0, [sp, #4]
  void *objp;

  chSysLock();
 8008ca6:	f7ff ff4b 	bl	8008b40 <chSysLock.lto_priv.319>
  objp = chPoolAllocI(mp);
 8008caa:	9801      	ldr	r0, [sp, #4]
 8008cac:	f7ff ffc8 	bl	8008c40 <chPoolAllocI>
 8008cb0:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8008cb2:	f7ff ff4d 	bl	8008b50 <chSysUnlock.lto_priv.314>

  return objp;
 8008cb6:	9b03      	ldr	r3, [sp, #12]
}
 8008cb8:	4618      	mov	r0, r3
 8008cba:	b005      	add	sp, #20
 8008cbc:	f85d fb04 	ldr.w	pc, [sp], #4

08008cc0 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8008cc0:	b500      	push	{lr}
 8008cc2:	b085      	sub	sp, #20
 8008cc4:	9001      	str	r0, [sp, #4]
 8008cc6:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
 8008cc8:	9b00      	ldr	r3, [sp, #0]
 8008cca:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
 8008ccc:	f003 f908 	bl	800bee0 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
 8008cd0:	9b01      	ldr	r3, [sp, #4]
 8008cd2:	2b00      	cmp	r3, #0
 8008cd4:	d002      	beq.n	8008cdc <chPoolFreeI+0x1c>
 8008cd6:	9b00      	ldr	r3, [sp, #0]
 8008cd8:	2b00      	cmp	r3, #0
 8008cda:	d102      	bne.n	8008ce2 <chPoolFreeI+0x22>
 8008cdc:	4806      	ldr	r0, [pc, #24]	; (8008cf8 <chPoolFreeI+0x38>)
 8008cde:	f002 ff07 	bl	800baf0 <chSysHalt>

  php->ph_next = mp->mp_next;
 8008ce2:	9b01      	ldr	r3, [sp, #4]
 8008ce4:	681a      	ldr	r2, [r3, #0]
 8008ce6:	9b03      	ldr	r3, [sp, #12]
 8008ce8:	601a      	str	r2, [r3, #0]
  mp->mp_next = php;
 8008cea:	9b01      	ldr	r3, [sp, #4]
 8008cec:	9a03      	ldr	r2, [sp, #12]
 8008cee:	601a      	str	r2, [r3, #0]
}
 8008cf0:	b005      	add	sp, #20
 8008cf2:	f85d fb04 	ldr.w	pc, [sp], #4
 8008cf6:	bf00      	nop
 8008cf8:	0800e160 	.word	0x0800e160
 8008cfc:	00000000 	.word	0x00000000

08008d00 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 8008d00:	b500      	push	{lr}
 8008d02:	b083      	sub	sp, #12
 8008d04:	9001      	str	r0, [sp, #4]
 8008d06:	9100      	str	r1, [sp, #0]

  chSysLock();
 8008d08:	f7ff ff1a 	bl	8008b40 <chSysLock.lto_priv.319>
  chPoolFreeI(mp, objp);
 8008d0c:	9801      	ldr	r0, [sp, #4]
 8008d0e:	9900      	ldr	r1, [sp, #0]
 8008d10:	f7ff ffd6 	bl	8008cc0 <chPoolFreeI>
  chSysUnlock();
 8008d14:	f7ff ff1c 	bl	8008b50 <chSysUnlock.lto_priv.314>
}
 8008d18:	b003      	add	sp, #12
 8008d1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8008d1e:	bf00      	nop

08008d20 <port_lock.lto_priv.327>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8008d20:	b082      	sub	sp, #8
 8008d22:	2320      	movs	r3, #32
 8008d24:	9301      	str	r3, [sp, #4]
 8008d26:	9b01      	ldr	r3, [sp, #4]
 8008d28:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8008d2c:	b002      	add	sp, #8
 8008d2e:	4770      	bx	lr

08008d30 <port_unlock.lto_priv.323>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8008d30:	b082      	sub	sp, #8
 8008d32:	2300      	movs	r3, #0
 8008d34:	9301      	str	r3, [sp, #4]
 8008d36:	9b01      	ldr	r3, [sp, #4]
 8008d38:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8008d3c:	b002      	add	sp, #8
 8008d3e:	4770      	bx	lr

08008d40 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8008d40:	b508      	push	{r3, lr}

  port_lock();
 8008d42:	f7ff ffed 	bl	8008d20 <port_lock.lto_priv.327>
}
 8008d46:	bd08      	pop	{r3, pc}
	...

08008d50 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8008d50:	b508      	push	{r3, lr}

  port_unlock();
 8008d52:	f7ff ffed 	bl	8008d30 <port_unlock.lto_priv.323>
}
 8008d56:	bd08      	pop	{r3, pc}
	...

08008d60 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8008d60:	b510      	push	{r4, lr}
 8008d62:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8008d64:	f3ef 8309 	mrs	r3, PSP
 8008d68:	461c      	mov	r4, r3
  return(result);
 8008d6a:	4623      	mov	r3, r4
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
 8008d6c:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8008d6e:	9b01      	ldr	r3, [sp, #4]
 8008d70:	3320      	adds	r3, #32
 8008d72:	9301      	str	r3, [sp, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
 8008d74:	9b01      	ldr	r3, [sp, #4]
 8008d76:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8008d78:	9b00      	ldr	r3, [sp, #0]
 8008d7a:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 8008d7e:	f7ff ffe7 	bl	8008d50 <port_unlock_from_isr>
}
 8008d82:	b002      	add	sp, #8
 8008d84:	bd10      	pop	{r4, pc}
 8008d86:	bf00      	nop
	...

08008d90 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8008d90:	b510      	push	{r4, lr}
 8008d92:	b082      	sub	sp, #8

  port_lock_from_isr();
 8008d94:	f7ff ffd4 	bl	8008d40 <port_lock_from_isr>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8008d98:	4b13      	ldr	r3, [pc, #76]	; (8008de8 <_port_irq_epilogue+0x58>)
 8008d9a:	685b      	ldr	r3, [r3, #4]
 8008d9c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8008da0:	2b00      	cmp	r3, #0
 8008da2:	d01d      	beq.n	8008de0 <_port_irq_epilogue+0x50>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8008da4:	f3ef 8309 	mrs	r3, PSP
 8008da8:	461c      	mov	r4, r3
  return(result);
 8008daa:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 8008dac:	9301      	str	r3, [sp, #4]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8008dae:	9b01      	ldr	r3, [sp, #4]
 8008db0:	3b20      	subs	r3, #32
 8008db2:	9301      	str	r3, [sp, #4]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8008db4:	9b01      	ldr	r3, [sp, #4]
 8008db6:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8008dba:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 8008dbc:	9b01      	ldr	r3, [sp, #4]
 8008dbe:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8008dc0:	9b00      	ldr	r3, [sp, #0]
 8008dc2:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8008dc6:	f003 fc73 	bl	800c6b0 <chSchIsPreemptionRequired>
 8008dca:	4603      	mov	r3, r0
 8008dcc:	2b00      	cmp	r3, #0
 8008dce:	d003      	beq.n	8008dd8 <_port_irq_epilogue+0x48>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8008dd0:	9b01      	ldr	r3, [sp, #4]
 8008dd2:	4a06      	ldr	r2, [pc, #24]	; (8008dec <_port_irq_epilogue+0x5c>)
 8008dd4:	619a      	str	r2, [r3, #24]
 8008dd6:	e005      	b.n	8008de4 <_port_irq_epilogue+0x54>
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8008dd8:	9b01      	ldr	r3, [sp, #4]
 8008dda:	4a05      	ldr	r2, [pc, #20]	; (8008df0 <_port_irq_epilogue+0x60>)
 8008ddc:	619a      	str	r2, [r3, #24]
 8008dde:	e001      	b.n	8008de4 <_port_irq_epilogue+0x54>

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
 8008de0:	f7ff ffb6 	bl	8008d50 <port_unlock_from_isr>
}
 8008de4:	b002      	add	sp, #8
 8008de6:	bd10      	pop	{r4, pc}
 8008de8:	e000ed00 	.word	0xe000ed00
 8008dec:	080002b9 	.word	0x080002b9
 8008df0:	080002cc 	.word	0x080002cc
	...

08008e00 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8008e00:	4770      	bx	lr
 8008e02:	bf00      	nop
	...

08008e10 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8008e10:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8008e12:	f7ff fff5 	bl	8008e00 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8008e16:	f7fe ff73 	bl	8007d00 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8008e1a:	4806      	ldr	r0, [pc, #24]	; (8008e34 <halInit+0x24>)
 8008e1c:	f7fd fb48 	bl	80064b0 <_pal_lld_init>
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
#endif
#if (HAL_USE_I2C == TRUE) || defined(__DOXYGEN__)
  i2cInit();
 8008e20:	f7fe fc76 	bl	8007710 <i2cInit>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8008e24:	f7fe fe7c 	bl	8007b20 <sdInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8008e28:	f7fc fab2 	bl	8005390 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8008e2c:	f000 f838 	bl	8008ea0 <stInit>
#endif
}
 8008e30:	bd08      	pop	{r3, pc}
 8008e32:	bf00      	nop
 8008e34:	0800e370 	.word	0x0800e370
	...

08008e40 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 8008e40:	b082      	sub	sp, #8
 8008e42:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8008e44:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8008e48:	9b01      	ldr	r3, [sp, #4]
 8008e4a:	6353      	str	r3, [r2, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8008e4c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008e50:	2200      	movs	r2, #0
 8008e52:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8008e54:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008e58:	2202      	movs	r2, #2
 8008e5a:	60da      	str	r2, [r3, #12]
}
 8008e5c:	b002      	add	sp, #8
 8008e5e:	4770      	bx	lr

08008e60 <st_lld_stop_alarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8008e60:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008e64:	2200      	movs	r2, #0
 8008e66:	60da      	str	r2, [r3, #12]
}
 8008e68:	4770      	bx	lr
 8008e6a:	bf00      	nop
 8008e6c:	0000      	movs	r0, r0
	...

08008e70 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8008e70:	b082      	sub	sp, #8
 8008e72:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8008e74:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8008e78:	9b01      	ldr	r3, [sp, #4]
 8008e7a:	6353      	str	r3, [r2, #52]	; 0x34
}
 8008e7c:	b002      	add	sp, #8
 8008e7e:	4770      	bx	lr

08008e80 <st_lld_is_alarm_active>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8008e80:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008e84:	68db      	ldr	r3, [r3, #12]
 8008e86:	f003 0302 	and.w	r3, r3, #2
 8008e8a:	2b00      	cmp	r3, #0
 8008e8c:	bf14      	ite	ne
 8008e8e:	2301      	movne	r3, #1
 8008e90:	2300      	moveq	r3, #0
 8008e92:	b2db      	uxtb	r3, r3
}
 8008e94:	4618      	mov	r0, r3
 8008e96:	4770      	bx	lr
	...

08008ea0 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8008ea0:	b508      	push	{r3, lr}

  st_lld_init();
 8008ea2:	f7fd faa5 	bl	80063f0 <st_lld_init>
}
 8008ea6:	bd08      	pop	{r3, pc}
	...

08008eb0 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8008eb0:	b500      	push	{lr}
 8008eb2:	b083      	sub	sp, #12
 8008eb4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8008eb6:	f7ff ffe3 	bl	8008e80 <st_lld_is_alarm_active>
 8008eba:	4603      	mov	r3, r0
 8008ebc:	2b00      	cmp	r3, #0
 8008ebe:	d002      	beq.n	8008ec6 <stStartAlarm+0x16>
 8008ec0:	4804      	ldr	r0, [pc, #16]	; (8008ed4 <stStartAlarm+0x24>)
 8008ec2:	f002 fe15 	bl	800baf0 <chSysHalt>

  st_lld_start_alarm(abstime);
 8008ec6:	9801      	ldr	r0, [sp, #4]
 8008ec8:	f7ff ffba 	bl	8008e40 <st_lld_start_alarm>
}
 8008ecc:	b003      	add	sp, #12
 8008ece:	f85d fb04 	ldr.w	pc, [sp], #4
 8008ed2:	bf00      	nop
 8008ed4:	0800e170 	.word	0x0800e170
	...

08008ee0 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8008ee0:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 8008ee2:	f7ff ffbd 	bl	8008e60 <st_lld_stop_alarm>
}
 8008ee6:	bd08      	pop	{r3, pc}
	...

08008ef0 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8008ef0:	b500      	push	{lr}
 8008ef2:	b083      	sub	sp, #12
 8008ef4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8008ef6:	f7ff ffc3 	bl	8008e80 <st_lld_is_alarm_active>
 8008efa:	4603      	mov	r3, r0
 8008efc:	f083 0301 	eor.w	r3, r3, #1
 8008f00:	b2db      	uxtb	r3, r3
 8008f02:	2b00      	cmp	r3, #0
 8008f04:	d002      	beq.n	8008f0c <stSetAlarm+0x1c>
 8008f06:	4804      	ldr	r0, [pc, #16]	; (8008f18 <stSetAlarm+0x28>)
 8008f08:	f002 fdf2 	bl	800baf0 <chSysHalt>

  st_lld_set_alarm(abstime);
 8008f0c:	9801      	ldr	r0, [sp, #4]
 8008f0e:	f7ff ffaf 	bl	8008e70 <st_lld_set_alarm>
}
 8008f12:	b003      	add	sp, #12
 8008f14:	f85d fb04 	ldr.w	pc, [sp], #4
 8008f18:	0800e180 	.word	0x0800e180
 8008f1c:	00000000 	.word	0x00000000

08008f20 <chCondObjectInit>:
 *
 * @param[out] cp       pointer to a @p condition_variable_t structure
 *
 * @init
 */
void chCondObjectInit(condition_variable_t *cp) {
 8008f20:	b500      	push	{lr}
 8008f22:	b083      	sub	sp, #12
 8008f24:	9001      	str	r0, [sp, #4]

  chDbgCheck(cp != NULL);
 8008f26:	9b01      	ldr	r3, [sp, #4]
 8008f28:	2b00      	cmp	r3, #0
 8008f2a:	d102      	bne.n	8008f32 <chCondObjectInit+0x12>
 8008f2c:	4804      	ldr	r0, [pc, #16]	; (8008f40 <chCondObjectInit+0x20>)
 8008f2e:	f002 fddf 	bl	800baf0 <chSysHalt>

  queue_init(&cp->c_queue);
 8008f32:	9b01      	ldr	r3, [sp, #4]
 8008f34:	4618      	mov	r0, r3
 8008f36:	f002 fabb 	bl	800b4b0 <queue_init.lto_priv.341>
}
 8008f3a:	b003      	add	sp, #12
 8008f3c:	f85d fb04 	ldr.w	pc, [sp], #4
 8008f40:	0800dea0 	.word	0x0800dea0
	...

08008f50 <chCondSignal>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 8008f50:	b500      	push	{lr}
 8008f52:	b083      	sub	sp, #12
 8008f54:	9001      	str	r0, [sp, #4]

  chDbgCheck(cp != NULL);
 8008f56:	9b01      	ldr	r3, [sp, #4]
 8008f58:	2b00      	cmp	r3, #0
 8008f5a:	d102      	bne.n	8008f62 <chCondSignal+0x12>
 8008f5c:	480c      	ldr	r0, [pc, #48]	; (8008f90 <chCondSignal+0x40>)
 8008f5e:	f002 fdc7 	bl	800baf0 <chSysHalt>

  chSysLock();
 8008f62:	f002 fb05 	bl	800b570 <chSysLock.lto_priv.358>
  if (queue_notempty(&cp->c_queue)) {
 8008f66:	9b01      	ldr	r3, [sp, #4]
 8008f68:	4618      	mov	r0, r3
 8008f6a:	f002 fab1 	bl	800b4d0 <queue_notempty.lto_priv.371>
 8008f6e:	4603      	mov	r3, r0
 8008f70:	2b00      	cmp	r3, #0
 8008f72:	d008      	beq.n	8008f86 <chCondSignal+0x36>
    chSchWakeupS(queue_fifo_remove(&cp->c_queue), MSG_OK);
 8008f74:	9b01      	ldr	r3, [sp, #4]
 8008f76:	4618      	mov	r0, r3
 8008f78:	f002 fae2 	bl	800b540 <queue_fifo_remove.lto_priv.362>
 8008f7c:	4603      	mov	r3, r0
 8008f7e:	4618      	mov	r0, r3
 8008f80:	2100      	movs	r1, #0
 8008f82:	f003 fb2d 	bl	800c5e0 <chSchWakeupS>
  }
  chSysUnlock();
 8008f86:	f002 fafb 	bl	800b580 <chSysUnlock.lto_priv.354>
}
 8008f8a:	b003      	add	sp, #12
 8008f8c:	f85d fb04 	ldr.w	pc, [sp], #4
 8008f90:	0800dec0 	.word	0x0800dec0
	...

08008fa0 <chCondSignalI>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 8008fa0:	b500      	push	{lr}
 8008fa2:	b085      	sub	sp, #20
 8008fa4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8008fa6:	f002 ff9b 	bl	800bee0 <chDbgCheckClassI>
  chDbgCheck(cp != NULL);
 8008faa:	9b01      	ldr	r3, [sp, #4]
 8008fac:	2b00      	cmp	r3, #0
 8008fae:	d102      	bne.n	8008fb6 <chCondSignalI+0x16>
 8008fb0:	480b      	ldr	r0, [pc, #44]	; (8008fe0 <chCondSignalI+0x40>)
 8008fb2:	f002 fd9d 	bl	800baf0 <chSysHalt>

  if (queue_notempty(&cp->c_queue)) {
 8008fb6:	9b01      	ldr	r3, [sp, #4]
 8008fb8:	4618      	mov	r0, r3
 8008fba:	f002 fa89 	bl	800b4d0 <queue_notempty.lto_priv.371>
 8008fbe:	4603      	mov	r3, r0
 8008fc0:	2b00      	cmp	r3, #0
 8008fc2:	d00a      	beq.n	8008fda <chCondSignalI+0x3a>
    thread_t *tp = queue_fifo_remove(&cp->c_queue);
 8008fc4:	9b01      	ldr	r3, [sp, #4]
 8008fc6:	4618      	mov	r0, r3
 8008fc8:	f002 faba 	bl	800b540 <queue_fifo_remove.lto_priv.362>
 8008fcc:	9003      	str	r0, [sp, #12]
    tp->p_u.rdymsg = MSG_OK;
 8008fce:	9b03      	ldr	r3, [sp, #12]
 8008fd0:	2200      	movs	r2, #0
 8008fd2:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8008fd4:	9803      	ldr	r0, [sp, #12]
 8008fd6:	f003 fa0b 	bl	800c3f0 <chSchReadyI>
  }
}
 8008fda:	b005      	add	sp, #20
 8008fdc:	f85d fb04 	ldr.w	pc, [sp], #4
 8008fe0:	0800dee0 	.word	0x0800dee0
	...

08008ff0 <chCondBroadcast>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondBroadcast(condition_variable_t *cp) {
 8008ff0:	b500      	push	{lr}
 8008ff2:	b083      	sub	sp, #12
 8008ff4:	9001      	str	r0, [sp, #4]

  chSysLock();
 8008ff6:	f002 fabb 	bl	800b570 <chSysLock.lto_priv.358>
  chCondBroadcastI(cp);
 8008ffa:	9801      	ldr	r0, [sp, #4]
 8008ffc:	f000 f808 	bl	8009010 <chCondBroadcastI>
  chSchRescheduleS();
 8009000:	f003 fb46 	bl	800c690 <chSchRescheduleS>
  chSysUnlock();
 8009004:	f002 fabc 	bl	800b580 <chSysUnlock.lto_priv.354>
}
 8009008:	b003      	add	sp, #12
 800900a:	f85d fb04 	ldr.w	pc, [sp], #4
 800900e:	bf00      	nop

08009010 <chCondBroadcastI>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondBroadcastI(condition_variable_t *cp) {
 8009010:	b500      	push	{lr}
 8009012:	b083      	sub	sp, #12
 8009014:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8009016:	f002 ff63 	bl	800bee0 <chDbgCheckClassI>
  chDbgCheck(cp != NULL);
 800901a:	9b01      	ldr	r3, [sp, #4]
 800901c:	2b00      	cmp	r3, #0
 800901e:	d10f      	bne.n	8009040 <chCondBroadcastI+0x30>
 8009020:	480c      	ldr	r0, [pc, #48]	; (8009054 <chCondBroadcastI+0x44>)
 8009022:	f002 fd65 	bl	800baf0 <chSysHalt>
 8009026:	e00b      	b.n	8009040 <chCondBroadcastI+0x30>

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
 8009028:	9b01      	ldr	r3, [sp, #4]
 800902a:	4618      	mov	r0, r3
 800902c:	f002 fa88 	bl	800b540 <queue_fifo_remove.lto_priv.362>
 8009030:	4603      	mov	r3, r0
 8009032:	4618      	mov	r0, r3
 8009034:	f003 f9dc 	bl	800c3f0 <chSchReadyI>
 8009038:	4602      	mov	r2, r0
 800903a:	f06f 0301 	mvn.w	r3, #1
 800903e:	6253      	str	r3, [r2, #36]	; 0x24
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 8009040:	9b01      	ldr	r3, [sp, #4]
 8009042:	4618      	mov	r0, r3
 8009044:	f002 fa44 	bl	800b4d0 <queue_notempty.lto_priv.371>
 8009048:	4603      	mov	r3, r0
 800904a:	2b00      	cmp	r3, #0
 800904c:	d1ec      	bne.n	8009028 <chCondBroadcastI+0x18>
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
  }
}
 800904e:	b003      	add	sp, #12
 8009050:	f85d fb04 	ldr.w	pc, [sp], #4
 8009054:	0800def0 	.word	0x0800def0
	...

08009060 <chCondWait>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @api
 */
msg_t chCondWait(condition_variable_t *cp) {
 8009060:	b500      	push	{lr}
 8009062:	b085      	sub	sp, #20
 8009064:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chSysLock();
 8009066:	f002 fa83 	bl	800b570 <chSysLock.lto_priv.358>
  msg = chCondWaitS(cp);
 800906a:	9801      	ldr	r0, [sp, #4]
 800906c:	f000 f808 	bl	8009080 <chCondWaitS>
 8009070:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8009072:	f002 fa85 	bl	800b580 <chSysUnlock.lto_priv.354>
  return msg;
 8009076:	9b03      	ldr	r3, [sp, #12]
}
 8009078:	4618      	mov	r0, r3
 800907a:	b005      	add	sp, #20
 800907c:	f85d fb04 	ldr.w	pc, [sp], #4

08009080 <chCondWaitS>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
 8009080:	b500      	push	{lr}
 8009082:	b087      	sub	sp, #28
 8009084:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8009086:	4b17      	ldr	r3, [pc, #92]	; (80090e4 <chCondWaitS+0x64>)
 8009088:	699b      	ldr	r3, [r3, #24]
 800908a:	9305      	str	r3, [sp, #20]
  mutex_t *mp;
  msg_t msg;

  chDbgCheckClassS();
 800908c:	f002 ff40 	bl	800bf10 <chDbgCheckClassS>
  chDbgCheck(cp != NULL);
 8009090:	9b01      	ldr	r3, [sp, #4]
 8009092:	2b00      	cmp	r3, #0
 8009094:	d102      	bne.n	800909c <chCondWaitS+0x1c>
 8009096:	4814      	ldr	r0, [pc, #80]	; (80090e8 <chCondWaitS+0x68>)
 8009098:	f002 fd2a 	bl	800baf0 <chSysHalt>
  chDbgAssert(ctp->p_mtxlist != NULL, "not owning a mutex");
 800909c:	9b05      	ldr	r3, [sp, #20]
 800909e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80090a0:	2b00      	cmp	r3, #0
 80090a2:	d102      	bne.n	80090aa <chCondWaitS+0x2a>
 80090a4:	4810      	ldr	r0, [pc, #64]	; (80090e8 <chCondWaitS+0x68>)
 80090a6:	f002 fd23 	bl	800baf0 <chSysHalt>

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
 80090aa:	f002 fa91 	bl	800b5d0 <chMtxGetNextMutexS.lto_priv.370>
 80090ae:	9004      	str	r0, [sp, #16]
  chMtxUnlockS(mp);
 80090b0:	9804      	ldr	r0, [sp, #16]
 80090b2:	f002 f93d 	bl	800b330 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->p_u.wtobjp = cp;
 80090b6:	9b05      	ldr	r3, [sp, #20]
 80090b8:	9a01      	ldr	r2, [sp, #4]
 80090ba:	625a      	str	r2, [r3, #36]	; 0x24
  queue_prio_insert(ctp, &cp->c_queue);
 80090bc:	9b01      	ldr	r3, [sp, #4]
 80090be:	9805      	ldr	r0, [sp, #20]
 80090c0:	4619      	mov	r1, r3
 80090c2:	f002 fa15 	bl	800b4f0 <queue_prio_insert.lto_priv.369>
  chSchGoSleepS(CH_STATE_WTCOND);
 80090c6:	2007      	movs	r0, #7
 80090c8:	f003 f9d2 	bl	800c470 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 80090cc:	9b05      	ldr	r3, [sp, #20]
 80090ce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80090d0:	9303      	str	r3, [sp, #12]
  chMtxLockS(mp);
 80090d2:	9804      	ldr	r0, [sp, #16]
 80090d4:	f001 fff4 	bl	800b0c0 <chMtxLockS>

  return msg;
 80090d8:	9b03      	ldr	r3, [sp, #12]
}
 80090da:	4618      	mov	r0, r3
 80090dc:	b007      	add	sp, #28
 80090de:	f85d fb04 	ldr.w	pc, [sp], #4
 80090e2:	bf00      	nop
 80090e4:	20000d30 	.word	0x20000d30
 80090e8:	0800df10 	.word	0x0800df10
 80090ec:	00000000 	.word	0x00000000

080090f0 <chCondWaitTimeout>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chCondWaitTimeout(condition_variable_t *cp, systime_t time) {
 80090f0:	b500      	push	{lr}
 80090f2:	b085      	sub	sp, #20
 80090f4:	9001      	str	r0, [sp, #4]
 80090f6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chSysLock();
 80090f8:	f002 fa3a 	bl	800b570 <chSysLock.lto_priv.358>
  msg = chCondWaitTimeoutS(cp, time);
 80090fc:	9801      	ldr	r0, [sp, #4]
 80090fe:	9900      	ldr	r1, [sp, #0]
 8009100:	f000 f80e 	bl	8009120 <chCondWaitTimeoutS>
 8009104:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8009106:	f002 fa3b 	bl	800b580 <chSysUnlock.lto_priv.354>

  return msg;
 800910a:	9b03      	ldr	r3, [sp, #12]
}
 800910c:	4618      	mov	r0, r3
 800910e:	b005      	add	sp, #20
 8009110:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08009120 <chCondWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chCondWaitTimeoutS(condition_variable_t *cp, systime_t time) {
 8009120:	b500      	push	{lr}
 8009122:	b085      	sub	sp, #20
 8009124:	9001      	str	r0, [sp, #4]
 8009126:	9100      	str	r1, [sp, #0]
  mutex_t *mp;
  msg_t msg;

  chDbgCheckClassS();
 8009128:	f002 fef2 	bl	800bf10 <chDbgCheckClassS>
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
 800912c:	9b01      	ldr	r3, [sp, #4]
 800912e:	2b00      	cmp	r3, #0
 8009130:	d002      	beq.n	8009138 <chCondWaitTimeoutS+0x18>
 8009132:	9b00      	ldr	r3, [sp, #0]
 8009134:	2b00      	cmp	r3, #0
 8009136:	d102      	bne.n	800913e <chCondWaitTimeoutS+0x1e>
 8009138:	4816      	ldr	r0, [pc, #88]	; (8009194 <chCondWaitTimeoutS+0x74>)
 800913a:	f002 fcd9 	bl	800baf0 <chSysHalt>
  chDbgAssert(currp->p_mtxlist != NULL, "not owning a mutex");
 800913e:	4b16      	ldr	r3, [pc, #88]	; (8009198 <chCondWaitTimeoutS+0x78>)
 8009140:	699b      	ldr	r3, [r3, #24]
 8009142:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8009144:	2b00      	cmp	r3, #0
 8009146:	d102      	bne.n	800914e <chCondWaitTimeoutS+0x2e>
 8009148:	4812      	ldr	r0, [pc, #72]	; (8009194 <chCondWaitTimeoutS+0x74>)
 800914a:	f002 fcd1 	bl	800baf0 <chSysHalt>

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
 800914e:	f002 fa3f 	bl	800b5d0 <chMtxGetNextMutexS.lto_priv.370>
 8009152:	9003      	str	r0, [sp, #12]
  chMtxUnlockS(mp);
 8009154:	9803      	ldr	r0, [sp, #12]
 8009156:	f002 f8eb 	bl	800b330 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->p_u.wtobjp = cp;
 800915a:	4b0f      	ldr	r3, [pc, #60]	; (8009198 <chCondWaitTimeoutS+0x78>)
 800915c:	699b      	ldr	r3, [r3, #24]
 800915e:	9a01      	ldr	r2, [sp, #4]
 8009160:	625a      	str	r2, [r3, #36]	; 0x24
  queue_prio_insert(currp, &cp->c_queue);
 8009162:	4b0d      	ldr	r3, [pc, #52]	; (8009198 <chCondWaitTimeoutS+0x78>)
 8009164:	699a      	ldr	r2, [r3, #24]
 8009166:	9b01      	ldr	r3, [sp, #4]
 8009168:	4610      	mov	r0, r2
 800916a:	4619      	mov	r1, r3
 800916c:	f002 f9c0 	bl	800b4f0 <queue_prio_insert.lto_priv.369>
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
 8009170:	2007      	movs	r0, #7
 8009172:	9900      	ldr	r1, [sp, #0]
 8009174:	f003 f9fc 	bl	800c570 <chSchGoSleepTimeoutS>
 8009178:	9002      	str	r0, [sp, #8]
  if (msg != MSG_TIMEOUT) {
 800917a:	9b02      	ldr	r3, [sp, #8]
 800917c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8009180:	d002      	beq.n	8009188 <chCondWaitTimeoutS+0x68>
    chMtxLockS(mp);
 8009182:	9803      	ldr	r0, [sp, #12]
 8009184:	f001 ff9c 	bl	800b0c0 <chMtxLockS>
  }

  return msg;
 8009188:	9b02      	ldr	r3, [sp, #8]
}
 800918a:	4618      	mov	r0, r3
 800918c:	b005      	add	sp, #20
 800918e:	f85d fb04 	ldr.w	pc, [sp], #4
 8009192:	bf00      	nop
 8009194:	0800df20 	.word	0x0800df20
 8009198:	20000d30 	.word	0x20000d30
 800919c:	00000000 	.word	0x00000000

080091a0 <port_lock.lto_priv.347>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80091a0:	b082      	sub	sp, #8
 80091a2:	2320      	movs	r3, #32
 80091a4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80091a6:	9b01      	ldr	r3, [sp, #4]
 80091a8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80091ac:	b002      	add	sp, #8
 80091ae:	4770      	bx	lr

080091b0 <port_unlock.lto_priv.343>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80091b0:	b082      	sub	sp, #8
 80091b2:	2300      	movs	r3, #0
 80091b4:	9301      	str	r3, [sp, #4]
 80091b6:	9b01      	ldr	r3, [sp, #4]
 80091b8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80091bc:	b002      	add	sp, #8
 80091be:	4770      	bx	lr

080091c0 <chSysLock.lto_priv.359>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80091c0:	b508      	push	{r3, lr}

  port_lock();
 80091c2:	f7ff ffed 	bl	80091a0 <port_lock.lto_priv.347>
  _stats_start_measure_crit_thd();
 80091c6:	f001 f93b 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 80091ca:	f002 fde9 	bl	800bda0 <_dbg_check_lock>
}
 80091ce:	bd08      	pop	{r3, pc}

080091d0 <chSysUnlock.lto_priv.355>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80091d0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 80091d2:	f002 fdfd 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80091d6:	f001 f93b 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80091da:	4b09      	ldr	r3, [pc, #36]	; (8009200 <chSysUnlock.lto_priv.355+0x30>)
 80091dc:	681b      	ldr	r3, [r3, #0]
 80091de:	4a08      	ldr	r2, [pc, #32]	; (8009200 <chSysUnlock.lto_priv.355+0x30>)
 80091e0:	4293      	cmp	r3, r2
 80091e2:	d00a      	beq.n	80091fa <chSysUnlock.lto_priv.355+0x2a>
 80091e4:	4b06      	ldr	r3, [pc, #24]	; (8009200 <chSysUnlock.lto_priv.355+0x30>)
 80091e6:	699b      	ldr	r3, [r3, #24]
 80091e8:	689a      	ldr	r2, [r3, #8]
 80091ea:	4b05      	ldr	r3, [pc, #20]	; (8009200 <chSysUnlock.lto_priv.355+0x30>)
 80091ec:	681b      	ldr	r3, [r3, #0]
 80091ee:	689b      	ldr	r3, [r3, #8]
 80091f0:	429a      	cmp	r2, r3
 80091f2:	d202      	bcs.n	80091fa <chSysUnlock.lto_priv.355+0x2a>
 80091f4:	4803      	ldr	r0, [pc, #12]	; (8009204 <chSysUnlock.lto_priv.355+0x34>)
 80091f6:	f002 fc7b 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80091fa:	f7ff ffd9 	bl	80091b0 <port_unlock.lto_priv.343>
}
 80091fe:	bd08      	pop	{r3, pc}
 8009200:	20000d30 	.word	0x20000d30
 8009204:	0800df60 	.word	0x0800df60
	...

08009210 <chEvtRegisterMaskWithFlags>:
 * @api
 */
void chEvtRegisterMaskWithFlags(event_source_t *esp,
                                event_listener_t *elp,
                                eventmask_t events,
                                eventflags_t wflags) {
 8009210:	b500      	push	{lr}
 8009212:	b085      	sub	sp, #20
 8009214:	9003      	str	r0, [sp, #12]
 8009216:	9102      	str	r1, [sp, #8]
 8009218:	9201      	str	r2, [sp, #4]
 800921a:	9300      	str	r3, [sp, #0]

  chDbgCheck((esp != NULL) && (elp != NULL));
 800921c:	9b03      	ldr	r3, [sp, #12]
 800921e:	2b00      	cmp	r3, #0
 8009220:	d002      	beq.n	8009228 <chEvtRegisterMaskWithFlags+0x18>
 8009222:	9b02      	ldr	r3, [sp, #8]
 8009224:	2b00      	cmp	r3, #0
 8009226:	d102      	bne.n	800922e <chEvtRegisterMaskWithFlags+0x1e>
 8009228:	480e      	ldr	r0, [pc, #56]	; (8009264 <chEvtRegisterMaskWithFlags+0x54>)
 800922a:	f002 fc61 	bl	800baf0 <chSysHalt>

  chSysLock();
 800922e:	f7ff ffc7 	bl	80091c0 <chSysLock.lto_priv.359>
  elp->el_next     = esp->es_next;
 8009232:	9b03      	ldr	r3, [sp, #12]
 8009234:	681a      	ldr	r2, [r3, #0]
 8009236:	9b02      	ldr	r3, [sp, #8]
 8009238:	601a      	str	r2, [r3, #0]
  esp->es_next     = elp;
 800923a:	9b03      	ldr	r3, [sp, #12]
 800923c:	9a02      	ldr	r2, [sp, #8]
 800923e:	601a      	str	r2, [r3, #0]
  elp->el_listener = currp;
 8009240:	4b09      	ldr	r3, [pc, #36]	; (8009268 <chEvtRegisterMaskWithFlags+0x58>)
 8009242:	699a      	ldr	r2, [r3, #24]
 8009244:	9b02      	ldr	r3, [sp, #8]
 8009246:	605a      	str	r2, [r3, #4]
  elp->el_events   = events;
 8009248:	9b02      	ldr	r3, [sp, #8]
 800924a:	9a01      	ldr	r2, [sp, #4]
 800924c:	609a      	str	r2, [r3, #8]
  elp->el_flags    = (eventflags_t)0;
 800924e:	9b02      	ldr	r3, [sp, #8]
 8009250:	2200      	movs	r2, #0
 8009252:	60da      	str	r2, [r3, #12]
  elp->el_wflags   = wflags;
 8009254:	9b02      	ldr	r3, [sp, #8]
 8009256:	9a00      	ldr	r2, [sp, #0]
 8009258:	611a      	str	r2, [r3, #16]
  chSysUnlock();
 800925a:	f7ff ffb9 	bl	80091d0 <chSysUnlock.lto_priv.355>
}
 800925e:	b005      	add	sp, #20
 8009260:	f85d fb04 	ldr.w	pc, [sp], #4
 8009264:	0800df40 	.word	0x0800df40
 8009268:	20000d30 	.word	0x20000d30
 800926c:	00000000 	.word	0x00000000

08009270 <chEvtUnregister>:
 * @param[in] esp       pointer to the  @p event_source_t structure
 * @param[in] elp       pointer to the @p event_listener_t structure
 *
 * @api
 */
void chEvtUnregister(event_source_t *esp, event_listener_t *elp) {
 8009270:	b500      	push	{lr}
 8009272:	b085      	sub	sp, #20
 8009274:	9001      	str	r0, [sp, #4]
 8009276:	9100      	str	r1, [sp, #0]
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));
 8009278:	9b01      	ldr	r3, [sp, #4]
 800927a:	2b00      	cmp	r3, #0
 800927c:	d002      	beq.n	8009284 <chEvtUnregister+0x14>
 800927e:	9b00      	ldr	r3, [sp, #0]
 8009280:	2b00      	cmp	r3, #0
 8009282:	d102      	bne.n	800928a <chEvtUnregister+0x1a>
 8009284:	480f      	ldr	r0, [pc, #60]	; (80092c4 <chEvtUnregister+0x54>)
 8009286:	f002 fc33 	bl	800baf0 <chSysHalt>

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
 800928a:	9b01      	ldr	r3, [sp, #4]
 800928c:	9303      	str	r3, [sp, #12]
  /*lint -restore*/
  chSysLock();
 800928e:	f7ff ff97 	bl	80091c0 <chSysLock.lto_priv.359>
 8009292:	e00c      	b.n	80092ae <chEvtUnregister+0x3e>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->el_next == elp) {
 8009294:	9b03      	ldr	r3, [sp, #12]
 8009296:	681a      	ldr	r2, [r3, #0]
 8009298:	9b00      	ldr	r3, [sp, #0]
 800929a:	429a      	cmp	r2, r3
 800929c:	d104      	bne.n	80092a8 <chEvtUnregister+0x38>
      p->el_next = elp->el_next;
 800929e:	9b00      	ldr	r3, [sp, #0]
 80092a0:	681a      	ldr	r2, [r3, #0]
 80092a2:	9b03      	ldr	r3, [sp, #12]
 80092a4:	601a      	str	r2, [r3, #0]
 80092a6:	e007      	b.n	80092b8 <chEvtUnregister+0x48>
      break;
    }
    p = p->el_next;
 80092a8:	9b03      	ldr	r3, [sp, #12]
 80092aa:	681b      	ldr	r3, [r3, #0]
 80092ac:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
 80092ae:	9b03      	ldr	r3, [sp, #12]
 80092b0:	681a      	ldr	r2, [r3, #0]
 80092b2:	9b01      	ldr	r3, [sp, #4]
 80092b4:	429a      	cmp	r2, r3
 80092b6:	d1ed      	bne.n	8009294 <chEvtUnregister+0x24>
      p->el_next = elp->el_next;
      break;
    }
    p = p->el_next;
  }
  chSysUnlock();
 80092b8:	f7ff ff8a 	bl	80091d0 <chSysUnlock.lto_priv.355>
}
 80092bc:	b005      	add	sp, #20
 80092be:	f85d fb04 	ldr.w	pc, [sp], #4
 80092c2:	bf00      	nop
 80092c4:	0800df70 	.word	0x0800df70
	...

080092d0 <chEvtGetAndClearEvents>:
 * @param[in] events    the events to be cleared
 * @return              The pending events that were cleared.
 *
 * @api
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
 80092d0:	b500      	push	{lr}
 80092d2:	b085      	sub	sp, #20
 80092d4:	9001      	str	r0, [sp, #4]
  eventmask_t m;

  chSysLock();
 80092d6:	f7ff ff73 	bl	80091c0 <chSysLock.lto_priv.359>
  m = currp->p_epending & events;
 80092da:	4b0b      	ldr	r3, [pc, #44]	; (8009308 <chEvtGetAndClearEvents+0x38>)
 80092dc:	699b      	ldr	r3, [r3, #24]
 80092de:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80092e0:	9b01      	ldr	r3, [sp, #4]
 80092e2:	4013      	ands	r3, r2
 80092e4:	9303      	str	r3, [sp, #12]
  currp->p_epending &= ~events;
 80092e6:	4b08      	ldr	r3, [pc, #32]	; (8009308 <chEvtGetAndClearEvents+0x38>)
 80092e8:	699b      	ldr	r3, [r3, #24]
 80092ea:	4a07      	ldr	r2, [pc, #28]	; (8009308 <chEvtGetAndClearEvents+0x38>)
 80092ec:	6992      	ldr	r2, [r2, #24]
 80092ee:	6b91      	ldr	r1, [r2, #56]	; 0x38
 80092f0:	9a01      	ldr	r2, [sp, #4]
 80092f2:	43d2      	mvns	r2, r2
 80092f4:	400a      	ands	r2, r1
 80092f6:	639a      	str	r2, [r3, #56]	; 0x38
  chSysUnlock();
 80092f8:	f7ff ff6a 	bl	80091d0 <chSysUnlock.lto_priv.355>

  return m;
 80092fc:	9b03      	ldr	r3, [sp, #12]
}
 80092fe:	4618      	mov	r0, r3
 8009300:	b005      	add	sp, #20
 8009302:	f85d fb04 	ldr.w	pc, [sp], #4
 8009306:	bf00      	nop
 8009308:	20000d30 	.word	0x20000d30
 800930c:	00000000 	.word	0x00000000

08009310 <chEvtAddEvents>:
 * @param[in] events    the events to be added
 * @return              The current pending events.
 *
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t events) {
 8009310:	b500      	push	{lr}
 8009312:	b083      	sub	sp, #12
 8009314:	9001      	str	r0, [sp, #4]

  chSysLock();
 8009316:	f7ff ff53 	bl	80091c0 <chSysLock.lto_priv.359>
  currp->p_epending |= events;
 800931a:	4b09      	ldr	r3, [pc, #36]	; (8009340 <chEvtAddEvents+0x30>)
 800931c:	699b      	ldr	r3, [r3, #24]
 800931e:	4a08      	ldr	r2, [pc, #32]	; (8009340 <chEvtAddEvents+0x30>)
 8009320:	6992      	ldr	r2, [r2, #24]
 8009322:	6b91      	ldr	r1, [r2, #56]	; 0x38
 8009324:	9a01      	ldr	r2, [sp, #4]
 8009326:	430a      	orrs	r2, r1
 8009328:	639a      	str	r2, [r3, #56]	; 0x38
  events = currp->p_epending;
 800932a:	4b05      	ldr	r3, [pc, #20]	; (8009340 <chEvtAddEvents+0x30>)
 800932c:	699b      	ldr	r3, [r3, #24]
 800932e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009330:	9301      	str	r3, [sp, #4]
  chSysUnlock();
 8009332:	f7ff ff4d 	bl	80091d0 <chSysUnlock.lto_priv.355>

  return events;
 8009336:	9b01      	ldr	r3, [sp, #4]
}
 8009338:	4618      	mov	r0, r3
 800933a:	b003      	add	sp, #12
 800933c:	f85d fb04 	ldr.w	pc, [sp], #4
 8009340:	20000d30 	.word	0x20000d30
	...

08009350 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8009350:	b500      	push	{lr}
 8009352:	b085      	sub	sp, #20
 8009354:	9001      	str	r0, [sp, #4]
 8009356:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
 8009358:	f002 fdc2 	bl	800bee0 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
 800935c:	9b01      	ldr	r3, [sp, #4]
 800935e:	2b00      	cmp	r3, #0
 8009360:	d102      	bne.n	8009368 <chEvtBroadcastFlagsI+0x18>
 8009362:	4814      	ldr	r0, [pc, #80]	; (80093b4 <chEvtBroadcastFlagsI+0x64>)
 8009364:	f002 fbc4 	bl	800baf0 <chSysHalt>

  elp = esp->es_next;
 8009368:	9b01      	ldr	r3, [sp, #4]
 800936a:	681b      	ldr	r3, [r3, #0]
 800936c:	9303      	str	r3, [sp, #12]
 800936e:	e01a      	b.n	80093a6 <chEvtBroadcastFlagsI+0x56>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
 8009370:	9b03      	ldr	r3, [sp, #12]
 8009372:	68da      	ldr	r2, [r3, #12]
 8009374:	9b00      	ldr	r3, [sp, #0]
 8009376:	431a      	orrs	r2, r3
 8009378:	9b03      	ldr	r3, [sp, #12]
 800937a:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 800937c:	9b00      	ldr	r3, [sp, #0]
 800937e:	2b00      	cmp	r3, #0
 8009380:	d006      	beq.n	8009390 <chEvtBroadcastFlagsI+0x40>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 8009382:	9b03      	ldr	r3, [sp, #12]
 8009384:	68da      	ldr	r2, [r3, #12]
 8009386:	9b03      	ldr	r3, [sp, #12]
 8009388:	691b      	ldr	r3, [r3, #16]
 800938a:	4013      	ands	r3, r2
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 800938c:	2b00      	cmp	r3, #0
 800938e:	d007      	beq.n	80093a0 <chEvtBroadcastFlagsI+0x50>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 8009390:	9b03      	ldr	r3, [sp, #12]
 8009392:	685a      	ldr	r2, [r3, #4]
 8009394:	9b03      	ldr	r3, [sp, #12]
 8009396:	689b      	ldr	r3, [r3, #8]
 8009398:	4610      	mov	r0, r2
 800939a:	4619      	mov	r1, r3
 800939c:	f000 f830 	bl	8009400 <chEvtSignalI>
    }
    elp = elp->el_next;
 80093a0:	9b03      	ldr	r3, [sp, #12]
 80093a2:	681b      	ldr	r3, [r3, #0]
 80093a4:	9303      	str	r3, [sp, #12]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80093a6:	9a03      	ldr	r2, [sp, #12]
 80093a8:	9b01      	ldr	r3, [sp, #4]
 80093aa:	429a      	cmp	r2, r3
 80093ac:	d1e0      	bne.n	8009370 <chEvtBroadcastFlagsI+0x20>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
 80093ae:	b005      	add	sp, #20
 80093b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80093b4:	0800df80 	.word	0x0800df80
	...

080093c0 <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t events) {
 80093c0:	b500      	push	{lr}
 80093c2:	b083      	sub	sp, #12
 80093c4:	9001      	str	r0, [sp, #4]
 80093c6:	9100      	str	r1, [sp, #0]

  chDbgCheck(tp != NULL);
 80093c8:	9b01      	ldr	r3, [sp, #4]
 80093ca:	2b00      	cmp	r3, #0
 80093cc:	d102      	bne.n	80093d4 <chEvtSignal+0x14>
 80093ce:	4808      	ldr	r0, [pc, #32]	; (80093f0 <chEvtSignal+0x30>)
 80093d0:	f002 fb8e 	bl	800baf0 <chSysHalt>

  chSysLock();
 80093d4:	f7ff fef4 	bl	80091c0 <chSysLock.lto_priv.359>
  chEvtSignalI(tp, events);
 80093d8:	9801      	ldr	r0, [sp, #4]
 80093da:	9900      	ldr	r1, [sp, #0]
 80093dc:	f000 f810 	bl	8009400 <chEvtSignalI>
  chSchRescheduleS();
 80093e0:	f003 f956 	bl	800c690 <chSchRescheduleS>
  chSysUnlock();
 80093e4:	f7ff fef4 	bl	80091d0 <chSysUnlock.lto_priv.355>
}
 80093e8:	b003      	add	sp, #12
 80093ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80093ee:	bf00      	nop
 80093f0:	0800dfa0 	.word	0x0800dfa0
	...

08009400 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8009400:	b500      	push	{lr}
 8009402:	b083      	sub	sp, #12
 8009404:	9001      	str	r0, [sp, #4]
 8009406:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 8009408:	f002 fd6a 	bl	800bee0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800940c:	9b01      	ldr	r3, [sp, #4]
 800940e:	2b00      	cmp	r3, #0
 8009410:	d102      	bne.n	8009418 <chEvtSignalI+0x18>
 8009412:	4816      	ldr	r0, [pc, #88]	; (800946c <chEvtSignalI+0x6c>)
 8009414:	f002 fb6c 	bl	800baf0 <chSysHalt>

  tp->p_epending |= events;
 8009418:	9b01      	ldr	r3, [sp, #4]
 800941a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800941c:	9b00      	ldr	r3, [sp, #0]
 800941e:	431a      	orrs	r2, r3
 8009420:	9b01      	ldr	r3, [sp, #4]
 8009422:	639a      	str	r2, [r3, #56]	; 0x38
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8009424:	9b01      	ldr	r3, [sp, #4]
 8009426:	f893 3020 	ldrb.w	r3, [r3, #32]
 800942a:	2b0a      	cmp	r3, #10
 800942c:	d106      	bne.n	800943c <chEvtSignalI+0x3c>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800942e:	9b01      	ldr	r3, [sp, #4]
 8009430:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8009432:	9b01      	ldr	r3, [sp, #4]
 8009434:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009436:	4013      	ands	r3, r2
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8009438:	2b00      	cmp	r3, #0
 800943a:	d10d      	bne.n	8009458 <chEvtSignalI+0x58>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 800943c:	9b01      	ldr	r3, [sp, #4]
 800943e:	f893 3020 	ldrb.w	r3, [r3, #32]
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8009442:	2b0b      	cmp	r3, #11
 8009444:	d10e      	bne.n	8009464 <chEvtSignalI+0x64>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8009446:	9b01      	ldr	r3, [sp, #4]
 8009448:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800944a:	9b01      	ldr	r3, [sp, #4]
 800944c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800944e:	401a      	ands	r2, r3
 8009450:	9b01      	ldr	r3, [sp, #4]
 8009452:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8009454:	429a      	cmp	r2, r3
 8009456:	d105      	bne.n	8009464 <chEvtSignalI+0x64>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8009458:	9b01      	ldr	r3, [sp, #4]
 800945a:	2200      	movs	r2, #0
 800945c:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800945e:	9801      	ldr	r0, [sp, #4]
 8009460:	f002 ffc6 	bl	800c3f0 <chSchReadyI>
  }
}
 8009464:	b003      	add	sp, #12
 8009466:	f85d fb04 	ldr.w	pc, [sp], #4
 800946a:	bf00      	nop
 800946c:	0800dfb0 	.word	0x0800dfb0

08009470 <chEvtBroadcastFlags>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {
 8009470:	b500      	push	{lr}
 8009472:	b083      	sub	sp, #12
 8009474:	9001      	str	r0, [sp, #4]
 8009476:	9100      	str	r1, [sp, #0]

  chSysLock();
 8009478:	f7ff fea2 	bl	80091c0 <chSysLock.lto_priv.359>
  chEvtBroadcastFlagsI(esp, flags);
 800947c:	9801      	ldr	r0, [sp, #4]
 800947e:	9900      	ldr	r1, [sp, #0]
 8009480:	f7ff ff66 	bl	8009350 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 8009484:	f003 f904 	bl	800c690 <chSchRescheduleS>
  chSysUnlock();
 8009488:	f7ff fea2 	bl	80091d0 <chSysUnlock.lto_priv.355>
}
 800948c:	b003      	add	sp, #12
 800948e:	f85d fb04 	ldr.w	pc, [sp], #4
 8009492:	bf00      	nop
	...

080094a0 <chEvtDispatch>:
 * @param[in] handlers  an array of @p evhandler_t. The array must have size
 *                      equal to the number of bits in eventmask_t.
 *
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
 80094a0:	b500      	push	{lr}
 80094a2:	b085      	sub	sp, #20
 80094a4:	9001      	str	r0, [sp, #4]
 80094a6:	9100      	str	r1, [sp, #0]
  eventid_t eid;

  chDbgCheck(handlers != NULL);
 80094a8:	9b01      	ldr	r3, [sp, #4]
 80094aa:	2b00      	cmp	r3, #0
 80094ac:	d102      	bne.n	80094b4 <chEvtDispatch+0x14>
 80094ae:	4818      	ldr	r0, [pc, #96]	; (8009510 <chEvtDispatch+0x70>)
 80094b0:	f002 fb1e 	bl	800baf0 <chSysHalt>

  eid = (eventid_t)0;
 80094b4:	2300      	movs	r3, #0
 80094b6:	9303      	str	r3, [sp, #12]
 80094b8:	e023      	b.n	8009502 <chEvtDispatch+0x62>
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 80094ba:	9a00      	ldr	r2, [sp, #0]
 80094bc:	9b03      	ldr	r3, [sp, #12]
 80094be:	fa22 f303 	lsr.w	r3, r2, r3
 80094c2:	f003 0301 	and.w	r3, r3, #1
 80094c6:	2b00      	cmp	r3, #0
 80094c8:	d018      	beq.n	80094fc <chEvtDispatch+0x5c>
      chDbgAssert(handlers[eid] != NULL, "null handler");
 80094ca:	9b03      	ldr	r3, [sp, #12]
 80094cc:	009b      	lsls	r3, r3, #2
 80094ce:	9a01      	ldr	r2, [sp, #4]
 80094d0:	4413      	add	r3, r2
 80094d2:	681b      	ldr	r3, [r3, #0]
 80094d4:	2b00      	cmp	r3, #0
 80094d6:	d102      	bne.n	80094de <chEvtDispatch+0x3e>
 80094d8:	480d      	ldr	r0, [pc, #52]	; (8009510 <chEvtDispatch+0x70>)
 80094da:	f002 fb09 	bl	800baf0 <chSysHalt>
      events &= ~EVENT_MASK(eid);
 80094de:	2201      	movs	r2, #1
 80094e0:	9b03      	ldr	r3, [sp, #12]
 80094e2:	fa02 f303 	lsl.w	r3, r2, r3
 80094e6:	43db      	mvns	r3, r3
 80094e8:	9a00      	ldr	r2, [sp, #0]
 80094ea:	4013      	ands	r3, r2
 80094ec:	9300      	str	r3, [sp, #0]
      handlers[eid](eid);
 80094ee:	9b03      	ldr	r3, [sp, #12]
 80094f0:	009b      	lsls	r3, r3, #2
 80094f2:	9a01      	ldr	r2, [sp, #4]
 80094f4:	4413      	add	r3, r2
 80094f6:	681b      	ldr	r3, [r3, #0]
 80094f8:	9803      	ldr	r0, [sp, #12]
 80094fa:	4798      	blx	r3
    }
    eid++;
 80094fc:	9b03      	ldr	r3, [sp, #12]
 80094fe:	3301      	adds	r3, #1
 8009500:	9303      	str	r3, [sp, #12]
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 8009502:	9b00      	ldr	r3, [sp, #0]
 8009504:	2b00      	cmp	r3, #0
 8009506:	d1d8      	bne.n	80094ba <chEvtDispatch+0x1a>
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
  }
}
 8009508:	b005      	add	sp, #20
 800950a:	f85d fb04 	ldr.w	pc, [sp], #4
 800950e:	bf00      	nop
 8009510:	0800dfc0 	.word	0x0800dfc0
	...

08009520 <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 8009520:	b500      	push	{lr}
 8009522:	b085      	sub	sp, #20
 8009524:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8009526:	4b15      	ldr	r3, [pc, #84]	; (800957c <chEvtWaitOne+0x5c>)
 8009528:	699b      	ldr	r3, [r3, #24]
 800952a:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 800952c:	f7ff fe48 	bl	80091c0 <chSysLock.lto_priv.359>
  m = ctp->p_epending & events;
 8009530:	9b02      	ldr	r3, [sp, #8]
 8009532:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8009534:	9b01      	ldr	r3, [sp, #4]
 8009536:	4013      	ands	r3, r2
 8009538:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 800953a:	9b03      	ldr	r3, [sp, #12]
 800953c:	2b00      	cmp	r3, #0
 800953e:	d10a      	bne.n	8009556 <chEvtWaitOne+0x36>
    ctp->p_u.ewmask = events;
 8009540:	9b02      	ldr	r3, [sp, #8]
 8009542:	9a01      	ldr	r2, [sp, #4]
 8009544:	625a      	str	r2, [r3, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 8009546:	200a      	movs	r0, #10
 8009548:	f002 ff92 	bl	800c470 <chSchGoSleepS>
    m = ctp->p_epending & events;
 800954c:	9b02      	ldr	r3, [sp, #8]
 800954e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8009550:	9b01      	ldr	r3, [sp, #4]
 8009552:	4013      	ands	r3, r2
 8009554:	9303      	str	r3, [sp, #12]
  }
  m ^= m & (m - (eventmask_t)1);
 8009556:	9b03      	ldr	r3, [sp, #12]
 8009558:	425b      	negs	r3, r3
 800955a:	9a03      	ldr	r2, [sp, #12]
 800955c:	4013      	ands	r3, r2
 800955e:	9303      	str	r3, [sp, #12]
  ctp->p_epending &= ~m;
 8009560:	9b02      	ldr	r3, [sp, #8]
 8009562:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8009564:	9b03      	ldr	r3, [sp, #12]
 8009566:	43db      	mvns	r3, r3
 8009568:	401a      	ands	r2, r3
 800956a:	9b02      	ldr	r3, [sp, #8]
 800956c:	639a      	str	r2, [r3, #56]	; 0x38
  chSysUnlock();
 800956e:	f7ff fe2f 	bl	80091d0 <chSysUnlock.lto_priv.355>

  return m;
 8009572:	9b03      	ldr	r3, [sp, #12]
}
 8009574:	4618      	mov	r0, r3
 8009576:	b005      	add	sp, #20
 8009578:	f85d fb04 	ldr.w	pc, [sp], #4
 800957c:	20000d30 	.word	0x20000d30

08009580 <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 8009580:	b500      	push	{lr}
 8009582:	b085      	sub	sp, #20
 8009584:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8009586:	4b13      	ldr	r3, [pc, #76]	; (80095d4 <chEvtWaitAny+0x54>)
 8009588:	699b      	ldr	r3, [r3, #24]
 800958a:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 800958c:	f7ff fe18 	bl	80091c0 <chSysLock.lto_priv.359>
  m = ctp->p_epending & events;
 8009590:	9b02      	ldr	r3, [sp, #8]
 8009592:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8009594:	9b01      	ldr	r3, [sp, #4]
 8009596:	4013      	ands	r3, r2
 8009598:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 800959a:	9b03      	ldr	r3, [sp, #12]
 800959c:	2b00      	cmp	r3, #0
 800959e:	d10a      	bne.n	80095b6 <chEvtWaitAny+0x36>
    ctp->p_u.ewmask = events;
 80095a0:	9b02      	ldr	r3, [sp, #8]
 80095a2:	9a01      	ldr	r2, [sp, #4]
 80095a4:	625a      	str	r2, [r3, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 80095a6:	200a      	movs	r0, #10
 80095a8:	f002 ff62 	bl	800c470 <chSchGoSleepS>
    m = ctp->p_epending & events;
 80095ac:	9b02      	ldr	r3, [sp, #8]
 80095ae:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80095b0:	9b01      	ldr	r3, [sp, #4]
 80095b2:	4013      	ands	r3, r2
 80095b4:	9303      	str	r3, [sp, #12]
  }
  ctp->p_epending &= ~m;
 80095b6:	9b02      	ldr	r3, [sp, #8]
 80095b8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80095ba:	9b03      	ldr	r3, [sp, #12]
 80095bc:	43db      	mvns	r3, r3
 80095be:	401a      	ands	r2, r3
 80095c0:	9b02      	ldr	r3, [sp, #8]
 80095c2:	639a      	str	r2, [r3, #56]	; 0x38
  chSysUnlock();
 80095c4:	f7ff fe04 	bl	80091d0 <chSysUnlock.lto_priv.355>

  return m;
 80095c8:	9b03      	ldr	r3, [sp, #12]
}
 80095ca:	4618      	mov	r0, r3
 80095cc:	b005      	add	sp, #20
 80095ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80095d2:	bf00      	nop
 80095d4:	20000d30 	.word	0x20000d30
	...

080095e0 <chEvtWaitAll>:
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 80095e0:	b500      	push	{lr}
 80095e2:	b085      	sub	sp, #20
 80095e4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 80095e6:	4b10      	ldr	r3, [pc, #64]	; (8009628 <chEvtWaitAll+0x48>)
 80095e8:	699b      	ldr	r3, [r3, #24]
 80095ea:	9303      	str	r3, [sp, #12]

  chSysLock();
 80095ec:	f7ff fde8 	bl	80091c0 <chSysLock.lto_priv.359>
  if ((ctp->p_epending & events) != events) {
 80095f0:	9b03      	ldr	r3, [sp, #12]
 80095f2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80095f4:	9b01      	ldr	r3, [sp, #4]
 80095f6:	401a      	ands	r2, r3
 80095f8:	9b01      	ldr	r3, [sp, #4]
 80095fa:	429a      	cmp	r2, r3
 80095fc:	d005      	beq.n	800960a <chEvtWaitAll+0x2a>
    ctp->p_u.ewmask = events;
 80095fe:	9b03      	ldr	r3, [sp, #12]
 8009600:	9a01      	ldr	r2, [sp, #4]
 8009602:	625a      	str	r2, [r3, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTANDEVT);
 8009604:	200b      	movs	r0, #11
 8009606:	f002 ff33 	bl	800c470 <chSchGoSleepS>
  }
  ctp->p_epending &= ~events;
 800960a:	9b03      	ldr	r3, [sp, #12]
 800960c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800960e:	9b01      	ldr	r3, [sp, #4]
 8009610:	43db      	mvns	r3, r3
 8009612:	401a      	ands	r2, r3
 8009614:	9b03      	ldr	r3, [sp, #12]
 8009616:	639a      	str	r2, [r3, #56]	; 0x38
  chSysUnlock();
 8009618:	f7ff fdda 	bl	80091d0 <chSysUnlock.lto_priv.355>

  return events;
 800961c:	9b01      	ldr	r3, [sp, #4]
}
 800961e:	4618      	mov	r0, r3
 8009620:	b005      	add	sp, #20
 8009622:	f85d fb04 	ldr.w	pc, [sp], #4
 8009626:	bf00      	nop
 8009628:	20000d30 	.word	0x20000d30
 800962c:	00000000 	.word	0x00000000

08009630 <chEvtWaitOneTimeout>:
 * @return              The mask of the lowest event id served and cleared.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
 8009630:	b500      	push	{lr}
 8009632:	b085      	sub	sp, #20
 8009634:	9001      	str	r0, [sp, #4]
 8009636:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8009638:	4b1c      	ldr	r3, [pc, #112]	; (80096ac <chEvtWaitOneTimeout+0x7c>)
 800963a:	699b      	ldr	r3, [r3, #24]
 800963c:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 800963e:	f7ff fdbf 	bl	80091c0 <chSysLock.lto_priv.359>
  m = ctp->p_epending & events;
 8009642:	9b02      	ldr	r3, [sp, #8]
 8009644:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8009646:	9b01      	ldr	r3, [sp, #4]
 8009648:	4013      	ands	r3, r2
 800964a:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 800964c:	9b03      	ldr	r3, [sp, #12]
 800964e:	2b00      	cmp	r3, #0
 8009650:	d119      	bne.n	8009686 <chEvtWaitOneTimeout+0x56>
    if (TIME_IMMEDIATE == time) {
 8009652:	9b00      	ldr	r3, [sp, #0]
 8009654:	2b00      	cmp	r3, #0
 8009656:	d103      	bne.n	8009660 <chEvtWaitOneTimeout+0x30>
      chSysUnlock();
 8009658:	f7ff fdba 	bl	80091d0 <chSysUnlock.lto_priv.355>
      return (eventmask_t)0;
 800965c:	2300      	movs	r3, #0
 800965e:	e021      	b.n	80096a4 <chEvtWaitOneTimeout+0x74>
    }
    ctp->p_u.ewmask = events;
 8009660:	9b02      	ldr	r3, [sp, #8]
 8009662:	9a01      	ldr	r2, [sp, #4]
 8009664:	625a      	str	r2, [r3, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8009666:	200a      	movs	r0, #10
 8009668:	9900      	ldr	r1, [sp, #0]
 800966a:	f002 ff81 	bl	800c570 <chSchGoSleepTimeoutS>
 800966e:	4603      	mov	r3, r0
 8009670:	2b00      	cmp	r3, #0
 8009672:	da03      	bge.n	800967c <chEvtWaitOneTimeout+0x4c>
      chSysUnlock();
 8009674:	f7ff fdac 	bl	80091d0 <chSysUnlock.lto_priv.355>
      return (eventmask_t)0;
 8009678:	2300      	movs	r3, #0
 800967a:	e013      	b.n	80096a4 <chEvtWaitOneTimeout+0x74>
    }
    m = ctp->p_epending & events;
 800967c:	9b02      	ldr	r3, [sp, #8]
 800967e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8009680:	9b01      	ldr	r3, [sp, #4]
 8009682:	4013      	ands	r3, r2
 8009684:	9303      	str	r3, [sp, #12]
  }
  m ^= m & (m - (eventmask_t)1);
 8009686:	9b03      	ldr	r3, [sp, #12]
 8009688:	425b      	negs	r3, r3
 800968a:	9a03      	ldr	r2, [sp, #12]
 800968c:	4013      	ands	r3, r2
 800968e:	9303      	str	r3, [sp, #12]
  ctp->p_epending &= ~m;
 8009690:	9b02      	ldr	r3, [sp, #8]
 8009692:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8009694:	9b03      	ldr	r3, [sp, #12]
 8009696:	43db      	mvns	r3, r3
 8009698:	401a      	ands	r2, r3
 800969a:	9b02      	ldr	r3, [sp, #8]
 800969c:	639a      	str	r2, [r3, #56]	; 0x38
  chSysUnlock();
 800969e:	f7ff fd97 	bl	80091d0 <chSysUnlock.lto_priv.355>

  return m;
 80096a2:	9b03      	ldr	r3, [sp, #12]
}
 80096a4:	4618      	mov	r0, r3
 80096a6:	b005      	add	sp, #20
 80096a8:	f85d fb04 	ldr.w	pc, [sp], #4
 80096ac:	20000d30 	.word	0x20000d30

080096b0 <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
 80096b0:	b500      	push	{lr}
 80096b2:	b085      	sub	sp, #20
 80096b4:	9001      	str	r0, [sp, #4]
 80096b6:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 80096b8:	4b1a      	ldr	r3, [pc, #104]	; (8009724 <chEvtWaitAnyTimeout+0x74>)
 80096ba:	699b      	ldr	r3, [r3, #24]
 80096bc:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 80096be:	f7ff fd7f 	bl	80091c0 <chSysLock.lto_priv.359>
  m = ctp->p_epending & events;
 80096c2:	9b02      	ldr	r3, [sp, #8]
 80096c4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80096c6:	9b01      	ldr	r3, [sp, #4]
 80096c8:	4013      	ands	r3, r2
 80096ca:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 80096cc:	9b03      	ldr	r3, [sp, #12]
 80096ce:	2b00      	cmp	r3, #0
 80096d0:	d119      	bne.n	8009706 <chEvtWaitAnyTimeout+0x56>
    if (TIME_IMMEDIATE == time) {
 80096d2:	9b00      	ldr	r3, [sp, #0]
 80096d4:	2b00      	cmp	r3, #0
 80096d6:	d103      	bne.n	80096e0 <chEvtWaitAnyTimeout+0x30>
      chSysUnlock();
 80096d8:	f7ff fd7a 	bl	80091d0 <chSysUnlock.lto_priv.355>
      return (eventmask_t)0;
 80096dc:	2300      	movs	r3, #0
 80096de:	e01c      	b.n	800971a <chEvtWaitAnyTimeout+0x6a>
    }
    ctp->p_u.ewmask = events;
 80096e0:	9b02      	ldr	r3, [sp, #8]
 80096e2:	9a01      	ldr	r2, [sp, #4]
 80096e4:	625a      	str	r2, [r3, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 80096e6:	200a      	movs	r0, #10
 80096e8:	9900      	ldr	r1, [sp, #0]
 80096ea:	f002 ff41 	bl	800c570 <chSchGoSleepTimeoutS>
 80096ee:	4603      	mov	r3, r0
 80096f0:	2b00      	cmp	r3, #0
 80096f2:	da03      	bge.n	80096fc <chEvtWaitAnyTimeout+0x4c>
      chSysUnlock();
 80096f4:	f7ff fd6c 	bl	80091d0 <chSysUnlock.lto_priv.355>
      return (eventmask_t)0;
 80096f8:	2300      	movs	r3, #0
 80096fa:	e00e      	b.n	800971a <chEvtWaitAnyTimeout+0x6a>
    }
    m = ctp->p_epending & events;
 80096fc:	9b02      	ldr	r3, [sp, #8]
 80096fe:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8009700:	9b01      	ldr	r3, [sp, #4]
 8009702:	4013      	ands	r3, r2
 8009704:	9303      	str	r3, [sp, #12]
  }
  ctp->p_epending &= ~m;
 8009706:	9b02      	ldr	r3, [sp, #8]
 8009708:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800970a:	9b03      	ldr	r3, [sp, #12]
 800970c:	43db      	mvns	r3, r3
 800970e:	401a      	ands	r2, r3
 8009710:	9b02      	ldr	r3, [sp, #8]
 8009712:	639a      	str	r2, [r3, #56]	; 0x38
  chSysUnlock();
 8009714:	f7ff fd5c 	bl	80091d0 <chSysUnlock.lto_priv.355>

  return m;
 8009718:	9b03      	ldr	r3, [sp, #12]
}
 800971a:	4618      	mov	r0, r3
 800971c:	b005      	add	sp, #20
 800971e:	f85d fb04 	ldr.w	pc, [sp], #4
 8009722:	bf00      	nop
 8009724:	20000d30 	.word	0x20000d30
	...

08009730 <chEvtWaitAllTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
 8009730:	b500      	push	{lr}
 8009732:	b085      	sub	sp, #20
 8009734:	9001      	str	r0, [sp, #4]
 8009736:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8009738:	4b17      	ldr	r3, [pc, #92]	; (8009798 <chEvtWaitAllTimeout+0x68>)
 800973a:	699b      	ldr	r3, [r3, #24]
 800973c:	9303      	str	r3, [sp, #12]

  chSysLock();
 800973e:	f7ff fd3f 	bl	80091c0 <chSysLock.lto_priv.359>
  if ((ctp->p_epending & events) != events) {
 8009742:	9b03      	ldr	r3, [sp, #12]
 8009744:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8009746:	9b01      	ldr	r3, [sp, #4]
 8009748:	401a      	ands	r2, r3
 800974a:	9b01      	ldr	r3, [sp, #4]
 800974c:	429a      	cmp	r2, r3
 800974e:	d014      	beq.n	800977a <chEvtWaitAllTimeout+0x4a>
    if (TIME_IMMEDIATE == time) {
 8009750:	9b00      	ldr	r3, [sp, #0]
 8009752:	2b00      	cmp	r3, #0
 8009754:	d103      	bne.n	800975e <chEvtWaitAllTimeout+0x2e>
      chSysUnlock();
 8009756:	f7ff fd3b 	bl	80091d0 <chSysUnlock.lto_priv.355>
      return (eventmask_t)0;
 800975a:	2300      	movs	r3, #0
 800975c:	e017      	b.n	800978e <chEvtWaitAllTimeout+0x5e>
    }
    ctp->p_u.ewmask = events;
 800975e:	9b03      	ldr	r3, [sp, #12]
 8009760:	9a01      	ldr	r2, [sp, #4]
 8009762:	625a      	str	r2, [r3, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
 8009764:	200b      	movs	r0, #11
 8009766:	9900      	ldr	r1, [sp, #0]
 8009768:	f002 ff02 	bl	800c570 <chSchGoSleepTimeoutS>
 800976c:	4603      	mov	r3, r0
 800976e:	2b00      	cmp	r3, #0
 8009770:	da03      	bge.n	800977a <chEvtWaitAllTimeout+0x4a>
      chSysUnlock();
 8009772:	f7ff fd2d 	bl	80091d0 <chSysUnlock.lto_priv.355>
      return (eventmask_t)0;
 8009776:	2300      	movs	r3, #0
 8009778:	e009      	b.n	800978e <chEvtWaitAllTimeout+0x5e>
    }
  }
  ctp->p_epending &= ~events;
 800977a:	9b03      	ldr	r3, [sp, #12]
 800977c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800977e:	9b01      	ldr	r3, [sp, #4]
 8009780:	43db      	mvns	r3, r3
 8009782:	401a      	ands	r2, r3
 8009784:	9b03      	ldr	r3, [sp, #12]
 8009786:	639a      	str	r2, [r3, #56]	; 0x38
  chSysUnlock();
 8009788:	f7ff fd22 	bl	80091d0 <chSysUnlock.lto_priv.355>

  return events;
 800978c:	9b01      	ldr	r3, [sp, #4]
}
 800978e:	4618      	mov	r0, r3
 8009790:	b005      	add	sp, #20
 8009792:	f85d fb04 	ldr.w	pc, [sp], #4
 8009796:	bf00      	nop
 8009798:	20000d30 	.word	0x20000d30
 800979c:	00000000 	.word	0x00000000

080097a0 <port_lock.lto_priv.348>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80097a0:	b082      	sub	sp, #8
 80097a2:	2320      	movs	r3, #32
 80097a4:	9301      	str	r3, [sp, #4]
 80097a6:	9b01      	ldr	r3, [sp, #4]
 80097a8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80097ac:	b002      	add	sp, #8
 80097ae:	4770      	bx	lr

080097b0 <port_unlock.lto_priv.344>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80097b0:	b082      	sub	sp, #8
 80097b2:	2300      	movs	r3, #0
 80097b4:	9301      	str	r3, [sp, #4]
 80097b6:	9b01      	ldr	r3, [sp, #4]
 80097b8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80097bc:	b002      	add	sp, #8
 80097be:	4770      	bx	lr

080097c0 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 80097c0:	b082      	sub	sp, #8
 80097c2:	9001      	str	r0, [sp, #4]
 80097c4:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 80097c6:	9b01      	ldr	r3, [sp, #4]
 80097c8:	9a00      	ldr	r2, [sp, #0]
 80097ca:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 80097cc:	9b00      	ldr	r3, [sp, #0]
 80097ce:	685a      	ldr	r2, [r3, #4]
 80097d0:	9b01      	ldr	r3, [sp, #4]
 80097d2:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 80097d4:	9b01      	ldr	r3, [sp, #4]
 80097d6:	685b      	ldr	r3, [r3, #4]
 80097d8:	9a01      	ldr	r2, [sp, #4]
 80097da:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 80097dc:	9b00      	ldr	r3, [sp, #0]
 80097de:	9a01      	ldr	r2, [sp, #4]
 80097e0:	605a      	str	r2, [r3, #4]
}
 80097e2:	b002      	add	sp, #8
 80097e4:	4770      	bx	lr
 80097e6:	bf00      	nop
	...

080097f0 <queue_fifo_remove.lto_priv.363>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 80097f0:	b084      	sub	sp, #16
 80097f2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 80097f4:	9b01      	ldr	r3, [sp, #4]
 80097f6:	681b      	ldr	r3, [r3, #0]
 80097f8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 80097fa:	9b03      	ldr	r3, [sp, #12]
 80097fc:	681a      	ldr	r2, [r3, #0]
 80097fe:	9b01      	ldr	r3, [sp, #4]
 8009800:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8009802:	9b01      	ldr	r3, [sp, #4]
 8009804:	681b      	ldr	r3, [r3, #0]
 8009806:	9a01      	ldr	r2, [sp, #4]
 8009808:	605a      	str	r2, [r3, #4]

  return tp;
 800980a:	9b03      	ldr	r3, [sp, #12]
}
 800980c:	4618      	mov	r0, r3
 800980e:	b004      	add	sp, #16
 8009810:	4770      	bx	lr
 8009812:	bf00      	nop
	...

08009820 <chSysLock.lto_priv.360>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8009820:	b508      	push	{r3, lr}

  port_lock();
 8009822:	f7ff ffbd 	bl	80097a0 <port_lock.lto_priv.348>
  _stats_start_measure_crit_thd();
 8009826:	f000 fe0b 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800982a:	f002 fab9 	bl	800bda0 <_dbg_check_lock>
}
 800982e:	bd08      	pop	{r3, pc}

08009830 <chSysUnlock.lto_priv.356>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8009830:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8009832:	f002 facd 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8009836:	f000 fe0b 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800983a:	4b09      	ldr	r3, [pc, #36]	; (8009860 <chSysUnlock.lto_priv.356+0x30>)
 800983c:	681b      	ldr	r3, [r3, #0]
 800983e:	4a08      	ldr	r2, [pc, #32]	; (8009860 <chSysUnlock.lto_priv.356+0x30>)
 8009840:	4293      	cmp	r3, r2
 8009842:	d00a      	beq.n	800985a <chSysUnlock.lto_priv.356+0x2a>
 8009844:	4b06      	ldr	r3, [pc, #24]	; (8009860 <chSysUnlock.lto_priv.356+0x30>)
 8009846:	699b      	ldr	r3, [r3, #24]
 8009848:	689a      	ldr	r2, [r3, #8]
 800984a:	4b05      	ldr	r3, [pc, #20]	; (8009860 <chSysUnlock.lto_priv.356+0x30>)
 800984c:	681b      	ldr	r3, [r3, #0]
 800984e:	689b      	ldr	r3, [r3, #8]
 8009850:	429a      	cmp	r2, r3
 8009852:	d202      	bcs.n	800985a <chSysUnlock.lto_priv.356+0x2a>
 8009854:	4803      	ldr	r0, [pc, #12]	; (8009864 <chSysUnlock.lto_priv.356+0x34>)
 8009856:	f002 f94b 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800985a:	f7ff ffa9 	bl	80097b0 <port_unlock.lto_priv.344>
}
 800985e:	bd08      	pop	{r3, pc}
 8009860:	20000d30 	.word	0x20000d30
 8009864:	0800dfe0 	.word	0x0800dfe0
	...

08009870 <chMsgIsPendingI>:
 * @param[in] tp        pointer to the thread
 * @return              The pending messages status.
 *
 * @iclass
 */
static inline bool chMsgIsPendingI(thread_t *tp) {
 8009870:	b500      	push	{lr}
 8009872:	b083      	sub	sp, #12
 8009874:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8009876:	f002 fb33 	bl	800bee0 <chDbgCheckClassI>

  return (bool)(tp->p_msgqueue.p_next != (thread_t *)&tp->p_msgqueue);
 800987a:	9b01      	ldr	r3, [sp, #4]
 800987c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800987e:	9b01      	ldr	r3, [sp, #4]
 8009880:	332c      	adds	r3, #44	; 0x2c
 8009882:	429a      	cmp	r2, r3
 8009884:	bf14      	ite	ne
 8009886:	2301      	movne	r3, #1
 8009888:	2300      	moveq	r3, #0
 800988a:	b2db      	uxtb	r3, r3
}
 800988c:	4618      	mov	r0, r3
 800988e:	b003      	add	sp, #12
 8009890:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080098a0 <chMsgReleaseS>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @sclass
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {
 80098a0:	b500      	push	{lr}
 80098a2:	b083      	sub	sp, #12
 80098a4:	9001      	str	r0, [sp, #4]
 80098a6:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();
 80098a8:	f002 fb32 	bl	800bf10 <chDbgCheckClassS>

  chSchWakeupS(tp, msg);
 80098ac:	9801      	ldr	r0, [sp, #4]
 80098ae:	9900      	ldr	r1, [sp, #0]
 80098b0:	f002 fe96 	bl	800c5e0 <chSchWakeupS>
}
 80098b4:	b003      	add	sp, #12
 80098b6:	f85d fb04 	ldr.w	pc, [sp], #4
 80098ba:	bf00      	nop
 80098bc:	0000      	movs	r0, r0
	...

080098c0 <chMsgSend>:
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 80098c0:	b500      	push	{lr}
 80098c2:	b085      	sub	sp, #20
 80098c4:	9001      	str	r0, [sp, #4]
 80098c6:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 80098c8:	4b16      	ldr	r3, [pc, #88]	; (8009924 <chMsgSend+0x64>)
 80098ca:	699b      	ldr	r3, [r3, #24]
 80098cc:	9303      	str	r3, [sp, #12]

  chDbgCheck(tp != NULL);
 80098ce:	9b01      	ldr	r3, [sp, #4]
 80098d0:	2b00      	cmp	r3, #0
 80098d2:	d102      	bne.n	80098da <chMsgSend+0x1a>
 80098d4:	4814      	ldr	r0, [pc, #80]	; (8009928 <chMsgSend+0x68>)
 80098d6:	f002 f90b 	bl	800baf0 <chSysHalt>

  chSysLock();
 80098da:	f7ff ffa1 	bl	8009820 <chSysLock.lto_priv.360>
  ctp->p_msg = msg;
 80098de:	9b03      	ldr	r3, [sp, #12]
 80098e0:	9a00      	ldr	r2, [sp, #0]
 80098e2:	635a      	str	r2, [r3, #52]	; 0x34
  ctp->p_u.wtobjp = &tp->p_msgqueue;
 80098e4:	9b01      	ldr	r3, [sp, #4]
 80098e6:	f103 022c 	add.w	r2, r3, #44	; 0x2c
 80098ea:	9b03      	ldr	r3, [sp, #12]
 80098ec:	625a      	str	r2, [r3, #36]	; 0x24
  msg_insert(ctp, &tp->p_msgqueue);
 80098ee:	9b01      	ldr	r3, [sp, #4]
 80098f0:	332c      	adds	r3, #44	; 0x2c
 80098f2:	9803      	ldr	r0, [sp, #12]
 80098f4:	4619      	mov	r1, r3
 80098f6:	f7ff ff63 	bl	80097c0 <queue_insert>
  if (tp->p_state == CH_STATE_WTMSG) {
 80098fa:	9b01      	ldr	r3, [sp, #4]
 80098fc:	f893 3020 	ldrb.w	r3, [r3, #32]
 8009900:	2b0e      	cmp	r3, #14
 8009902:	d102      	bne.n	800990a <chMsgSend+0x4a>
    (void) chSchReadyI(tp);
 8009904:	9801      	ldr	r0, [sp, #4]
 8009906:	f002 fd73 	bl	800c3f0 <chSchReadyI>
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 800990a:	200c      	movs	r0, #12
 800990c:	f002 fdb0 	bl	800c470 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 8009910:	9b03      	ldr	r3, [sp, #12]
 8009912:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009914:	9300      	str	r3, [sp, #0]
  chSysUnlock();
 8009916:	f7ff ff8b 	bl	8009830 <chSysUnlock.lto_priv.356>

  return msg;
 800991a:	9b00      	ldr	r3, [sp, #0]
}
 800991c:	4618      	mov	r0, r3
 800991e:	b005      	add	sp, #20
 8009920:	f85d fb04 	ldr.w	pc, [sp], #4
 8009924:	20000d30 	.word	0x20000d30
 8009928:	0800dfd0 	.word	0x0800dfd0
 800992c:	00000000 	.word	0x00000000

08009930 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
 8009930:	b500      	push	{lr}
 8009932:	b083      	sub	sp, #12
  thread_t *tp;

  chSysLock();
 8009934:	f7ff ff74 	bl	8009820 <chSysLock.lto_priv.360>
  if (!chMsgIsPendingI(currp)) {
 8009938:	4b0f      	ldr	r3, [pc, #60]	; (8009978 <chMsgWait+0x48>)
 800993a:	699b      	ldr	r3, [r3, #24]
 800993c:	4618      	mov	r0, r3
 800993e:	f7ff ff97 	bl	8009870 <chMsgIsPendingI>
 8009942:	4603      	mov	r3, r0
 8009944:	f083 0301 	eor.w	r3, r3, #1
 8009948:	b2db      	uxtb	r3, r3
 800994a:	2b00      	cmp	r3, #0
 800994c:	d002      	beq.n	8009954 <chMsgWait+0x24>
    chSchGoSleepS(CH_STATE_WTMSG);
 800994e:	200e      	movs	r0, #14
 8009950:	f002 fd8e 	bl	800c470 <chSchGoSleepS>
  }
  tp = queue_fifo_remove(&currp->p_msgqueue);
 8009954:	4b08      	ldr	r3, [pc, #32]	; (8009978 <chMsgWait+0x48>)
 8009956:	699b      	ldr	r3, [r3, #24]
 8009958:	332c      	adds	r3, #44	; 0x2c
 800995a:	4618      	mov	r0, r3
 800995c:	f7ff ff48 	bl	80097f0 <queue_fifo_remove.lto_priv.363>
 8009960:	9001      	str	r0, [sp, #4]
  tp->p_state = CH_STATE_SNDMSG;
 8009962:	9b01      	ldr	r3, [sp, #4]
 8009964:	220d      	movs	r2, #13
 8009966:	f883 2020 	strb.w	r2, [r3, #32]
  chSysUnlock();
 800996a:	f7ff ff61 	bl	8009830 <chSysUnlock.lto_priv.356>

  return tp;
 800996e:	9b01      	ldr	r3, [sp, #4]
}
 8009970:	4618      	mov	r0, r3
 8009972:	b003      	add	sp, #12
 8009974:	f85d fb04 	ldr.w	pc, [sp], #4
 8009978:	20000d30 	.word	0x20000d30
 800997c:	00000000 	.word	0x00000000

08009980 <chMsgRelease>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @api
 */
void chMsgRelease(thread_t *tp, msg_t msg) {
 8009980:	b500      	push	{lr}
 8009982:	b083      	sub	sp, #12
 8009984:	9001      	str	r0, [sp, #4]
 8009986:	9100      	str	r1, [sp, #0]

  chSysLock();
 8009988:	f7ff ff4a 	bl	8009820 <chSysLock.lto_priv.360>
  chDbgAssert(tp->p_state == CH_STATE_SNDMSG, "invalid state");
 800998c:	9b01      	ldr	r3, [sp, #4]
 800998e:	f893 3020 	ldrb.w	r3, [r3, #32]
 8009992:	2b0d      	cmp	r3, #13
 8009994:	d002      	beq.n	800999c <chMsgRelease+0x1c>
 8009996:	4806      	ldr	r0, [pc, #24]	; (80099b0 <chMsgRelease+0x30>)
 8009998:	f002 f8aa 	bl	800baf0 <chSysHalt>
  chMsgReleaseS(tp, msg);
 800999c:	9801      	ldr	r0, [sp, #4]
 800999e:	9900      	ldr	r1, [sp, #0]
 80099a0:	f7ff ff7e 	bl	80098a0 <chMsgReleaseS>
  chSysUnlock();
 80099a4:	f7ff ff44 	bl	8009830 <chSysUnlock.lto_priv.356>
}
 80099a8:	b003      	add	sp, #12
 80099aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80099ae:	bf00      	nop
 80099b0:	0800dff0 	.word	0x0800dff0
	...

080099c0 <port_lock.lto_priv.349>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80099c0:	b082      	sub	sp, #8
 80099c2:	2320      	movs	r3, #32
 80099c4:	9301      	str	r3, [sp, #4]
 80099c6:	9b01      	ldr	r3, [sp, #4]
 80099c8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80099cc:	b002      	add	sp, #8
 80099ce:	4770      	bx	lr

080099d0 <port_unlock.lto_priv.345>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80099d0:	b082      	sub	sp, #8
 80099d2:	2300      	movs	r3, #0
 80099d4:	9301      	str	r3, [sp, #4]
 80099d6:	9b01      	ldr	r3, [sp, #4]
 80099d8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80099dc:	b002      	add	sp, #8
 80099de:	4770      	bx	lr

080099e0 <chSysLock.lto_priv.361>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80099e0:	b508      	push	{r3, lr}

  port_lock();
 80099e2:	f7ff ffed 	bl	80099c0 <port_lock.lto_priv.349>
  _stats_start_measure_crit_thd();
 80099e6:	f000 fd2b 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 80099ea:	f002 f9d9 	bl	800bda0 <_dbg_check_lock>
}
 80099ee:	bd08      	pop	{r3, pc}

080099f0 <chSysUnlock.lto_priv.357>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80099f0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 80099f2:	f002 f9ed 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 80099f6:	f000 fd2b 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 80099fa:	4b09      	ldr	r3, [pc, #36]	; (8009a20 <chSysUnlock.lto_priv.357+0x30>)
 80099fc:	681b      	ldr	r3, [r3, #0]
 80099fe:	4a08      	ldr	r2, [pc, #32]	; (8009a20 <chSysUnlock.lto_priv.357+0x30>)
 8009a00:	4293      	cmp	r3, r2
 8009a02:	d00a      	beq.n	8009a1a <chSysUnlock.lto_priv.357+0x2a>
 8009a04:	4b06      	ldr	r3, [pc, #24]	; (8009a20 <chSysUnlock.lto_priv.357+0x30>)
 8009a06:	699b      	ldr	r3, [r3, #24]
 8009a08:	689a      	ldr	r2, [r3, #8]
 8009a0a:	4b05      	ldr	r3, [pc, #20]	; (8009a20 <chSysUnlock.lto_priv.357+0x30>)
 8009a0c:	681b      	ldr	r3, [r3, #0]
 8009a0e:	689b      	ldr	r3, [r3, #8]
 8009a10:	429a      	cmp	r2, r3
 8009a12:	d202      	bcs.n	8009a1a <chSysUnlock.lto_priv.357+0x2a>
 8009a14:	4803      	ldr	r0, [pc, #12]	; (8009a24 <chSysUnlock.lto_priv.357+0x34>)
 8009a16:	f002 f86b 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8009a1a:	f7ff ffd9 	bl	80099d0 <port_unlock.lto_priv.345>
}
 8009a1e:	bd08      	pop	{r3, pc}
 8009a20:	20000d30 	.word	0x20000d30
 8009a24:	0800e010 	.word	0x0800e010
	...

08009a30 <chSemFastWaitI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastWaitI(semaphore_t *sp) {
 8009a30:	b500      	push	{lr}
 8009a32:	b083      	sub	sp, #12
 8009a34:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8009a36:	f002 fa53 	bl	800bee0 <chDbgCheckClassI>

  sp->s_cnt--;
 8009a3a:	9b01      	ldr	r3, [sp, #4]
 8009a3c:	689b      	ldr	r3, [r3, #8]
 8009a3e:	1e5a      	subs	r2, r3, #1
 8009a40:	9b01      	ldr	r3, [sp, #4]
 8009a42:	609a      	str	r2, [r3, #8]
}
 8009a44:	b003      	add	sp, #12
 8009a46:	f85d fb04 	ldr.w	pc, [sp], #4
 8009a4a:	bf00      	nop
 8009a4c:	0000      	movs	r0, r0
	...

08009a50 <chSemGetCounterI>:
 * @param[in] sp        pointer to a @p semaphore_t structure
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {
 8009a50:	b500      	push	{lr}
 8009a52:	b083      	sub	sp, #12
 8009a54:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8009a56:	f002 fa43 	bl	800bee0 <chDbgCheckClassI>

  return sp->s_cnt;
 8009a5a:	9b01      	ldr	r3, [sp, #4]
 8009a5c:	689b      	ldr	r3, [r3, #8]
}
 8009a5e:	4618      	mov	r0, r3
 8009a60:	b003      	add	sp, #12
 8009a62:	f85d fb04 	ldr.w	pc, [sp], #4
 8009a66:	bf00      	nop
	...

08009a70 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
 8009a70:	b500      	push	{lr}
 8009a72:	b085      	sub	sp, #20
 8009a74:	9003      	str	r0, [sp, #12]
 8009a76:	9102      	str	r1, [sp, #8]
 8009a78:	9201      	str	r2, [sp, #4]

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));
 8009a7a:	9b03      	ldr	r3, [sp, #12]
 8009a7c:	2b00      	cmp	r3, #0
 8009a7e:	d005      	beq.n	8009a8c <chMBObjectInit+0x1c>
 8009a80:	9b02      	ldr	r3, [sp, #8]
 8009a82:	2b00      	cmp	r3, #0
 8009a84:	d002      	beq.n	8009a8c <chMBObjectInit+0x1c>
 8009a86:	9b01      	ldr	r3, [sp, #4]
 8009a88:	2b00      	cmp	r3, #0
 8009a8a:	dc02      	bgt.n	8009a92 <chMBObjectInit+0x22>
 8009a8c:	4810      	ldr	r0, [pc, #64]	; (8009ad0 <chMBObjectInit+0x60>)
 8009a8e:	f002 f82f 	bl	800baf0 <chSysHalt>

  mbp->mb_buffer = buf;
 8009a92:	9b03      	ldr	r3, [sp, #12]
 8009a94:	9a02      	ldr	r2, [sp, #8]
 8009a96:	601a      	str	r2, [r3, #0]
  mbp->mb_rdptr = buf;
 8009a98:	9b03      	ldr	r3, [sp, #12]
 8009a9a:	9a02      	ldr	r2, [sp, #8]
 8009a9c:	60da      	str	r2, [r3, #12]
  mbp->mb_wrptr = buf;
 8009a9e:	9b03      	ldr	r3, [sp, #12]
 8009aa0:	9a02      	ldr	r2, [sp, #8]
 8009aa2:	609a      	str	r2, [r3, #8]
  mbp->mb_top = &buf[n];
 8009aa4:	9b01      	ldr	r3, [sp, #4]
 8009aa6:	009b      	lsls	r3, r3, #2
 8009aa8:	9a02      	ldr	r2, [sp, #8]
 8009aaa:	441a      	add	r2, r3
 8009aac:	9b03      	ldr	r3, [sp, #12]
 8009aae:	605a      	str	r2, [r3, #4]
  chSemObjectInit(&mbp->mb_emptysem, n);
 8009ab0:	9b03      	ldr	r3, [sp, #12]
 8009ab2:	331c      	adds	r3, #28
 8009ab4:	4618      	mov	r0, r3
 8009ab6:	9901      	ldr	r1, [sp, #4]
 8009ab8:	f000 ff52 	bl	800a960 <chSemObjectInit>
  chSemObjectInit(&mbp->mb_fullsem, (cnt_t)0);
 8009abc:	9b03      	ldr	r3, [sp, #12]
 8009abe:	3310      	adds	r3, #16
 8009ac0:	4618      	mov	r0, r3
 8009ac2:	2100      	movs	r1, #0
 8009ac4:	f000 ff4c 	bl	800a960 <chSemObjectInit>
}
 8009ac8:	b005      	add	sp, #20
 8009aca:	f85d fb04 	ldr.w	pc, [sp], #4
 8009ace:	bf00      	nop
 8009ad0:	0800e000 	.word	0x0800e000
	...

08009ae0 <chMBReset>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBReset(mailbox_t *mbp) {
 8009ae0:	b500      	push	{lr}
 8009ae2:	b083      	sub	sp, #12
 8009ae4:	9001      	str	r0, [sp, #4]

  chSysLock();
 8009ae6:	f7ff ff7b 	bl	80099e0 <chSysLock.lto_priv.361>
  chMBResetI(mbp);
 8009aea:	9801      	ldr	r0, [sp, #4]
 8009aec:	f000 f808 	bl	8009b00 <chMBResetI>
  chSchRescheduleS();
 8009af0:	f002 fdce 	bl	800c690 <chSchRescheduleS>
  chSysUnlock();
 8009af4:	f7ff ff7c 	bl	80099f0 <chSysUnlock.lto_priv.357>
}
 8009af8:	b003      	add	sp, #12
 8009afa:	f85d fb04 	ldr.w	pc, [sp], #4
 8009afe:	bf00      	nop

08009b00 <chMBResetI>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBResetI(mailbox_t *mbp) {
 8009b00:	b500      	push	{lr}
 8009b02:	b083      	sub	sp, #12
 8009b04:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8009b06:	f002 f9eb 	bl	800bee0 <chDbgCheckClassI>
  chDbgCheck(mbp != NULL);
 8009b0a:	9b01      	ldr	r3, [sp, #4]
 8009b0c:	2b00      	cmp	r3, #0
 8009b0e:	d102      	bne.n	8009b16 <chMBResetI+0x16>
 8009b10:	4810      	ldr	r0, [pc, #64]	; (8009b54 <chMBResetI+0x54>)
 8009b12:	f001 ffed 	bl	800baf0 <chSysHalt>

  mbp->mb_wrptr = mbp->mb_buffer;
 8009b16:	9b01      	ldr	r3, [sp, #4]
 8009b18:	681a      	ldr	r2, [r3, #0]
 8009b1a:	9b01      	ldr	r3, [sp, #4]
 8009b1c:	609a      	str	r2, [r3, #8]
  mbp->mb_rdptr = mbp->mb_buffer;
 8009b1e:	9b01      	ldr	r3, [sp, #4]
 8009b20:	681a      	ldr	r2, [r3, #0]
 8009b22:	9b01      	ldr	r3, [sp, #4]
 8009b24:	60da      	str	r2, [r3, #12]
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 8009b26:	9b01      	ldr	r3, [sp, #4]
 8009b28:	f103 021c 	add.w	r2, r3, #28
 8009b2c:	9b01      	ldr	r3, [sp, #4]
 8009b2e:	685b      	ldr	r3, [r3, #4]
 8009b30:	4619      	mov	r1, r3
 8009b32:	9b01      	ldr	r3, [sp, #4]
 8009b34:	681b      	ldr	r3, [r3, #0]
 8009b36:	1acb      	subs	r3, r1, r3
 8009b38:	109b      	asrs	r3, r3, #2
 8009b3a:	4610      	mov	r0, r2
 8009b3c:	4619      	mov	r1, r3
 8009b3e:	f000 ff47 	bl	800a9d0 <chSemResetI>
  chSemResetI(&mbp->mb_fullsem, (cnt_t)0);
 8009b42:	9b01      	ldr	r3, [sp, #4]
 8009b44:	3310      	adds	r3, #16
 8009b46:	4618      	mov	r0, r3
 8009b48:	2100      	movs	r1, #0
 8009b4a:	f000 ff41 	bl	800a9d0 <chSemResetI>
}
 8009b4e:	b003      	add	sp, #12
 8009b50:	f85d fb04 	ldr.w	pc, [sp], #4
 8009b54:	0800e020 	.word	0x0800e020
	...

08009b60 <chMBPost>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8009b60:	b500      	push	{lr}
 8009b62:	b087      	sub	sp, #28
 8009b64:	9003      	str	r0, [sp, #12]
 8009b66:	9102      	str	r1, [sp, #8]
 8009b68:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 8009b6a:	f7ff ff39 	bl	80099e0 <chSysLock.lto_priv.361>
  rdymsg = chMBPostS(mbp, msg, timeout);
 8009b6e:	9803      	ldr	r0, [sp, #12]
 8009b70:	9902      	ldr	r1, [sp, #8]
 8009b72:	9a01      	ldr	r2, [sp, #4]
 8009b74:	f000 f80c 	bl	8009b90 <chMBPostS>
 8009b78:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8009b7a:	f7ff ff39 	bl	80099f0 <chSysUnlock.lto_priv.357>

  return rdymsg;
 8009b7e:	9b05      	ldr	r3, [sp, #20]
}
 8009b80:	4618      	mov	r0, r3
 8009b82:	b007      	add	sp, #28
 8009b84:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08009b90 <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8009b90:	b500      	push	{lr}
 8009b92:	b087      	sub	sp, #28
 8009b94:	9003      	str	r0, [sp, #12]
 8009b96:	9102      	str	r1, [sp, #8]
 8009b98:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
 8009b9a:	f002 f9b9 	bl	800bf10 <chDbgCheckClassS>
  chDbgCheck(mbp != NULL);
 8009b9e:	9b03      	ldr	r3, [sp, #12]
 8009ba0:	2b00      	cmp	r3, #0
 8009ba2:	d102      	bne.n	8009baa <chMBPostS+0x1a>
 8009ba4:	4814      	ldr	r0, [pc, #80]	; (8009bf8 <chMBPostS+0x68>)
 8009ba6:	f001 ffa3 	bl	800baf0 <chSysHalt>

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 8009baa:	9b03      	ldr	r3, [sp, #12]
 8009bac:	331c      	adds	r3, #28
 8009bae:	4618      	mov	r0, r3
 8009bb0:	9901      	ldr	r1, [sp, #4]
 8009bb2:	f000 ffd5 	bl	800ab60 <chSemWaitTimeoutS>
 8009bb6:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
 8009bb8:	9b05      	ldr	r3, [sp, #20]
 8009bba:	2b00      	cmp	r3, #0
 8009bbc:	d117      	bne.n	8009bee <chMBPostS+0x5e>
    *mbp->mb_wrptr++ = msg;
 8009bbe:	9b03      	ldr	r3, [sp, #12]
 8009bc0:	689b      	ldr	r3, [r3, #8]
 8009bc2:	1d19      	adds	r1, r3, #4
 8009bc4:	9a03      	ldr	r2, [sp, #12]
 8009bc6:	6091      	str	r1, [r2, #8]
 8009bc8:	9a02      	ldr	r2, [sp, #8]
 8009bca:	601a      	str	r2, [r3, #0]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 8009bcc:	9b03      	ldr	r3, [sp, #12]
 8009bce:	689a      	ldr	r2, [r3, #8]
 8009bd0:	9b03      	ldr	r3, [sp, #12]
 8009bd2:	685b      	ldr	r3, [r3, #4]
 8009bd4:	429a      	cmp	r2, r3
 8009bd6:	d303      	bcc.n	8009be0 <chMBPostS+0x50>
      mbp->mb_wrptr = mbp->mb_buffer;
 8009bd8:	9b03      	ldr	r3, [sp, #12]
 8009bda:	681a      	ldr	r2, [r3, #0]
 8009bdc:	9b03      	ldr	r3, [sp, #12]
 8009bde:	609a      	str	r2, [r3, #8]
    }
    chSemSignalI(&mbp->mb_fullsem);
 8009be0:	9b03      	ldr	r3, [sp, #12]
 8009be2:	3310      	adds	r3, #16
 8009be4:	4618      	mov	r0, r3
 8009be6:	f001 f863 	bl	800acb0 <chSemSignalI>
    chSchRescheduleS();
 8009bea:	f002 fd51 	bl	800c690 <chSchRescheduleS>
  }

  return rdymsg;
 8009bee:	9b05      	ldr	r3, [sp, #20]
}
 8009bf0:	4618      	mov	r0, r3
 8009bf2:	b007      	add	sp, #28
 8009bf4:	f85d fb04 	ldr.w	pc, [sp], #4
 8009bf8:	0800e030 	.word	0x0800e030
 8009bfc:	00000000 	.word	0x00000000

08009c00 <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8009c00:	b500      	push	{lr}
 8009c02:	b083      	sub	sp, #12
 8009c04:	9001      	str	r0, [sp, #4]
 8009c06:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 8009c08:	f002 f96a 	bl	800bee0 <chDbgCheckClassI>
  chDbgCheck(mbp != NULL);
 8009c0c:	9b01      	ldr	r3, [sp, #4]
 8009c0e:	2b00      	cmp	r3, #0
 8009c10:	d102      	bne.n	8009c18 <chMBPostI+0x18>
 8009c12:	4817      	ldr	r0, [pc, #92]	; (8009c70 <chMBPostI+0x70>)
 8009c14:	f001 ff6c 	bl	800baf0 <chSysHalt>

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 8009c18:	9b01      	ldr	r3, [sp, #4]
 8009c1a:	331c      	adds	r3, #28
 8009c1c:	4618      	mov	r0, r3
 8009c1e:	f7ff ff17 	bl	8009a50 <chSemGetCounterI>
 8009c22:	4603      	mov	r3, r0
 8009c24:	2b00      	cmp	r3, #0
 8009c26:	dc02      	bgt.n	8009c2e <chMBPostI+0x2e>
    return MSG_TIMEOUT;
 8009c28:	f04f 33ff 	mov.w	r3, #4294967295
 8009c2c:	e01b      	b.n	8009c66 <chMBPostI+0x66>
  }

  chSemFastWaitI(&mbp->mb_emptysem);
 8009c2e:	9b01      	ldr	r3, [sp, #4]
 8009c30:	331c      	adds	r3, #28
 8009c32:	4618      	mov	r0, r3
 8009c34:	f7ff fefc 	bl	8009a30 <chSemFastWaitI>
  *mbp->mb_wrptr++ = msg;
 8009c38:	9b01      	ldr	r3, [sp, #4]
 8009c3a:	689b      	ldr	r3, [r3, #8]
 8009c3c:	1d19      	adds	r1, r3, #4
 8009c3e:	9a01      	ldr	r2, [sp, #4]
 8009c40:	6091      	str	r1, [r2, #8]
 8009c42:	9a00      	ldr	r2, [sp, #0]
 8009c44:	601a      	str	r2, [r3, #0]
  if (mbp->mb_wrptr >= mbp->mb_top) {
 8009c46:	9b01      	ldr	r3, [sp, #4]
 8009c48:	689a      	ldr	r2, [r3, #8]
 8009c4a:	9b01      	ldr	r3, [sp, #4]
 8009c4c:	685b      	ldr	r3, [r3, #4]
 8009c4e:	429a      	cmp	r2, r3
 8009c50:	d303      	bcc.n	8009c5a <chMBPostI+0x5a>
     mbp->mb_wrptr = mbp->mb_buffer;
 8009c52:	9b01      	ldr	r3, [sp, #4]
 8009c54:	681a      	ldr	r2, [r3, #0]
 8009c56:	9b01      	ldr	r3, [sp, #4]
 8009c58:	609a      	str	r2, [r3, #8]
  }
  chSemSignalI(&mbp->mb_fullsem);
 8009c5a:	9b01      	ldr	r3, [sp, #4]
 8009c5c:	3310      	adds	r3, #16
 8009c5e:	4618      	mov	r0, r3
 8009c60:	f001 f826 	bl	800acb0 <chSemSignalI>

  return MSG_OK;
 8009c64:	2300      	movs	r3, #0
}
 8009c66:	4618      	mov	r0, r3
 8009c68:	b003      	add	sp, #12
 8009c6a:	f85d fb04 	ldr.w	pc, [sp], #4
 8009c6e:	bf00      	nop
 8009c70:	0800e040 	.word	0x0800e040
	...

08009c80 <chMBPostAhead>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostAhead(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8009c80:	b500      	push	{lr}
 8009c82:	b087      	sub	sp, #28
 8009c84:	9003      	str	r0, [sp, #12]
 8009c86:	9102      	str	r1, [sp, #8]
 8009c88:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 8009c8a:	f7ff fea9 	bl	80099e0 <chSysLock.lto_priv.361>
  rdymsg = chMBPostAheadS(mbp, msg, timeout);
 8009c8e:	9803      	ldr	r0, [sp, #12]
 8009c90:	9902      	ldr	r1, [sp, #8]
 8009c92:	9a01      	ldr	r2, [sp, #4]
 8009c94:	f000 f80c 	bl	8009cb0 <chMBPostAheadS>
 8009c98:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8009c9a:	f7ff fea9 	bl	80099f0 <chSysUnlock.lto_priv.357>

  return rdymsg;
 8009c9e:	9b05      	ldr	r3, [sp, #20]
}
 8009ca0:	4618      	mov	r0, r3
 8009ca2:	b007      	add	sp, #28
 8009ca4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08009cb0 <chMBPostAheadS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostAheadS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8009cb0:	b500      	push	{lr}
 8009cb2:	b087      	sub	sp, #28
 8009cb4:	9003      	str	r0, [sp, #12]
 8009cb6:	9102      	str	r1, [sp, #8]
 8009cb8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
 8009cba:	f002 f929 	bl	800bf10 <chDbgCheckClassS>
  chDbgCheck(mbp != NULL);
 8009cbe:	9b03      	ldr	r3, [sp, #12]
 8009cc0:	2b00      	cmp	r3, #0
 8009cc2:	d102      	bne.n	8009cca <chMBPostAheadS+0x1a>
 8009cc4:	4816      	ldr	r0, [pc, #88]	; (8009d20 <chMBPostAheadS+0x70>)
 8009cc6:	f001 ff13 	bl	800baf0 <chSysHalt>

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 8009cca:	9b03      	ldr	r3, [sp, #12]
 8009ccc:	331c      	adds	r3, #28
 8009cce:	4618      	mov	r0, r3
 8009cd0:	9901      	ldr	r1, [sp, #4]
 8009cd2:	f000 ff45 	bl	800ab60 <chSemWaitTimeoutS>
 8009cd6:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
 8009cd8:	9b05      	ldr	r3, [sp, #20]
 8009cda:	2b00      	cmp	r3, #0
 8009cdc:	d11a      	bne.n	8009d14 <chMBPostAheadS+0x64>
    if (--mbp->mb_rdptr < mbp->mb_buffer) {
 8009cde:	9b03      	ldr	r3, [sp, #12]
 8009ce0:	68db      	ldr	r3, [r3, #12]
 8009ce2:	1f1a      	subs	r2, r3, #4
 8009ce4:	9b03      	ldr	r3, [sp, #12]
 8009ce6:	60da      	str	r2, [r3, #12]
 8009ce8:	9b03      	ldr	r3, [sp, #12]
 8009cea:	68da      	ldr	r2, [r3, #12]
 8009cec:	9b03      	ldr	r3, [sp, #12]
 8009cee:	681b      	ldr	r3, [r3, #0]
 8009cf0:	429a      	cmp	r2, r3
 8009cf2:	d204      	bcs.n	8009cfe <chMBPostAheadS+0x4e>
      mbp->mb_rdptr = mbp->mb_top - 1;
 8009cf4:	9b03      	ldr	r3, [sp, #12]
 8009cf6:	685b      	ldr	r3, [r3, #4]
 8009cf8:	1f1a      	subs	r2, r3, #4
 8009cfa:	9b03      	ldr	r3, [sp, #12]
 8009cfc:	60da      	str	r2, [r3, #12]
    }
    *mbp->mb_rdptr = msg;
 8009cfe:	9b03      	ldr	r3, [sp, #12]
 8009d00:	68db      	ldr	r3, [r3, #12]
 8009d02:	9a02      	ldr	r2, [sp, #8]
 8009d04:	601a      	str	r2, [r3, #0]
    chSemSignalI(&mbp->mb_fullsem);
 8009d06:	9b03      	ldr	r3, [sp, #12]
 8009d08:	3310      	adds	r3, #16
 8009d0a:	4618      	mov	r0, r3
 8009d0c:	f000 ffd0 	bl	800acb0 <chSemSignalI>
    chSchRescheduleS();
 8009d10:	f002 fcbe 	bl	800c690 <chSchRescheduleS>
  }

  return rdymsg;
 8009d14:	9b05      	ldr	r3, [sp, #20]
}
 8009d16:	4618      	mov	r0, r3
 8009d18:	b007      	add	sp, #28
 8009d1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8009d1e:	bf00      	nop
 8009d20:	0800e050 	.word	0x0800e050
	...

08009d30 <chMBPostAheadI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 8009d30:	b500      	push	{lr}
 8009d32:	b083      	sub	sp, #12
 8009d34:	9001      	str	r0, [sp, #4]
 8009d36:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 8009d38:	f002 f8d2 	bl	800bee0 <chDbgCheckClassI>
  chDbgCheck(mbp != NULL);
 8009d3c:	9b01      	ldr	r3, [sp, #4]
 8009d3e:	2b00      	cmp	r3, #0
 8009d40:	d102      	bne.n	8009d48 <chMBPostAheadI+0x18>
 8009d42:	4818      	ldr	r0, [pc, #96]	; (8009da4 <chMBPostAheadI+0x74>)
 8009d44:	f001 fed4 	bl	800baf0 <chSysHalt>

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 8009d48:	9b01      	ldr	r3, [sp, #4]
 8009d4a:	331c      	adds	r3, #28
 8009d4c:	4618      	mov	r0, r3
 8009d4e:	f7ff fe7f 	bl	8009a50 <chSemGetCounterI>
 8009d52:	4603      	mov	r3, r0
 8009d54:	2b00      	cmp	r3, #0
 8009d56:	dc02      	bgt.n	8009d5e <chMBPostAheadI+0x2e>
    return MSG_TIMEOUT;
 8009d58:	f04f 33ff 	mov.w	r3, #4294967295
 8009d5c:	e01e      	b.n	8009d9c <chMBPostAheadI+0x6c>
  }
  chSemFastWaitI(&mbp->mb_emptysem);
 8009d5e:	9b01      	ldr	r3, [sp, #4]
 8009d60:	331c      	adds	r3, #28
 8009d62:	4618      	mov	r0, r3
 8009d64:	f7ff fe64 	bl	8009a30 <chSemFastWaitI>
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
 8009d68:	9b01      	ldr	r3, [sp, #4]
 8009d6a:	68db      	ldr	r3, [r3, #12]
 8009d6c:	1f1a      	subs	r2, r3, #4
 8009d6e:	9b01      	ldr	r3, [sp, #4]
 8009d70:	60da      	str	r2, [r3, #12]
 8009d72:	9b01      	ldr	r3, [sp, #4]
 8009d74:	68da      	ldr	r2, [r3, #12]
 8009d76:	9b01      	ldr	r3, [sp, #4]
 8009d78:	681b      	ldr	r3, [r3, #0]
 8009d7a:	429a      	cmp	r2, r3
 8009d7c:	d204      	bcs.n	8009d88 <chMBPostAheadI+0x58>
    mbp->mb_rdptr = mbp->mb_top - 1;
 8009d7e:	9b01      	ldr	r3, [sp, #4]
 8009d80:	685b      	ldr	r3, [r3, #4]
 8009d82:	1f1a      	subs	r2, r3, #4
 8009d84:	9b01      	ldr	r3, [sp, #4]
 8009d86:	60da      	str	r2, [r3, #12]
  }
  *mbp->mb_rdptr = msg;
 8009d88:	9b01      	ldr	r3, [sp, #4]
 8009d8a:	68db      	ldr	r3, [r3, #12]
 8009d8c:	9a00      	ldr	r2, [sp, #0]
 8009d8e:	601a      	str	r2, [r3, #0]
  chSemSignalI(&mbp->mb_fullsem);
 8009d90:	9b01      	ldr	r3, [sp, #4]
 8009d92:	3310      	adds	r3, #16
 8009d94:	4618      	mov	r0, r3
 8009d96:	f000 ff8b 	bl	800acb0 <chSemSignalI>

  return MSG_OK;
 8009d9a:	2300      	movs	r3, #0
}
 8009d9c:	4618      	mov	r0, r3
 8009d9e:	b003      	add	sp, #12
 8009da0:	f85d fb04 	ldr.w	pc, [sp], #4
 8009da4:	0800e060 	.word	0x0800e060
	...

08009db0 <chMBFetch>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8009db0:	b500      	push	{lr}
 8009db2:	b087      	sub	sp, #28
 8009db4:	9003      	str	r0, [sp, #12]
 8009db6:	9102      	str	r1, [sp, #8]
 8009db8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 8009dba:	f7ff fe11 	bl	80099e0 <chSysLock.lto_priv.361>
  rdymsg = chMBFetchS(mbp, msgp, timeout);
 8009dbe:	9803      	ldr	r0, [sp, #12]
 8009dc0:	9902      	ldr	r1, [sp, #8]
 8009dc2:	9a01      	ldr	r2, [sp, #4]
 8009dc4:	f000 f80c 	bl	8009de0 <chMBFetchS>
 8009dc8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8009dca:	f7ff fe11 	bl	80099f0 <chSysUnlock.lto_priv.357>

  return rdymsg;
 8009dce:	9b05      	ldr	r3, [sp, #20]
}
 8009dd0:	4618      	mov	r0, r3
 8009dd2:	b007      	add	sp, #28
 8009dd4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08009de0 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8009de0:	b500      	push	{lr}
 8009de2:	b087      	sub	sp, #28
 8009de4:	9003      	str	r0, [sp, #12]
 8009de6:	9102      	str	r1, [sp, #8]
 8009de8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
 8009dea:	f002 f891 	bl	800bf10 <chDbgCheckClassS>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
 8009dee:	9b03      	ldr	r3, [sp, #12]
 8009df0:	2b00      	cmp	r3, #0
 8009df2:	d002      	beq.n	8009dfa <chMBFetchS+0x1a>
 8009df4:	9b02      	ldr	r3, [sp, #8]
 8009df6:	2b00      	cmp	r3, #0
 8009df8:	d102      	bne.n	8009e00 <chMBFetchS+0x20>
 8009dfa:	4815      	ldr	r0, [pc, #84]	; (8009e50 <chMBFetchS+0x70>)
 8009dfc:	f001 fe78 	bl	800baf0 <chSysHalt>

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
 8009e00:	9b03      	ldr	r3, [sp, #12]
 8009e02:	3310      	adds	r3, #16
 8009e04:	4618      	mov	r0, r3
 8009e06:	9901      	ldr	r1, [sp, #4]
 8009e08:	f000 feaa 	bl	800ab60 <chSemWaitTimeoutS>
 8009e0c:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
 8009e0e:	9b05      	ldr	r3, [sp, #20]
 8009e10:	2b00      	cmp	r3, #0
 8009e12:	d118      	bne.n	8009e46 <chMBFetchS+0x66>
    *msgp = *mbp->mb_rdptr++;
 8009e14:	9b03      	ldr	r3, [sp, #12]
 8009e16:	68db      	ldr	r3, [r3, #12]
 8009e18:	1d19      	adds	r1, r3, #4
 8009e1a:	9a03      	ldr	r2, [sp, #12]
 8009e1c:	60d1      	str	r1, [r2, #12]
 8009e1e:	681a      	ldr	r2, [r3, #0]
 8009e20:	9b02      	ldr	r3, [sp, #8]
 8009e22:	601a      	str	r2, [r3, #0]
    if (mbp->mb_rdptr >= mbp->mb_top) {
 8009e24:	9b03      	ldr	r3, [sp, #12]
 8009e26:	68da      	ldr	r2, [r3, #12]
 8009e28:	9b03      	ldr	r3, [sp, #12]
 8009e2a:	685b      	ldr	r3, [r3, #4]
 8009e2c:	429a      	cmp	r2, r3
 8009e2e:	d303      	bcc.n	8009e38 <chMBFetchS+0x58>
      mbp->mb_rdptr = mbp->mb_buffer;
 8009e30:	9b03      	ldr	r3, [sp, #12]
 8009e32:	681a      	ldr	r2, [r3, #0]
 8009e34:	9b03      	ldr	r3, [sp, #12]
 8009e36:	60da      	str	r2, [r3, #12]
    }
    chSemSignalI(&mbp->mb_emptysem);
 8009e38:	9b03      	ldr	r3, [sp, #12]
 8009e3a:	331c      	adds	r3, #28
 8009e3c:	4618      	mov	r0, r3
 8009e3e:	f000 ff37 	bl	800acb0 <chSemSignalI>
    chSchRescheduleS();
 8009e42:	f002 fc25 	bl	800c690 <chSchRescheduleS>
  }

  return rdymsg;
 8009e46:	9b05      	ldr	r3, [sp, #20]
}
 8009e48:	4618      	mov	r0, r3
 8009e4a:	b007      	add	sp, #28
 8009e4c:	f85d fb04 	ldr.w	pc, [sp], #4
 8009e50:	0800e070 	.word	0x0800e070
	...

08009e60 <chMBFetchI>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 8009e60:	b500      	push	{lr}
 8009e62:	b083      	sub	sp, #12
 8009e64:	9001      	str	r0, [sp, #4]
 8009e66:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 8009e68:	f002 f83a 	bl	800bee0 <chDbgCheckClassI>
  chDbgCheck((mbp != NULL) && (msgp != NULL));
 8009e6c:	9b01      	ldr	r3, [sp, #4]
 8009e6e:	2b00      	cmp	r3, #0
 8009e70:	d002      	beq.n	8009e78 <chMBFetchI+0x18>
 8009e72:	9b00      	ldr	r3, [sp, #0]
 8009e74:	2b00      	cmp	r3, #0
 8009e76:	d102      	bne.n	8009e7e <chMBFetchI+0x1e>
 8009e78:	4817      	ldr	r0, [pc, #92]	; (8009ed8 <chMBFetchI+0x78>)
 8009e7a:	f001 fe39 	bl	800baf0 <chSysHalt>

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
 8009e7e:	9b01      	ldr	r3, [sp, #4]
 8009e80:	3310      	adds	r3, #16
 8009e82:	4618      	mov	r0, r3
 8009e84:	f7ff fde4 	bl	8009a50 <chSemGetCounterI>
 8009e88:	4603      	mov	r3, r0
 8009e8a:	2b00      	cmp	r3, #0
 8009e8c:	dc02      	bgt.n	8009e94 <chMBFetchI+0x34>
    return MSG_TIMEOUT;
 8009e8e:	f04f 33ff 	mov.w	r3, #4294967295
 8009e92:	e01c      	b.n	8009ece <chMBFetchI+0x6e>
  }
  chSemFastWaitI(&mbp->mb_fullsem);
 8009e94:	9b01      	ldr	r3, [sp, #4]
 8009e96:	3310      	adds	r3, #16
 8009e98:	4618      	mov	r0, r3
 8009e9a:	f7ff fdc9 	bl	8009a30 <chSemFastWaitI>
  *msgp = *mbp->mb_rdptr++;
 8009e9e:	9b01      	ldr	r3, [sp, #4]
 8009ea0:	68db      	ldr	r3, [r3, #12]
 8009ea2:	1d19      	adds	r1, r3, #4
 8009ea4:	9a01      	ldr	r2, [sp, #4]
 8009ea6:	60d1      	str	r1, [r2, #12]
 8009ea8:	681a      	ldr	r2, [r3, #0]
 8009eaa:	9b00      	ldr	r3, [sp, #0]
 8009eac:	601a      	str	r2, [r3, #0]
  if (mbp->mb_rdptr >= mbp->mb_top) {
 8009eae:	9b01      	ldr	r3, [sp, #4]
 8009eb0:	68da      	ldr	r2, [r3, #12]
 8009eb2:	9b01      	ldr	r3, [sp, #4]
 8009eb4:	685b      	ldr	r3, [r3, #4]
 8009eb6:	429a      	cmp	r2, r3
 8009eb8:	d303      	bcc.n	8009ec2 <chMBFetchI+0x62>
    mbp->mb_rdptr = mbp->mb_buffer;
 8009eba:	9b01      	ldr	r3, [sp, #4]
 8009ebc:	681a      	ldr	r2, [r3, #0]
 8009ebe:	9b01      	ldr	r3, [sp, #4]
 8009ec0:	60da      	str	r2, [r3, #12]
  }
  chSemSignalI(&mbp->mb_emptysem);
 8009ec2:	9b01      	ldr	r3, [sp, #4]
 8009ec4:	331c      	adds	r3, #28
 8009ec6:	4618      	mov	r0, r3
 8009ec8:	f000 fef2 	bl	800acb0 <chSemSignalI>

  return MSG_OK;
 8009ecc:	2300      	movs	r3, #0
}
 8009ece:	4618      	mov	r0, r3
 8009ed0:	b003      	add	sp, #12
 8009ed2:	f85d fb04 	ldr.w	pc, [sp], #4
 8009ed6:	bf00      	nop
 8009ed8:	0800e080 	.word	0x0800e080
 8009edc:	00000000 	.word	0x00000000

08009ee0 <port_lock.lto_priv.350>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8009ee0:	b082      	sub	sp, #8
 8009ee2:	2320      	movs	r3, #32
 8009ee4:	9301      	str	r3, [sp, #4]
 8009ee6:	9b01      	ldr	r3, [sp, #4]
 8009ee8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8009eec:	b002      	add	sp, #8
 8009eee:	4770      	bx	lr

08009ef0 <port_unlock.lto_priv.346>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8009ef0:	b082      	sub	sp, #8
 8009ef2:	2300      	movs	r3, #0
 8009ef4:	9301      	str	r3, [sp, #4]
 8009ef6:	9b01      	ldr	r3, [sp, #4]
 8009ef8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8009efc:	b002      	add	sp, #8
 8009efe:	4770      	bx	lr

08009f00 <queue_init.lto_priv.342>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8009f00:	b082      	sub	sp, #8
 8009f02:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8009f04:	9b01      	ldr	r3, [sp, #4]
 8009f06:	9a01      	ldr	r2, [sp, #4]
 8009f08:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8009f0a:	9b01      	ldr	r3, [sp, #4]
 8009f0c:	9a01      	ldr	r2, [sp, #4]
 8009f0e:	605a      	str	r2, [r3, #4]
}
 8009f10:	b002      	add	sp, #8
 8009f12:	4770      	bx	lr
	...

08009f20 <chSysLock.lto_priv.317>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8009f20:	b508      	push	{r3, lr}

  port_lock();
 8009f22:	f7ff ffdd 	bl	8009ee0 <port_lock.lto_priv.350>
  _stats_start_measure_crit_thd();
 8009f26:	f000 fa8b 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 8009f2a:	f001 ff39 	bl	800bda0 <_dbg_check_lock>
}
 8009f2e:	bd08      	pop	{r3, pc}

08009f30 <chSysUnlock.lto_priv.312>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8009f30:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 8009f32:	f001 ff4d 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 8009f36:	f000 fa8b 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 8009f3a:	4b09      	ldr	r3, [pc, #36]	; (8009f60 <chSysUnlock.lto_priv.312+0x30>)
 8009f3c:	681b      	ldr	r3, [r3, #0]
 8009f3e:	4a08      	ldr	r2, [pc, #32]	; (8009f60 <chSysUnlock.lto_priv.312+0x30>)
 8009f40:	4293      	cmp	r3, r2
 8009f42:	d00a      	beq.n	8009f5a <chSysUnlock.lto_priv.312+0x2a>
 8009f44:	4b06      	ldr	r3, [pc, #24]	; (8009f60 <chSysUnlock.lto_priv.312+0x30>)
 8009f46:	699b      	ldr	r3, [r3, #24]
 8009f48:	689a      	ldr	r2, [r3, #8]
 8009f4a:	4b05      	ldr	r3, [pc, #20]	; (8009f60 <chSysUnlock.lto_priv.312+0x30>)
 8009f4c:	681b      	ldr	r3, [r3, #0]
 8009f4e:	689b      	ldr	r3, [r3, #8]
 8009f50:	429a      	cmp	r2, r3
 8009f52:	d202      	bcs.n	8009f5a <chSysUnlock.lto_priv.312+0x2a>
 8009f54:	4803      	ldr	r0, [pc, #12]	; (8009f64 <chSysUnlock.lto_priv.312+0x34>)
 8009f56:	f001 fdcb 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8009f5a:	f7ff ffc9 	bl	8009ef0 <port_unlock.lto_priv.346>
}
 8009f5e:	bd08      	pop	{r3, pc}
 8009f60:	20000d30 	.word	0x20000d30
 8009f64:	0800e090 	.word	0x0800e090
	...

08009f70 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8009f70:	b500      	push	{lr}
 8009f72:	b083      	sub	sp, #12
 8009f74:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 8009f76:	9801      	ldr	r0, [sp, #4]
 8009f78:	f7ff ffc2 	bl	8009f00 <queue_init.lto_priv.342>
}
 8009f7c:	b003      	add	sp, #12
 8009f7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8009f82:	bf00      	nop
	...

08009f90 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 8009f90:	b500      	push	{lr}
 8009f92:	b083      	sub	sp, #12
 8009f94:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8009f96:	f001 ffa3 	bl	800bee0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(iqp) == 0U);
 8009f9a:	9b01      	ldr	r3, [sp, #4]
 8009f9c:	689b      	ldr	r3, [r3, #8]
 8009f9e:	2b00      	cmp	r3, #0
 8009fa0:	bf0c      	ite	eq
 8009fa2:	2301      	moveq	r3, #1
 8009fa4:	2300      	movne	r3, #0
 8009fa6:	b2db      	uxtb	r3, r3
}
 8009fa8:	4618      	mov	r0, r3
 8009faa:	b003      	add	sp, #12
 8009fac:	f85d fb04 	ldr.w	pc, [sp], #4

08009fb0 <chIQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
 8009fb0:	b500      	push	{lr}
 8009fb2:	b083      	sub	sp, #12
 8009fb4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8009fb6:	f001 ff93 	bl	800bee0 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8009fba:	9b01      	ldr	r3, [sp, #4]
 8009fbc:	695a      	ldr	r2, [r3, #20]
 8009fbe:	9b01      	ldr	r3, [sp, #4]
 8009fc0:	699b      	ldr	r3, [r3, #24]
 8009fc2:	429a      	cmp	r2, r3
 8009fc4:	d105      	bne.n	8009fd2 <chIQIsFullI+0x22>
 8009fc6:	9b01      	ldr	r3, [sp, #4]
 8009fc8:	689b      	ldr	r3, [r3, #8]
 8009fca:	2b00      	cmp	r3, #0
 8009fcc:	d001      	beq.n	8009fd2 <chIQIsFullI+0x22>
 8009fce:	2301      	movs	r3, #1
 8009fd0:	e000      	b.n	8009fd4 <chIQIsFullI+0x24>
 8009fd2:	2300      	movs	r3, #0
 8009fd4:	f003 0301 	and.w	r3, r3, #1
 8009fd8:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 8009fda:	4618      	mov	r0, r3
 8009fdc:	b003      	add	sp, #12
 8009fde:	f85d fb04 	ldr.w	pc, [sp], #4
 8009fe2:	bf00      	nop
	...

08009ff0 <chOQIsEmptyI.lto_priv.339>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 8009ff0:	b500      	push	{lr}
 8009ff2:	b083      	sub	sp, #12
 8009ff4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8009ff6:	f001 ff73 	bl	800bee0 <chDbgCheckClassI>

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8009ffa:	9b01      	ldr	r3, [sp, #4]
 8009ffc:	695a      	ldr	r2, [r3, #20]
 8009ffe:	9b01      	ldr	r3, [sp, #4]
 800a000:	699b      	ldr	r3, [r3, #24]
 800a002:	429a      	cmp	r2, r3
 800a004:	d105      	bne.n	800a012 <chOQIsEmptyI.lto_priv.339+0x22>
 800a006:	9b01      	ldr	r3, [sp, #4]
 800a008:	689b      	ldr	r3, [r3, #8]
 800a00a:	2b00      	cmp	r3, #0
 800a00c:	d001      	beq.n	800a012 <chOQIsEmptyI.lto_priv.339+0x22>
 800a00e:	2301      	movs	r3, #1
 800a010:	e000      	b.n	800a014 <chOQIsEmptyI.lto_priv.339+0x24>
 800a012:	2300      	movs	r3, #0
 800a014:	f003 0301 	and.w	r3, r3, #1
 800a018:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 800a01a:	4618      	mov	r0, r3
 800a01c:	b003      	add	sp, #12
 800a01e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a022:	bf00      	nop
	...

0800a030 <chOQIsFullI.lto_priv.338>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 800a030:	b500      	push	{lr}
 800a032:	b083      	sub	sp, #12
 800a034:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800a036:	f001 ff53 	bl	800bee0 <chDbgCheckClassI>

  return (bool)(chQSpaceI(oqp) == 0U);
 800a03a:	9b01      	ldr	r3, [sp, #4]
 800a03c:	689b      	ldr	r3, [r3, #8]
 800a03e:	2b00      	cmp	r3, #0
 800a040:	bf0c      	ite	eq
 800a042:	2301      	moveq	r3, #1
 800a044:	2300      	movne	r3, #0
 800a046:	b2db      	uxtb	r3, r3
}
 800a048:	4618      	mov	r0, r3
 800a04a:	b003      	add	sp, #12
 800a04c:	f85d fb04 	ldr.w	pc, [sp], #4

0800a050 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 800a050:	b500      	push	{lr}
 800a052:	b085      	sub	sp, #20
 800a054:	9003      	str	r0, [sp, #12]
 800a056:	9102      	str	r1, [sp, #8]
 800a058:	9201      	str	r2, [sp, #4]
 800a05a:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&iqp->q_waiting);
 800a05c:	9b03      	ldr	r3, [sp, #12]
 800a05e:	4618      	mov	r0, r3
 800a060:	f7ff ff86 	bl	8009f70 <chThdQueueObjectInit>
  iqp->q_counter = 0;
 800a064:	9b03      	ldr	r3, [sp, #12]
 800a066:	2200      	movs	r2, #0
 800a068:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 800a06a:	9b03      	ldr	r3, [sp, #12]
 800a06c:	9a02      	ldr	r2, [sp, #8]
 800a06e:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 800a070:	9b03      	ldr	r3, [sp, #12]
 800a072:	9a02      	ldr	r2, [sp, #8]
 800a074:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 800a076:	9b03      	ldr	r3, [sp, #12]
 800a078:	9a02      	ldr	r2, [sp, #8]
 800a07a:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 800a07c:	9a02      	ldr	r2, [sp, #8]
 800a07e:	9b01      	ldr	r3, [sp, #4]
 800a080:	441a      	add	r2, r3
 800a082:	9b03      	ldr	r3, [sp, #12]
 800a084:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 800a086:	9b03      	ldr	r3, [sp, #12]
 800a088:	9a00      	ldr	r2, [sp, #0]
 800a08a:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 800a08c:	9b03      	ldr	r3, [sp, #12]
 800a08e:	9a06      	ldr	r2, [sp, #24]
 800a090:	621a      	str	r2, [r3, #32]
}
 800a092:	b005      	add	sp, #20
 800a094:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800a0a0 <chIQResetI>:
 *
 * @param[in] iqp       pointer to an @p input_queue_t structure
 *
 * @iclass
 */
void chIQResetI(input_queue_t *iqp) {
 800a0a0:	b500      	push	{lr}
 800a0a2:	b083      	sub	sp, #12
 800a0a4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800a0a6:	f001 ff1b 	bl	800bee0 <chDbgCheckClassI>

  iqp->q_rdptr = iqp->q_buffer;
 800a0aa:	9b01      	ldr	r3, [sp, #4]
 800a0ac:	68da      	ldr	r2, [r3, #12]
 800a0ae:	9b01      	ldr	r3, [sp, #4]
 800a0b0:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr = iqp->q_buffer;
 800a0b2:	9b01      	ldr	r3, [sp, #4]
 800a0b4:	68da      	ldr	r2, [r3, #12]
 800a0b6:	9b01      	ldr	r3, [sp, #4]
 800a0b8:	615a      	str	r2, [r3, #20]
  iqp->q_counter = 0;
 800a0ba:	9b01      	ldr	r3, [sp, #4]
 800a0bc:	2200      	movs	r2, #0
 800a0be:	609a      	str	r2, [r3, #8]
  chThdDequeueAllI(&iqp->q_waiting, Q_RESET);
 800a0c0:	9b01      	ldr	r3, [sp, #4]
 800a0c2:	4618      	mov	r0, r3
 800a0c4:	f06f 0101 	mvn.w	r1, #1
 800a0c8:	f002 ff72 	bl	800cfb0 <chThdDequeueAllI>
}
 800a0cc:	b003      	add	sp, #12
 800a0ce:	f85d fb04 	ldr.w	pc, [sp], #4
 800a0d2:	bf00      	nop
	...

0800a0e0 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 800a0e0:	b500      	push	{lr}
 800a0e2:	b083      	sub	sp, #12
 800a0e4:	9001      	str	r0, [sp, #4]
 800a0e6:	460b      	mov	r3, r1
 800a0e8:	f88d 3003 	strb.w	r3, [sp, #3]

  chDbgCheckClassI();
 800a0ec:	f001 fef8 	bl	800bee0 <chDbgCheckClassI>

  if (chIQIsFullI(iqp)) {
 800a0f0:	9801      	ldr	r0, [sp, #4]
 800a0f2:	f7ff ff5d 	bl	8009fb0 <chIQIsFullI>
 800a0f6:	4603      	mov	r3, r0
 800a0f8:	2b00      	cmp	r3, #0
 800a0fa:	d002      	beq.n	800a102 <chIQPutI+0x22>
    return Q_FULL;
 800a0fc:	f06f 0303 	mvn.w	r3, #3
 800a100:	e01c      	b.n	800a13c <chIQPutI+0x5c>
  }

  iqp->q_counter++;
 800a102:	9b01      	ldr	r3, [sp, #4]
 800a104:	689b      	ldr	r3, [r3, #8]
 800a106:	1c5a      	adds	r2, r3, #1
 800a108:	9b01      	ldr	r3, [sp, #4]
 800a10a:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
 800a10c:	9b01      	ldr	r3, [sp, #4]
 800a10e:	695b      	ldr	r3, [r3, #20]
 800a110:	1c59      	adds	r1, r3, #1
 800a112:	9a01      	ldr	r2, [sp, #4]
 800a114:	6151      	str	r1, [r2, #20]
 800a116:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800a11a:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 800a11c:	9b01      	ldr	r3, [sp, #4]
 800a11e:	695a      	ldr	r2, [r3, #20]
 800a120:	9b01      	ldr	r3, [sp, #4]
 800a122:	691b      	ldr	r3, [r3, #16]
 800a124:	429a      	cmp	r2, r3
 800a126:	d303      	bcc.n	800a130 <chIQPutI+0x50>
    iqp->q_wrptr = iqp->q_buffer;
 800a128:	9b01      	ldr	r3, [sp, #4]
 800a12a:	68da      	ldr	r2, [r3, #12]
 800a12c:	9b01      	ldr	r3, [sp, #4]
 800a12e:	615a      	str	r2, [r3, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 800a130:	9b01      	ldr	r3, [sp, #4]
 800a132:	4618      	mov	r0, r3
 800a134:	2100      	movs	r1, #0
 800a136:	f002 ff23 	bl	800cf80 <chThdDequeueNextI>

  return Q_OK;
 800a13a:	2300      	movs	r3, #0
}
 800a13c:	4618      	mov	r0, r3
 800a13e:	b003      	add	sp, #12
 800a140:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800a150 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 800a150:	b500      	push	{lr}
 800a152:	b085      	sub	sp, #20
 800a154:	9001      	str	r0, [sp, #4]
 800a156:	9100      	str	r1, [sp, #0]
  uint8_t b;

  chSysLock();
 800a158:	f7ff fee2 	bl	8009f20 <chSysLock.lto_priv.317>
  if (iqp->q_notify != NULL) {
 800a15c:	9b01      	ldr	r3, [sp, #4]
 800a15e:	69db      	ldr	r3, [r3, #28]
 800a160:	2b00      	cmp	r3, #0
 800a162:	d011      	beq.n	800a188 <chIQGetTimeout+0x38>
    iqp->q_notify(iqp);
 800a164:	9b01      	ldr	r3, [sp, #4]
 800a166:	69db      	ldr	r3, [r3, #28]
 800a168:	9801      	ldr	r0, [sp, #4]
 800a16a:	4798      	blx	r3
 800a16c:	e00c      	b.n	800a188 <chIQGetTimeout+0x38>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 800a16e:	9b01      	ldr	r3, [sp, #4]
 800a170:	4618      	mov	r0, r3
 800a172:	9900      	ldr	r1, [sp, #0]
 800a174:	f002 fee4 	bl	800cf40 <chThdEnqueueTimeoutS>
 800a178:	9003      	str	r0, [sp, #12]
    if (msg < Q_OK) {
 800a17a:	9b03      	ldr	r3, [sp, #12]
 800a17c:	2b00      	cmp	r3, #0
 800a17e:	da03      	bge.n	800a188 <chIQGetTimeout+0x38>
      chSysUnlock();
 800a180:	f7ff fed6 	bl	8009f30 <chSysUnlock.lto_priv.312>
      return msg;
 800a184:	9b03      	ldr	r3, [sp, #12]
 800a186:	e020      	b.n	800a1ca <chIQGetTimeout+0x7a>
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 800a188:	9801      	ldr	r0, [sp, #4]
 800a18a:	f7ff ff01 	bl	8009f90 <chIQIsEmptyI>
 800a18e:	4603      	mov	r3, r0
 800a190:	2b00      	cmp	r3, #0
 800a192:	d1ec      	bne.n	800a16e <chIQGetTimeout+0x1e>
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 800a194:	9b01      	ldr	r3, [sp, #4]
 800a196:	689b      	ldr	r3, [r3, #8]
 800a198:	1e5a      	subs	r2, r3, #1
 800a19a:	9b01      	ldr	r3, [sp, #4]
 800a19c:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 800a19e:	9b01      	ldr	r3, [sp, #4]
 800a1a0:	699b      	ldr	r3, [r3, #24]
 800a1a2:	1c59      	adds	r1, r3, #1
 800a1a4:	9a01      	ldr	r2, [sp, #4]
 800a1a6:	6191      	str	r1, [r2, #24]
 800a1a8:	781b      	ldrb	r3, [r3, #0]
 800a1aa:	f88d 300b 	strb.w	r3, [sp, #11]
  if (iqp->q_rdptr >= iqp->q_top) {
 800a1ae:	9b01      	ldr	r3, [sp, #4]
 800a1b0:	699a      	ldr	r2, [r3, #24]
 800a1b2:	9b01      	ldr	r3, [sp, #4]
 800a1b4:	691b      	ldr	r3, [r3, #16]
 800a1b6:	429a      	cmp	r2, r3
 800a1b8:	d303      	bcc.n	800a1c2 <chIQGetTimeout+0x72>
    iqp->q_rdptr = iqp->q_buffer;
 800a1ba:	9b01      	ldr	r3, [sp, #4]
 800a1bc:	68da      	ldr	r2, [r3, #12]
 800a1be:	9b01      	ldr	r3, [sp, #4]
 800a1c0:	619a      	str	r2, [r3, #24]
  }
  chSysUnlock();
 800a1c2:	f7ff feb5 	bl	8009f30 <chSysUnlock.lto_priv.312>

  return (msg_t)b;
 800a1c6:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 800a1ca:	4618      	mov	r0, r3
 800a1cc:	b005      	add	sp, #20
 800a1ce:	f85d fb04 	ldr.w	pc, [sp], #4
 800a1d2:	bf00      	nop
	...

0800a1e0 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 800a1e0:	b500      	push	{lr}
 800a1e2:	b087      	sub	sp, #28
 800a1e4:	9003      	str	r0, [sp, #12]
 800a1e6:	9102      	str	r1, [sp, #8]
 800a1e8:	9201      	str	r2, [sp, #4]
 800a1ea:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
 800a1ec:	9b03      	ldr	r3, [sp, #12]
 800a1ee:	69db      	ldr	r3, [r3, #28]
 800a1f0:	9304      	str	r3, [sp, #16]
  size_t r = 0;
 800a1f2:	2300      	movs	r3, #0
 800a1f4:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);
 800a1f6:	9b01      	ldr	r3, [sp, #4]
 800a1f8:	2b00      	cmp	r3, #0
 800a1fa:	d102      	bne.n	800a202 <chIQReadTimeout+0x22>
 800a1fc:	4825      	ldr	r0, [pc, #148]	; (800a294 <chIQReadTimeout+0xb4>)
 800a1fe:	f001 fc77 	bl	800baf0 <chSysHalt>

  chSysLock();
 800a202:	f7ff fe8d 	bl	8009f20 <chSysLock.lto_priv.317>
  while (true) {
    if (nfy != NULL) {
 800a206:	9b04      	ldr	r3, [sp, #16]
 800a208:	2b00      	cmp	r3, #0
 800a20a:	d00f      	beq.n	800a22c <chIQReadTimeout+0x4c>
      nfy(iqp);
 800a20c:	9b04      	ldr	r3, [sp, #16]
 800a20e:	9803      	ldr	r0, [sp, #12]
 800a210:	4798      	blx	r3
 800a212:	e00b      	b.n	800a22c <chIQReadTimeout+0x4c>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 800a214:	9b03      	ldr	r3, [sp, #12]
 800a216:	4618      	mov	r0, r3
 800a218:	9900      	ldr	r1, [sp, #0]
 800a21a:	f002 fe91 	bl	800cf40 <chThdEnqueueTimeoutS>
 800a21e:	4603      	mov	r3, r0
 800a220:	2b00      	cmp	r3, #0
 800a222:	d003      	beq.n	800a22c <chIQReadTimeout+0x4c>
        chSysUnlock();
 800a224:	f7ff fe84 	bl	8009f30 <chSysUnlock.lto_priv.312>
        return r;
 800a228:	9b05      	ldr	r3, [sp, #20]
 800a22a:	e02e      	b.n	800a28a <chIQReadTimeout+0xaa>
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 800a22c:	9803      	ldr	r0, [sp, #12]
 800a22e:	f7ff feaf 	bl	8009f90 <chIQIsEmptyI>
 800a232:	4603      	mov	r3, r0
 800a234:	2b00      	cmp	r3, #0
 800a236:	d1ed      	bne.n	800a214 <chIQReadTimeout+0x34>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 800a238:	9b03      	ldr	r3, [sp, #12]
 800a23a:	689b      	ldr	r3, [r3, #8]
 800a23c:	1e5a      	subs	r2, r3, #1
 800a23e:	9b03      	ldr	r3, [sp, #12]
 800a240:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
 800a242:	9b02      	ldr	r3, [sp, #8]
 800a244:	1c5a      	adds	r2, r3, #1
 800a246:	9202      	str	r2, [sp, #8]
 800a248:	9a03      	ldr	r2, [sp, #12]
 800a24a:	6992      	ldr	r2, [r2, #24]
 800a24c:	1c50      	adds	r0, r2, #1
 800a24e:	9903      	ldr	r1, [sp, #12]
 800a250:	6188      	str	r0, [r1, #24]
 800a252:	7812      	ldrb	r2, [r2, #0]
 800a254:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 800a256:	9b03      	ldr	r3, [sp, #12]
 800a258:	699a      	ldr	r2, [r3, #24]
 800a25a:	9b03      	ldr	r3, [sp, #12]
 800a25c:	691b      	ldr	r3, [r3, #16]
 800a25e:	429a      	cmp	r2, r3
 800a260:	d303      	bcc.n	800a26a <chIQReadTimeout+0x8a>
      iqp->q_rdptr = iqp->q_buffer;
 800a262:	9b03      	ldr	r3, [sp, #12]
 800a264:	68da      	ldr	r2, [r3, #12]
 800a266:	9b03      	ldr	r3, [sp, #12]
 800a268:	619a      	str	r2, [r3, #24]
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 800a26a:	f7ff fe61 	bl	8009f30 <chSysUnlock.lto_priv.312>

    r++;
 800a26e:	9b05      	ldr	r3, [sp, #20]
 800a270:	3301      	adds	r3, #1
 800a272:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 800a274:	9b01      	ldr	r3, [sp, #4]
 800a276:	3b01      	subs	r3, #1
 800a278:	9301      	str	r3, [sp, #4]
 800a27a:	9b01      	ldr	r3, [sp, #4]
 800a27c:	2b00      	cmp	r3, #0
 800a27e:	d101      	bne.n	800a284 <chIQReadTimeout+0xa4>
      return r;
 800a280:	9b05      	ldr	r3, [sp, #20]
 800a282:	e002      	b.n	800a28a <chIQReadTimeout+0xaa>
    }

    chSysLock();
 800a284:	f7ff fe4c 	bl	8009f20 <chSysLock.lto_priv.317>
 800a288:	e7bd      	b.n	800a206 <chIQReadTimeout+0x26>
  }
}
 800a28a:	4618      	mov	r0, r3
 800a28c:	b007      	add	sp, #28
 800a28e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a292:	bf00      	nop
 800a294:	0800e0a0 	.word	0x0800e0a0
	...

0800a2a0 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 800a2a0:	b500      	push	{lr}
 800a2a2:	b085      	sub	sp, #20
 800a2a4:	9003      	str	r0, [sp, #12]
 800a2a6:	9102      	str	r1, [sp, #8]
 800a2a8:	9201      	str	r2, [sp, #4]
 800a2aa:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&oqp->q_waiting);
 800a2ac:	9b03      	ldr	r3, [sp, #12]
 800a2ae:	4618      	mov	r0, r3
 800a2b0:	f7ff fe5e 	bl	8009f70 <chThdQueueObjectInit>
  oqp->q_counter = size;
 800a2b4:	9b03      	ldr	r3, [sp, #12]
 800a2b6:	9a01      	ldr	r2, [sp, #4]
 800a2b8:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 800a2ba:	9b03      	ldr	r3, [sp, #12]
 800a2bc:	9a02      	ldr	r2, [sp, #8]
 800a2be:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 800a2c0:	9b03      	ldr	r3, [sp, #12]
 800a2c2:	9a02      	ldr	r2, [sp, #8]
 800a2c4:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 800a2c6:	9b03      	ldr	r3, [sp, #12]
 800a2c8:	9a02      	ldr	r2, [sp, #8]
 800a2ca:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 800a2cc:	9a02      	ldr	r2, [sp, #8]
 800a2ce:	9b01      	ldr	r3, [sp, #4]
 800a2d0:	441a      	add	r2, r3
 800a2d2:	9b03      	ldr	r3, [sp, #12]
 800a2d4:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 800a2d6:	9b03      	ldr	r3, [sp, #12]
 800a2d8:	9a00      	ldr	r2, [sp, #0]
 800a2da:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 800a2dc:	9b03      	ldr	r3, [sp, #12]
 800a2de:	9a06      	ldr	r2, [sp, #24]
 800a2e0:	621a      	str	r2, [r3, #32]
}
 800a2e2:	b005      	add	sp, #20
 800a2e4:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800a2f0 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 800a2f0:	b500      	push	{lr}
 800a2f2:	b083      	sub	sp, #12
 800a2f4:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
 800a2f6:	f002 fe73 	bl	800cfe0 <port_rt_get_counter_value.lto_priv.406>
 800a2fa:	4602      	mov	r2, r0
 800a2fc:	9b01      	ldr	r3, [sp, #4]
 800a2fe:	609a      	str	r2, [r3, #8]
}
 800a300:	b003      	add	sp, #12
 800a302:	f85d fb04 	ldr.w	pc, [sp], #4
 800a306:	bf00      	nop
	...

0800a310 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 800a310:	b500      	push	{lr}
 800a312:	b083      	sub	sp, #12
 800a314:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 800a316:	f002 fe63 	bl	800cfe0 <port_rt_get_counter_value.lto_priv.406>
 800a31a:	4602      	mov	r2, r0
 800a31c:	4b05      	ldr	r3, [pc, #20]	; (800a334 <chTMStopMeasurementX+0x24>)
 800a31e:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
 800a322:	9801      	ldr	r0, [sp, #4]
 800a324:	4611      	mov	r1, r2
 800a326:	461a      	mov	r2, r3
 800a328:	f002 fe62 	bl	800cff0 <tm_stop.lto_priv.405>
}
 800a32c:	b003      	add	sp, #12
 800a32e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a332:	bf00      	nop
 800a334:	20000d30 	.word	0x20000d30
	...

0800a340 <chTMChainMeasurementToX>:
 *
 *
 * @xclass
 */
NOINLINE void chTMChainMeasurementToX(time_measurement_t *tmp1,
                                      time_measurement_t *tmp2) {
 800a340:	b500      	push	{lr}
 800a342:	b083      	sub	sp, #12
 800a344:	9001      	str	r0, [sp, #4]
 800a346:	9100      	str	r1, [sp, #0]

  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();
 800a348:	f002 fe4a 	bl	800cfe0 <port_rt_get_counter_value.lto_priv.406>
 800a34c:	4602      	mov	r2, r0
 800a34e:	9b00      	ldr	r3, [sp, #0]
 800a350:	609a      	str	r2, [r3, #8]

  /* Stops previous measurement using the same time stamp.*/
  tm_stop(tmp1, tmp2->last, (rtcnt_t)0);
 800a352:	9b00      	ldr	r3, [sp, #0]
 800a354:	689b      	ldr	r3, [r3, #8]
 800a356:	9801      	ldr	r0, [sp, #4]
 800a358:	4619      	mov	r1, r3
 800a35a:	2200      	movs	r2, #0
 800a35c:	f002 fe48 	bl	800cff0 <tm_stop.lto_priv.405>
}
 800a360:	b003      	add	sp, #12
 800a362:	f85d fb04 	ldr.w	pc, [sp], #4
 800a366:	bf00      	nop
	...

0800a370 <port_lock.lto_priv.378>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800a370:	b082      	sub	sp, #8
 800a372:	2320      	movs	r3, #32
 800a374:	9301      	str	r3, [sp, #4]
 800a376:	9b01      	ldr	r3, [sp, #4]
 800a378:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a37c:	b002      	add	sp, #8
 800a37e:	4770      	bx	lr

0800a380 <port_unlock.lto_priv.372>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800a380:	b082      	sub	sp, #8
 800a382:	2300      	movs	r3, #0
 800a384:	9301      	str	r3, [sp, #4]
 800a386:	9b01      	ldr	r3, [sp, #4]
 800a388:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a38c:	b002      	add	sp, #8
 800a38e:	4770      	bx	lr

0800a390 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800a390:	b508      	push	{r3, lr}

  port_lock();
 800a392:	f7ff ffed 	bl	800a370 <port_lock.lto_priv.378>
}
 800a396:	bd08      	pop	{r3, pc}
	...

0800a3a0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800a3a0:	b508      	push	{r3, lr}

  port_unlock();
 800a3a2:	f7ff ffed 	bl	800a380 <port_unlock.lto_priv.372>
}
 800a3a6:	bd08      	pop	{r3, pc}
	...

0800a3b0 <_stats_init>:
/**
 * @brief   Initializes the statistics module.
 *
 * @init
 */
void _stats_init(void) {
 800a3b0:	b508      	push	{r3, lr}

  ch.kernel_stats.n_irq = (ucnt_t)0;
 800a3b2:	4b07      	ldr	r3, [pc, #28]	; (800a3d0 <_stats_init+0x20>)
 800a3b4:	2200      	movs	r2, #0
 800a3b6:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
  ch.kernel_stats.n_ctxswc = (ucnt_t)0;
 800a3ba:	4b05      	ldr	r3, [pc, #20]	; (800a3d0 <_stats_init+0x20>)
 800a3bc:	2200      	movs	r2, #0
 800a3be:	f8c3 24ac 	str.w	r2, [r3, #1196]	; 0x4ac
  chTMObjectInit(&ch.kernel_stats.m_crit_thd);
 800a3c2:	4804      	ldr	r0, [pc, #16]	; (800a3d4 <_stats_init+0x24>)
 800a3c4:	f002 fe6c 	bl	800d0a0 <chTMObjectInit>
  chTMObjectInit(&ch.kernel_stats.m_crit_isr);
 800a3c8:	4803      	ldr	r0, [pc, #12]	; (800a3d8 <_stats_init+0x28>)
 800a3ca:	f002 fe69 	bl	800d0a0 <chTMObjectInit>
}
 800a3ce:	bd08      	pop	{r3, pc}
 800a3d0:	20000d30 	.word	0x20000d30
 800a3d4:	200011e0 	.word	0x200011e0
 800a3d8:	200011f8 	.word	0x200011f8
 800a3dc:	00000000 	.word	0x00000000

0800a3e0 <_stats_increase_irq>:

/**
 * @brief   Increases the IRQ counter.
 */
void _stats_increase_irq(void) {
 800a3e0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800a3e2:	f7ff ffd5 	bl	800a390 <port_lock_from_isr>
  ch.kernel_stats.n_irq++;
 800a3e6:	4b05      	ldr	r3, [pc, #20]	; (800a3fc <_stats_increase_irq+0x1c>)
 800a3e8:	f8d3 34a8 	ldr.w	r3, [r3, #1192]	; 0x4a8
 800a3ec:	3301      	adds	r3, #1
 800a3ee:	4a03      	ldr	r2, [pc, #12]	; (800a3fc <_stats_increase_irq+0x1c>)
 800a3f0:	f8c2 34a8 	str.w	r3, [r2, #1192]	; 0x4a8
  port_unlock_from_isr();
 800a3f4:	f7ff ffd4 	bl	800a3a0 <port_unlock_from_isr>
}
 800a3f8:	bd08      	pop	{r3, pc}
 800a3fa:	bf00      	nop
 800a3fc:	20000d30 	.word	0x20000d30

0800a400 <_stats_ctxswc>:
 * @brief   Updates context switch related statistics.
 *
 * @param[in] ntp       the thread to be switched in
 * @param[in] otp       the thread to be switched out
 */
void _stats_ctxswc(thread_t *ntp, thread_t *otp) {
 800a400:	b500      	push	{lr}
 800a402:	b083      	sub	sp, #12
 800a404:	9001      	str	r0, [sp, #4]
 800a406:	9100      	str	r1, [sp, #0]

  ch.kernel_stats.n_ctxswc++;
 800a408:	4b09      	ldr	r3, [pc, #36]	; (800a430 <_stats_ctxswc+0x30>)
 800a40a:	f8d3 34ac 	ldr.w	r3, [r3, #1196]	; 0x4ac
 800a40e:	3301      	adds	r3, #1
 800a410:	4a07      	ldr	r2, [pc, #28]	; (800a430 <_stats_ctxswc+0x30>)
 800a412:	f8c2 34ac 	str.w	r3, [r2, #1196]	; 0x4ac
  chTMChainMeasurementToX(&otp->p_stats, &ntp->p_stats);
 800a416:	9b00      	ldr	r3, [sp, #0]
 800a418:	f103 0248 	add.w	r2, r3, #72	; 0x48
 800a41c:	9b01      	ldr	r3, [sp, #4]
 800a41e:	3348      	adds	r3, #72	; 0x48
 800a420:	4610      	mov	r0, r2
 800a422:	4619      	mov	r1, r3
 800a424:	f7ff ff8c 	bl	800a340 <chTMChainMeasurementToX>
}
 800a428:	b003      	add	sp, #12
 800a42a:	f85d fb04 	ldr.w	pc, [sp], #4
 800a42e:	bf00      	nop
 800a430:	20000d30 	.word	0x20000d30
	...

0800a440 <_stats_start_measure_crit_thd>:

/**
 * @brief   Starts the measurement of a thread critical zone.
 */
void _stats_start_measure_crit_thd(void) {
 800a440:	b508      	push	{r3, lr}

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_thd);
 800a442:	4802      	ldr	r0, [pc, #8]	; (800a44c <_stats_start_measure_crit_thd+0xc>)
 800a444:	f7ff ff54 	bl	800a2f0 <chTMStartMeasurementX>
}
 800a448:	bd08      	pop	{r3, pc}
 800a44a:	bf00      	nop
 800a44c:	200011e0 	.word	0x200011e0

0800a450 <_stats_stop_measure_crit_thd>:

/**
 * @brief   Stops the measurement of a thread critical zone.
 */
void _stats_stop_measure_crit_thd(void) {
 800a450:	b508      	push	{r3, lr}

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_thd);
 800a452:	4802      	ldr	r0, [pc, #8]	; (800a45c <_stats_stop_measure_crit_thd+0xc>)
 800a454:	f7ff ff5c 	bl	800a310 <chTMStopMeasurementX>
}
 800a458:	bd08      	pop	{r3, pc}
 800a45a:	bf00      	nop
 800a45c:	200011e0 	.word	0x200011e0

0800a460 <_stats_start_measure_crit_isr>:

/**
 * @brief   Starts the measurement of an ISR critical zone.
 */
void _stats_start_measure_crit_isr(void) {
 800a460:	b508      	push	{r3, lr}

  chTMStartMeasurementX(&ch.kernel_stats.m_crit_isr);
 800a462:	4802      	ldr	r0, [pc, #8]	; (800a46c <_stats_start_measure_crit_isr+0xc>)
 800a464:	f7ff ff44 	bl	800a2f0 <chTMStartMeasurementX>
}
 800a468:	bd08      	pop	{r3, pc}
 800a46a:	bf00      	nop
 800a46c:	200011f8 	.word	0x200011f8

0800a470 <_stats_stop_measure_crit_isr>:

/**
 * @brief   Stops the measurement of an ISR critical zone.
 */
void _stats_stop_measure_crit_isr(void) {
 800a470:	b508      	push	{r3, lr}

  chTMStopMeasurementX(&ch.kernel_stats.m_crit_isr);
 800a472:	4802      	ldr	r0, [pc, #8]	; (800a47c <_stats_stop_measure_crit_isr+0xc>)
 800a474:	f7ff ff4c 	bl	800a310 <chTMStopMeasurementX>
}
 800a478:	bd08      	pop	{r3, pc}
 800a47a:	bf00      	nop
 800a47c:	200011f8 	.word	0x200011f8

0800a480 <port_lock.lto_priv.379>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800a480:	b082      	sub	sp, #8
 800a482:	2320      	movs	r3, #32
 800a484:	9301      	str	r3, [sp, #4]
 800a486:	9b01      	ldr	r3, [sp, #4]
 800a488:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a48c:	b002      	add	sp, #8
 800a48e:	4770      	bx	lr

0800a490 <port_unlock.lto_priv.373>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800a490:	b082      	sub	sp, #8
 800a492:	2300      	movs	r3, #0
 800a494:	9301      	str	r3, [sp, #4]
 800a496:	9b01      	ldr	r3, [sp, #4]
 800a498:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a49c:	b002      	add	sp, #8
 800a49e:	4770      	bx	lr

0800a4a0 <chSysLock.lto_priv.389>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800a4a0:	b508      	push	{r3, lr}

  port_lock();
 800a4a2:	f7ff ffed 	bl	800a480 <port_lock.lto_priv.379>
  _stats_start_measure_crit_thd();
 800a4a6:	f7ff ffcb 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800a4aa:	f001 fc79 	bl	800bda0 <_dbg_check_lock>
}
 800a4ae:	bd08      	pop	{r3, pc}

0800a4b0 <chSysUnlock.lto_priv.385>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800a4b0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800a4b2:	f001 fc8d 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800a4b6:	f7ff ffcb 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800a4ba:	4b09      	ldr	r3, [pc, #36]	; (800a4e0 <chSysUnlock.lto_priv.385+0x30>)
 800a4bc:	681b      	ldr	r3, [r3, #0]
 800a4be:	4a08      	ldr	r2, [pc, #32]	; (800a4e0 <chSysUnlock.lto_priv.385+0x30>)
 800a4c0:	4293      	cmp	r3, r2
 800a4c2:	d00a      	beq.n	800a4da <chSysUnlock.lto_priv.385+0x2a>
 800a4c4:	4b06      	ldr	r3, [pc, #24]	; (800a4e0 <chSysUnlock.lto_priv.385+0x30>)
 800a4c6:	699b      	ldr	r3, [r3, #24]
 800a4c8:	689a      	ldr	r2, [r3, #8]
 800a4ca:	4b05      	ldr	r3, [pc, #20]	; (800a4e0 <chSysUnlock.lto_priv.385+0x30>)
 800a4cc:	681b      	ldr	r3, [r3, #0]
 800a4ce:	689b      	ldr	r3, [r3, #8]
 800a4d0:	429a      	cmp	r2, r3
 800a4d2:	d202      	bcs.n	800a4da <chSysUnlock.lto_priv.385+0x2a>
 800a4d4:	4803      	ldr	r0, [pc, #12]	; (800a4e4 <chSysUnlock.lto_priv.385+0x34>)
 800a4d6:	f001 fb0b 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800a4da:	f7ff ffd9 	bl	800a490 <port_unlock.lto_priv.373>
}
 800a4de:	bd08      	pop	{r3, pc}
 800a4e0:	20000d30 	.word	0x20000d30
 800a4e4:	0800dd10 	.word	0x0800dd10
	...

0800a4f0 <chThdAddRef>:
 * @return              The same thread pointer passed as parameter
 *                      representing the new reference.
 *
 * @api
 */
thread_t *chThdAddRef(thread_t *tp) {
 800a4f0:	b500      	push	{lr}
 800a4f2:	b083      	sub	sp, #12
 800a4f4:	9001      	str	r0, [sp, #4]

  chSysLock();
 800a4f6:	f7ff ffd3 	bl	800a4a0 <chSysLock.lto_priv.389>
  chDbgAssert(tp->p_refs < (trefs_t)255, "too many references");
 800a4fa:	9b01      	ldr	r3, [sp, #4]
 800a4fc:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a500:	2bff      	cmp	r3, #255	; 0xff
 800a502:	d102      	bne.n	800a50a <chThdAddRef+0x1a>
 800a504:	4808      	ldr	r0, [pc, #32]	; (800a528 <chThdAddRef+0x38>)
 800a506:	f001 faf3 	bl	800baf0 <chSysHalt>
  tp->p_refs++;
 800a50a:	9b01      	ldr	r3, [sp, #4]
 800a50c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a510:	3301      	adds	r3, #1
 800a512:	b2da      	uxtb	r2, r3
 800a514:	9b01      	ldr	r3, [sp, #4]
 800a516:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  chSysUnlock();
 800a51a:	f7ff ffc9 	bl	800a4b0 <chSysUnlock.lto_priv.385>

  return tp;
 800a51e:	9b01      	ldr	r3, [sp, #4]
}
 800a520:	4618      	mov	r0, r3
 800a522:	b003      	add	sp, #12
 800a524:	f85d fb04 	ldr.w	pc, [sp], #4
 800a528:	0800dd00 	.word	0x0800dd00
 800a52c:	00000000 	.word	0x00000000

0800a530 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 800a530:	b500      	push	{lr}
 800a532:	b085      	sub	sp, #20
 800a534:	9001      	str	r0, [sp, #4]
  trefs_t refs;

  chSysLock();
 800a536:	f7ff ffb3 	bl	800a4a0 <chSysLock.lto_priv.389>
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
 800a53a:	9b01      	ldr	r3, [sp, #4]
 800a53c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a540:	2b00      	cmp	r3, #0
 800a542:	d102      	bne.n	800a54a <chThdRelease+0x1a>
 800a544:	4825      	ldr	r0, [pc, #148]	; (800a5dc <chThdRelease+0xac>)
 800a546:	f001 fad3 	bl	800baf0 <chSysHalt>
  tp->p_refs--;
 800a54a:	9b01      	ldr	r3, [sp, #4]
 800a54c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a550:	3b01      	subs	r3, #1
 800a552:	b2da      	uxtb	r2, r3
 800a554:	9b01      	ldr	r3, [sp, #4]
 800a556:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  refs = tp->p_refs;
 800a55a:	9b01      	ldr	r3, [sp, #4]
 800a55c:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a560:	f88d 300f 	strb.w	r3, [sp, #15]

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
 800a564:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800a568:	2b00      	cmp	r3, #0
 800a56a:	d131      	bne.n	800a5d0 <chThdRelease+0xa0>
 800a56c:	9b01      	ldr	r3, [sp, #4]
 800a56e:	f893 3020 	ldrb.w	r3, [r3, #32]
 800a572:	2b0f      	cmp	r3, #15
 800a574:	d12c      	bne.n	800a5d0 <chThdRelease+0xa0>
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
 800a576:	9b01      	ldr	r3, [sp, #4]
 800a578:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800a57c:	f003 0303 	and.w	r3, r3, #3
 800a580:	2b01      	cmp	r3, #1
 800a582:	d002      	beq.n	800a58a <chThdRelease+0x5a>
 800a584:	2b02      	cmp	r3, #2
 800a586:	d010      	beq.n	800a5aa <chThdRelease+0x7a>
 800a588:	e022      	b.n	800a5d0 <chThdRelease+0xa0>
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 800a58a:	9b01      	ldr	r3, [sp, #4]
 800a58c:	695b      	ldr	r3, [r3, #20]
 800a58e:	9a01      	ldr	r2, [sp, #4]
 800a590:	6912      	ldr	r2, [r2, #16]
 800a592:	611a      	str	r2, [r3, #16]
 800a594:	9b01      	ldr	r3, [sp, #4]
 800a596:	691b      	ldr	r3, [r3, #16]
 800a598:	9a01      	ldr	r2, [sp, #4]
 800a59a:	6952      	ldr	r2, [r2, #20]
 800a59c:	615a      	str	r2, [r3, #20]
#endif
      chSysUnlock();
 800a59e:	f7ff ff87 	bl	800a4b0 <chSysUnlock.lto_priv.385>
      chHeapFree(tp);
 800a5a2:	9801      	ldr	r0, [sp, #4]
 800a5a4:	f7fe fa04 	bl	80089b0 <chHeapFree>
 800a5a8:	e014      	b.n	800a5d4 <chThdRelease+0xa4>
      return;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 800a5aa:	9b01      	ldr	r3, [sp, #4]
 800a5ac:	695b      	ldr	r3, [r3, #20]
 800a5ae:	9a01      	ldr	r2, [sp, #4]
 800a5b0:	6912      	ldr	r2, [r2, #16]
 800a5b2:	611a      	str	r2, [r3, #16]
 800a5b4:	9b01      	ldr	r3, [sp, #4]
 800a5b6:	691b      	ldr	r3, [r3, #16]
 800a5b8:	9a01      	ldr	r2, [sp, #4]
 800a5ba:	6952      	ldr	r2, [r2, #20]
 800a5bc:	615a      	str	r2, [r3, #20]
#endif
      chSysUnlock();
 800a5be:	f7ff ff77 	bl	800a4b0 <chSysUnlock.lto_priv.385>
      chPoolFree(tp->p_mpool, tp);
 800a5c2:	9b01      	ldr	r3, [sp, #4]
 800a5c4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a5c6:	4618      	mov	r0, r3
 800a5c8:	9901      	ldr	r1, [sp, #4]
 800a5ca:	f7fe fb99 	bl	8008d00 <chPoolFree>
 800a5ce:	e001      	b.n	800a5d4 <chThdRelease+0xa4>
      /* Nothing to do for static threads, those are removed from the
         registry on exit.*/
      break;
    }
  }
  chSysUnlock();
 800a5d0:	f7ff ff6e 	bl	800a4b0 <chSysUnlock.lto_priv.385>
}
 800a5d4:	b005      	add	sp, #20
 800a5d6:	f85d fb04 	ldr.w	pc, [sp], #4
 800a5da:	bf00      	nop
 800a5dc:	0800dd20 	.word	0x0800dd20

0800a5e0 <chThdCreateFromHeap>:
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
                              tprio_t prio, tfunc_t pf, void *arg) {
 800a5e0:	b500      	push	{lr}
 800a5e2:	b089      	sub	sp, #36	; 0x24
 800a5e4:	9005      	str	r0, [sp, #20]
 800a5e6:	9104      	str	r1, [sp, #16]
 800a5e8:	9203      	str	r2, [sp, #12]
 800a5ea:	9302      	str	r3, [sp, #8]
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
 800a5ec:	9805      	ldr	r0, [sp, #20]
 800a5ee:	9904      	ldr	r1, [sp, #16]
 800a5f0:	f7fe f966 	bl	80088c0 <chHeapAlloc>
 800a5f4:	9007      	str	r0, [sp, #28]
  if (wsp == NULL) {
 800a5f6:	9b07      	ldr	r3, [sp, #28]
 800a5f8:	2b00      	cmp	r3, #0
 800a5fa:	d101      	bne.n	800a600 <chThdCreateFromHeap+0x20>
    return NULL;
 800a5fc:	2300      	movs	r3, #0
 800a5fe:	e027      	b.n	800a650 <chThdCreateFromHeap+0x70>
  }

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 800a600:	9b07      	ldr	r3, [sp, #28]
 800a602:	3360      	adds	r3, #96	; 0x60
 800a604:	9807      	ldr	r0, [sp, #28]
 800a606:	4619      	mov	r1, r3
 800a608:	22ff      	movs	r2, #255	; 0xff
 800a60a:	f002 faa9 	bl	800cb60 <_thread_memfill>
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 800a60e:	9b07      	ldr	r3, [sp, #28]
 800a610:	f103 0160 	add.w	r1, r3, #96	; 0x60
 800a614:	9a07      	ldr	r2, [sp, #28]
 800a616:	9b04      	ldr	r3, [sp, #16]
 800a618:	4413      	add	r3, r2
 800a61a:	4608      	mov	r0, r1
 800a61c:	4619      	mov	r1, r3
 800a61e:	2255      	movs	r2, #85	; 0x55
 800a620:	f002 fa9e 	bl	800cb60 <_thread_memfill>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 800a624:	f7ff ff3c 	bl	800a4a0 <chSysLock.lto_priv.389>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 800a628:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a62a:	9300      	str	r3, [sp, #0]
 800a62c:	9807      	ldr	r0, [sp, #28]
 800a62e:	9904      	ldr	r1, [sp, #16]
 800a630:	9a03      	ldr	r2, [sp, #12]
 800a632:	9b02      	ldr	r3, [sp, #8]
 800a634:	f002 faac 	bl	800cb90 <chThdCreateI>
 800a638:	9006      	str	r0, [sp, #24]
  tp->p_flags = CH_FLAG_MODE_HEAP;
 800a63a:	9b06      	ldr	r3, [sp, #24]
 800a63c:	2201      	movs	r2, #1
 800a63e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  chSchWakeupS(tp, MSG_OK);
 800a642:	9806      	ldr	r0, [sp, #24]
 800a644:	2100      	movs	r1, #0
 800a646:	f001 ffcb 	bl	800c5e0 <chSchWakeupS>
  chSysUnlock();
 800a64a:	f7ff ff31 	bl	800a4b0 <chSysUnlock.lto_priv.385>

  return tp;
 800a64e:	9b06      	ldr	r3, [sp, #24]
}
 800a650:	4618      	mov	r0, r3
 800a652:	b009      	add	sp, #36	; 0x24
 800a654:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800a660 <chThdCreateFromMemoryPool>:
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
                                    tfunc_t pf, void *arg) {
 800a660:	b500      	push	{lr}
 800a662:	b089      	sub	sp, #36	; 0x24
 800a664:	9005      	str	r0, [sp, #20]
 800a666:	9104      	str	r1, [sp, #16]
 800a668:	9203      	str	r2, [sp, #12]
 800a66a:	9302      	str	r3, [sp, #8]
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);
 800a66c:	9b05      	ldr	r3, [sp, #20]
 800a66e:	2b00      	cmp	r3, #0
 800a670:	d102      	bne.n	800a678 <chThdCreateFromMemoryPool+0x18>
 800a672:	481f      	ldr	r0, [pc, #124]	; (800a6f0 <chThdCreateFromMemoryPool+0x90>)
 800a674:	f001 fa3c 	bl	800baf0 <chSysHalt>

  wsp = chPoolAlloc(mp);
 800a678:	9805      	ldr	r0, [sp, #20]
 800a67a:	f7fe fb11 	bl	8008ca0 <chPoolAlloc>
 800a67e:	9007      	str	r0, [sp, #28]
  if (wsp == NULL) {
 800a680:	9b07      	ldr	r3, [sp, #28]
 800a682:	2b00      	cmp	r3, #0
 800a684:	d101      	bne.n	800a68a <chThdCreateFromMemoryPool+0x2a>
    return NULL;
 800a686:	2300      	movs	r3, #0
 800a688:	e02d      	b.n	800a6e6 <chThdCreateFromMemoryPool+0x86>
  }

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 800a68a:	9b07      	ldr	r3, [sp, #28]
 800a68c:	3360      	adds	r3, #96	; 0x60
 800a68e:	9807      	ldr	r0, [sp, #28]
 800a690:	4619      	mov	r1, r3
 800a692:	22ff      	movs	r2, #255	; 0xff
 800a694:	f002 fa64 	bl	800cb60 <_thread_memfill>
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 800a698:	9b07      	ldr	r3, [sp, #28]
 800a69a:	f103 0160 	add.w	r1, r3, #96	; 0x60
                  (uint8_t *)wsp + mp->mp_object_size,
 800a69e:	9b05      	ldr	r3, [sp, #20]
 800a6a0:	685b      	ldr	r3, [r3, #4]

#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 800a6a2:	9a07      	ldr	r2, [sp, #28]
 800a6a4:	4413      	add	r3, r2
 800a6a6:	4608      	mov	r0, r1
 800a6a8:	4619      	mov	r1, r3
 800a6aa:	2255      	movs	r2, #85	; 0x55
 800a6ac:	f002 fa58 	bl	800cb60 <_thread_memfill>
                  (uint8_t *)wsp + mp->mp_object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 800a6b0:	f7ff fef6 	bl	800a4a0 <chSysLock.lto_priv.389>
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
 800a6b4:	9b05      	ldr	r3, [sp, #20]
 800a6b6:	685a      	ldr	r2, [r3, #4]
 800a6b8:	9b02      	ldr	r3, [sp, #8]
 800a6ba:	9300      	str	r3, [sp, #0]
 800a6bc:	9807      	ldr	r0, [sp, #28]
 800a6be:	4611      	mov	r1, r2
 800a6c0:	9a04      	ldr	r2, [sp, #16]
 800a6c2:	9b03      	ldr	r3, [sp, #12]
 800a6c4:	f002 fa64 	bl	800cb90 <chThdCreateI>
 800a6c8:	9006      	str	r0, [sp, #24]
  tp->p_flags = CH_FLAG_MODE_MPOOL;
 800a6ca:	9b06      	ldr	r3, [sp, #24]
 800a6cc:	2202      	movs	r2, #2
 800a6ce:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  tp->p_mpool = mp;
 800a6d2:	9b06      	ldr	r3, [sp, #24]
 800a6d4:	9a05      	ldr	r2, [sp, #20]
 800a6d6:	645a      	str	r2, [r3, #68]	; 0x44
  chSchWakeupS(tp, MSG_OK);
 800a6d8:	9806      	ldr	r0, [sp, #24]
 800a6da:	2100      	movs	r1, #0
 800a6dc:	f001 ff80 	bl	800c5e0 <chSchWakeupS>
  chSysUnlock();
 800a6e0:	f7ff fee6 	bl	800a4b0 <chSysUnlock.lto_priv.385>

  return tp;
 800a6e4:	9b06      	ldr	r3, [sp, #24]
}
 800a6e6:	4618      	mov	r0, r3
 800a6e8:	b009      	add	sp, #36	; 0x24
 800a6ea:	f85d fb04 	ldr.w	pc, [sp], #4
 800a6ee:	bf00      	nop
 800a6f0:	0800dd30 	.word	0x0800dd30
	...

0800a700 <port_lock.lto_priv.380>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800a700:	b082      	sub	sp, #8
 800a702:	2320      	movs	r3, #32
 800a704:	9301      	str	r3, [sp, #4]
 800a706:	9b01      	ldr	r3, [sp, #4]
 800a708:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a70c:	b002      	add	sp, #8
 800a70e:	4770      	bx	lr

0800a710 <port_unlock.lto_priv.374>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800a710:	b082      	sub	sp, #8
 800a712:	2300      	movs	r3, #0
 800a714:	9301      	str	r3, [sp, #4]
 800a716:	9b01      	ldr	r3, [sp, #4]
 800a718:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a71c:	b002      	add	sp, #8
 800a71e:	4770      	bx	lr

0800a720 <chSysLock.lto_priv.390>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800a720:	b508      	push	{r3, lr}

  port_lock();
 800a722:	f7ff ffed 	bl	800a700 <port_lock.lto_priv.380>
  _stats_start_measure_crit_thd();
 800a726:	f7ff fe8b 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800a72a:	f001 fb39 	bl	800bda0 <_dbg_check_lock>
}
 800a72e:	bd08      	pop	{r3, pc}

0800a730 <chSysUnlock.lto_priv.386>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800a730:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800a732:	f001 fb4d 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800a736:	f7ff fe8b 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800a73a:	4b09      	ldr	r3, [pc, #36]	; (800a760 <chSysUnlock.lto_priv.386+0x30>)
 800a73c:	681b      	ldr	r3, [r3, #0]
 800a73e:	4a08      	ldr	r2, [pc, #32]	; (800a760 <chSysUnlock.lto_priv.386+0x30>)
 800a740:	4293      	cmp	r3, r2
 800a742:	d00a      	beq.n	800a75a <chSysUnlock.lto_priv.386+0x2a>
 800a744:	4b06      	ldr	r3, [pc, #24]	; (800a760 <chSysUnlock.lto_priv.386+0x30>)
 800a746:	699b      	ldr	r3, [r3, #24]
 800a748:	689a      	ldr	r2, [r3, #8]
 800a74a:	4b05      	ldr	r3, [pc, #20]	; (800a760 <chSysUnlock.lto_priv.386+0x30>)
 800a74c:	681b      	ldr	r3, [r3, #0]
 800a74e:	689b      	ldr	r3, [r3, #8]
 800a750:	429a      	cmp	r2, r3
 800a752:	d202      	bcs.n	800a75a <chSysUnlock.lto_priv.386+0x2a>
 800a754:	4803      	ldr	r0, [pc, #12]	; (800a764 <chSysUnlock.lto_priv.386+0x34>)
 800a756:	f001 f9cb 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800a75a:	f7ff ffd9 	bl	800a710 <port_unlock.lto_priv.374>
}
 800a75e:	bd08      	pop	{r3, pc}
 800a760:	20000d30 	.word	0x20000d30
 800a764:	0800dd70 	.word	0x0800dd70
	...

0800a770 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 800a770:	b500      	push	{lr}
 800a772:	b083      	sub	sp, #12
  thread_t *tp;

  chSysLock();
 800a774:	f7ff ffd4 	bl	800a720 <chSysLock.lto_priv.390>
  tp = ch.rlist.r_newer;
 800a778:	4b08      	ldr	r3, [pc, #32]	; (800a79c <chRegFirstThread+0x2c>)
 800a77a:	691b      	ldr	r3, [r3, #16]
 800a77c:	9301      	str	r3, [sp, #4]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs++;
 800a77e:	9b01      	ldr	r3, [sp, #4]
 800a780:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a784:	3301      	adds	r3, #1
 800a786:	b2da      	uxtb	r2, r3
 800a788:	9b01      	ldr	r3, [sp, #4]
 800a78a:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
#endif
  chSysUnlock();
 800a78e:	f7ff ffcf 	bl	800a730 <chSysUnlock.lto_priv.386>

  return tp;
 800a792:	9b01      	ldr	r3, [sp, #4]
}
 800a794:	4618      	mov	r0, r3
 800a796:	b003      	add	sp, #12
 800a798:	f85d fb04 	ldr.w	pc, [sp], #4
 800a79c:	20000d30 	.word	0x20000d30

0800a7a0 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 800a7a0:	b500      	push	{lr}
 800a7a2:	b085      	sub	sp, #20
 800a7a4:	9001      	str	r0, [sp, #4]
  thread_t *ntp;

  chSysLock();
 800a7a6:	f7ff ffbb 	bl	800a720 <chSysLock.lto_priv.390>
  ntp = tp->p_newer;
 800a7aa:	9b01      	ldr	r3, [sp, #4]
 800a7ac:	691b      	ldr	r3, [r3, #16]
 800a7ae:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 800a7b0:	9b03      	ldr	r3, [sp, #12]
 800a7b2:	4a10      	ldr	r2, [pc, #64]	; (800a7f4 <chRegNextThread+0x54>)
 800a7b4:	4293      	cmp	r3, r2
 800a7b6:	d102      	bne.n	800a7be <chRegNextThread+0x1e>
  /*lint -restore*/
    ntp = NULL;
 800a7b8:	2300      	movs	r3, #0
 800a7ba:	9303      	str	r3, [sp, #12]
 800a7bc:	e00f      	b.n	800a7de <chRegNextThread+0x3e>
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->p_refs < (trefs_t)255, "too many references");
 800a7be:	9b03      	ldr	r3, [sp, #12]
 800a7c0:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a7c4:	2bff      	cmp	r3, #255	; 0xff
 800a7c6:	d102      	bne.n	800a7ce <chRegNextThread+0x2e>
 800a7c8:	480b      	ldr	r0, [pc, #44]	; (800a7f8 <chRegNextThread+0x58>)
 800a7ca:	f001 f991 	bl	800baf0 <chSysHalt>
    ntp->p_refs++;
 800a7ce:	9b03      	ldr	r3, [sp, #12]
 800a7d0:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800a7d4:	3301      	adds	r3, #1
 800a7d6:	b2da      	uxtb	r2, r3
 800a7d8:	9b03      	ldr	r3, [sp, #12]
 800a7da:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  }
#endif
  chSysUnlock();
 800a7de:	f7ff ffa7 	bl	800a730 <chSysUnlock.lto_priv.386>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 800a7e2:	9801      	ldr	r0, [sp, #4]
 800a7e4:	f7ff fea4 	bl	800a530 <chThdRelease>
#endif

  return ntp;
 800a7e8:	9b03      	ldr	r3, [sp, #12]
}
 800a7ea:	4618      	mov	r0, r3
 800a7ec:	b005      	add	sp, #20
 800a7ee:	f85d fb04 	ldr.w	pc, [sp], #4
 800a7f2:	bf00      	nop
 800a7f4:	20000d30 	.word	0x20000d30
 800a7f8:	0800dd80 	.word	0x0800dd80
 800a7fc:	00000000 	.word	0x00000000

0800a800 <port_lock.lto_priv.381>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800a800:	b082      	sub	sp, #8
 800a802:	2320      	movs	r3, #32
 800a804:	9301      	str	r3, [sp, #4]
 800a806:	9b01      	ldr	r3, [sp, #4]
 800a808:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a80c:	b002      	add	sp, #8
 800a80e:	4770      	bx	lr

0800a810 <port_unlock.lto_priv.375>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800a810:	b082      	sub	sp, #8
 800a812:	2300      	movs	r3, #0
 800a814:	9301      	str	r3, [sp, #4]
 800a816:	9b01      	ldr	r3, [sp, #4]
 800a818:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a81c:	b002      	add	sp, #8
 800a81e:	4770      	bx	lr

0800a820 <queue_init.lto_priv.397>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 800a820:	b082      	sub	sp, #8
 800a822:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 800a824:	9b01      	ldr	r3, [sp, #4]
 800a826:	9a01      	ldr	r2, [sp, #4]
 800a828:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800a82a:	9b01      	ldr	r3, [sp, #4]
 800a82c:	9a01      	ldr	r2, [sp, #4]
 800a82e:	605a      	str	r2, [r3, #4]
}
 800a830:	b002      	add	sp, #8
 800a832:	4770      	bx	lr
	...

0800a840 <queue_isempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
 800a840:	b082      	sub	sp, #8
 800a842:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 800a844:	9b01      	ldr	r3, [sp, #4]
 800a846:	681a      	ldr	r2, [r3, #0]
 800a848:	9b01      	ldr	r3, [sp, #4]
 800a84a:	429a      	cmp	r2, r3
 800a84c:	bf0c      	ite	eq
 800a84e:	2301      	moveq	r3, #1
 800a850:	2300      	movne	r3, #0
 800a852:	b2db      	uxtb	r3, r3
}
 800a854:	4618      	mov	r0, r3
 800a856:	b002      	add	sp, #8
 800a858:	4770      	bx	lr
 800a85a:	bf00      	nop
 800a85c:	0000      	movs	r0, r0
	...

0800a860 <queue_notempty.lto_priv.395>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 800a860:	b082      	sub	sp, #8
 800a862:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800a864:	9b01      	ldr	r3, [sp, #4]
 800a866:	681a      	ldr	r2, [r3, #0]
 800a868:	9b01      	ldr	r3, [sp, #4]
 800a86a:	429a      	cmp	r2, r3
 800a86c:	bf14      	ite	ne
 800a86e:	2301      	movne	r3, #1
 800a870:	2300      	moveq	r3, #0
 800a872:	b2db      	uxtb	r3, r3
}
 800a874:	4618      	mov	r0, r3
 800a876:	b002      	add	sp, #8
 800a878:	4770      	bx	lr
 800a87a:	bf00      	nop
 800a87c:	0000      	movs	r0, r0
	...

0800a880 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 800a880:	b082      	sub	sp, #8
 800a882:	9001      	str	r0, [sp, #4]
 800a884:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 800a886:	9b01      	ldr	r3, [sp, #4]
 800a888:	9a00      	ldr	r2, [sp, #0]
 800a88a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 800a88c:	9b00      	ldr	r3, [sp, #0]
 800a88e:	685a      	ldr	r2, [r3, #4]
 800a890:	9b01      	ldr	r3, [sp, #4]
 800a892:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 800a894:	9b01      	ldr	r3, [sp, #4]
 800a896:	685b      	ldr	r3, [r3, #4]
 800a898:	9a01      	ldr	r2, [sp, #4]
 800a89a:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 800a89c:	9b00      	ldr	r3, [sp, #0]
 800a89e:	9a01      	ldr	r2, [sp, #4]
 800a8a0:	605a      	str	r2, [r3, #4]
}
 800a8a2:	b002      	add	sp, #8
 800a8a4:	4770      	bx	lr
 800a8a6:	bf00      	nop
	...

0800a8b0 <queue_fifo_remove.lto_priv.393>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 800a8b0:	b084      	sub	sp, #16
 800a8b2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 800a8b4:	9b01      	ldr	r3, [sp, #4]
 800a8b6:	681b      	ldr	r3, [r3, #0]
 800a8b8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 800a8ba:	9b03      	ldr	r3, [sp, #12]
 800a8bc:	681a      	ldr	r2, [r3, #0]
 800a8be:	9b01      	ldr	r3, [sp, #4]
 800a8c0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800a8c2:	9b01      	ldr	r3, [sp, #4]
 800a8c4:	681b      	ldr	r3, [r3, #0]
 800a8c6:	9a01      	ldr	r2, [sp, #4]
 800a8c8:	605a      	str	r2, [r3, #4]

  return tp;
 800a8ca:	9b03      	ldr	r3, [sp, #12]
}
 800a8cc:	4618      	mov	r0, r3
 800a8ce:	b004      	add	sp, #16
 800a8d0:	4770      	bx	lr
 800a8d2:	bf00      	nop
	...

0800a8e0 <queue_lifo_remove>:

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
 800a8e0:	b084      	sub	sp, #16
 800a8e2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_prev;
 800a8e4:	9b01      	ldr	r3, [sp, #4]
 800a8e6:	685b      	ldr	r3, [r3, #4]
 800a8e8:	9303      	str	r3, [sp, #12]

  tqp->p_prev = tp->p_prev;
 800a8ea:	9b03      	ldr	r3, [sp, #12]
 800a8ec:	685a      	ldr	r2, [r3, #4]
 800a8ee:	9b01      	ldr	r3, [sp, #4]
 800a8f0:	605a      	str	r2, [r3, #4]
  tqp->p_prev->p_next = (thread_t *)tqp;
 800a8f2:	9b01      	ldr	r3, [sp, #4]
 800a8f4:	685b      	ldr	r3, [r3, #4]
 800a8f6:	9a01      	ldr	r2, [sp, #4]
 800a8f8:	601a      	str	r2, [r3, #0]

  return tp;
 800a8fa:	9b03      	ldr	r3, [sp, #12]
}
 800a8fc:	4618      	mov	r0, r3
 800a8fe:	b004      	add	sp, #16
 800a900:	4770      	bx	lr
 800a902:	bf00      	nop
	...

0800a910 <chSysLock.lto_priv.391>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800a910:	b508      	push	{r3, lr}

  port_lock();
 800a912:	f7ff ff75 	bl	800a800 <port_lock.lto_priv.381>
  _stats_start_measure_crit_thd();
 800a916:	f7ff fd93 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800a91a:	f001 fa41 	bl	800bda0 <_dbg_check_lock>
}
 800a91e:	bd08      	pop	{r3, pc}

0800a920 <chSysUnlock.lto_priv.387>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800a920:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800a922:	f001 fa55 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800a926:	f7ff fd93 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800a92a:	4b09      	ldr	r3, [pc, #36]	; (800a950 <chSysUnlock.lto_priv.387+0x30>)
 800a92c:	681b      	ldr	r3, [r3, #0]
 800a92e:	4a08      	ldr	r2, [pc, #32]	; (800a950 <chSysUnlock.lto_priv.387+0x30>)
 800a930:	4293      	cmp	r3, r2
 800a932:	d00a      	beq.n	800a94a <chSysUnlock.lto_priv.387+0x2a>
 800a934:	4b06      	ldr	r3, [pc, #24]	; (800a950 <chSysUnlock.lto_priv.387+0x30>)
 800a936:	699b      	ldr	r3, [r3, #24]
 800a938:	689a      	ldr	r2, [r3, #8]
 800a93a:	4b05      	ldr	r3, [pc, #20]	; (800a950 <chSysUnlock.lto_priv.387+0x30>)
 800a93c:	681b      	ldr	r3, [r3, #0]
 800a93e:	689b      	ldr	r3, [r3, #8]
 800a940:	429a      	cmp	r2, r3
 800a942:	d202      	bcs.n	800a94a <chSysUnlock.lto_priv.387+0x2a>
 800a944:	4803      	ldr	r0, [pc, #12]	; (800a954 <chSysUnlock.lto_priv.387+0x34>)
 800a946:	f001 f8d3 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800a94a:	f7ff ff61 	bl	800a810 <port_unlock.lto_priv.375>
}
 800a94e:	bd08      	pop	{r3, pc}
 800a950:	20000d30 	.word	0x20000d30
 800a954:	0800dda0 	.word	0x0800dda0
	...

0800a960 <chSemObjectInit>:
 * @param[in] n         initial value of the semaphore counter. Must be
 *                      non-negative.
 *
 * @init
 */
void chSemObjectInit(semaphore_t *sp, cnt_t n) {
 800a960:	b500      	push	{lr}
 800a962:	b083      	sub	sp, #12
 800a964:	9001      	str	r0, [sp, #4]
 800a966:	9100      	str	r1, [sp, #0]

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
 800a968:	9b01      	ldr	r3, [sp, #4]
 800a96a:	2b00      	cmp	r3, #0
 800a96c:	d002      	beq.n	800a974 <chSemObjectInit+0x14>
 800a96e:	9b00      	ldr	r3, [sp, #0]
 800a970:	2b00      	cmp	r3, #0
 800a972:	da02      	bge.n	800a97a <chSemObjectInit+0x1a>
 800a974:	4806      	ldr	r0, [pc, #24]	; (800a990 <chSemObjectInit+0x30>)
 800a976:	f001 f8bb 	bl	800baf0 <chSysHalt>

  queue_init(&sp->s_queue);
 800a97a:	9b01      	ldr	r3, [sp, #4]
 800a97c:	4618      	mov	r0, r3
 800a97e:	f7ff ff4f 	bl	800a820 <queue_init.lto_priv.397>
  sp->s_cnt = n;
 800a982:	9b01      	ldr	r3, [sp, #4]
 800a984:	9a00      	ldr	r2, [sp, #0]
 800a986:	609a      	str	r2, [r3, #8]
}
 800a988:	b003      	add	sp, #12
 800a98a:	f85d fb04 	ldr.w	pc, [sp], #4
 800a98e:	bf00      	nop
 800a990:	0800dd90 	.word	0x0800dd90
	...

0800a9a0 <chSemReset>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {
 800a9a0:	b500      	push	{lr}
 800a9a2:	b083      	sub	sp, #12
 800a9a4:	9001      	str	r0, [sp, #4]
 800a9a6:	9100      	str	r1, [sp, #0]

  chSysLock();
 800a9a8:	f7ff ffb2 	bl	800a910 <chSysLock.lto_priv.391>
  chSemResetI(sp, n);
 800a9ac:	9801      	ldr	r0, [sp, #4]
 800a9ae:	9900      	ldr	r1, [sp, #0]
 800a9b0:	f000 f80e 	bl	800a9d0 <chSemResetI>
  chSchRescheduleS();
 800a9b4:	f001 fe6c 	bl	800c690 <chSchRescheduleS>
  chSysUnlock();
 800a9b8:	f7ff ffb2 	bl	800a920 <chSysUnlock.lto_priv.387>
}
 800a9bc:	b003      	add	sp, #12
 800a9be:	f85d fb04 	ldr.w	pc, [sp], #4
 800a9c2:	bf00      	nop
	...

0800a9d0 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 800a9d0:	b500      	push	{lr}
 800a9d2:	b085      	sub	sp, #20
 800a9d4:	9001      	str	r0, [sp, #4]
 800a9d6:	9100      	str	r1, [sp, #0]
  cnt_t cnt;

  chDbgCheckClassI();
 800a9d8:	f001 fa82 	bl	800bee0 <chDbgCheckClassI>
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
 800a9dc:	9b01      	ldr	r3, [sp, #4]
 800a9de:	2b00      	cmp	r3, #0
 800a9e0:	d002      	beq.n	800a9e8 <chSemResetI+0x18>
 800a9e2:	9b00      	ldr	r3, [sp, #0]
 800a9e4:	2b00      	cmp	r3, #0
 800a9e6:	da02      	bge.n	800a9ee <chSemResetI+0x1e>
 800a9e8:	481e      	ldr	r0, [pc, #120]	; (800aa64 <chSemResetI+0x94>)
 800a9ea:	f001 f881 	bl	800baf0 <chSysHalt>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
 800a9ee:	9b01      	ldr	r3, [sp, #4]
 800a9f0:	689b      	ldr	r3, [r3, #8]
 800a9f2:	2b00      	cmp	r3, #0
 800a9f4:	db09      	blt.n	800aa0a <chSemResetI+0x3a>
 800a9f6:	9b01      	ldr	r3, [sp, #4]
 800a9f8:	4618      	mov	r0, r3
 800a9fa:	f7ff ff21 	bl	800a840 <queue_isempty>
 800a9fe:	4603      	mov	r3, r0
 800aa00:	f083 0301 	eor.w	r3, r3, #1
 800aa04:	b2db      	uxtb	r3, r3
 800aa06:	2b00      	cmp	r3, #0
 800aa08:	d010      	beq.n	800aa2c <chSemResetI+0x5c>
 800aa0a:	9b01      	ldr	r3, [sp, #4]
 800aa0c:	689b      	ldr	r3, [r3, #8]
 800aa0e:	2b00      	cmp	r3, #0
 800aa10:	da09      	bge.n	800aa26 <chSemResetI+0x56>
 800aa12:	9b01      	ldr	r3, [sp, #4]
 800aa14:	4618      	mov	r0, r3
 800aa16:	f7ff ff23 	bl	800a860 <queue_notempty.lto_priv.395>
 800aa1a:	4603      	mov	r3, r0
 800aa1c:	f083 0301 	eor.w	r3, r3, #1
 800aa20:	b2db      	uxtb	r3, r3
 800aa22:	2b00      	cmp	r3, #0
 800aa24:	d002      	beq.n	800aa2c <chSemResetI+0x5c>
 800aa26:	480f      	ldr	r0, [pc, #60]	; (800aa64 <chSemResetI+0x94>)
 800aa28:	f001 f862 	bl	800baf0 <chSysHalt>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
 800aa2c:	9b01      	ldr	r3, [sp, #4]
 800aa2e:	689b      	ldr	r3, [r3, #8]
 800aa30:	9303      	str	r3, [sp, #12]
  sp->s_cnt = n;
 800aa32:	9b01      	ldr	r3, [sp, #4]
 800aa34:	9a00      	ldr	r2, [sp, #0]
 800aa36:	609a      	str	r2, [r3, #8]
 800aa38:	e00b      	b.n	800aa52 <chSemResetI+0x82>
  while (++cnt <= (cnt_t)0) {
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 800aa3a:	9b01      	ldr	r3, [sp, #4]
 800aa3c:	4618      	mov	r0, r3
 800aa3e:	f7ff ff4f 	bl	800a8e0 <queue_lifo_remove>
 800aa42:	4603      	mov	r3, r0
 800aa44:	4618      	mov	r0, r3
 800aa46:	f001 fcd3 	bl	800c3f0 <chSchReadyI>
 800aa4a:	4602      	mov	r2, r0
 800aa4c:	f06f 0301 	mvn.w	r3, #1
 800aa50:	6253      	str	r3, [r2, #36]	; 0x24
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 800aa52:	9b03      	ldr	r3, [sp, #12]
 800aa54:	3301      	adds	r3, #1
 800aa56:	9303      	str	r3, [sp, #12]
 800aa58:	9b03      	ldr	r3, [sp, #12]
 800aa5a:	2b00      	cmp	r3, #0
 800aa5c:	dded      	ble.n	800aa3a <chSemResetI+0x6a>
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
  }
}
 800aa5e:	b005      	add	sp, #20
 800aa60:	f85d fb04 	ldr.w	pc, [sp], #4
 800aa64:	0800ddb0 	.word	0x0800ddb0
	...

0800aa70 <chSemWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
 800aa70:	b500      	push	{lr}
 800aa72:	b085      	sub	sp, #20
 800aa74:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chSysLock();
 800aa76:	f7ff ff4b 	bl	800a910 <chSysLock.lto_priv.391>
  msg = chSemWaitS(sp);
 800aa7a:	9801      	ldr	r0, [sp, #4]
 800aa7c:	f000 f808 	bl	800aa90 <chSemWaitS>
 800aa80:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 800aa82:	f7ff ff4d 	bl	800a920 <chSysUnlock.lto_priv.387>

  return msg;
 800aa86:	9b03      	ldr	r3, [sp, #12]
}
 800aa88:	4618      	mov	r0, r3
 800aa8a:	b005      	add	sp, #20
 800aa8c:	f85d fb04 	ldr.w	pc, [sp], #4

0800aa90 <chSemWaitS>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @sclass
 */
msg_t chSemWaitS(semaphore_t *sp) {
 800aa90:	b500      	push	{lr}
 800aa92:	b083      	sub	sp, #12
 800aa94:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 800aa96:	f001 fa3b 	bl	800bf10 <chDbgCheckClassS>
  chDbgCheck(sp != NULL);
 800aa9a:	9b01      	ldr	r3, [sp, #4]
 800aa9c:	2b00      	cmp	r3, #0
 800aa9e:	d102      	bne.n	800aaa6 <chSemWaitS+0x16>
 800aaa0:	4820      	ldr	r0, [pc, #128]	; (800ab24 <chSemWaitS+0x94>)
 800aaa2:	f001 f825 	bl	800baf0 <chSysHalt>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
 800aaa6:	9b01      	ldr	r3, [sp, #4]
 800aaa8:	689b      	ldr	r3, [r3, #8]
 800aaaa:	2b00      	cmp	r3, #0
 800aaac:	db09      	blt.n	800aac2 <chSemWaitS+0x32>
 800aaae:	9b01      	ldr	r3, [sp, #4]
 800aab0:	4618      	mov	r0, r3
 800aab2:	f7ff fec5 	bl	800a840 <queue_isempty>
 800aab6:	4603      	mov	r3, r0
 800aab8:	f083 0301 	eor.w	r3, r3, #1
 800aabc:	b2db      	uxtb	r3, r3
 800aabe:	2b00      	cmp	r3, #0
 800aac0:	d010      	beq.n	800aae4 <chSemWaitS+0x54>
 800aac2:	9b01      	ldr	r3, [sp, #4]
 800aac4:	689b      	ldr	r3, [r3, #8]
 800aac6:	2b00      	cmp	r3, #0
 800aac8:	da09      	bge.n	800aade <chSemWaitS+0x4e>
 800aaca:	9b01      	ldr	r3, [sp, #4]
 800aacc:	4618      	mov	r0, r3
 800aace:	f7ff fec7 	bl	800a860 <queue_notempty.lto_priv.395>
 800aad2:	4603      	mov	r3, r0
 800aad4:	f083 0301 	eor.w	r3, r3, #1
 800aad8:	b2db      	uxtb	r3, r3
 800aada:	2b00      	cmp	r3, #0
 800aadc:	d002      	beq.n	800aae4 <chSemWaitS+0x54>
 800aade:	4811      	ldr	r0, [pc, #68]	; (800ab24 <chSemWaitS+0x94>)
 800aae0:	f001 f806 	bl	800baf0 <chSysHalt>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 800aae4:	9b01      	ldr	r3, [sp, #4]
 800aae6:	689b      	ldr	r3, [r3, #8]
 800aae8:	1e5a      	subs	r2, r3, #1
 800aaea:	9b01      	ldr	r3, [sp, #4]
 800aaec:	609a      	str	r2, [r3, #8]
 800aaee:	9b01      	ldr	r3, [sp, #4]
 800aaf0:	689b      	ldr	r3, [r3, #8]
 800aaf2:	2b00      	cmp	r3, #0
 800aaf4:	da11      	bge.n	800ab1a <chSemWaitS+0x8a>
    currp->p_u.wtsemp = sp;
 800aaf6:	4b0c      	ldr	r3, [pc, #48]	; (800ab28 <chSemWaitS+0x98>)
 800aaf8:	699b      	ldr	r3, [r3, #24]
 800aafa:	9a01      	ldr	r2, [sp, #4]
 800aafc:	625a      	str	r2, [r3, #36]	; 0x24
    sem_insert(currp, &sp->s_queue);
 800aafe:	4b0a      	ldr	r3, [pc, #40]	; (800ab28 <chSemWaitS+0x98>)
 800ab00:	699a      	ldr	r2, [r3, #24]
 800ab02:	9b01      	ldr	r3, [sp, #4]
 800ab04:	4610      	mov	r0, r2
 800ab06:	4619      	mov	r1, r3
 800ab08:	f7ff feba 	bl	800a880 <queue_insert>
    chSchGoSleepS(CH_STATE_WTSEM);
 800ab0c:	2005      	movs	r0, #5
 800ab0e:	f001 fcaf 	bl	800c470 <chSchGoSleepS>

    return currp->p_u.rdymsg;
 800ab12:	4b05      	ldr	r3, [pc, #20]	; (800ab28 <chSemWaitS+0x98>)
 800ab14:	699b      	ldr	r3, [r3, #24]
 800ab16:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ab18:	e000      	b.n	800ab1c <chSemWaitS+0x8c>
  }

  return MSG_OK;
 800ab1a:	2300      	movs	r3, #0
}
 800ab1c:	4618      	mov	r0, r3
 800ab1e:	b003      	add	sp, #12
 800ab20:	f85d fb04 	ldr.w	pc, [sp], #4
 800ab24:	0800ddc0 	.word	0x0800ddc0
 800ab28:	20000d30 	.word	0x20000d30
 800ab2c:	00000000 	.word	0x00000000

0800ab30 <chSemWaitTimeout>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t time) {
 800ab30:	b500      	push	{lr}
 800ab32:	b085      	sub	sp, #20
 800ab34:	9001      	str	r0, [sp, #4]
 800ab36:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chSysLock();
 800ab38:	f7ff feea 	bl	800a910 <chSysLock.lto_priv.391>
  msg = chSemWaitTimeoutS(sp, time);
 800ab3c:	9801      	ldr	r0, [sp, #4]
 800ab3e:	9900      	ldr	r1, [sp, #0]
 800ab40:	f000 f80e 	bl	800ab60 <chSemWaitTimeoutS>
 800ab44:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 800ab46:	f7ff feeb 	bl	800a920 <chSysUnlock.lto_priv.387>

  return msg;
 800ab4a:	9b03      	ldr	r3, [sp, #12]
}
 800ab4c:	4618      	mov	r0, r3
 800ab4e:	b005      	add	sp, #20
 800ab50:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800ab60 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 800ab60:	b500      	push	{lr}
 800ab62:	b083      	sub	sp, #12
 800ab64:	9001      	str	r0, [sp, #4]
 800ab66:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();
 800ab68:	f001 f9d2 	bl	800bf10 <chDbgCheckClassS>
  chDbgCheck(sp != NULL);
 800ab6c:	9b01      	ldr	r3, [sp, #4]
 800ab6e:	2b00      	cmp	r3, #0
 800ab70:	d102      	bne.n	800ab78 <chSemWaitTimeoutS+0x18>
 800ab72:	4826      	ldr	r0, [pc, #152]	; (800ac0c <chSemWaitTimeoutS+0xac>)
 800ab74:	f000 ffbc 	bl	800baf0 <chSysHalt>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
 800ab78:	9b01      	ldr	r3, [sp, #4]
 800ab7a:	689b      	ldr	r3, [r3, #8]
 800ab7c:	2b00      	cmp	r3, #0
 800ab7e:	db09      	blt.n	800ab94 <chSemWaitTimeoutS+0x34>
 800ab80:	9b01      	ldr	r3, [sp, #4]
 800ab82:	4618      	mov	r0, r3
 800ab84:	f7ff fe5c 	bl	800a840 <queue_isempty>
 800ab88:	4603      	mov	r3, r0
 800ab8a:	f083 0301 	eor.w	r3, r3, #1
 800ab8e:	b2db      	uxtb	r3, r3
 800ab90:	2b00      	cmp	r3, #0
 800ab92:	d010      	beq.n	800abb6 <chSemWaitTimeoutS+0x56>
 800ab94:	9b01      	ldr	r3, [sp, #4]
 800ab96:	689b      	ldr	r3, [r3, #8]
 800ab98:	2b00      	cmp	r3, #0
 800ab9a:	da09      	bge.n	800abb0 <chSemWaitTimeoutS+0x50>
 800ab9c:	9b01      	ldr	r3, [sp, #4]
 800ab9e:	4618      	mov	r0, r3
 800aba0:	f7ff fe5e 	bl	800a860 <queue_notempty.lto_priv.395>
 800aba4:	4603      	mov	r3, r0
 800aba6:	f083 0301 	eor.w	r3, r3, #1
 800abaa:	b2db      	uxtb	r3, r3
 800abac:	2b00      	cmp	r3, #0
 800abae:	d002      	beq.n	800abb6 <chSemWaitTimeoutS+0x56>
 800abb0:	4816      	ldr	r0, [pc, #88]	; (800ac0c <chSemWaitTimeoutS+0xac>)
 800abb2:	f000 ff9d 	bl	800baf0 <chSysHalt>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 800abb6:	9b01      	ldr	r3, [sp, #4]
 800abb8:	689b      	ldr	r3, [r3, #8]
 800abba:	1e5a      	subs	r2, r3, #1
 800abbc:	9b01      	ldr	r3, [sp, #4]
 800abbe:	609a      	str	r2, [r3, #8]
 800abc0:	9b01      	ldr	r3, [sp, #4]
 800abc2:	689b      	ldr	r3, [r3, #8]
 800abc4:	2b00      	cmp	r3, #0
 800abc6:	da1b      	bge.n	800ac00 <chSemWaitTimeoutS+0xa0>
    if (TIME_IMMEDIATE == time) {
 800abc8:	9b00      	ldr	r3, [sp, #0]
 800abca:	2b00      	cmp	r3, #0
 800abcc:	d107      	bne.n	800abde <chSemWaitTimeoutS+0x7e>
      sp->s_cnt++;
 800abce:	9b01      	ldr	r3, [sp, #4]
 800abd0:	689b      	ldr	r3, [r3, #8]
 800abd2:	1c5a      	adds	r2, r3, #1
 800abd4:	9b01      	ldr	r3, [sp, #4]
 800abd6:	609a      	str	r2, [r3, #8]

      return MSG_TIMEOUT;
 800abd8:	f04f 33ff 	mov.w	r3, #4294967295
 800abdc:	e011      	b.n	800ac02 <chSemWaitTimeoutS+0xa2>
    }
    currp->p_u.wtsemp = sp;
 800abde:	4b0c      	ldr	r3, [pc, #48]	; (800ac10 <chSemWaitTimeoutS+0xb0>)
 800abe0:	699b      	ldr	r3, [r3, #24]
 800abe2:	9a01      	ldr	r2, [sp, #4]
 800abe4:	625a      	str	r2, [r3, #36]	; 0x24
    sem_insert(currp, &sp->s_queue);
 800abe6:	4b0a      	ldr	r3, [pc, #40]	; (800ac10 <chSemWaitTimeoutS+0xb0>)
 800abe8:	699a      	ldr	r2, [r3, #24]
 800abea:	9b01      	ldr	r3, [sp, #4]
 800abec:	4610      	mov	r0, r2
 800abee:	4619      	mov	r1, r3
 800abf0:	f7ff fe46 	bl	800a880 <queue_insert>

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 800abf4:	2005      	movs	r0, #5
 800abf6:	9900      	ldr	r1, [sp, #0]
 800abf8:	f001 fcba 	bl	800c570 <chSchGoSleepTimeoutS>
 800abfc:	4603      	mov	r3, r0
 800abfe:	e000      	b.n	800ac02 <chSemWaitTimeoutS+0xa2>
  }

  return MSG_OK;
 800ac00:	2300      	movs	r3, #0
}
 800ac02:	4618      	mov	r0, r3
 800ac04:	b003      	add	sp, #12
 800ac06:	f85d fb04 	ldr.w	pc, [sp], #4
 800ac0a:	bf00      	nop
 800ac0c:	0800ddd0 	.word	0x0800ddd0
 800ac10:	20000d30 	.word	0x20000d30
	...

0800ac20 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 800ac20:	b500      	push	{lr}
 800ac22:	b083      	sub	sp, #12
 800ac24:	9001      	str	r0, [sp, #4]

  chDbgCheck(sp != NULL);
 800ac26:	9b01      	ldr	r3, [sp, #4]
 800ac28:	2b00      	cmp	r3, #0
 800ac2a:	d102      	bne.n	800ac32 <chSemSignal+0x12>
 800ac2c:	481d      	ldr	r0, [pc, #116]	; (800aca4 <chSemSignal+0x84>)
 800ac2e:	f000 ff5f 	bl	800baf0 <chSysHalt>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
 800ac32:	9b01      	ldr	r3, [sp, #4]
 800ac34:	689b      	ldr	r3, [r3, #8]
 800ac36:	2b00      	cmp	r3, #0
 800ac38:	db09      	blt.n	800ac4e <chSemSignal+0x2e>
 800ac3a:	9b01      	ldr	r3, [sp, #4]
 800ac3c:	4618      	mov	r0, r3
 800ac3e:	f7ff fdff 	bl	800a840 <queue_isempty>
 800ac42:	4603      	mov	r3, r0
 800ac44:	f083 0301 	eor.w	r3, r3, #1
 800ac48:	b2db      	uxtb	r3, r3
 800ac4a:	2b00      	cmp	r3, #0
 800ac4c:	d010      	beq.n	800ac70 <chSemSignal+0x50>
 800ac4e:	9b01      	ldr	r3, [sp, #4]
 800ac50:	689b      	ldr	r3, [r3, #8]
 800ac52:	2b00      	cmp	r3, #0
 800ac54:	da09      	bge.n	800ac6a <chSemSignal+0x4a>
 800ac56:	9b01      	ldr	r3, [sp, #4]
 800ac58:	4618      	mov	r0, r3
 800ac5a:	f7ff fe01 	bl	800a860 <queue_notempty.lto_priv.395>
 800ac5e:	4603      	mov	r3, r0
 800ac60:	f083 0301 	eor.w	r3, r3, #1
 800ac64:	b2db      	uxtb	r3, r3
 800ac66:	2b00      	cmp	r3, #0
 800ac68:	d002      	beq.n	800ac70 <chSemSignal+0x50>
 800ac6a:	480e      	ldr	r0, [pc, #56]	; (800aca4 <chSemSignal+0x84>)
 800ac6c:	f000 ff40 	bl	800baf0 <chSysHalt>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  chSysLock();
 800ac70:	f7ff fe4e 	bl	800a910 <chSysLock.lto_priv.391>
  if (++sp->s_cnt <= (cnt_t)0) {
 800ac74:	9b01      	ldr	r3, [sp, #4]
 800ac76:	689b      	ldr	r3, [r3, #8]
 800ac78:	1c5a      	adds	r2, r3, #1
 800ac7a:	9b01      	ldr	r3, [sp, #4]
 800ac7c:	609a      	str	r2, [r3, #8]
 800ac7e:	9b01      	ldr	r3, [sp, #4]
 800ac80:	689b      	ldr	r3, [r3, #8]
 800ac82:	2b00      	cmp	r3, #0
 800ac84:	dc08      	bgt.n	800ac98 <chSemSignal+0x78>
    chSchWakeupS(queue_fifo_remove(&sp->s_queue), MSG_OK);
 800ac86:	9b01      	ldr	r3, [sp, #4]
 800ac88:	4618      	mov	r0, r3
 800ac8a:	f7ff fe11 	bl	800a8b0 <queue_fifo_remove.lto_priv.393>
 800ac8e:	4603      	mov	r3, r0
 800ac90:	4618      	mov	r0, r3
 800ac92:	2100      	movs	r1, #0
 800ac94:	f001 fca4 	bl	800c5e0 <chSchWakeupS>
  }
  chSysUnlock();
 800ac98:	f7ff fe42 	bl	800a920 <chSysUnlock.lto_priv.387>
}
 800ac9c:	b003      	add	sp, #12
 800ac9e:	f85d fb04 	ldr.w	pc, [sp], #4
 800aca2:	bf00      	nop
 800aca4:	0800ddf0 	.word	0x0800ddf0
	...

0800acb0 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
 800acb0:	b500      	push	{lr}
 800acb2:	b085      	sub	sp, #20
 800acb4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800acb6:	f001 f913 	bl	800bee0 <chDbgCheckClassI>
  chDbgCheck(sp != NULL);
 800acba:	9b01      	ldr	r3, [sp, #4]
 800acbc:	2b00      	cmp	r3, #0
 800acbe:	d102      	bne.n	800acc6 <chSemSignalI+0x16>
 800acc0:	481c      	ldr	r0, [pc, #112]	; (800ad34 <chSemSignalI+0x84>)
 800acc2:	f000 ff15 	bl	800baf0 <chSysHalt>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
 800acc6:	9b01      	ldr	r3, [sp, #4]
 800acc8:	689b      	ldr	r3, [r3, #8]
 800acca:	2b00      	cmp	r3, #0
 800accc:	db09      	blt.n	800ace2 <chSemSignalI+0x32>
 800acce:	9b01      	ldr	r3, [sp, #4]
 800acd0:	4618      	mov	r0, r3
 800acd2:	f7ff fdb5 	bl	800a840 <queue_isempty>
 800acd6:	4603      	mov	r3, r0
 800acd8:	f083 0301 	eor.w	r3, r3, #1
 800acdc:	b2db      	uxtb	r3, r3
 800acde:	2b00      	cmp	r3, #0
 800ace0:	d010      	beq.n	800ad04 <chSemSignalI+0x54>
 800ace2:	9b01      	ldr	r3, [sp, #4]
 800ace4:	689b      	ldr	r3, [r3, #8]
 800ace6:	2b00      	cmp	r3, #0
 800ace8:	da09      	bge.n	800acfe <chSemSignalI+0x4e>
 800acea:	9b01      	ldr	r3, [sp, #4]
 800acec:	4618      	mov	r0, r3
 800acee:	f7ff fdb7 	bl	800a860 <queue_notempty.lto_priv.395>
 800acf2:	4603      	mov	r3, r0
 800acf4:	f083 0301 	eor.w	r3, r3, #1
 800acf8:	b2db      	uxtb	r3, r3
 800acfa:	2b00      	cmp	r3, #0
 800acfc:	d002      	beq.n	800ad04 <chSemSignalI+0x54>
 800acfe:	480d      	ldr	r0, [pc, #52]	; (800ad34 <chSemSignalI+0x84>)
 800ad00:	f000 fef6 	bl	800baf0 <chSysHalt>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= (cnt_t)0) {
 800ad04:	9b01      	ldr	r3, [sp, #4]
 800ad06:	689b      	ldr	r3, [r3, #8]
 800ad08:	1c5a      	adds	r2, r3, #1
 800ad0a:	9b01      	ldr	r3, [sp, #4]
 800ad0c:	609a      	str	r2, [r3, #8]
 800ad0e:	9b01      	ldr	r3, [sp, #4]
 800ad10:	689b      	ldr	r3, [r3, #8]
 800ad12:	2b00      	cmp	r3, #0
 800ad14:	dc0a      	bgt.n	800ad2c <chSemSignalI+0x7c>
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
 800ad16:	9b01      	ldr	r3, [sp, #4]
 800ad18:	4618      	mov	r0, r3
 800ad1a:	f7ff fdc9 	bl	800a8b0 <queue_fifo_remove.lto_priv.393>
 800ad1e:	9003      	str	r0, [sp, #12]
    tp->p_u.rdymsg = MSG_OK;
 800ad20:	9b03      	ldr	r3, [sp, #12]
 800ad22:	2200      	movs	r2, #0
 800ad24:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800ad26:	9803      	ldr	r0, [sp, #12]
 800ad28:	f001 fb62 	bl	800c3f0 <chSchReadyI>
  }
}
 800ad2c:	b005      	add	sp, #20
 800ad2e:	f85d fb04 	ldr.w	pc, [sp], #4
 800ad32:	bf00      	nop
 800ad34:	0800de00 	.word	0x0800de00
	...

0800ad40 <chSemAddCounterI>:
 * @param[in] n         value to be added to the semaphore counter. The value
 *                      must be positive.
 *
 * @iclass
 */
void chSemAddCounterI(semaphore_t *sp, cnt_t n) {
 800ad40:	b500      	push	{lr}
 800ad42:	b083      	sub	sp, #12
 800ad44:	9001      	str	r0, [sp, #4]
 800ad46:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
 800ad48:	f001 f8ca 	bl	800bee0 <chDbgCheckClassI>
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
 800ad4c:	9b01      	ldr	r3, [sp, #4]
 800ad4e:	2b00      	cmp	r3, #0
 800ad50:	d002      	beq.n	800ad58 <chSemAddCounterI+0x18>
 800ad52:	9b00      	ldr	r3, [sp, #0]
 800ad54:	2b00      	cmp	r3, #0
 800ad56:	dc02      	bgt.n	800ad5e <chSemAddCounterI+0x1e>
 800ad58:	481f      	ldr	r0, [pc, #124]	; (800add8 <chSemAddCounterI+0x98>)
 800ad5a:	f000 fec9 	bl	800baf0 <chSysHalt>
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
 800ad5e:	9b01      	ldr	r3, [sp, #4]
 800ad60:	689b      	ldr	r3, [r3, #8]
 800ad62:	2b00      	cmp	r3, #0
 800ad64:	db09      	blt.n	800ad7a <chSemAddCounterI+0x3a>
 800ad66:	9b01      	ldr	r3, [sp, #4]
 800ad68:	4618      	mov	r0, r3
 800ad6a:	f7ff fd69 	bl	800a840 <queue_isempty>
 800ad6e:	4603      	mov	r3, r0
 800ad70:	f083 0301 	eor.w	r3, r3, #1
 800ad74:	b2db      	uxtb	r3, r3
 800ad76:	2b00      	cmp	r3, #0
 800ad78:	d028      	beq.n	800adcc <chSemAddCounterI+0x8c>
 800ad7a:	9b01      	ldr	r3, [sp, #4]
 800ad7c:	689b      	ldr	r3, [r3, #8]
 800ad7e:	2b00      	cmp	r3, #0
 800ad80:	da09      	bge.n	800ad96 <chSemAddCounterI+0x56>
 800ad82:	9b01      	ldr	r3, [sp, #4]
 800ad84:	4618      	mov	r0, r3
 800ad86:	f7ff fd6b 	bl	800a860 <queue_notempty.lto_priv.395>
 800ad8a:	4603      	mov	r3, r0
 800ad8c:	f083 0301 	eor.w	r3, r3, #1
 800ad90:	b2db      	uxtb	r3, r3
 800ad92:	2b00      	cmp	r3, #0
 800ad94:	d01a      	beq.n	800adcc <chSemAddCounterI+0x8c>
 800ad96:	4810      	ldr	r0, [pc, #64]	; (800add8 <chSemAddCounterI+0x98>)
 800ad98:	f000 feaa 	bl	800baf0 <chSysHalt>
 800ad9c:	e016      	b.n	800adcc <chSemAddCounterI+0x8c>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
    if (++sp->s_cnt <= (cnt_t)0) {
 800ad9e:	9b01      	ldr	r3, [sp, #4]
 800ada0:	689b      	ldr	r3, [r3, #8]
 800ada2:	1c5a      	adds	r2, r3, #1
 800ada4:	9b01      	ldr	r3, [sp, #4]
 800ada6:	609a      	str	r2, [r3, #8]
 800ada8:	9b01      	ldr	r3, [sp, #4]
 800adaa:	689b      	ldr	r3, [r3, #8]
 800adac:	2b00      	cmp	r3, #0
 800adae:	dc0a      	bgt.n	800adc6 <chSemAddCounterI+0x86>
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 800adb0:	9b01      	ldr	r3, [sp, #4]
 800adb2:	4618      	mov	r0, r3
 800adb4:	f7ff fd7c 	bl	800a8b0 <queue_fifo_remove.lto_priv.393>
 800adb8:	4603      	mov	r3, r0
 800adba:	4618      	mov	r0, r3
 800adbc:	f001 fb18 	bl	800c3f0 <chSchReadyI>
 800adc0:	4602      	mov	r2, r0
 800adc2:	2300      	movs	r3, #0
 800adc4:	6253      	str	r3, [r2, #36]	; 0x24
    }
    n--;
 800adc6:	9b00      	ldr	r3, [sp, #0]
 800adc8:	3b01      	subs	r3, #1
 800adca:	9300      	str	r3, [sp, #0]
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 800adcc:	9b00      	ldr	r3, [sp, #0]
 800adce:	2b00      	cmp	r3, #0
 800add0:	dce5      	bgt.n	800ad9e <chSemAddCounterI+0x5e>
    if (++sp->s_cnt <= (cnt_t)0) {
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
    }
    n--;
  }
}
 800add2:	b003      	add	sp, #12
 800add4:	f85d fb04 	ldr.w	pc, [sp], #4
 800add8:	0800de10 	.word	0x0800de10
 800addc:	00000000 	.word	0x00000000

0800ade0 <chSemSignalWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 800ade0:	b500      	push	{lr}
 800ade2:	b085      	sub	sp, #20
 800ade4:	9001      	str	r0, [sp, #4]
 800ade6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chDbgCheck((sps != NULL) && (spw != NULL));
 800ade8:	9b01      	ldr	r3, [sp, #4]
 800adea:	2b00      	cmp	r3, #0
 800adec:	d002      	beq.n	800adf4 <chSemSignalWait+0x14>
 800adee:	9b00      	ldr	r3, [sp, #0]
 800adf0:	2b00      	cmp	r3, #0
 800adf2:	d102      	bne.n	800adfa <chSemSignalWait+0x1a>
 800adf4:	483e      	ldr	r0, [pc, #248]	; (800aef0 <chSemSignalWait+0x110>)
 800adf6:	f000 fe7b 	bl	800baf0 <chSysHalt>
  chDbgAssert(((sps->s_cnt >= (cnt_t)0) && queue_isempty(&sps->s_queue)) ||
 800adfa:	9b01      	ldr	r3, [sp, #4]
 800adfc:	689b      	ldr	r3, [r3, #8]
 800adfe:	2b00      	cmp	r3, #0
 800ae00:	db09      	blt.n	800ae16 <chSemSignalWait+0x36>
 800ae02:	9b01      	ldr	r3, [sp, #4]
 800ae04:	4618      	mov	r0, r3
 800ae06:	f7ff fd1b 	bl	800a840 <queue_isempty>
 800ae0a:	4603      	mov	r3, r0
 800ae0c:	f083 0301 	eor.w	r3, r3, #1
 800ae10:	b2db      	uxtb	r3, r3
 800ae12:	2b00      	cmp	r3, #0
 800ae14:	d010      	beq.n	800ae38 <chSemSignalWait+0x58>
 800ae16:	9b01      	ldr	r3, [sp, #4]
 800ae18:	689b      	ldr	r3, [r3, #8]
 800ae1a:	2b00      	cmp	r3, #0
 800ae1c:	da09      	bge.n	800ae32 <chSemSignalWait+0x52>
 800ae1e:	9b01      	ldr	r3, [sp, #4]
 800ae20:	4618      	mov	r0, r3
 800ae22:	f7ff fd1d 	bl	800a860 <queue_notempty.lto_priv.395>
 800ae26:	4603      	mov	r3, r0
 800ae28:	f083 0301 	eor.w	r3, r3, #1
 800ae2c:	b2db      	uxtb	r3, r3
 800ae2e:	2b00      	cmp	r3, #0
 800ae30:	d002      	beq.n	800ae38 <chSemSignalWait+0x58>
 800ae32:	482f      	ldr	r0, [pc, #188]	; (800aef0 <chSemSignalWait+0x110>)
 800ae34:	f000 fe5c 	bl	800baf0 <chSysHalt>
              ((sps->s_cnt < (cnt_t)0) && queue_notempty(&sps->s_queue)),
              "inconsistent semaphore");
  chDbgAssert(((spw->s_cnt >= (cnt_t)0) && queue_isempty(&spw->s_queue)) ||
 800ae38:	9b00      	ldr	r3, [sp, #0]
 800ae3a:	689b      	ldr	r3, [r3, #8]
 800ae3c:	2b00      	cmp	r3, #0
 800ae3e:	db09      	blt.n	800ae54 <chSemSignalWait+0x74>
 800ae40:	9b00      	ldr	r3, [sp, #0]
 800ae42:	4618      	mov	r0, r3
 800ae44:	f7ff fcfc 	bl	800a840 <queue_isempty>
 800ae48:	4603      	mov	r3, r0
 800ae4a:	f083 0301 	eor.w	r3, r3, #1
 800ae4e:	b2db      	uxtb	r3, r3
 800ae50:	2b00      	cmp	r3, #0
 800ae52:	d010      	beq.n	800ae76 <chSemSignalWait+0x96>
 800ae54:	9b00      	ldr	r3, [sp, #0]
 800ae56:	689b      	ldr	r3, [r3, #8]
 800ae58:	2b00      	cmp	r3, #0
 800ae5a:	da09      	bge.n	800ae70 <chSemSignalWait+0x90>
 800ae5c:	9b00      	ldr	r3, [sp, #0]
 800ae5e:	4618      	mov	r0, r3
 800ae60:	f7ff fcfe 	bl	800a860 <queue_notempty.lto_priv.395>
 800ae64:	4603      	mov	r3, r0
 800ae66:	f083 0301 	eor.w	r3, r3, #1
 800ae6a:	b2db      	uxtb	r3, r3
 800ae6c:	2b00      	cmp	r3, #0
 800ae6e:	d002      	beq.n	800ae76 <chSemSignalWait+0x96>
 800ae70:	481f      	ldr	r0, [pc, #124]	; (800aef0 <chSemSignalWait+0x110>)
 800ae72:	f000 fe3d 	bl	800baf0 <chSysHalt>
              ((spw->s_cnt < (cnt_t)0) && queue_notempty(&spw->s_queue)),
              "inconsistent semaphore");

  chSysLock();
 800ae76:	f7ff fd4b 	bl	800a910 <chSysLock.lto_priv.391>
  if (++sps->s_cnt <= (cnt_t)0) {
 800ae7a:	9b01      	ldr	r3, [sp, #4]
 800ae7c:	689b      	ldr	r3, [r3, #8]
 800ae7e:	1c5a      	adds	r2, r3, #1
 800ae80:	9b01      	ldr	r3, [sp, #4]
 800ae82:	609a      	str	r2, [r3, #8]
 800ae84:	9b01      	ldr	r3, [sp, #4]
 800ae86:	689b      	ldr	r3, [r3, #8]
 800ae88:	2b00      	cmp	r3, #0
 800ae8a:	dc0a      	bgt.n	800aea2 <chSemSignalWait+0xc2>
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
 800ae8c:	9b01      	ldr	r3, [sp, #4]
 800ae8e:	4618      	mov	r0, r3
 800ae90:	f7ff fd0e 	bl	800a8b0 <queue_fifo_remove.lto_priv.393>
 800ae94:	4603      	mov	r3, r0
 800ae96:	4618      	mov	r0, r3
 800ae98:	f001 faaa 	bl	800c3f0 <chSchReadyI>
 800ae9c:	4602      	mov	r2, r0
 800ae9e:	2300      	movs	r3, #0
 800aea0:	6253      	str	r3, [r2, #36]	; 0x24
  }
  if (--spw->s_cnt < (cnt_t)0) {
 800aea2:	9b00      	ldr	r3, [sp, #0]
 800aea4:	689b      	ldr	r3, [r3, #8]
 800aea6:	1e5a      	subs	r2, r3, #1
 800aea8:	9b00      	ldr	r3, [sp, #0]
 800aeaa:	609a      	str	r2, [r3, #8]
 800aeac:	9b00      	ldr	r3, [sp, #0]
 800aeae:	689b      	ldr	r3, [r3, #8]
 800aeb0:	2b00      	cmp	r3, #0
 800aeb2:	da11      	bge.n	800aed8 <chSemSignalWait+0xf8>
    thread_t *ctp = currp;
 800aeb4:	4b0f      	ldr	r3, [pc, #60]	; (800aef4 <chSemSignalWait+0x114>)
 800aeb6:	699b      	ldr	r3, [r3, #24]
 800aeb8:	9302      	str	r3, [sp, #8]
    sem_insert(ctp, &spw->s_queue);
 800aeba:	9b00      	ldr	r3, [sp, #0]
 800aebc:	9802      	ldr	r0, [sp, #8]
 800aebe:	4619      	mov	r1, r3
 800aec0:	f7ff fcde 	bl	800a880 <queue_insert>
    ctp->p_u.wtsemp = spw;
 800aec4:	9b02      	ldr	r3, [sp, #8]
 800aec6:	9a00      	ldr	r2, [sp, #0]
 800aec8:	625a      	str	r2, [r3, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTSEM);
 800aeca:	2005      	movs	r0, #5
 800aecc:	f001 fad0 	bl	800c470 <chSchGoSleepS>
    msg = ctp->p_u.rdymsg;
 800aed0:	9b02      	ldr	r3, [sp, #8]
 800aed2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800aed4:	9303      	str	r3, [sp, #12]
 800aed6:	e003      	b.n	800aee0 <chSemSignalWait+0x100>
  }
  else {
    chSchRescheduleS();
 800aed8:	f001 fbda 	bl	800c690 <chSchRescheduleS>
    msg = MSG_OK;
 800aedc:	2300      	movs	r3, #0
 800aede:	9303      	str	r3, [sp, #12]
  }
  chSysUnlock();
 800aee0:	f7ff fd1e 	bl	800a920 <chSysUnlock.lto_priv.387>

  return msg;
 800aee4:	9b03      	ldr	r3, [sp, #12]
}
 800aee6:	4618      	mov	r0, r3
 800aee8:	b005      	add	sp, #20
 800aeea:	f85d fb04 	ldr.w	pc, [sp], #4
 800aeee:	bf00      	nop
 800aef0:	0800de30 	.word	0x0800de30
 800aef4:	20000d30 	.word	0x20000d30
	...

0800af00 <port_lock.lto_priv.382>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800af00:	b082      	sub	sp, #8
 800af02:	2320      	movs	r3, #32
 800af04:	9301      	str	r3, [sp, #4]
 800af06:	9b01      	ldr	r3, [sp, #4]
 800af08:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800af0c:	b002      	add	sp, #8
 800af0e:	4770      	bx	lr

0800af10 <port_unlock.lto_priv.376>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800af10:	b082      	sub	sp, #8
 800af12:	2300      	movs	r3, #0
 800af14:	9301      	str	r3, [sp, #4]
 800af16:	9b01      	ldr	r3, [sp, #4]
 800af18:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800af1c:	b002      	add	sp, #8
 800af1e:	4770      	bx	lr

0800af20 <queue_init.lto_priv.398>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 800af20:	b082      	sub	sp, #8
 800af22:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 800af24:	9b01      	ldr	r3, [sp, #4]
 800af26:	9a01      	ldr	r2, [sp, #4]
 800af28:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800af2a:	9b01      	ldr	r3, [sp, #4]
 800af2c:	9a01      	ldr	r2, [sp, #4]
 800af2e:	605a      	str	r2, [r3, #4]
}
 800af30:	b002      	add	sp, #8
 800af32:	4770      	bx	lr
	...

0800af40 <queue_notempty.lto_priv.396>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 800af40:	b082      	sub	sp, #8
 800af42:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800af44:	9b01      	ldr	r3, [sp, #4]
 800af46:	681a      	ldr	r2, [r3, #0]
 800af48:	9b01      	ldr	r3, [sp, #4]
 800af4a:	429a      	cmp	r2, r3
 800af4c:	bf14      	ite	ne
 800af4e:	2301      	movne	r3, #1
 800af50:	2300      	moveq	r3, #0
 800af52:	b2db      	uxtb	r3, r3
}
 800af54:	4618      	mov	r0, r3
 800af56:	b002      	add	sp, #8
 800af58:	4770      	bx	lr
 800af5a:	bf00      	nop
 800af5c:	0000      	movs	r0, r0
	...

0800af60 <queue_prio_insert>:
  tlp->p_next = tp->p_next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 800af60:	b084      	sub	sp, #16
 800af62:	9001      	str	r0, [sp, #4]
 800af64:	9100      	str	r1, [sp, #0]

  thread_t *cp = (thread_t *)tqp;
 800af66:	9b00      	ldr	r3, [sp, #0]
 800af68:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 800af6a:	9b03      	ldr	r3, [sp, #12]
 800af6c:	681b      	ldr	r3, [r3, #0]
 800af6e:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800af70:	9a03      	ldr	r2, [sp, #12]
 800af72:	9b00      	ldr	r3, [sp, #0]
 800af74:	429a      	cmp	r2, r3
 800af76:	d005      	beq.n	800af84 <queue_prio_insert+0x24>
 800af78:	9b03      	ldr	r3, [sp, #12]
 800af7a:	689a      	ldr	r2, [r3, #8]
 800af7c:	9b01      	ldr	r3, [sp, #4]
 800af7e:	689b      	ldr	r3, [r3, #8]
 800af80:	429a      	cmp	r2, r3
 800af82:	d2f2      	bcs.n	800af6a <queue_prio_insert+0xa>
  tp->p_next = cp;
 800af84:	9b01      	ldr	r3, [sp, #4]
 800af86:	9a03      	ldr	r2, [sp, #12]
 800af88:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 800af8a:	9b03      	ldr	r3, [sp, #12]
 800af8c:	685a      	ldr	r2, [r3, #4]
 800af8e:	9b01      	ldr	r3, [sp, #4]
 800af90:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 800af92:	9b01      	ldr	r3, [sp, #4]
 800af94:	685b      	ldr	r3, [r3, #4]
 800af96:	9a01      	ldr	r2, [sp, #4]
 800af98:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 800af9a:	9b03      	ldr	r3, [sp, #12]
 800af9c:	9a01      	ldr	r2, [sp, #4]
 800af9e:	605a      	str	r2, [r3, #4]
}
 800afa0:	b004      	add	sp, #16
 800afa2:	4770      	bx	lr
	...

0800afb0 <queue_fifo_remove.lto_priv.394>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 800afb0:	b084      	sub	sp, #16
 800afb2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 800afb4:	9b01      	ldr	r3, [sp, #4]
 800afb6:	681b      	ldr	r3, [r3, #0]
 800afb8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 800afba:	9b03      	ldr	r3, [sp, #12]
 800afbc:	681a      	ldr	r2, [r3, #0]
 800afbe:	9b01      	ldr	r3, [sp, #4]
 800afc0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800afc2:	9b01      	ldr	r3, [sp, #4]
 800afc4:	681b      	ldr	r3, [r3, #0]
 800afc6:	9a01      	ldr	r2, [sp, #4]
 800afc8:	605a      	str	r2, [r3, #4]

  return tp;
 800afca:	9b03      	ldr	r3, [sp, #12]
}
 800afcc:	4618      	mov	r0, r3
 800afce:	b004      	add	sp, #16
 800afd0:	4770      	bx	lr
 800afd2:	bf00      	nop
	...

0800afe0 <queue_dequeue>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 800afe0:	b082      	sub	sp, #8
 800afe2:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 800afe4:	9b01      	ldr	r3, [sp, #4]
 800afe6:	685b      	ldr	r3, [r3, #4]
 800afe8:	9a01      	ldr	r2, [sp, #4]
 800afea:	6812      	ldr	r2, [r2, #0]
 800afec:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 800afee:	9b01      	ldr	r3, [sp, #4]
 800aff0:	681b      	ldr	r3, [r3, #0]
 800aff2:	9a01      	ldr	r2, [sp, #4]
 800aff4:	6852      	ldr	r2, [r2, #4]
 800aff6:	605a      	str	r2, [r3, #4]

  return tp;
 800aff8:	9b01      	ldr	r3, [sp, #4]
}
 800affa:	4618      	mov	r0, r3
 800affc:	b002      	add	sp, #8
 800affe:	4770      	bx	lr

0800b000 <chSysLock.lto_priv.392>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800b000:	b508      	push	{r3, lr}

  port_lock();
 800b002:	f7ff ff7d 	bl	800af00 <port_lock.lto_priv.382>
  _stats_start_measure_crit_thd();
 800b006:	f7ff fa1b 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800b00a:	f000 fec9 	bl	800bda0 <_dbg_check_lock>
}
 800b00e:	bd08      	pop	{r3, pc}

0800b010 <chSysUnlock.lto_priv.388>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800b010:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800b012:	f000 fedd 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800b016:	f7ff fa1b 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800b01a:	4b09      	ldr	r3, [pc, #36]	; (800b040 <chSysUnlock.lto_priv.388+0x30>)
 800b01c:	681b      	ldr	r3, [r3, #0]
 800b01e:	4a08      	ldr	r2, [pc, #32]	; (800b040 <chSysUnlock.lto_priv.388+0x30>)
 800b020:	4293      	cmp	r3, r2
 800b022:	d00a      	beq.n	800b03a <chSysUnlock.lto_priv.388+0x2a>
 800b024:	4b06      	ldr	r3, [pc, #24]	; (800b040 <chSysUnlock.lto_priv.388+0x30>)
 800b026:	699b      	ldr	r3, [r3, #24]
 800b028:	689a      	ldr	r2, [r3, #8]
 800b02a:	4b05      	ldr	r3, [pc, #20]	; (800b040 <chSysUnlock.lto_priv.388+0x30>)
 800b02c:	681b      	ldr	r3, [r3, #0]
 800b02e:	689b      	ldr	r3, [r3, #8]
 800b030:	429a      	cmp	r2, r3
 800b032:	d202      	bcs.n	800b03a <chSysUnlock.lto_priv.388+0x2a>
 800b034:	4803      	ldr	r0, [pc, #12]	; (800b044 <chSysUnlock.lto_priv.388+0x34>)
 800b036:	f000 fd5b 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800b03a:	f7ff ff69 	bl	800af10 <port_unlock.lto_priv.376>
}
 800b03e:	bd08      	pop	{r3, pc}
 800b040:	20000d30 	.word	0x20000d30
 800b044:	0800de50 	.word	0x0800de50
	...

0800b050 <chMtxQueueNotEmptyS>:
 * @return              The mutex queue status.
 *
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 800b050:	b500      	push	{lr}
 800b052:	b083      	sub	sp, #12
 800b054:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 800b056:	f000 ff5b 	bl	800bf10 <chDbgCheckClassS>

  return queue_notempty(&mp->m_queue);
 800b05a:	9b01      	ldr	r3, [sp, #4]
 800b05c:	4618      	mov	r0, r3
 800b05e:	f7ff ff6f 	bl	800af40 <queue_notempty.lto_priv.396>
 800b062:	4603      	mov	r3, r0
}
 800b064:	4618      	mov	r0, r3
 800b066:	b003      	add	sp, #12
 800b068:	f85d fb04 	ldr.w	pc, [sp], #4
 800b06c:	0000      	movs	r0, r0
	...

0800b070 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 800b070:	b500      	push	{lr}
 800b072:	b083      	sub	sp, #12
 800b074:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
 800b076:	9b01      	ldr	r3, [sp, #4]
 800b078:	2b00      	cmp	r3, #0
 800b07a:	d102      	bne.n	800b082 <chMtxObjectInit+0x12>
 800b07c:	4806      	ldr	r0, [pc, #24]	; (800b098 <chMtxObjectInit+0x28>)
 800b07e:	f000 fd37 	bl	800baf0 <chSysHalt>

  queue_init(&mp->m_queue);
 800b082:	9b01      	ldr	r3, [sp, #4]
 800b084:	4618      	mov	r0, r3
 800b086:	f7ff ff4b 	bl	800af20 <queue_init.lto_priv.398>
  mp->m_owner = NULL;
 800b08a:	9b01      	ldr	r3, [sp, #4]
 800b08c:	2200      	movs	r2, #0
 800b08e:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
 800b090:	b003      	add	sp, #12
 800b092:	f85d fb04 	ldr.w	pc, [sp], #4
 800b096:	bf00      	nop
 800b098:	0800de40 	.word	0x0800de40
 800b09c:	00000000 	.word	0x00000000

0800b0a0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 800b0a0:	b500      	push	{lr}
 800b0a2:	b083      	sub	sp, #12
 800b0a4:	9001      	str	r0, [sp, #4]

  chSysLock();
 800b0a6:	f7ff ffab 	bl	800b000 <chSysLock.lto_priv.392>
  chMtxLockS(mp);
 800b0aa:	9801      	ldr	r0, [sp, #4]
 800b0ac:	f000 f808 	bl	800b0c0 <chMtxLockS>
  chSysUnlock();
 800b0b0:	f7ff ffae 	bl	800b010 <chSysUnlock.lto_priv.388>
}
 800b0b4:	b003      	add	sp, #12
 800b0b6:	f85d fb04 	ldr.w	pc, [sp], #4
 800b0ba:	bf00      	nop
 800b0bc:	0000      	movs	r0, r0
	...

0800b0c0 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 800b0c0:	b500      	push	{lr}
 800b0c2:	b085      	sub	sp, #20
 800b0c4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 800b0c6:	4b3b      	ldr	r3, [pc, #236]	; (800b1b4 <chMtxLockS+0xf4>)
 800b0c8:	699b      	ldr	r3, [r3, #24]
 800b0ca:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
 800b0cc:	f000 ff20 	bl	800bf10 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 800b0d0:	9b01      	ldr	r3, [sp, #4]
 800b0d2:	2b00      	cmp	r3, #0
 800b0d4:	d102      	bne.n	800b0dc <chMtxLockS+0x1c>
 800b0d6:	4838      	ldr	r0, [pc, #224]	; (800b1b8 <chMtxLockS+0xf8>)
 800b0d8:	f000 fd0a 	bl	800baf0 <chSysHalt>

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 800b0dc:	9b01      	ldr	r3, [sp, #4]
 800b0de:	689b      	ldr	r3, [r3, #8]
 800b0e0:	2b00      	cmp	r3, #0
 800b0e2:	d059      	beq.n	800b198 <chMtxLockS+0xd8>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;
 800b0e4:	9b01      	ldr	r3, [sp, #4]
 800b0e6:	689b      	ldr	r3, [r3, #8]
 800b0e8:	9303      	str	r3, [sp, #12]
 800b0ea:	e033      	b.n	800b154 <chMtxLockS+0x94>

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 800b0ec:	9b02      	ldr	r3, [sp, #8]
 800b0ee:	689a      	ldr	r2, [r3, #8]
 800b0f0:	9b03      	ldr	r3, [sp, #12]
 800b0f2:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 800b0f4:	9b03      	ldr	r3, [sp, #12]
 800b0f6:	f893 3020 	ldrb.w	r3, [r3, #32]
 800b0fa:	2b06      	cmp	r3, #6
 800b0fc:	d004      	beq.n	800b108 <chMtxLockS+0x48>
 800b0fe:	2b07      	cmp	r3, #7
 800b100:	d011      	beq.n	800b126 <chMtxLockS+0x66>
 800b102:	2b00      	cmp	r3, #0
 800b104:	d01a      	beq.n	800b13c <chMtxLockS+0x7c>
 800b106:	e02b      	b.n	800b160 <chMtxLockS+0xa0>
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 800b108:	9803      	ldr	r0, [sp, #12]
 800b10a:	f7ff ff69 	bl	800afe0 <queue_dequeue>
 800b10e:	4602      	mov	r2, r0
 800b110:	9b03      	ldr	r3, [sp, #12]
 800b112:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b114:	4610      	mov	r0, r2
 800b116:	4619      	mov	r1, r3
 800b118:	f7ff ff22 	bl	800af60 <queue_prio_insert>
          tp = tp->p_u.wtmtxp->m_owner;
 800b11c:	9b03      	ldr	r3, [sp, #12]
 800b11e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b120:	689b      	ldr	r3, [r3, #8]
 800b122:	9303      	str	r3, [sp, #12]
 800b124:	e016      	b.n	800b154 <chMtxLockS+0x94>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 800b126:	9803      	ldr	r0, [sp, #12]
 800b128:	f7ff ff5a 	bl	800afe0 <queue_dequeue>
 800b12c:	4602      	mov	r2, r0
 800b12e:	9b03      	ldr	r3, [sp, #12]
 800b130:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b132:	4610      	mov	r0, r2
 800b134:	4619      	mov	r1, r3
 800b136:	f7ff ff13 	bl	800af60 <queue_prio_insert>
 800b13a:	e011      	b.n	800b160 <chMtxLockS+0xa0>
          break;
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
 800b13c:	9b03      	ldr	r3, [sp, #12]
 800b13e:	2201      	movs	r2, #1
 800b140:	f883 2020 	strb.w	r2, [r3, #32]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 800b144:	9803      	ldr	r0, [sp, #12]
 800b146:	f7ff ff4b 	bl	800afe0 <queue_dequeue>
 800b14a:	4603      	mov	r3, r0
 800b14c:	4618      	mov	r0, r3
 800b14e:	f001 f94f 	bl	800c3f0 <chSchReadyI>
 800b152:	e005      	b.n	800b160 <chMtxLockS+0xa0>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 800b154:	9b03      	ldr	r3, [sp, #12]
 800b156:	689a      	ldr	r2, [r3, #8]
 800b158:	9b02      	ldr	r3, [sp, #8]
 800b15a:	689b      	ldr	r3, [r3, #8]
 800b15c:	429a      	cmp	r2, r3
 800b15e:	d3c5      	bcc.n	800b0ec <chMtxLockS+0x2c>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
 800b160:	9b01      	ldr	r3, [sp, #4]
 800b162:	9802      	ldr	r0, [sp, #8]
 800b164:	4619      	mov	r1, r3
 800b166:	f7ff fefb 	bl	800af60 <queue_prio_insert>
      ctp->p_u.wtmtxp = mp;
 800b16a:	9b02      	ldr	r3, [sp, #8]
 800b16c:	9a01      	ldr	r2, [sp, #4]
 800b16e:	625a      	str	r2, [r3, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 800b170:	2006      	movs	r0, #6
 800b172:	f001 f97d 	bl	800c470 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->m_owner == ctp, "not owner");
 800b176:	9b01      	ldr	r3, [sp, #4]
 800b178:	689a      	ldr	r2, [r3, #8]
 800b17a:	9b02      	ldr	r3, [sp, #8]
 800b17c:	429a      	cmp	r2, r3
 800b17e:	d002      	beq.n	800b186 <chMtxLockS+0xc6>
 800b180:	480d      	ldr	r0, [pc, #52]	; (800b1b8 <chMtxLockS+0xf8>)
 800b182:	f000 fcb5 	bl	800baf0 <chSysHalt>
      chDbgAssert(ctp->p_mtxlist == mp, "not owned");
 800b186:	9b02      	ldr	r3, [sp, #8]
 800b188:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800b18a:	9b01      	ldr	r3, [sp, #4]
 800b18c:	429a      	cmp	r2, r3
 800b18e:	d00d      	beq.n	800b1ac <chMtxLockS+0xec>
 800b190:	4809      	ldr	r0, [pc, #36]	; (800b1b8 <chMtxLockS+0xf8>)
 800b192:	f000 fcad 	bl	800baf0 <chSysHalt>
 800b196:	e009      	b.n	800b1ac <chMtxLockS+0xec>
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 800b198:	9b01      	ldr	r3, [sp, #4]
 800b19a:	9a02      	ldr	r2, [sp, #8]
 800b19c:	609a      	str	r2, [r3, #8]
    mp->m_next = ctp->p_mtxlist;
 800b19e:	9b02      	ldr	r3, [sp, #8]
 800b1a0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800b1a2:	9b01      	ldr	r3, [sp, #4]
 800b1a4:	60da      	str	r2, [r3, #12]
    ctp->p_mtxlist = mp;
 800b1a6:	9b02      	ldr	r3, [sp, #8]
 800b1a8:	9a01      	ldr	r2, [sp, #4]
 800b1aa:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
 800b1ac:	b005      	add	sp, #20
 800b1ae:	f85d fb04 	ldr.w	pc, [sp], #4
 800b1b2:	bf00      	nop
 800b1b4:	20000d30 	.word	0x20000d30
 800b1b8:	0800de60 	.word	0x0800de60
 800b1bc:	00000000 	.word	0x00000000

0800b1c0 <chMtxTryLock>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @api
 */
bool chMtxTryLock(mutex_t *mp) {
 800b1c0:	b500      	push	{lr}
 800b1c2:	b085      	sub	sp, #20
 800b1c4:	9001      	str	r0, [sp, #4]
  bool b;

  chSysLock();
 800b1c6:	f7ff ff1b 	bl	800b000 <chSysLock.lto_priv.392>
  b = chMtxTryLockS(mp);
 800b1ca:	9801      	ldr	r0, [sp, #4]
 800b1cc:	f000 f810 	bl	800b1f0 <chMtxTryLockS>
 800b1d0:	4603      	mov	r3, r0
 800b1d2:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
 800b1d6:	f7ff ff1b 	bl	800b010 <chSysUnlock.lto_priv.388>

  return b;
 800b1da:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 800b1de:	4618      	mov	r0, r3
 800b1e0:	b005      	add	sp, #20
 800b1e2:	f85d fb04 	ldr.w	pc, [sp], #4
 800b1e6:	bf00      	nop
	...

0800b1f0 <chMtxTryLockS>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @sclass
 */
bool chMtxTryLockS(mutex_t *mp) {
 800b1f0:	b500      	push	{lr}
 800b1f2:	b083      	sub	sp, #12
 800b1f4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
 800b1f6:	f000 fe8b 	bl	800bf10 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 800b1fa:	9b01      	ldr	r3, [sp, #4]
 800b1fc:	2b00      	cmp	r3, #0
 800b1fe:	d102      	bne.n	800b206 <chMtxTryLockS+0x16>
 800b200:	480d      	ldr	r0, [pc, #52]	; (800b238 <chMtxTryLockS+0x48>)
 800b202:	f000 fc75 	bl	800baf0 <chSysHalt>

  if (mp->m_owner != NULL) {
 800b206:	9b01      	ldr	r3, [sp, #4]
 800b208:	689b      	ldr	r3, [r3, #8]
 800b20a:	2b00      	cmp	r3, #0
 800b20c:	d001      	beq.n	800b212 <chMtxTryLockS+0x22>
    if (mp->m_owner == currp) {
      mp->m_cnt++;
      return true;
    }
#endif
    return false;
 800b20e:	2300      	movs	r3, #0
 800b210:	e00d      	b.n	800b22e <chMtxTryLockS+0x3e>

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 800b212:	4b0a      	ldr	r3, [pc, #40]	; (800b23c <chMtxTryLockS+0x4c>)
 800b214:	699a      	ldr	r2, [r3, #24]
 800b216:	9b01      	ldr	r3, [sp, #4]
 800b218:	609a      	str	r2, [r3, #8]
  mp->m_next = currp->p_mtxlist;
 800b21a:	4b08      	ldr	r3, [pc, #32]	; (800b23c <chMtxTryLockS+0x4c>)
 800b21c:	699b      	ldr	r3, [r3, #24]
 800b21e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800b220:	9b01      	ldr	r3, [sp, #4]
 800b222:	60da      	str	r2, [r3, #12]
  currp->p_mtxlist = mp;
 800b224:	4b05      	ldr	r3, [pc, #20]	; (800b23c <chMtxTryLockS+0x4c>)
 800b226:	699b      	ldr	r3, [r3, #24]
 800b228:	9a01      	ldr	r2, [sp, #4]
 800b22a:	63da      	str	r2, [r3, #60]	; 0x3c
  return true;
 800b22c:	2301      	movs	r3, #1
}
 800b22e:	4618      	mov	r0, r3
 800b230:	b003      	add	sp, #12
 800b232:	f85d fb04 	ldr.w	pc, [sp], #4
 800b236:	bf00      	nop
 800b238:	0800de70 	.word	0x0800de70
 800b23c:	20000d30 	.word	0x20000d30

0800b240 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 800b240:	b500      	push	{lr}
 800b242:	b087      	sub	sp, #28
 800b244:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 800b246:	4b35      	ldr	r3, [pc, #212]	; (800b31c <chMtxUnlock+0xdc>)
 800b248:	699b      	ldr	r3, [r3, #24]
 800b24a:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 800b24c:	9b01      	ldr	r3, [sp, #4]
 800b24e:	2b00      	cmp	r3, #0
 800b250:	d102      	bne.n	800b258 <chMtxUnlock+0x18>
 800b252:	4833      	ldr	r0, [pc, #204]	; (800b320 <chMtxUnlock+0xe0>)
 800b254:	f000 fc4c 	bl	800baf0 <chSysHalt>

  chSysLock();
 800b258:	f7ff fed2 	bl	800b000 <chSysLock.lto_priv.392>

  chDbgAssert(ctp->p_mtxlist != NULL, "owned mutexes list empty");
 800b25c:	9b03      	ldr	r3, [sp, #12]
 800b25e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b260:	2b00      	cmp	r3, #0
 800b262:	d102      	bne.n	800b26a <chMtxUnlock+0x2a>
 800b264:	482e      	ldr	r0, [pc, #184]	; (800b320 <chMtxUnlock+0xe0>)
 800b266:	f000 fc43 	bl	800baf0 <chSysHalt>
  chDbgAssert(ctp->p_mtxlist->m_owner == ctp, "ownership failure");
 800b26a:	9b03      	ldr	r3, [sp, #12]
 800b26c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b26e:	689a      	ldr	r2, [r3, #8]
 800b270:	9b03      	ldr	r3, [sp, #12]
 800b272:	429a      	cmp	r2, r3
 800b274:	d002      	beq.n	800b27c <chMtxUnlock+0x3c>
 800b276:	482a      	ldr	r0, [pc, #168]	; (800b320 <chMtxUnlock+0xe0>)
 800b278:	f000 fc3a 	bl	800baf0 <chSysHalt>
  chDbgAssert(mp->m_cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->m_cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");
 800b27c:	9b03      	ldr	r3, [sp, #12]
 800b27e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800b280:	9b01      	ldr	r3, [sp, #4]
 800b282:	429a      	cmp	r2, r3
 800b284:	d002      	beq.n	800b28c <chMtxUnlock+0x4c>
 800b286:	4826      	ldr	r0, [pc, #152]	; (800b320 <chMtxUnlock+0xe0>)
 800b288:	f000 fc32 	bl	800baf0 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 800b28c:	9b01      	ldr	r3, [sp, #4]
 800b28e:	68da      	ldr	r2, [r3, #12]
 800b290:	9b03      	ldr	r3, [sp, #12]
 800b292:	63da      	str	r2, [r3, #60]	; 0x3c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800b294:	9801      	ldr	r0, [sp, #4]
 800b296:	f7ff fedb 	bl	800b050 <chMtxQueueNotEmptyS>
 800b29a:	4603      	mov	r3, r0
 800b29c:	2b00      	cmp	r3, #0
 800b29e:	d034      	beq.n	800b30a <chMtxUnlock+0xca>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 800b2a0:	9b03      	ldr	r3, [sp, #12]
 800b2a2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b2a4:	9304      	str	r3, [sp, #16]
      lmp = ctp->p_mtxlist;
 800b2a6:	9b03      	ldr	r3, [sp, #12]
 800b2a8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b2aa:	9305      	str	r3, [sp, #20]
 800b2ac:	e012      	b.n	800b2d4 <chMtxUnlock+0x94>
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800b2ae:	9805      	ldr	r0, [sp, #20]
 800b2b0:	f7ff fece 	bl	800b050 <chMtxQueueNotEmptyS>
 800b2b4:	4603      	mov	r3, r0
 800b2b6:	2b00      	cmp	r3, #0
 800b2b8:	d009      	beq.n	800b2ce <chMtxUnlock+0x8e>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 800b2ba:	9b05      	ldr	r3, [sp, #20]
 800b2bc:	681b      	ldr	r3, [r3, #0]
 800b2be:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800b2c0:	9b04      	ldr	r3, [sp, #16]
 800b2c2:	429a      	cmp	r2, r3
 800b2c4:	d903      	bls.n	800b2ce <chMtxUnlock+0x8e>
            (lmp->m_queue.p_next->p_prio > newprio)) {
          newprio = lmp->m_queue.p_next->p_prio;
 800b2c6:	9b05      	ldr	r3, [sp, #20]
 800b2c8:	681b      	ldr	r3, [r3, #0]
 800b2ca:	689b      	ldr	r3, [r3, #8]
 800b2cc:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->m_next;
 800b2ce:	9b05      	ldr	r3, [sp, #20]
 800b2d0:	68db      	ldr	r3, [r3, #12]
 800b2d2:	9305      	str	r3, [sp, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 800b2d4:	9b05      	ldr	r3, [sp, #20]
 800b2d6:	2b00      	cmp	r3, #0
 800b2d8:	d1e9      	bne.n	800b2ae <chMtxUnlock+0x6e>
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 800b2da:	9b03      	ldr	r3, [sp, #12]
 800b2dc:	9a04      	ldr	r2, [sp, #16]
 800b2de:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
 800b2e0:	9b01      	ldr	r3, [sp, #4]
 800b2e2:	4618      	mov	r0, r3
 800b2e4:	f7ff fe64 	bl	800afb0 <queue_fifo_remove.lto_priv.394>
 800b2e8:	9002      	str	r0, [sp, #8]
      mp->m_owner = tp;
 800b2ea:	9b01      	ldr	r3, [sp, #4]
 800b2ec:	9a02      	ldr	r2, [sp, #8]
 800b2ee:	609a      	str	r2, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 800b2f0:	9b02      	ldr	r3, [sp, #8]
 800b2f2:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800b2f4:	9b01      	ldr	r3, [sp, #4]
 800b2f6:	60da      	str	r2, [r3, #12]
      tp->p_mtxlist = mp;
 800b2f8:	9b02      	ldr	r3, [sp, #8]
 800b2fa:	9a01      	ldr	r2, [sp, #4]
 800b2fc:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 800b2fe:	9802      	ldr	r0, [sp, #8]
 800b300:	f001 f876 	bl	800c3f0 <chSchReadyI>
      chSchRescheduleS();
 800b304:	f001 f9c4 	bl	800c690 <chSchRescheduleS>
 800b308:	e002      	b.n	800b310 <chMtxUnlock+0xd0>
    }
    else {
      mp->m_owner = NULL;
 800b30a:	9b01      	ldr	r3, [sp, #4]
 800b30c:	2200      	movs	r2, #0
 800b30e:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 800b310:	f7ff fe7e 	bl	800b010 <chSysUnlock.lto_priv.388>
}
 800b314:	b007      	add	sp, #28
 800b316:	f85d fb04 	ldr.w	pc, [sp], #4
 800b31a:	bf00      	nop
 800b31c:	20000d30 	.word	0x20000d30
 800b320:	0800de80 	.word	0x0800de80
	...

0800b330 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 800b330:	b500      	push	{lr}
 800b332:	b087      	sub	sp, #28
 800b334:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 800b336:	4b33      	ldr	r3, [pc, #204]	; (800b404 <chMtxUnlockS+0xd4>)
 800b338:	699b      	ldr	r3, [r3, #24]
 800b33a:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheckClassS();
 800b33c:	f000 fde8 	bl	800bf10 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 800b340:	9b01      	ldr	r3, [sp, #4]
 800b342:	2b00      	cmp	r3, #0
 800b344:	d102      	bne.n	800b34c <chMtxUnlockS+0x1c>
 800b346:	4830      	ldr	r0, [pc, #192]	; (800b408 <chMtxUnlockS+0xd8>)
 800b348:	f000 fbd2 	bl	800baf0 <chSysHalt>

  chDbgAssert(ctp->p_mtxlist != NULL, "owned mutexes list empty");
 800b34c:	9b03      	ldr	r3, [sp, #12]
 800b34e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b350:	2b00      	cmp	r3, #0
 800b352:	d102      	bne.n	800b35a <chMtxUnlockS+0x2a>
 800b354:	482c      	ldr	r0, [pc, #176]	; (800b408 <chMtxUnlockS+0xd8>)
 800b356:	f000 fbcb 	bl	800baf0 <chSysHalt>
  chDbgAssert(ctp->p_mtxlist->m_owner == ctp, "ownership failure");
 800b35a:	9b03      	ldr	r3, [sp, #12]
 800b35c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b35e:	689a      	ldr	r2, [r3, #8]
 800b360:	9b03      	ldr	r3, [sp, #12]
 800b362:	429a      	cmp	r2, r3
 800b364:	d002      	beq.n	800b36c <chMtxUnlockS+0x3c>
 800b366:	4828      	ldr	r0, [pc, #160]	; (800b408 <chMtxUnlockS+0xd8>)
 800b368:	f000 fbc2 	bl	800baf0 <chSysHalt>
  chDbgAssert(mp->m_cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->m_cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");
 800b36c:	9b03      	ldr	r3, [sp, #12]
 800b36e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800b370:	9b01      	ldr	r3, [sp, #4]
 800b372:	429a      	cmp	r2, r3
 800b374:	d002      	beq.n	800b37c <chMtxUnlockS+0x4c>
 800b376:	4824      	ldr	r0, [pc, #144]	; (800b408 <chMtxUnlockS+0xd8>)
 800b378:	f000 fbba 	bl	800baf0 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 800b37c:	9b01      	ldr	r3, [sp, #4]
 800b37e:	68da      	ldr	r2, [r3, #12]
 800b380:	9b03      	ldr	r3, [sp, #12]
 800b382:	63da      	str	r2, [r3, #60]	; 0x3c

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800b384:	9801      	ldr	r0, [sp, #4]
 800b386:	f7ff fe63 	bl	800b050 <chMtxQueueNotEmptyS>
 800b38a:	4603      	mov	r3, r0
 800b38c:	2b00      	cmp	r3, #0
 800b38e:	d032      	beq.n	800b3f6 <chMtxUnlockS+0xc6>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 800b390:	9b03      	ldr	r3, [sp, #12]
 800b392:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b394:	9304      	str	r3, [sp, #16]
      lmp = ctp->p_mtxlist;
 800b396:	9b03      	ldr	r3, [sp, #12]
 800b398:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b39a:	9305      	str	r3, [sp, #20]
 800b39c:	e012      	b.n	800b3c4 <chMtxUnlockS+0x94>
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800b39e:	9805      	ldr	r0, [sp, #20]
 800b3a0:	f7ff fe56 	bl	800b050 <chMtxQueueNotEmptyS>
 800b3a4:	4603      	mov	r3, r0
 800b3a6:	2b00      	cmp	r3, #0
 800b3a8:	d009      	beq.n	800b3be <chMtxUnlockS+0x8e>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 800b3aa:	9b05      	ldr	r3, [sp, #20]
 800b3ac:	681b      	ldr	r3, [r3, #0]
 800b3ae:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800b3b0:	9b04      	ldr	r3, [sp, #16]
 800b3b2:	429a      	cmp	r2, r3
 800b3b4:	d903      	bls.n	800b3be <chMtxUnlockS+0x8e>
            (lmp->m_queue.p_next->p_prio > newprio)) {
          newprio = lmp->m_queue.p_next->p_prio;
 800b3b6:	9b05      	ldr	r3, [sp, #20]
 800b3b8:	681b      	ldr	r3, [r3, #0]
 800b3ba:	689b      	ldr	r3, [r3, #8]
 800b3bc:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->m_next;
 800b3be:	9b05      	ldr	r3, [sp, #20]
 800b3c0:	68db      	ldr	r3, [r3, #12]
 800b3c2:	9305      	str	r3, [sp, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 800b3c4:	9b05      	ldr	r3, [sp, #20]
 800b3c6:	2b00      	cmp	r3, #0
 800b3c8:	d1e9      	bne.n	800b39e <chMtxUnlockS+0x6e>
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 800b3ca:	9b03      	ldr	r3, [sp, #12]
 800b3cc:	9a04      	ldr	r2, [sp, #16]
 800b3ce:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
 800b3d0:	9b01      	ldr	r3, [sp, #4]
 800b3d2:	4618      	mov	r0, r3
 800b3d4:	f7ff fdec 	bl	800afb0 <queue_fifo_remove.lto_priv.394>
 800b3d8:	9002      	str	r0, [sp, #8]
      mp->m_owner = tp;
 800b3da:	9b01      	ldr	r3, [sp, #4]
 800b3dc:	9a02      	ldr	r2, [sp, #8]
 800b3de:	609a      	str	r2, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 800b3e0:	9b02      	ldr	r3, [sp, #8]
 800b3e2:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800b3e4:	9b01      	ldr	r3, [sp, #4]
 800b3e6:	60da      	str	r2, [r3, #12]
      tp->p_mtxlist = mp;
 800b3e8:	9b02      	ldr	r3, [sp, #8]
 800b3ea:	9a01      	ldr	r2, [sp, #4]
 800b3ec:	63da      	str	r2, [r3, #60]	; 0x3c
      (void) chSchReadyI(tp);
 800b3ee:	9802      	ldr	r0, [sp, #8]
 800b3f0:	f000 fffe 	bl	800c3f0 <chSchReadyI>
 800b3f4:	e002      	b.n	800b3fc <chMtxUnlockS+0xcc>
    }
    else {
      mp->m_owner = NULL;
 800b3f6:	9b01      	ldr	r3, [sp, #4]
 800b3f8:	2200      	movs	r2, #0
 800b3fa:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 800b3fc:	b007      	add	sp, #28
 800b3fe:	f85d fb04 	ldr.w	pc, [sp], #4
 800b402:	bf00      	nop
 800b404:	20000d30 	.word	0x20000d30
 800b408:	0800de90 	.word	0x0800de90
 800b40c:	00000000 	.word	0x00000000

0800b410 <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
 800b410:	b500      	push	{lr}
 800b412:	b085      	sub	sp, #20
  thread_t *ctp = currp;
 800b414:	4b1d      	ldr	r3, [pc, #116]	; (800b48c <chMtxUnlockAll+0x7c>)
 800b416:	699b      	ldr	r3, [r3, #24]
 800b418:	9303      	str	r3, [sp, #12]

  chSysLock();
 800b41a:	f7ff fdf1 	bl	800b000 <chSysLock.lto_priv.392>
  if (ctp->p_mtxlist != NULL) {
 800b41e:	9b03      	ldr	r3, [sp, #12]
 800b420:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b422:	2b00      	cmp	r3, #0
 800b424:	d02c      	beq.n	800b480 <chMtxUnlockAll+0x70>
    do {
      mutex_t *mp = ctp->p_mtxlist;
 800b426:	9b03      	ldr	r3, [sp, #12]
 800b428:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b42a:	9302      	str	r3, [sp, #8]
      ctp->p_mtxlist = mp->m_next;
 800b42c:	9b02      	ldr	r3, [sp, #8]
 800b42e:	68da      	ldr	r2, [r3, #12]
 800b430:	9b03      	ldr	r3, [sp, #12]
 800b432:	63da      	str	r2, [r3, #60]	; 0x3c
      if (chMtxQueueNotEmptyS(mp)) {
 800b434:	9802      	ldr	r0, [sp, #8]
 800b436:	f7ff fe0b 	bl	800b050 <chMtxQueueNotEmptyS>
 800b43a:	4603      	mov	r3, r0
 800b43c:	2b00      	cmp	r3, #0
 800b43e:	d012      	beq.n	800b466 <chMtxUnlockAll+0x56>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
 800b440:	9b02      	ldr	r3, [sp, #8]
 800b442:	4618      	mov	r0, r3
 800b444:	f7ff fdb4 	bl	800afb0 <queue_fifo_remove.lto_priv.394>
 800b448:	9001      	str	r0, [sp, #4]
        mp->m_owner = tp;
 800b44a:	9b02      	ldr	r3, [sp, #8]
 800b44c:	9a01      	ldr	r2, [sp, #4]
 800b44e:	609a      	str	r2, [r3, #8]
        mp->m_next = tp->p_mtxlist;
 800b450:	9b01      	ldr	r3, [sp, #4]
 800b452:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800b454:	9b02      	ldr	r3, [sp, #8]
 800b456:	60da      	str	r2, [r3, #12]
        tp->p_mtxlist = mp;
 800b458:	9b01      	ldr	r3, [sp, #4]
 800b45a:	9a02      	ldr	r2, [sp, #8]
 800b45c:	63da      	str	r2, [r3, #60]	; 0x3c
        (void) chSchReadyI(tp);
 800b45e:	9801      	ldr	r0, [sp, #4]
 800b460:	f000 ffc6 	bl	800c3f0 <chSchReadyI>
 800b464:	e002      	b.n	800b46c <chMtxUnlockAll+0x5c>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
 800b466:	9b02      	ldr	r3, [sp, #8]
 800b468:	2200      	movs	r2, #0
 800b46a:	609a      	str	r2, [r3, #8]
      }
    } while (ctp->p_mtxlist != NULL);
 800b46c:	9b03      	ldr	r3, [sp, #12]
 800b46e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b470:	2b00      	cmp	r3, #0
 800b472:	d1d8      	bne.n	800b426 <chMtxUnlockAll+0x16>
    ctp->p_prio = ctp->p_realprio;
 800b474:	9b03      	ldr	r3, [sp, #12]
 800b476:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800b478:	9b03      	ldr	r3, [sp, #12]
 800b47a:	609a      	str	r2, [r3, #8]
    chSchRescheduleS();
 800b47c:	f001 f908 	bl	800c690 <chSchRescheduleS>
  }
  chSysUnlock();
 800b480:	f7ff fdc6 	bl	800b010 <chSysUnlock.lto_priv.388>
}
 800b484:	b005      	add	sp, #20
 800b486:	f85d fb04 	ldr.w	pc, [sp], #4
 800b48a:	bf00      	nop
 800b48c:	20000d30 	.word	0x20000d30

0800b490 <port_lock.lto_priv.383>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800b490:	b082      	sub	sp, #8
 800b492:	2320      	movs	r3, #32
 800b494:	9301      	str	r3, [sp, #4]
 800b496:	9b01      	ldr	r3, [sp, #4]
 800b498:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b49c:	b002      	add	sp, #8
 800b49e:	4770      	bx	lr

0800b4a0 <port_unlock.lto_priv.377>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800b4a0:	b082      	sub	sp, #8
 800b4a2:	2300      	movs	r3, #0
 800b4a4:	9301      	str	r3, [sp, #4]
 800b4a6:	9b01      	ldr	r3, [sp, #4]
 800b4a8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b4ac:	b002      	add	sp, #8
 800b4ae:	4770      	bx	lr

0800b4b0 <queue_init.lto_priv.341>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 800b4b0:	b082      	sub	sp, #8
 800b4b2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 800b4b4:	9b01      	ldr	r3, [sp, #4]
 800b4b6:	9a01      	ldr	r2, [sp, #4]
 800b4b8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800b4ba:	9b01      	ldr	r3, [sp, #4]
 800b4bc:	9a01      	ldr	r2, [sp, #4]
 800b4be:	605a      	str	r2, [r3, #4]
}
 800b4c0:	b002      	add	sp, #8
 800b4c2:	4770      	bx	lr
	...

0800b4d0 <queue_notempty.lto_priv.371>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 800b4d0:	b082      	sub	sp, #8
 800b4d2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800b4d4:	9b01      	ldr	r3, [sp, #4]
 800b4d6:	681a      	ldr	r2, [r3, #0]
 800b4d8:	9b01      	ldr	r3, [sp, #4]
 800b4da:	429a      	cmp	r2, r3
 800b4dc:	bf14      	ite	ne
 800b4de:	2301      	movne	r3, #1
 800b4e0:	2300      	moveq	r3, #0
 800b4e2:	b2db      	uxtb	r3, r3
}
 800b4e4:	4618      	mov	r0, r3
 800b4e6:	b002      	add	sp, #8
 800b4e8:	4770      	bx	lr
 800b4ea:	bf00      	nop
 800b4ec:	0000      	movs	r0, r0
	...

0800b4f0 <queue_prio_insert.lto_priv.369>:
  tlp->p_next = tp->p_next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 800b4f0:	b084      	sub	sp, #16
 800b4f2:	9001      	str	r0, [sp, #4]
 800b4f4:	9100      	str	r1, [sp, #0]

  thread_t *cp = (thread_t *)tqp;
 800b4f6:	9b00      	ldr	r3, [sp, #0]
 800b4f8:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 800b4fa:	9b03      	ldr	r3, [sp, #12]
 800b4fc:	681b      	ldr	r3, [r3, #0]
 800b4fe:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800b500:	9a03      	ldr	r2, [sp, #12]
 800b502:	9b00      	ldr	r3, [sp, #0]
 800b504:	429a      	cmp	r2, r3
 800b506:	d005      	beq.n	800b514 <queue_prio_insert.lto_priv.369+0x24>
 800b508:	9b03      	ldr	r3, [sp, #12]
 800b50a:	689a      	ldr	r2, [r3, #8]
 800b50c:	9b01      	ldr	r3, [sp, #4]
 800b50e:	689b      	ldr	r3, [r3, #8]
 800b510:	429a      	cmp	r2, r3
 800b512:	d2f2      	bcs.n	800b4fa <queue_prio_insert.lto_priv.369+0xa>
  tp->p_next = cp;
 800b514:	9b01      	ldr	r3, [sp, #4]
 800b516:	9a03      	ldr	r2, [sp, #12]
 800b518:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 800b51a:	9b03      	ldr	r3, [sp, #12]
 800b51c:	685a      	ldr	r2, [r3, #4]
 800b51e:	9b01      	ldr	r3, [sp, #4]
 800b520:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 800b522:	9b01      	ldr	r3, [sp, #4]
 800b524:	685b      	ldr	r3, [r3, #4]
 800b526:	9a01      	ldr	r2, [sp, #4]
 800b528:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 800b52a:	9b03      	ldr	r3, [sp, #12]
 800b52c:	9a01      	ldr	r2, [sp, #4]
 800b52e:	605a      	str	r2, [r3, #4]
}
 800b530:	b004      	add	sp, #16
 800b532:	4770      	bx	lr
	...

0800b540 <queue_fifo_remove.lto_priv.362>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 800b540:	b084      	sub	sp, #16
 800b542:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 800b544:	9b01      	ldr	r3, [sp, #4]
 800b546:	681b      	ldr	r3, [r3, #0]
 800b548:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 800b54a:	9b03      	ldr	r3, [sp, #12]
 800b54c:	681a      	ldr	r2, [r3, #0]
 800b54e:	9b01      	ldr	r3, [sp, #4]
 800b550:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800b552:	9b01      	ldr	r3, [sp, #4]
 800b554:	681b      	ldr	r3, [r3, #0]
 800b556:	9a01      	ldr	r2, [sp, #4]
 800b558:	605a      	str	r2, [r3, #4]

  return tp;
 800b55a:	9b03      	ldr	r3, [sp, #12]
}
 800b55c:	4618      	mov	r0, r3
 800b55e:	b004      	add	sp, #16
 800b560:	4770      	bx	lr
 800b562:	bf00      	nop
	...

0800b570 <chSysLock.lto_priv.358>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800b570:	b508      	push	{r3, lr}

  port_lock();
 800b572:	f7ff ff8d 	bl	800b490 <port_lock.lto_priv.383>
  _stats_start_measure_crit_thd();
 800b576:	f7fe ff63 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800b57a:	f000 fc11 	bl	800bda0 <_dbg_check_lock>
}
 800b57e:	bd08      	pop	{r3, pc}

0800b580 <chSysUnlock.lto_priv.354>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800b580:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800b582:	f000 fc25 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800b586:	f7fe ff63 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800b58a:	4b09      	ldr	r3, [pc, #36]	; (800b5b0 <chSysUnlock.lto_priv.354+0x30>)
 800b58c:	681b      	ldr	r3, [r3, #0]
 800b58e:	4a08      	ldr	r2, [pc, #32]	; (800b5b0 <chSysUnlock.lto_priv.354+0x30>)
 800b590:	4293      	cmp	r3, r2
 800b592:	d00a      	beq.n	800b5aa <chSysUnlock.lto_priv.354+0x2a>
 800b594:	4b06      	ldr	r3, [pc, #24]	; (800b5b0 <chSysUnlock.lto_priv.354+0x30>)
 800b596:	699b      	ldr	r3, [r3, #24]
 800b598:	689a      	ldr	r2, [r3, #8]
 800b59a:	4b05      	ldr	r3, [pc, #20]	; (800b5b0 <chSysUnlock.lto_priv.354+0x30>)
 800b59c:	681b      	ldr	r3, [r3, #0]
 800b59e:	689b      	ldr	r3, [r3, #8]
 800b5a0:	429a      	cmp	r2, r3
 800b5a2:	d202      	bcs.n	800b5aa <chSysUnlock.lto_priv.354+0x2a>
 800b5a4:	4803      	ldr	r0, [pc, #12]	; (800b5b4 <chSysUnlock.lto_priv.354+0x34>)
 800b5a6:	f000 faa3 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800b5aa:	f7ff ff79 	bl	800b4a0 <port_unlock.lto_priv.377>
}
 800b5ae:	bd08      	pop	{r3, pc}
 800b5b0:	20000d30 	.word	0x20000d30
 800b5b4:	0800ded0 	.word	0x0800ded0
	...

0800b5c0 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800b5c0:	4b01      	ldr	r3, [pc, #4]	; (800b5c8 <chThdGetSelfX+0x8>)
 800b5c2:	699b      	ldr	r3, [r3, #24]
}
 800b5c4:	4618      	mov	r0, r3
 800b5c6:	4770      	bx	lr
 800b5c8:	20000d30 	.word	0x20000d30
 800b5cc:	00000000 	.word	0x00000000

0800b5d0 <chMtxGetNextMutexS.lto_priv.370>:
 * @return              A pointer to the next mutex in the stack.
 * @retval NULL         if the stack is empty.
 *
 * @sclass
 */
static inline mutex_t *chMtxGetNextMutexS(void) {
 800b5d0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_mtxlist;
 800b5d2:	f7ff fff5 	bl	800b5c0 <chThdGetSelfX>
 800b5d6:	4603      	mov	r3, r0
 800b5d8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
}
 800b5da:	4618      	mov	r0, r3
 800b5dc:	bd08      	pop	{r3, pc}
 800b5de:	bf00      	nop

0800b5e0 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 800b5e0:	4770      	bx	lr
 800b5e2:	bf00      	nop
	...

0800b5f0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 800b5f0:	4770      	bx	lr
 800b5f2:	bf00      	nop
	...

0800b600 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 800b600:	e7fe      	b.n	800b600 <__default_exit>
 800b602:	bf00      	nop
	...

0800b610 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 800b610:	b084      	sub	sp, #16
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 800b612:	4b16      	ldr	r3, [pc, #88]	; (800b66c <__init_ram_areas+0x5c>)
 800b614:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 800b616:	9b03      	ldr	r3, [sp, #12]
 800b618:	681b      	ldr	r3, [r3, #0]
 800b61a:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 800b61c:	9b03      	ldr	r3, [sp, #12]
 800b61e:	685b      	ldr	r3, [r3, #4]
 800b620:	9301      	str	r3, [sp, #4]
 800b622:	e009      	b.n	800b638 <__init_ram_areas+0x28>

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
      *p = *tp;
 800b624:	9b02      	ldr	r3, [sp, #8]
 800b626:	681a      	ldr	r2, [r3, #0]
 800b628:	9b01      	ldr	r3, [sp, #4]
 800b62a:	601a      	str	r2, [r3, #0]
      p++;
 800b62c:	9b01      	ldr	r3, [sp, #4]
 800b62e:	3304      	adds	r3, #4
 800b630:	9301      	str	r3, [sp, #4]
      tp++;
 800b632:	9b02      	ldr	r3, [sp, #8]
 800b634:	3304      	adds	r3, #4
 800b636:	9302      	str	r3, [sp, #8]
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800b638:	9b03      	ldr	r3, [sp, #12]
 800b63a:	689a      	ldr	r2, [r3, #8]
 800b63c:	9b01      	ldr	r3, [sp, #4]
 800b63e:	429a      	cmp	r2, r3
 800b640:	d8f0      	bhi.n	800b624 <__init_ram_areas+0x14>
 800b642:	e005      	b.n	800b650 <__init_ram_areas+0x40>
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 800b644:	9b01      	ldr	r3, [sp, #4]
 800b646:	2200      	movs	r2, #0
 800b648:	601a      	str	r2, [r3, #0]
      p++;
 800b64a:	9b01      	ldr	r3, [sp, #4]
 800b64c:	3304      	adds	r3, #4
 800b64e:	9301      	str	r3, [sp, #4]
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800b650:	9b03      	ldr	r3, [sp, #12]
 800b652:	68da      	ldr	r2, [r3, #12]
 800b654:	9b01      	ldr	r3, [sp, #4]
 800b656:	429a      	cmp	r2, r3
 800b658:	d8f4      	bhi.n	800b644 <__init_ram_areas+0x34>
      *p = 0;
      p++;
    }
    rap++;
 800b65a:	9b03      	ldr	r3, [sp, #12]
 800b65c:	3310      	adds	r3, #16
 800b65e:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800b660:	9b03      	ldr	r3, [sp, #12]
 800b662:	4a03      	ldr	r2, [pc, #12]	; (800b670 <__init_ram_areas+0x60>)
 800b664:	4293      	cmp	r3, r2
 800b666:	d3d6      	bcc.n	800b616 <__init_ram_areas+0x6>
#endif
}
 800b668:	b004      	add	sp, #16
 800b66a:	4770      	bx	lr
 800b66c:	0800db50 	.word	0x0800db50
 800b670:	0800dbd0 	.word	0x0800dbd0
	...

0800b680 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 800b680:	e7fe      	b.n	800b680 <BusFault_Handler>
 800b682:	bf00      	nop
	...

0800b690 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800b690:	b084      	sub	sp, #16
 800b692:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 800b694:	9b01      	ldr	r3, [sp, #4]
 800b696:	f003 0307 	and.w	r3, r3, #7
 800b69a:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800b69c:	4b0a      	ldr	r3, [pc, #40]	; (800b6c8 <NVIC_SetPriorityGrouping+0x38>)
 800b69e:	68db      	ldr	r3, [r3, #12]
 800b6a0:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 800b6a2:	9a02      	ldr	r2, [sp, #8]
 800b6a4:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 800b6a8:	4013      	ands	r3, r2
 800b6aa:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
 800b6ac:	9b03      	ldr	r3, [sp, #12]
 800b6ae:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800b6b0:	9b02      	ldr	r3, [sp, #8]
 800b6b2:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 800b6b4:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 800b6b8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800b6bc:	9302      	str	r3, [sp, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 800b6be:	4a02      	ldr	r2, [pc, #8]	; (800b6c8 <NVIC_SetPriorityGrouping+0x38>)
 800b6c0:	9b02      	ldr	r3, [sp, #8]
 800b6c2:	60d3      	str	r3, [r2, #12]
}
 800b6c4:	b004      	add	sp, #16
 800b6c6:	4770      	bx	lr
 800b6c8:	e000ed00 	.word	0xe000ed00
 800b6cc:	00000000 	.word	0x00000000

0800b6d0 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800b6d0:	b082      	sub	sp, #8
 800b6d2:	4603      	mov	r3, r0
 800b6d4:	9100      	str	r1, [sp, #0]
 800b6d6:	f88d 3007 	strb.w	r3, [sp, #7]
  if((int32_t)IRQn < 0) {
 800b6da:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 800b6de:	2b00      	cmp	r3, #0
 800b6e0:	da0c      	bge.n	800b6fc <NVIC_SetPriority+0x2c>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b6e2:	490c      	ldr	r1, [pc, #48]	; (800b714 <NVIC_SetPriority+0x44>)
 800b6e4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800b6e8:	f003 030f 	and.w	r3, r3, #15
 800b6ec:	3b04      	subs	r3, #4
 800b6ee:	9a00      	ldr	r2, [sp, #0]
 800b6f0:	b2d2      	uxtb	r2, r2
 800b6f2:	0112      	lsls	r2, r2, #4
 800b6f4:	b2d2      	uxtb	r2, r2
 800b6f6:	440b      	add	r3, r1
 800b6f8:	761a      	strb	r2, [r3, #24]
 800b6fa:	e009      	b.n	800b710 <NVIC_SetPriority+0x40>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800b6fc:	4906      	ldr	r1, [pc, #24]	; (800b718 <NVIC_SetPriority+0x48>)
 800b6fe:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 800b702:	9a00      	ldr	r2, [sp, #0]
 800b704:	b2d2      	uxtb	r2, r2
 800b706:	0112      	lsls	r2, r2, #4
 800b708:	b2d2      	uxtb	r2, r2
 800b70a:	440b      	add	r3, r1
 800b70c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 800b710:	b002      	add	sp, #8
 800b712:	4770      	bx	lr
 800b714:	e000ed00 	.word	0xe000ed00
 800b718:	e000e100 	.word	0xe000e100
 800b71c:	00000000 	.word	0x00000000

0800b720 <port_init>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
 800b720:	b508      	push	{r3, lr}

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 800b722:	4b0e      	ldr	r3, [pc, #56]	; (800b75c <port_init+0x3c>)
 800b724:	2200      	movs	r2, #0
 800b726:	609a      	str	r2, [r3, #8]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 800b728:	2003      	movs	r0, #3
 800b72a:	f7ff ffb1 	bl	800b690 <NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800b72e:	4a0c      	ldr	r2, [pc, #48]	; (800b760 <port_init+0x40>)
 800b730:	4b0b      	ldr	r3, [pc, #44]	; (800b760 <port_init+0x40>)
 800b732:	68db      	ldr	r3, [r3, #12]
 800b734:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800b738:	60d3      	str	r3, [r2, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800b73a:	4a0a      	ldr	r2, [pc, #40]	; (800b764 <port_init+0x44>)
 800b73c:	4b09      	ldr	r3, [pc, #36]	; (800b764 <port_init+0x44>)
 800b73e:	681b      	ldr	r3, [r3, #0]
 800b740:	f043 0301 	orr.w	r3, r3, #1
 800b744:	6013      	str	r3, [r2, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 800b746:	f06f 0004 	mvn.w	r0, #4
 800b74a:	2101      	movs	r1, #1
 800b74c:	f7ff ffc0 	bl	800b6d0 <NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 800b750:	f06f 0001 	mvn.w	r0, #1
 800b754:	2102      	movs	r1, #2
 800b756:	f7ff ffbb 	bl	800b6d0 <NVIC_SetPriority>
}
 800b75a:	bd08      	pop	{r3, pc}
 800b75c:	e000ed00 	.word	0xe000ed00
 800b760:	e000edf0 	.word	0xe000edf0
 800b764:	e0001000 	.word	0xe0001000
	...

0800b770 <port_get_irq_status>:
/**
 * @brief   Returns a word encoding the current interrupts status.
 *
 * @return              The interrupts status.
 */
static inline syssts_t port_get_irq_status(void) {
 800b770:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b772:	f3ef 8311 	mrs	r3, BASEPRI
 800b776:	9300      	str	r3, [sp, #0]
  return(result);
 800b778:	9b00      	ldr	r3, [sp, #0]
  syssts_t sts;

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  sts = (syssts_t)__get_BASEPRI();
 800b77a:	9301      	str	r3, [sp, #4]
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  sts = (syssts_t)__get_PRIMASK();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
  return sts;
 800b77c:	9b01      	ldr	r3, [sp, #4]
}
 800b77e:	4618      	mov	r0, r3
 800b780:	b002      	add	sp, #8
 800b782:	4770      	bx	lr
	...

0800b790 <port_irq_enabled>:
 *
 * @return              The interrupt status.
 * @retvel false        the word specified a disabled interrupts status.
 * @retvel true         the word specified an enabled interrupts status.
 */
static inline bool port_irq_enabled(syssts_t sts) {
 800b790:	b082      	sub	sp, #8
 800b792:	9001      	str	r0, [sp, #4]

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  return sts == (syssts_t)CORTEX_BASEPRI_DISABLED;
 800b794:	9b01      	ldr	r3, [sp, #4]
 800b796:	2b00      	cmp	r3, #0
 800b798:	bf0c      	ite	eq
 800b79a:	2301      	moveq	r3, #1
 800b79c:	2300      	movne	r3, #0
 800b79e:	b2db      	uxtb	r3, r3
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  return (sts & (syssts_t)1) == (syssts_t)0;
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b7a0:	4618      	mov	r0, r3
 800b7a2:	b002      	add	sp, #8
 800b7a4:	4770      	bx	lr
 800b7a6:	bf00      	nop
	...

0800b7b0 <port_is_isr_context>:
 *
 * @return              The execution context.
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {
 800b7b0:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b7b2:	f3ef 8305 	mrs	r3, IPSR
 800b7b6:	9301      	str	r3, [sp, #4]
  return(result);
 800b7b8:	9b01      	ldr	r3, [sp, #4]

  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 800b7ba:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800b7be:	2b00      	cmp	r3, #0
 800b7c0:	bf14      	ite	ne
 800b7c2:	2301      	movne	r3, #1
 800b7c4:	2300      	moveq	r3, #0
 800b7c6:	b2db      	uxtb	r3, r3
}
 800b7c8:	4618      	mov	r0, r3
 800b7ca:	b002      	add	sp, #8
 800b7cc:	4770      	bx	lr
 800b7ce:	bf00      	nop

0800b7d0 <port_lock.lto_priv.441>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800b7d0:	b082      	sub	sp, #8
 800b7d2:	2320      	movs	r3, #32
 800b7d4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800b7d6:	9b01      	ldr	r3, [sp, #4]
 800b7d8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b7dc:	b002      	add	sp, #8
 800b7de:	4770      	bx	lr

0800b7e0 <port_unlock.lto_priv.437>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800b7e0:	b082      	sub	sp, #8
 800b7e2:	2300      	movs	r3, #0
 800b7e4:	9301      	str	r3, [sp, #4]
 800b7e6:	9b01      	ldr	r3, [sp, #4]
 800b7e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b7ec:	b002      	add	sp, #8
 800b7ee:	4770      	bx	lr

0800b7f0 <port_lock_from_isr.lto_priv.452>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800b7f0:	b508      	push	{r3, lr}

  port_lock();
 800b7f2:	f7ff ffed 	bl	800b7d0 <port_lock.lto_priv.441>
}
 800b7f6:	bd08      	pop	{r3, pc}
	...

0800b800 <port_unlock_from_isr.lto_priv.449>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800b800:	b508      	push	{r3, lr}

  port_unlock();
 800b802:	f7ff ffed 	bl	800b7e0 <port_unlock.lto_priv.437>
}
 800b806:	bd08      	pop	{r3, pc}
	...

0800b810 <port_disable>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800b810:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 800b812:	4770      	bx	lr
	...

0800b820 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 800b820:	b082      	sub	sp, #8
 800b822:	2300      	movs	r3, #0
 800b824:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800b826:	9b01      	ldr	r3, [sp, #4]
 800b828:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800b82c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 800b82e:	b002      	add	sp, #8
 800b830:	4770      	bx	lr
 800b832:	bf00      	nop
	...

0800b840 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 800b840:	4770      	bx	lr
 800b842:	bf00      	nop
	...

0800b850 <st_lld_get_counter.lto_priv.433>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800b850:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b854:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800b856:	4618      	mov	r0, r3
 800b858:	4770      	bx	lr
 800b85a:	bf00      	nop
 800b85c:	0000      	movs	r0, r0
	...

0800b860 <port_timer_stop_alarm.lto_priv.457>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 800b860:	b508      	push	{r3, lr}

  stStopAlarm();
 800b862:	f7fd fb3d 	bl	8008ee0 <stStopAlarm>
}
 800b866:	bd08      	pop	{r3, pc}
	...

0800b870 <port_timer_set_alarm.lto_priv.455>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 800b870:	b500      	push	{lr}
 800b872:	b083      	sub	sp, #12
 800b874:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 800b876:	9801      	ldr	r0, [sp, #4]
 800b878:	f7fd fb3a 	bl	8008ef0 <stSetAlarm>
}
 800b87c:	b003      	add	sp, #12
 800b87e:	f85d fb04 	ldr.w	pc, [sp], #4
 800b882:	bf00      	nop
	...

0800b890 <port_timer_get_time.lto_priv.429>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 800b890:	b508      	push	{r3, lr}

  return stGetCounter();
 800b892:	f7ff ffdd 	bl	800b850 <st_lld_get_counter.lto_priv.433>
 800b896:	4603      	mov	r3, r0
}
 800b898:	4618      	mov	r0, r3
 800b89a:	bd08      	pop	{r3, pc}
 800b89c:	0000      	movs	r0, r0
	...

0800b8a0 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 800b8a0:	b508      	push	{r3, lr}

  _dbg_check_enable();
 800b8a2:	f000 fa65 	bl	800bd70 <_dbg_check_enable>
  port_enable();
 800b8a6:	f7ff ffbb 	bl	800b820 <port_enable>
}
 800b8aa:	bd08      	pop	{r3, pc}
 800b8ac:	0000      	movs	r0, r0
	...

0800b8b0 <chSysLock.lto_priv.423>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800b8b0:	b508      	push	{r3, lr}

  port_lock();
 800b8b2:	f7ff ff8d 	bl	800b7d0 <port_lock.lto_priv.441>
  _stats_start_measure_crit_thd();
 800b8b6:	f7fe fdc3 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800b8ba:	f000 fa71 	bl	800bda0 <_dbg_check_lock>
}
 800b8be:	bd08      	pop	{r3, pc}

0800b8c0 <chSysUnlock.lto_priv.421>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800b8c0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800b8c2:	f000 fa85 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800b8c6:	f7fe fdc3 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800b8ca:	4b09      	ldr	r3, [pc, #36]	; (800b8f0 <chSysUnlock.lto_priv.421+0x30>)
 800b8cc:	681b      	ldr	r3, [r3, #0]
 800b8ce:	4a08      	ldr	r2, [pc, #32]	; (800b8f0 <chSysUnlock.lto_priv.421+0x30>)
 800b8d0:	4293      	cmp	r3, r2
 800b8d2:	d00a      	beq.n	800b8ea <chSysUnlock.lto_priv.421+0x2a>
 800b8d4:	4b06      	ldr	r3, [pc, #24]	; (800b8f0 <chSysUnlock.lto_priv.421+0x30>)
 800b8d6:	699b      	ldr	r3, [r3, #24]
 800b8d8:	689a      	ldr	r2, [r3, #8]
 800b8da:	4b05      	ldr	r3, [pc, #20]	; (800b8f0 <chSysUnlock.lto_priv.421+0x30>)
 800b8dc:	681b      	ldr	r3, [r3, #0]
 800b8de:	689b      	ldr	r3, [r3, #8]
 800b8e0:	429a      	cmp	r2, r3
 800b8e2:	d202      	bcs.n	800b8ea <chSysUnlock.lto_priv.421+0x2a>
 800b8e4:	4803      	ldr	r0, [pc, #12]	; (800b8f4 <chSysUnlock.lto_priv.421+0x34>)
 800b8e6:	f000 f903 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800b8ea:	f7ff ff79 	bl	800b7e0 <port_unlock.lto_priv.437>
}
 800b8ee:	bd08      	pop	{r3, pc}
 800b8f0:	20000d30 	.word	0x20000d30
 800b8f4:	0800dbe0 	.word	0x0800dbe0
	...

0800b900 <chSysLockFromISR.lto_priv.447>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800b900:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800b902:	f7ff ff75 	bl	800b7f0 <port_lock_from_isr.lto_priv.452>
  _stats_start_measure_crit_isr();
 800b906:	f7fe fdab 	bl	800a460 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 800b90a:	f000 fa79 	bl	800be00 <_dbg_check_lock_from_isr>
}
 800b90e:	bd08      	pop	{r3, pc}

0800b910 <chSysUnlockFromISR.lto_priv.445>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800b910:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 800b912:	f000 fa8d 	bl	800be30 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 800b916:	f7fe fdab 	bl	800a470 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 800b91a:	f7ff ff71 	bl	800b800 <port_unlock_from_isr.lto_priv.449>
}
 800b91e:	bd08      	pop	{r3, pc}

0800b920 <chVTGetSystemTimeX.lto_priv.417>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 800b920:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 800b922:	f7ff ffb5 	bl	800b890 <port_timer_get_time.lto_priv.429>
 800b926:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800b928:	4618      	mov	r0, r3
 800b92a:	bd08      	pop	{r3, pc}
 800b92c:	0000      	movs	r0, r0
	...

0800b930 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 800b930:	b500      	push	{lr}
 800b932:	b085      	sub	sp, #20

  chDbgCheckClassI();
 800b934:	f000 fad4 	bl	800bee0 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 800b938:	4b32      	ldr	r3, [pc, #200]	; (800ba04 <chVTDoTickI+0xd4>)
 800b93a:	69db      	ldr	r3, [r3, #28]
 800b93c:	9303      	str	r3, [sp, #12]
  now = chVTGetSystemTimeX();
 800b93e:	f7ff ffef 	bl	800b920 <chVTGetSystemTimeX.lto_priv.417>
 800b942:	9002      	str	r0, [sp, #8]
 800b944:	e02a      	b.n	800b99c <chVTDoTickI+0x6c>
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 800b946:	4b2f      	ldr	r3, [pc, #188]	; (800ba04 <chVTDoTickI+0xd4>)
 800b948:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800b94a:	9b03      	ldr	r3, [sp, #12]
 800b94c:	689b      	ldr	r3, [r3, #8]
 800b94e:	4413      	add	r3, r2
 800b950:	4a2c      	ldr	r2, [pc, #176]	; (800ba04 <chVTDoTickI+0xd4>)
 800b952:	6293      	str	r3, [r2, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800b954:	9b03      	ldr	r3, [sp, #12]
 800b956:	681b      	ldr	r3, [r3, #0]
 800b958:	4a2b      	ldr	r2, [pc, #172]	; (800ba08 <chVTDoTickI+0xd8>)
 800b95a:	605a      	str	r2, [r3, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 800b95c:	9b03      	ldr	r3, [sp, #12]
 800b95e:	681b      	ldr	r3, [r3, #0]
 800b960:	4a28      	ldr	r2, [pc, #160]	; (800ba04 <chVTDoTickI+0xd4>)
 800b962:	61d3      	str	r3, [r2, #28]
    fn = vtp->vt_func;
 800b964:	9b03      	ldr	r3, [sp, #12]
 800b966:	68db      	ldr	r3, [r3, #12]
 800b968:	9300      	str	r3, [sp, #0]
    vtp->vt_func = NULL;
 800b96a:	9b03      	ldr	r3, [sp, #12]
 800b96c:	2200      	movs	r2, #0
 800b96e:	60da      	str	r2, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 800b970:	4b24      	ldr	r3, [pc, #144]	; (800ba04 <chVTDoTickI+0xd4>)
 800b972:	69db      	ldr	r3, [r3, #28]
 800b974:	4a24      	ldr	r2, [pc, #144]	; (800ba08 <chVTDoTickI+0xd8>)
 800b976:	4293      	cmp	r3, r2
 800b978:	d101      	bne.n	800b97e <chVTDoTickI+0x4e>
      port_timer_stop_alarm();
 800b97a:	f7ff ff71 	bl	800b860 <port_timer_stop_alarm.lto_priv.457>
    }

    /* Leaving the system critical zone in order to execute the callback
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();
 800b97e:	f7ff ffc7 	bl	800b910 <chSysUnlockFromISR.lto_priv.445>

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 800b982:	9b03      	ldr	r3, [sp, #12]
 800b984:	691a      	ldr	r2, [r3, #16]
 800b986:	9b00      	ldr	r3, [sp, #0]
 800b988:	4610      	mov	r0, r2
 800b98a:	4798      	blx	r3

    /* Re-entering the critical zone in order to continue the exploration
       of the list.*/
    chSysLockFromISR();
 800b98c:	f7ff ffb8 	bl	800b900 <chSysLockFromISR.lto_priv.447>

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 800b990:	4b1c      	ldr	r3, [pc, #112]	; (800ba04 <chVTDoTickI+0xd4>)
 800b992:	69db      	ldr	r3, [r3, #28]
 800b994:	9303      	str	r3, [sp, #12]
    now = chVTGetSystemTimeX();
 800b996:	f7ff ffc3 	bl	800b920 <chVTGetSystemTimeX.lto_priv.417>
 800b99a:	9002      	str	r0, [sp, #8]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 800b99c:	9b03      	ldr	r3, [sp, #12]
 800b99e:	689a      	ldr	r2, [r3, #8]
 800b9a0:	4b18      	ldr	r3, [pc, #96]	; (800ba04 <chVTDoTickI+0xd4>)
 800b9a2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b9a4:	9902      	ldr	r1, [sp, #8]
 800b9a6:	1acb      	subs	r3, r1, r3
 800b9a8:	429a      	cmp	r2, r3
 800b9aa:	d9cc      	bls.n	800b946 <chVTDoTickI+0x16>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 800b9ac:	4b15      	ldr	r3, [pc, #84]	; (800ba04 <chVTDoTickI+0xd4>)
 800b9ae:	69db      	ldr	r3, [r3, #28]
 800b9b0:	4a15      	ldr	r2, [pc, #84]	; (800ba08 <chVTDoTickI+0xd8>)
 800b9b2:	4293      	cmp	r3, r2
 800b9b4:	d023      	beq.n	800b9fe <chVTDoTickI+0xce>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 800b9b6:	4b13      	ldr	r3, [pc, #76]	; (800ba04 <chVTDoTickI+0xd4>)
 800b9b8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800b9ba:	9b03      	ldr	r3, [sp, #12]
 800b9bc:	689b      	ldr	r3, [r3, #8]
 800b9be:	441a      	add	r2, r3
 800b9c0:	9b02      	ldr	r3, [sp, #8]
 800b9c2:	1ad3      	subs	r3, r2, r3
 800b9c4:	9301      	str	r3, [sp, #4]
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800b9c6:	9b01      	ldr	r3, [sp, #4]
 800b9c8:	2b01      	cmp	r3, #1
 800b9ca:	d801      	bhi.n	800b9d0 <chVTDoTickI+0xa0>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800b9cc:	2302      	movs	r3, #2
 800b9ce:	9301      	str	r3, [sp, #4]
  }
  port_timer_set_alarm(now + delta);
 800b9d0:	9a02      	ldr	r2, [sp, #8]
 800b9d2:	9b01      	ldr	r3, [sp, #4]
 800b9d4:	4413      	add	r3, r2
 800b9d6:	4618      	mov	r0, r3
 800b9d8:	f7ff ff4a 	bl	800b870 <port_timer_set_alarm.lto_priv.455>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
 800b9dc:	f7ff ffa0 	bl	800b920 <chVTGetSystemTimeX.lto_priv.417>
 800b9e0:	4602      	mov	r2, r0
 800b9e2:	4b08      	ldr	r3, [pc, #32]	; (800ba04 <chVTDoTickI+0xd4>)
 800b9e4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b9e6:	1ad2      	subs	r2, r2, r3
 800b9e8:	9902      	ldr	r1, [sp, #8]
 800b9ea:	9b01      	ldr	r3, [sp, #4]
 800b9ec:	4419      	add	r1, r3
 800b9ee:	4b05      	ldr	r3, [pc, #20]	; (800ba04 <chVTDoTickI+0xd4>)
 800b9f0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b9f2:	1acb      	subs	r3, r1, r3
 800b9f4:	429a      	cmp	r2, r3
 800b9f6:	d902      	bls.n	800b9fe <chVTDoTickI+0xce>
 800b9f8:	4804      	ldr	r0, [pc, #16]	; (800ba0c <chVTDoTickI+0xdc>)
 800b9fa:	f000 f879 	bl	800baf0 <chSysHalt>
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800b9fe:	b005      	add	sp, #20
 800ba00:	f85d fb04 	ldr.w	pc, [sp], #4
 800ba04:	20000d30 	.word	0x20000d30
 800ba08:	20000d4c 	.word	0x20000d4c
 800ba0c:	0800dbd0 	.word	0x0800dbd0

0800ba10 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 800ba10:	b082      	sub	sp, #8
 800ba12:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 800ba14:	4b02      	ldr	r3, [pc, #8]	; (800ba20 <chRegSetThreadName+0x10>)
 800ba16:	699b      	ldr	r3, [r3, #24]
 800ba18:	9a01      	ldr	r2, [sp, #4]
 800ba1a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 800ba1c:	b002      	add	sp, #8
 800ba1e:	4770      	bx	lr
 800ba20:	20000d30 	.word	0x20000d30
	...

0800ba30 <chRegSetThreadNameX>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
 800ba30:	b082      	sub	sp, #8
 800ba32:	9001      	str	r0, [sp, #4]
 800ba34:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 800ba36:	9b01      	ldr	r3, [sp, #4]
 800ba38:	9a00      	ldr	r2, [sp, #0]
 800ba3a:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
 800ba3c:	b002      	add	sp, #8
 800ba3e:	4770      	bx	lr

0800ba40 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 800ba40:	b500      	push	{lr}
 800ba42:	b083      	sub	sp, #12
 800ba44:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 800ba46:	f7ff fefb 	bl	800b840 <port_wait_for_interrupt>
 800ba4a:	e7fc      	b.n	800ba46 <_idle_thread+0x6>
 800ba4c:	0000      	movs	r0, r0
	...

0800ba50 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 800ba50:	b500      	push	{lr}
 800ba52:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 800ba54:	f7ff fe64 	bl	800b720 <port_init>
  _scheduler_init();
 800ba58:	f000 fcba 	bl	800c3d0 <_scheduler_init>
  _vt_init();
 800ba5c:	f000 faf0 	bl	800c040 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 800ba60:	f001 fafe 	bl	800d060 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 800ba64:	f7fc fe84 	bl	8008770 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 800ba68:	f7fc fee2 	bl	8008830 <_heap_init>
#endif
#if CH_DBG_STATISTICS == TRUE
  _stats_init();
 800ba6c:	f7fe fca0 	bl	800a3b0 <_stats_init>
#endif
#if CH_DBG_ENABLE_TRACE == TRUE
  _dbg_trace_init();
 800ba70:	f000 fa66 	bl	800bf40 <_dbg_trace_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 800ba74:	4815      	ldr	r0, [pc, #84]	; (800bacc <chSysInit+0x7c>)
 800ba76:	2140      	movs	r1, #64	; 0x40
 800ba78:	f001 f82a 	bl	800cad0 <_thread_init>
 800ba7c:	4602      	mov	r2, r0
 800ba7e:	4b14      	ldr	r3, [pc, #80]	; (800bad0 <chSysInit+0x80>)
 800ba80:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 800ba82:	4b13      	ldr	r3, [pc, #76]	; (800bad0 <chSysInit+0x80>)
 800ba84:	699b      	ldr	r3, [r3, #24]
 800ba86:	2201      	movs	r2, #1
 800ba88:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  /* This is a special case because the main thread thread_t structure is not
     adjacent to its stack area.*/
  currp->p_stklimit = &__main_thread_stack_base__;
 800ba8c:	4b10      	ldr	r3, [pc, #64]	; (800bad0 <chSysInit+0x80>)
 800ba8e:	699b      	ldr	r3, [r3, #24]
 800ba90:	4a10      	ldr	r2, [pc, #64]	; (800bad4 <chSysInit+0x84>)
 800ba92:	61da      	str	r2, [r3, #28]
#endif

#if CH_DBG_STATISTICS == TRUE
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->p_stats);
 800ba94:	4b0e      	ldr	r3, [pc, #56]	; (800bad0 <chSysInit+0x80>)
 800ba96:	699b      	ldr	r3, [r3, #24]
 800ba98:	3348      	adds	r3, #72	; 0x48
 800ba9a:	4618      	mov	r0, r3
 800ba9c:	f7fe fc28 	bl	800a2f0 <chTMStartMeasurementX>
#endif

  chSysEnable();
 800baa0:	f7ff fefe 	bl	800b8a0 <chSysEnable>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
 800baa4:	480c      	ldr	r0, [pc, #48]	; (800bad8 <chSysInit+0x88>)
 800baa6:	f7ff ffb3 	bl	800ba10 <chRegSetThreadName>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 800baaa:	2300      	movs	r3, #0
 800baac:	9300      	str	r3, [sp, #0]
 800baae:	480b      	ldr	r0, [pc, #44]	; (800badc <chSysInit+0x8c>)
 800bab0:	21f8      	movs	r1, #248	; 0xf8
 800bab2:	2201      	movs	r2, #1
 800bab4:	4b0a      	ldr	r3, [pc, #40]	; (800bae0 <chSysInit+0x90>)
 800bab6:	f001 f8a3 	bl	800cc00 <chThdCreateStatic>
 800baba:	9003      	str	r0, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
 800babc:	9803      	ldr	r0, [sp, #12]
 800babe:	4909      	ldr	r1, [pc, #36]	; (800bae4 <chSysInit+0x94>)
 800bac0:	f7ff ffb6 	bl	800ba30 <chRegSetThreadNameX>
  }
#endif
}
 800bac4:	b005      	add	sp, #20
 800bac6:	f85d fb04 	ldr.w	pc, [sp], #4
 800baca:	bf00      	nop
 800bacc:	20001170 	.word	0x20001170
 800bad0:	20000d30 	.word	0x20000d30
 800bad4:	20000400 	.word	0x20000400
 800bad8:	0800dd50 	.word	0x0800dd50
 800badc:	20001210 	.word	0x20001210
 800bae0:	0800ba41 	.word	0x0800ba41
 800bae4:	0800dae0 	.word	0x0800dae0
	...

0800baf0 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 800baf0:	b500      	push	{lr}
 800baf2:	b083      	sub	sp, #12
 800baf4:	9001      	str	r0, [sp, #4]

  port_disable();
 800baf6:	f7ff fe8b 	bl	800b810 <port_disable>
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800bafa:	4a02      	ldr	r2, [pc, #8]	; (800bb04 <chSysHalt+0x14>)
 800bafc:	9b01      	ldr	r3, [sp, #4]
 800bafe:	62d3      	str	r3, [r2, #44]	; 0x2c
 800bb00:	e7fe      	b.n	800bb00 <chSysHalt+0x10>
 800bb02:	bf00      	nop
 800bb04:	20000d30 	.word	0x20000d30
	...

0800bb10 <chSysIntegrityCheckI>:
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @iclass
 */
bool chSysIntegrityCheckI(unsigned testmask) {
 800bb10:	b500      	push	{lr}
 800bb12:	b087      	sub	sp, #28
 800bb14:	9001      	str	r0, [sp, #4]
  cnt_t n;

  chDbgCheckClassI();
 800bb16:	f000 f9e3 	bl	800bee0 <chDbgCheckClassI>

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 800bb1a:	9b01      	ldr	r3, [sp, #4]
 800bb1c:	f003 0301 	and.w	r3, r3, #1
 800bb20:	2b00      	cmp	r3, #0
 800bb22:	d022      	beq.n	800bb6a <chSysIntegrityCheckI+0x5a>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 800bb24:	2300      	movs	r3, #0
 800bb26:	9305      	str	r3, [sp, #20]
    tp = ch.rlist.r_queue.p_next;
 800bb28:	4b3a      	ldr	r3, [pc, #232]	; (800bc14 <chSysIntegrityCheckI+0x104>)
 800bb2a:	681b      	ldr	r3, [r3, #0]
 800bb2c:	9304      	str	r3, [sp, #16]
 800bb2e:	e005      	b.n	800bb3c <chSysIntegrityCheckI+0x2c>
    while (tp != (thread_t *)&ch.rlist.r_queue) {
      n++;
 800bb30:	9b05      	ldr	r3, [sp, #20]
 800bb32:	3301      	adds	r3, #1
 800bb34:	9305      	str	r3, [sp, #20]
      tp = tp->p_next;
 800bb36:	9b04      	ldr	r3, [sp, #16]
 800bb38:	681b      	ldr	r3, [r3, #0]
 800bb3a:	9304      	str	r3, [sp, #16]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 800bb3c:	9b04      	ldr	r3, [sp, #16]
 800bb3e:	4a35      	ldr	r2, [pc, #212]	; (800bc14 <chSysIntegrityCheckI+0x104>)
 800bb40:	4293      	cmp	r3, r2
 800bb42:	d1f5      	bne.n	800bb30 <chSysIntegrityCheckI+0x20>
      n++;
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
 800bb44:	4b33      	ldr	r3, [pc, #204]	; (800bc14 <chSysIntegrityCheckI+0x104>)
 800bb46:	685b      	ldr	r3, [r3, #4]
 800bb48:	9304      	str	r3, [sp, #16]
 800bb4a:	e005      	b.n	800bb58 <chSysIntegrityCheckI+0x48>
    while (tp != (thread_t *)&ch.rlist.r_queue) {
      n--;
 800bb4c:	9b05      	ldr	r3, [sp, #20]
 800bb4e:	3b01      	subs	r3, #1
 800bb50:	9305      	str	r3, [sp, #20]
      tp = tp->p_prev;
 800bb52:	9b04      	ldr	r3, [sp, #16]
 800bb54:	685b      	ldr	r3, [r3, #4]
 800bb56:	9304      	str	r3, [sp, #16]
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 800bb58:	9b04      	ldr	r3, [sp, #16]
 800bb5a:	4a2e      	ldr	r2, [pc, #184]	; (800bc14 <chSysIntegrityCheckI+0x104>)
 800bb5c:	4293      	cmp	r3, r2
 800bb5e:	d1f5      	bne.n	800bb4c <chSysIntegrityCheckI+0x3c>
      n--;
      tp = tp->p_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800bb60:	9b05      	ldr	r3, [sp, #20]
 800bb62:	2b00      	cmp	r3, #0
 800bb64:	d001      	beq.n	800bb6a <chSysIntegrityCheckI+0x5a>
      return true;
 800bb66:	2301      	movs	r3, #1
 800bb68:	e050      	b.n	800bc0c <chSysIntegrityCheckI+0xfc>
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 800bb6a:	9b01      	ldr	r3, [sp, #4]
 800bb6c:	f003 0302 	and.w	r3, r3, #2
 800bb70:	2b00      	cmp	r3, #0
 800bb72:	d022      	beq.n	800bbba <chSysIntegrityCheckI+0xaa>
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
 800bb74:	2300      	movs	r3, #0
 800bb76:	9305      	str	r3, [sp, #20]
    vtp = ch.vtlist.vt_next;
 800bb78:	4b26      	ldr	r3, [pc, #152]	; (800bc14 <chSysIntegrityCheckI+0x104>)
 800bb7a:	69db      	ldr	r3, [r3, #28]
 800bb7c:	9303      	str	r3, [sp, #12]
 800bb7e:	e005      	b.n	800bb8c <chSysIntegrityCheckI+0x7c>
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
      n++;
 800bb80:	9b05      	ldr	r3, [sp, #20]
 800bb82:	3301      	adds	r3, #1
 800bb84:	9305      	str	r3, [sp, #20]
      vtp = vtp->vt_next;
 800bb86:	9b03      	ldr	r3, [sp, #12]
 800bb88:	681b      	ldr	r3, [r3, #0]
 800bb8a:	9303      	str	r3, [sp, #12]
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800bb8c:	9b03      	ldr	r3, [sp, #12]
 800bb8e:	4a22      	ldr	r2, [pc, #136]	; (800bc18 <chSysIntegrityCheckI+0x108>)
 800bb90:	4293      	cmp	r3, r2
 800bb92:	d1f5      	bne.n	800bb80 <chSysIntegrityCheckI+0x70>
      n++;
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
 800bb94:	4b1f      	ldr	r3, [pc, #124]	; (800bc14 <chSysIntegrityCheckI+0x104>)
 800bb96:	6a1b      	ldr	r3, [r3, #32]
 800bb98:	9303      	str	r3, [sp, #12]
 800bb9a:	e005      	b.n	800bba8 <chSysIntegrityCheckI+0x98>
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
      n--;
 800bb9c:	9b05      	ldr	r3, [sp, #20]
 800bb9e:	3b01      	subs	r3, #1
 800bba0:	9305      	str	r3, [sp, #20]
      vtp = vtp->vt_prev;
 800bba2:	9b03      	ldr	r3, [sp, #12]
 800bba4:	685b      	ldr	r3, [r3, #4]
 800bba6:	9303      	str	r3, [sp, #12]
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800bba8:	9b03      	ldr	r3, [sp, #12]
 800bbaa:	4a1b      	ldr	r2, [pc, #108]	; (800bc18 <chSysIntegrityCheckI+0x108>)
 800bbac:	4293      	cmp	r3, r2
 800bbae:	d1f5      	bne.n	800bb9c <chSysIntegrityCheckI+0x8c>
      n--;
      vtp = vtp->vt_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800bbb0:	9b05      	ldr	r3, [sp, #20]
 800bbb2:	2b00      	cmp	r3, #0
 800bbb4:	d001      	beq.n	800bbba <chSysIntegrityCheckI+0xaa>
      return true;
 800bbb6:	2301      	movs	r3, #1
 800bbb8:	e028      	b.n	800bc0c <chSysIntegrityCheckI+0xfc>
    }
  }

#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 800bbba:	9b01      	ldr	r3, [sp, #4]
 800bbbc:	f003 0304 	and.w	r3, r3, #4
 800bbc0:	2b00      	cmp	r3, #0
 800bbc2:	d022      	beq.n	800bc0a <chSysIntegrityCheckI+0xfa>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 800bbc4:	2300      	movs	r3, #0
 800bbc6:	9305      	str	r3, [sp, #20]
    tp = ch.rlist.r_newer;
 800bbc8:	4b12      	ldr	r3, [pc, #72]	; (800bc14 <chSysIntegrityCheckI+0x104>)
 800bbca:	691b      	ldr	r3, [r3, #16]
 800bbcc:	9302      	str	r3, [sp, #8]
 800bbce:	e005      	b.n	800bbdc <chSysIntegrityCheckI+0xcc>
    while (tp != (thread_t *)&ch.rlist) {
      n++;
 800bbd0:	9b05      	ldr	r3, [sp, #20]
 800bbd2:	3301      	adds	r3, #1
 800bbd4:	9305      	str	r3, [sp, #20]
      tp = tp->p_newer;
 800bbd6:	9b02      	ldr	r3, [sp, #8]
 800bbd8:	691b      	ldr	r3, [r3, #16]
 800bbda:	9302      	str	r3, [sp, #8]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
    while (tp != (thread_t *)&ch.rlist) {
 800bbdc:	9b02      	ldr	r3, [sp, #8]
 800bbde:	4a0d      	ldr	r2, [pc, #52]	; (800bc14 <chSysIntegrityCheckI+0x104>)
 800bbe0:	4293      	cmp	r3, r2
 800bbe2:	d1f5      	bne.n	800bbd0 <chSysIntegrityCheckI+0xc0>
      n++;
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
 800bbe4:	4b0b      	ldr	r3, [pc, #44]	; (800bc14 <chSysIntegrityCheckI+0x104>)
 800bbe6:	695b      	ldr	r3, [r3, #20]
 800bbe8:	9302      	str	r3, [sp, #8]
 800bbea:	e005      	b.n	800bbf8 <chSysIntegrityCheckI+0xe8>
    while (tp != (thread_t *)&ch.rlist) {
      n--;
 800bbec:	9b05      	ldr	r3, [sp, #20]
 800bbee:	3b01      	subs	r3, #1
 800bbf0:	9305      	str	r3, [sp, #20]
      tp = tp->p_older;
 800bbf2:	9b02      	ldr	r3, [sp, #8]
 800bbf4:	695b      	ldr	r3, [r3, #20]
 800bbf6:	9302      	str	r3, [sp, #8]
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
    while (tp != (thread_t *)&ch.rlist) {
 800bbf8:	9b02      	ldr	r3, [sp, #8]
 800bbfa:	4a06      	ldr	r2, [pc, #24]	; (800bc14 <chSysIntegrityCheckI+0x104>)
 800bbfc:	4293      	cmp	r3, r2
 800bbfe:	d1f5      	bne.n	800bbec <chSysIntegrityCheckI+0xdc>
      n--;
      tp = tp->p_older;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800bc00:	9b05      	ldr	r3, [sp, #20]
 800bc02:	2b00      	cmp	r3, #0
 800bc04:	d001      	beq.n	800bc0a <chSysIntegrityCheckI+0xfa>
      return true;
 800bc06:	2301      	movs	r3, #1
 800bc08:	e000      	b.n	800bc0c <chSysIntegrityCheckI+0xfc>
  if ((testmask & CH_INTEGRITY_PORT) != 0U) {
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
 800bc0a:	2300      	movs	r3, #0
}
 800bc0c:	4618      	mov	r0, r3
 800bc0e:	b007      	add	sp, #28
 800bc10:	f85d fb04 	ldr.w	pc, [sp], #4
 800bc14:	20000d30 	.word	0x20000d30
 800bc18:	20000d4c 	.word	0x20000d4c
 800bc1c:	00000000 	.word	0x00000000

0800bc20 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 800bc20:	b508      	push	{r3, lr}

  chDbgCheckClassI();
 800bc22:	f000 f95d 	bl	800bee0 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
 800bc26:	f7ff fe83 	bl	800b930 <chVTDoTickI>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 800bc2a:	bd08      	pop	{r3, pc}
 800bc2c:	0000      	movs	r0, r0
	...

0800bc30 <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {
 800bc30:	b500      	push	{lr}
 800bc32:	b083      	sub	sp, #12

  syssts_t sts = port_get_irq_status();
 800bc34:	f7ff fd9c 	bl	800b770 <port_get_irq_status>
 800bc38:	9001      	str	r0, [sp, #4]
  if (port_irq_enabled(sts)) {
 800bc3a:	9801      	ldr	r0, [sp, #4]
 800bc3c:	f7ff fda8 	bl	800b790 <port_irq_enabled>
 800bc40:	4603      	mov	r3, r0
 800bc42:	2b00      	cmp	r3, #0
 800bc44:	d009      	beq.n	800bc5a <chSysGetStatusAndLockX+0x2a>
    if (port_is_isr_context()) {
 800bc46:	f7ff fdb3 	bl	800b7b0 <port_is_isr_context>
 800bc4a:	4603      	mov	r3, r0
 800bc4c:	2b00      	cmp	r3, #0
 800bc4e:	d002      	beq.n	800bc56 <chSysGetStatusAndLockX+0x26>
      chSysLockFromISR();
 800bc50:	f7ff fe56 	bl	800b900 <chSysLockFromISR.lto_priv.447>
 800bc54:	e001      	b.n	800bc5a <chSysGetStatusAndLockX+0x2a>
    }
    else {
      chSysLock();
 800bc56:	f7ff fe2b 	bl	800b8b0 <chSysLock.lto_priv.423>
    }
  }
  return sts;
 800bc5a:	9b01      	ldr	r3, [sp, #4]
}
 800bc5c:	4618      	mov	r0, r3
 800bc5e:	b003      	add	sp, #12
 800bc60:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800bc70 <chSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 800bc70:	b500      	push	{lr}
 800bc72:	b083      	sub	sp, #12
 800bc74:	9001      	str	r0, [sp, #4]

  if (port_irq_enabled(sts)) {
 800bc76:	9801      	ldr	r0, [sp, #4]
 800bc78:	f7ff fd8a 	bl	800b790 <port_irq_enabled>
 800bc7c:	4603      	mov	r3, r0
 800bc7e:	2b00      	cmp	r3, #0
 800bc80:	d00b      	beq.n	800bc9a <chSysRestoreStatusX+0x2a>
    if (port_is_isr_context()) {
 800bc82:	f7ff fd95 	bl	800b7b0 <port_is_isr_context>
 800bc86:	4603      	mov	r3, r0
 800bc88:	2b00      	cmp	r3, #0
 800bc8a:	d002      	beq.n	800bc92 <chSysRestoreStatusX+0x22>
      chSysUnlockFromISR();
 800bc8c:	f7ff fe40 	bl	800b910 <chSysUnlockFromISR.lto_priv.445>
 800bc90:	e003      	b.n	800bc9a <chSysRestoreStatusX+0x2a>
    }
    else {
      chSchRescheduleS();
 800bc92:	f000 fcfd 	bl	800c690 <chSchRescheduleS>
      chSysUnlock();
 800bc96:	f7ff fe13 	bl	800b8c0 <chSysUnlock.lto_priv.421>
    }
  }
}
 800bc9a:	b003      	add	sp, #12
 800bc9c:	f85d fb04 	ldr.w	pc, [sp], #4

0800bca0 <port_lock.lto_priv.442>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800bca0:	b082      	sub	sp, #8
 800bca2:	2320      	movs	r3, #32
 800bca4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800bca6:	9b01      	ldr	r3, [sp, #4]
 800bca8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800bcac:	b002      	add	sp, #8
 800bcae:	4770      	bx	lr

0800bcb0 <port_unlock.lto_priv.438>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800bcb0:	b082      	sub	sp, #8
 800bcb2:	2300      	movs	r3, #0
 800bcb4:	9301      	str	r3, [sp, #4]
 800bcb6:	9b01      	ldr	r3, [sp, #4]
 800bcb8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800bcbc:	b002      	add	sp, #8
 800bcbe:	4770      	bx	lr

0800bcc0 <port_lock_from_isr.lto_priv.453>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800bcc0:	b508      	push	{r3, lr}

  port_lock();
 800bcc2:	f7ff ffed 	bl	800bca0 <port_lock.lto_priv.442>
}
 800bcc6:	bd08      	pop	{r3, pc}
	...

0800bcd0 <port_unlock_from_isr.lto_priv.450>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800bcd0:	b508      	push	{r3, lr}

  port_unlock();
 800bcd2:	f7ff ffed 	bl	800bcb0 <port_unlock.lto_priv.438>
}
 800bcd6:	bd08      	pop	{r3, pc}
	...

0800bce0 <st_lld_get_counter.lto_priv.434>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800bce0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800bce4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800bce6:	4618      	mov	r0, r3
 800bce8:	4770      	bx	lr
 800bcea:	bf00      	nop
 800bcec:	0000      	movs	r0, r0
	...

0800bcf0 <port_timer_get_time.lto_priv.430>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 800bcf0:	b508      	push	{r3, lr}

  return stGetCounter();
 800bcf2:	f7ff fff5 	bl	800bce0 <st_lld_get_counter.lto_priv.434>
 800bcf6:	4603      	mov	r3, r0
}
 800bcf8:	4618      	mov	r0, r3
 800bcfa:	bd08      	pop	{r3, pc}
 800bcfc:	0000      	movs	r0, r0
	...

0800bd00 <chVTGetSystemTimeX.lto_priv.418>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 800bd00:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 800bd02:	f7ff fff5 	bl	800bcf0 <port_timer_get_time.lto_priv.430>
 800bd06:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800bd08:	4618      	mov	r0, r3
 800bd0a:	bd08      	pop	{r3, pc}
 800bd0c:	0000      	movs	r0, r0
	...

0800bd10 <_dbg_check_disable>:
/**
 * @brief   Guard code for @p chSysDisable().
 *
 * @notapi
 */
void _dbg_check_disable(void) {
 800bd10:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800bd12:	4b06      	ldr	r3, [pc, #24]	; (800bd2c <_dbg_check_disable+0x1c>)
 800bd14:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bd16:	2b00      	cmp	r3, #0
 800bd18:	d103      	bne.n	800bd22 <_dbg_check_disable+0x12>
 800bd1a:	4b04      	ldr	r3, [pc, #16]	; (800bd2c <_dbg_check_disable+0x1c>)
 800bd1c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800bd1e:	2b00      	cmp	r3, #0
 800bd20:	d002      	beq.n	800bd28 <_dbg_check_disable+0x18>
    chSysHalt("SV#1");
 800bd22:	4803      	ldr	r0, [pc, #12]	; (800bd30 <_dbg_check_disable+0x20>)
 800bd24:	f7ff fee4 	bl	800baf0 <chSysHalt>
  }
}
 800bd28:	bd08      	pop	{r3, pc}
 800bd2a:	bf00      	nop
 800bd2c:	20000d30 	.word	0x20000d30
 800bd30:	0800dae8 	.word	0x0800dae8
	...

0800bd40 <_dbg_check_suspend>:
/**
 * @brief   Guard code for @p chSysSuspend().
 *
 * @notapi
 */
void _dbg_check_suspend(void) {
 800bd40:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800bd42:	4b06      	ldr	r3, [pc, #24]	; (800bd5c <_dbg_check_suspend+0x1c>)
 800bd44:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bd46:	2b00      	cmp	r3, #0
 800bd48:	d103      	bne.n	800bd52 <_dbg_check_suspend+0x12>
 800bd4a:	4b04      	ldr	r3, [pc, #16]	; (800bd5c <_dbg_check_suspend+0x1c>)
 800bd4c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800bd4e:	2b00      	cmp	r3, #0
 800bd50:	d002      	beq.n	800bd58 <_dbg_check_suspend+0x18>
    chSysHalt("SV#2");
 800bd52:	4803      	ldr	r0, [pc, #12]	; (800bd60 <_dbg_check_suspend+0x20>)
 800bd54:	f7ff fecc 	bl	800baf0 <chSysHalt>
  }
}
 800bd58:	bd08      	pop	{r3, pc}
 800bd5a:	bf00      	nop
 800bd5c:	20000d30 	.word	0x20000d30
 800bd60:	0800daf0 	.word	0x0800daf0
	...

0800bd70 <_dbg_check_enable>:
/**
 * @brief   Guard code for @p chSysEnable().
 *
 * @notapi
 */
void _dbg_check_enable(void) {
 800bd70:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800bd72:	4b06      	ldr	r3, [pc, #24]	; (800bd8c <_dbg_check_enable+0x1c>)
 800bd74:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bd76:	2b00      	cmp	r3, #0
 800bd78:	d103      	bne.n	800bd82 <_dbg_check_enable+0x12>
 800bd7a:	4b04      	ldr	r3, [pc, #16]	; (800bd8c <_dbg_check_enable+0x1c>)
 800bd7c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800bd7e:	2b00      	cmp	r3, #0
 800bd80:	d002      	beq.n	800bd88 <_dbg_check_enable+0x18>
    chSysHalt("SV#3");
 800bd82:	4803      	ldr	r0, [pc, #12]	; (800bd90 <_dbg_check_enable+0x20>)
 800bd84:	f7ff feb4 	bl	800baf0 <chSysHalt>
  }
}
 800bd88:	bd08      	pop	{r3, pc}
 800bd8a:	bf00      	nop
 800bd8c:	20000d30 	.word	0x20000d30
 800bd90:	0800daf8 	.word	0x0800daf8
	...

0800bda0 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
 800bda0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800bda2:	4b07      	ldr	r3, [pc, #28]	; (800bdc0 <_dbg_check_lock+0x20>)
 800bda4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bda6:	2b00      	cmp	r3, #0
 800bda8:	d103      	bne.n	800bdb2 <_dbg_check_lock+0x12>
 800bdaa:	4b05      	ldr	r3, [pc, #20]	; (800bdc0 <_dbg_check_lock+0x20>)
 800bdac:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800bdae:	2b00      	cmp	r3, #0
 800bdb0:	d002      	beq.n	800bdb8 <_dbg_check_lock+0x18>
    chSysHalt("SV#4");
 800bdb2:	4804      	ldr	r0, [pc, #16]	; (800bdc4 <_dbg_check_lock+0x24>)
 800bdb4:	f7ff fe9c 	bl	800baf0 <chSysHalt>
  }
  _dbg_enter_lock();
 800bdb8:	4b01      	ldr	r3, [pc, #4]	; (800bdc0 <_dbg_check_lock+0x20>)
 800bdba:	2201      	movs	r2, #1
 800bdbc:	635a      	str	r2, [r3, #52]	; 0x34
}
 800bdbe:	bd08      	pop	{r3, pc}
 800bdc0:	20000d30 	.word	0x20000d30
 800bdc4:	0800db00 	.word	0x0800db00
	...

0800bdd0 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
 800bdd0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800bdd2:	4b07      	ldr	r3, [pc, #28]	; (800bdf0 <_dbg_check_unlock+0x20>)
 800bdd4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bdd6:	2b00      	cmp	r3, #0
 800bdd8:	d103      	bne.n	800bde2 <_dbg_check_unlock+0x12>
 800bdda:	4b05      	ldr	r3, [pc, #20]	; (800bdf0 <_dbg_check_unlock+0x20>)
 800bddc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800bdde:	2b00      	cmp	r3, #0
 800bde0:	dc02      	bgt.n	800bde8 <_dbg_check_unlock+0x18>
    chSysHalt("SV#5");
 800bde2:	4804      	ldr	r0, [pc, #16]	; (800bdf4 <_dbg_check_unlock+0x24>)
 800bde4:	f7ff fe84 	bl	800baf0 <chSysHalt>
  }
  _dbg_leave_lock();
 800bde8:	4b01      	ldr	r3, [pc, #4]	; (800bdf0 <_dbg_check_unlock+0x20>)
 800bdea:	2200      	movs	r2, #0
 800bdec:	635a      	str	r2, [r3, #52]	; 0x34
}
 800bdee:	bd08      	pop	{r3, pc}
 800bdf0:	20000d30 	.word	0x20000d30
 800bdf4:	0800db08 	.word	0x0800db08
	...

0800be00 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
 800be00:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800be02:	4b07      	ldr	r3, [pc, #28]	; (800be20 <_dbg_check_lock_from_isr+0x20>)
 800be04:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800be06:	2b00      	cmp	r3, #0
 800be08:	dd03      	ble.n	800be12 <_dbg_check_lock_from_isr+0x12>
 800be0a:	4b05      	ldr	r3, [pc, #20]	; (800be20 <_dbg_check_lock_from_isr+0x20>)
 800be0c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800be0e:	2b00      	cmp	r3, #0
 800be10:	d002      	beq.n	800be18 <_dbg_check_lock_from_isr+0x18>
    chSysHalt("SV#6");
 800be12:	4804      	ldr	r0, [pc, #16]	; (800be24 <_dbg_check_lock_from_isr+0x24>)
 800be14:	f7ff fe6c 	bl	800baf0 <chSysHalt>
  }
  _dbg_enter_lock();
 800be18:	4b01      	ldr	r3, [pc, #4]	; (800be20 <_dbg_check_lock_from_isr+0x20>)
 800be1a:	2201      	movs	r2, #1
 800be1c:	635a      	str	r2, [r3, #52]	; 0x34
}
 800be1e:	bd08      	pop	{r3, pc}
 800be20:	20000d30 	.word	0x20000d30
 800be24:	0800db10 	.word	0x0800db10
	...

0800be30 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
 800be30:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800be32:	4b07      	ldr	r3, [pc, #28]	; (800be50 <_dbg_check_unlock_from_isr+0x20>)
 800be34:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800be36:	2b00      	cmp	r3, #0
 800be38:	dd03      	ble.n	800be42 <_dbg_check_unlock_from_isr+0x12>
 800be3a:	4b05      	ldr	r3, [pc, #20]	; (800be50 <_dbg_check_unlock_from_isr+0x20>)
 800be3c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800be3e:	2b00      	cmp	r3, #0
 800be40:	dc02      	bgt.n	800be48 <_dbg_check_unlock_from_isr+0x18>
    chSysHalt("SV#7");
 800be42:	4804      	ldr	r0, [pc, #16]	; (800be54 <_dbg_check_unlock_from_isr+0x24>)
 800be44:	f7ff fe54 	bl	800baf0 <chSysHalt>
  }
  _dbg_leave_lock();
 800be48:	4b01      	ldr	r3, [pc, #4]	; (800be50 <_dbg_check_unlock_from_isr+0x20>)
 800be4a:	2200      	movs	r2, #0
 800be4c:	635a      	str	r2, [r3, #52]	; 0x34
}
 800be4e:	bd08      	pop	{r3, pc}
 800be50:	20000d30 	.word	0x20000d30
 800be54:	0800db18 	.word	0x0800db18
	...

0800be60 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
 800be60:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800be62:	f7ff ff2d 	bl	800bcc0 <port_lock_from_isr.lto_priv.453>
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800be66:	4b09      	ldr	r3, [pc, #36]	; (800be8c <_dbg_check_enter_isr+0x2c>)
 800be68:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800be6a:	2b00      	cmp	r3, #0
 800be6c:	db03      	blt.n	800be76 <_dbg_check_enter_isr+0x16>
 800be6e:	4b07      	ldr	r3, [pc, #28]	; (800be8c <_dbg_check_enter_isr+0x2c>)
 800be70:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800be72:	2b00      	cmp	r3, #0
 800be74:	d002      	beq.n	800be7c <_dbg_check_enter_isr+0x1c>
    chSysHalt("SV#8");
 800be76:	4806      	ldr	r0, [pc, #24]	; (800be90 <_dbg_check_enter_isr+0x30>)
 800be78:	f7ff fe3a 	bl	800baf0 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 800be7c:	4b03      	ldr	r3, [pc, #12]	; (800be8c <_dbg_check_enter_isr+0x2c>)
 800be7e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800be80:	3301      	adds	r3, #1
 800be82:	4a02      	ldr	r2, [pc, #8]	; (800be8c <_dbg_check_enter_isr+0x2c>)
 800be84:	6313      	str	r3, [r2, #48]	; 0x30
  port_unlock_from_isr();
 800be86:	f7ff ff23 	bl	800bcd0 <port_unlock_from_isr.lto_priv.450>
}
 800be8a:	bd08      	pop	{r3, pc}
 800be8c:	20000d30 	.word	0x20000d30
 800be90:	0800db20 	.word	0x0800db20
	...

0800bea0 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
 800bea0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800bea2:	f7ff ff0d 	bl	800bcc0 <port_lock_from_isr.lto_priv.453>
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800bea6:	4b09      	ldr	r3, [pc, #36]	; (800becc <_dbg_check_leave_isr+0x2c>)
 800bea8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800beaa:	2b00      	cmp	r3, #0
 800beac:	dd03      	ble.n	800beb6 <_dbg_check_leave_isr+0x16>
 800beae:	4b07      	ldr	r3, [pc, #28]	; (800becc <_dbg_check_leave_isr+0x2c>)
 800beb0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800beb2:	2b00      	cmp	r3, #0
 800beb4:	d002      	beq.n	800bebc <_dbg_check_leave_isr+0x1c>
    chSysHalt("SV#9");
 800beb6:	4806      	ldr	r0, [pc, #24]	; (800bed0 <_dbg_check_leave_isr+0x30>)
 800beb8:	f7ff fe1a 	bl	800baf0 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 800bebc:	4b03      	ldr	r3, [pc, #12]	; (800becc <_dbg_check_leave_isr+0x2c>)
 800bebe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bec0:	3b01      	subs	r3, #1
 800bec2:	4a02      	ldr	r2, [pc, #8]	; (800becc <_dbg_check_leave_isr+0x2c>)
 800bec4:	6313      	str	r3, [r2, #48]	; 0x30
  port_unlock_from_isr();
 800bec6:	f7ff ff03 	bl	800bcd0 <port_unlock_from_isr.lto_priv.450>
}
 800beca:	bd08      	pop	{r3, pc}
 800becc:	20000d30 	.word	0x20000d30
 800bed0:	0800db28 	.word	0x0800db28
	...

0800bee0 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 800bee0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800bee2:	4b06      	ldr	r3, [pc, #24]	; (800befc <chDbgCheckClassI+0x1c>)
 800bee4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bee6:	2b00      	cmp	r3, #0
 800bee8:	db03      	blt.n	800bef2 <chDbgCheckClassI+0x12>
 800beea:	4b04      	ldr	r3, [pc, #16]	; (800befc <chDbgCheckClassI+0x1c>)
 800beec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800beee:	2b00      	cmp	r3, #0
 800bef0:	dc02      	bgt.n	800bef8 <chDbgCheckClassI+0x18>
    chSysHalt("SV#10");
 800bef2:	4803      	ldr	r0, [pc, #12]	; (800bf00 <chDbgCheckClassI+0x20>)
 800bef4:	f7ff fdfc 	bl	800baf0 <chSysHalt>
  }
}
 800bef8:	bd08      	pop	{r3, pc}
 800befa:	bf00      	nop
 800befc:	20000d30 	.word	0x20000d30
 800bf00:	0800db30 	.word	0x0800db30
	...

0800bf10 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 800bf10:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800bf12:	4b06      	ldr	r3, [pc, #24]	; (800bf2c <chDbgCheckClassS+0x1c>)
 800bf14:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bf16:	2b00      	cmp	r3, #0
 800bf18:	d103      	bne.n	800bf22 <chDbgCheckClassS+0x12>
 800bf1a:	4b04      	ldr	r3, [pc, #16]	; (800bf2c <chDbgCheckClassS+0x1c>)
 800bf1c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800bf1e:	2b00      	cmp	r3, #0
 800bf20:	dc02      	bgt.n	800bf28 <chDbgCheckClassS+0x18>
    chSysHalt("SV#11");
 800bf22:	4803      	ldr	r0, [pc, #12]	; (800bf30 <chDbgCheckClassS+0x20>)
 800bf24:	f7ff fde4 	bl	800baf0 <chSysHalt>
  }
}
 800bf28:	bd08      	pop	{r3, pc}
 800bf2a:	bf00      	nop
 800bf2c:	20000d30 	.word	0x20000d30
 800bf30:	0800db38 	.word	0x0800db38
	...

0800bf40 <_dbg_trace_init>:
 * @brief   Trace circular buffer subsystem initialization.
 * @note    Internal use only.
 */
void _dbg_trace_init(void) {

  ch.dbg.trace_buffer.tb_size = CH_DBG_TRACE_BUFFER_SIZE;
 800bf40:	4b03      	ldr	r3, [pc, #12]	; (800bf50 <_dbg_trace_init+0x10>)
 800bf42:	2240      	movs	r2, #64	; 0x40
 800bf44:	639a      	str	r2, [r3, #56]	; 0x38
  ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 800bf46:	4b02      	ldr	r3, [pc, #8]	; (800bf50 <_dbg_trace_init+0x10>)
 800bf48:	4a02      	ldr	r2, [pc, #8]	; (800bf54 <_dbg_trace_init+0x14>)
 800bf4a:	63da      	str	r2, [r3, #60]	; 0x3c
}
 800bf4c:	4770      	bx	lr
 800bf4e:	bf00      	nop
 800bf50:	20000d30 	.word	0x20000d30
 800bf54:	20000d70 	.word	0x20000d70
	...

0800bf60 <_dbg_trace>:
 *
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _dbg_trace(thread_t *otp) {
 800bf60:	b510      	push	{r4, lr}
 800bf62:	b082      	sub	sp, #8
 800bf64:	9001      	str	r0, [sp, #4]

  ch.dbg.trace_buffer.tb_ptr->se_time   = chVTGetSystemTimeX();
 800bf66:	4b12      	ldr	r3, [pc, #72]	; (800bfb0 <_dbg_trace+0x50>)
 800bf68:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 800bf6a:	f7ff fec9 	bl	800bd00 <chVTGetSystemTimeX.lto_priv.418>
 800bf6e:	4603      	mov	r3, r0
 800bf70:	6023      	str	r3, [r4, #0]
  ch.dbg.trace_buffer.tb_ptr->se_tp     = currp;
 800bf72:	4b0f      	ldr	r3, [pc, #60]	; (800bfb0 <_dbg_trace+0x50>)
 800bf74:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800bf76:	4a0e      	ldr	r2, [pc, #56]	; (800bfb0 <_dbg_trace+0x50>)
 800bf78:	6992      	ldr	r2, [r2, #24]
 800bf7a:	605a      	str	r2, [r3, #4]
  ch.dbg.trace_buffer.tb_ptr->se_wtobjp = otp->p_u.wtobjp;
 800bf7c:	4b0c      	ldr	r3, [pc, #48]	; (800bfb0 <_dbg_trace+0x50>)
 800bf7e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800bf80:	9a01      	ldr	r2, [sp, #4]
 800bf82:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800bf84:	609a      	str	r2, [r3, #8]
  ch.dbg.trace_buffer.tb_ptr->se_state  = (uint8_t)otp->p_state;
 800bf86:	4b0a      	ldr	r3, [pc, #40]	; (800bfb0 <_dbg_trace+0x50>)
 800bf88:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800bf8a:	9a01      	ldr	r2, [sp, #4]
 800bf8c:	f892 2020 	ldrb.w	r2, [r2, #32]
 800bf90:	731a      	strb	r2, [r3, #12]
  if (++ch.dbg.trace_buffer.tb_ptr >=
 800bf92:	4b07      	ldr	r3, [pc, #28]	; (800bfb0 <_dbg_trace+0x50>)
 800bf94:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800bf96:	3310      	adds	r3, #16
 800bf98:	4a05      	ldr	r2, [pc, #20]	; (800bfb0 <_dbg_trace+0x50>)
 800bf9a:	63d3      	str	r3, [r2, #60]	; 0x3c
 800bf9c:	4b04      	ldr	r3, [pc, #16]	; (800bfb0 <_dbg_trace+0x50>)
 800bf9e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800bfa0:	4a04      	ldr	r2, [pc, #16]	; (800bfb4 <_dbg_trace+0x54>)
 800bfa2:	4293      	cmp	r3, r2
 800bfa4:	d302      	bcc.n	800bfac <_dbg_trace+0x4c>
      &ch.dbg.trace_buffer.tb_buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.tb_ptr = &ch.dbg.trace_buffer.tb_buffer[0];
 800bfa6:	4b02      	ldr	r3, [pc, #8]	; (800bfb0 <_dbg_trace+0x50>)
 800bfa8:	4a03      	ldr	r2, [pc, #12]	; (800bfb8 <_dbg_trace+0x58>)
 800bfaa:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
 800bfac:	b002      	add	sp, #8
 800bfae:	bd10      	pop	{r4, pc}
 800bfb0:	20000d30 	.word	0x20000d30
 800bfb4:	20001170 	.word	0x20001170
 800bfb8:	20000d70 	.word	0x20000d70
 800bfbc:	00000000 	.word	0x00000000

0800bfc0 <st_lld_get_counter.lto_priv.435>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800bfc0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800bfc4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800bfc6:	4618      	mov	r0, r3
 800bfc8:	4770      	bx	lr
 800bfca:	bf00      	nop
 800bfcc:	0000      	movs	r0, r0
	...

0800bfd0 <port_timer_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {
 800bfd0:	b500      	push	{lr}
 800bfd2:	b083      	sub	sp, #12
 800bfd4:	9001      	str	r0, [sp, #4]

  stStartAlarm(time);
 800bfd6:	9801      	ldr	r0, [sp, #4]
 800bfd8:	f7fc ff6a 	bl	8008eb0 <stStartAlarm>
}
 800bfdc:	b003      	add	sp, #12
 800bfde:	f85d fb04 	ldr.w	pc, [sp], #4
 800bfe2:	bf00      	nop
	...

0800bff0 <port_timer_stop_alarm.lto_priv.458>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {
 800bff0:	b508      	push	{r3, lr}

  stStopAlarm();
 800bff2:	f7fc ff75 	bl	8008ee0 <stStopAlarm>
}
 800bff6:	bd08      	pop	{r3, pc}
	...

0800c000 <port_timer_set_alarm.lto_priv.456>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {
 800c000:	b500      	push	{lr}
 800c002:	b083      	sub	sp, #12
 800c004:	9001      	str	r0, [sp, #4]

  stSetAlarm(time);
 800c006:	9801      	ldr	r0, [sp, #4]
 800c008:	f7fc ff72 	bl	8008ef0 <stSetAlarm>
}
 800c00c:	b003      	add	sp, #12
 800c00e:	f85d fb04 	ldr.w	pc, [sp], #4
 800c012:	bf00      	nop
	...

0800c020 <port_timer_get_time.lto_priv.431>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 800c020:	b508      	push	{r3, lr}

  return stGetCounter();
 800c022:	f7ff ffcd 	bl	800bfc0 <st_lld_get_counter.lto_priv.435>
 800c026:	4603      	mov	r3, r0
}
 800c028:	4618      	mov	r0, r3
 800c02a:	bd08      	pop	{r3, pc}
 800c02c:	0000      	movs	r0, r0
	...

0800c030 <chVTGetSystemTimeX.lto_priv.419>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 800c030:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 800c032:	f7ff fff5 	bl	800c020 <port_timer_get_time.lto_priv.431>
 800c036:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800c038:	4618      	mov	r0, r3
 800c03a:	bd08      	pop	{r3, pc}
 800c03c:	0000      	movs	r0, r0
	...

0800c040 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 800c040:	4b06      	ldr	r3, [pc, #24]	; (800c05c <_vt_init+0x1c>)
 800c042:	4a07      	ldr	r2, [pc, #28]	; (800c060 <_vt_init+0x20>)
 800c044:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 800c046:	4b05      	ldr	r3, [pc, #20]	; (800c05c <_vt_init+0x1c>)
 800c048:	4a05      	ldr	r2, [pc, #20]	; (800c060 <_vt_init+0x20>)
 800c04a:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
 800c04c:	4b03      	ldr	r3, [pc, #12]	; (800c05c <_vt_init+0x1c>)
 800c04e:	f04f 32ff 	mov.w	r2, #4294967295
 800c052:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 800c054:	4b01      	ldr	r3, [pc, #4]	; (800c05c <_vt_init+0x1c>)
 800c056:	2200      	movs	r2, #0
 800c058:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800c05a:	4770      	bx	lr
 800c05c:	20000d30 	.word	0x20000d30
 800c060:	20000d4c 	.word	0x20000d4c
	...

0800c070 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 800c070:	b500      	push	{lr}
 800c072:	b089      	sub	sp, #36	; 0x24
 800c074:	9003      	str	r0, [sp, #12]
 800c076:	9102      	str	r1, [sp, #8]
 800c078:	9201      	str	r2, [sp, #4]
 800c07a:	9300      	str	r3, [sp, #0]
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
 800c07c:	f7ff ff30 	bl	800bee0 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 800c080:	9b03      	ldr	r3, [sp, #12]
 800c082:	2b00      	cmp	r3, #0
 800c084:	d005      	beq.n	800c092 <chVTDoSetI+0x22>
 800c086:	9b01      	ldr	r3, [sp, #4]
 800c088:	2b00      	cmp	r3, #0
 800c08a:	d002      	beq.n	800c092 <chVTDoSetI+0x22>
 800c08c:	9b02      	ldr	r3, [sp, #8]
 800c08e:	2b00      	cmp	r3, #0
 800c090:	d102      	bne.n	800c098 <chVTDoSetI+0x28>
 800c092:	483a      	ldr	r0, [pc, #232]	; (800c17c <chVTDoSetI+0x10c>)
 800c094:	f7ff fd2c 	bl	800baf0 <chSysHalt>

  vtp->vt_par = par;
 800c098:	9b03      	ldr	r3, [sp, #12]
 800c09a:	9a00      	ldr	r2, [sp, #0]
 800c09c:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
 800c09e:	9b03      	ldr	r3, [sp, #12]
 800c0a0:	9a01      	ldr	r2, [sp, #4]
 800c0a2:	60da      	str	r2, [r3, #12]

#if CH_CFG_ST_TIMEDELTA > 0
  {
    systime_t now = chVTGetSystemTimeX();
 800c0a4:	f7ff ffc4 	bl	800c030 <chVTGetSystemTimeX.lto_priv.419>
 800c0a8:	9005      	str	r0, [sp, #20]

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800c0aa:	9b02      	ldr	r3, [sp, #8]
 800c0ac:	2b01      	cmp	r3, #1
 800c0ae:	d801      	bhi.n	800c0b4 <chVTDoSetI+0x44>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 800c0b0:	2302      	movs	r3, #2
 800c0b2:	9302      	str	r3, [sp, #8]
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800c0b4:	4b32      	ldr	r3, [pc, #200]	; (800c180 <chVTDoSetI+0x110>)
 800c0b6:	69db      	ldr	r3, [r3, #28]
 800c0b8:	4a32      	ldr	r2, [pc, #200]	; (800c184 <chVTDoSetI+0x114>)
 800c0ba:	4293      	cmp	r3, r2
 800c0bc:	d119      	bne.n	800c0f2 <chVTDoSetI+0x82>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 800c0be:	4a30      	ldr	r2, [pc, #192]	; (800c180 <chVTDoSetI+0x110>)
 800c0c0:	9b05      	ldr	r3, [sp, #20]
 800c0c2:	6293      	str	r3, [r2, #40]	; 0x28
      ch.vtlist.vt_next = vtp;
 800c0c4:	4a2e      	ldr	r2, [pc, #184]	; (800c180 <chVTDoSetI+0x110>)
 800c0c6:	9b03      	ldr	r3, [sp, #12]
 800c0c8:	61d3      	str	r3, [r2, #28]
      ch.vtlist.vt_prev = vtp;
 800c0ca:	4a2d      	ldr	r2, [pc, #180]	; (800c180 <chVTDoSetI+0x110>)
 800c0cc:	9b03      	ldr	r3, [sp, #12]
 800c0ce:	6213      	str	r3, [r2, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 800c0d0:	9b03      	ldr	r3, [sp, #12]
 800c0d2:	4a2c      	ldr	r2, [pc, #176]	; (800c184 <chVTDoSetI+0x114>)
 800c0d4:	601a      	str	r2, [r3, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800c0d6:	9b03      	ldr	r3, [sp, #12]
 800c0d8:	4a2a      	ldr	r2, [pc, #168]	; (800c184 <chVTDoSetI+0x114>)
 800c0da:	605a      	str	r2, [r3, #4]
      vtp->vt_delta = delay;
 800c0dc:	9b03      	ldr	r3, [sp, #12]
 800c0de:	9a02      	ldr	r2, [sp, #8]
 800c0e0:	609a      	str	r2, [r3, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 800c0e2:	4b27      	ldr	r3, [pc, #156]	; (800c180 <chVTDoSetI+0x110>)
 800c0e4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800c0e6:	9b02      	ldr	r3, [sp, #8]
 800c0e8:	4413      	add	r3, r2
 800c0ea:	4618      	mov	r0, r3
 800c0ec:	f7ff ff70 	bl	800bfd0 <port_timer_start_alarm>
 800c0f0:	e040      	b.n	800c174 <chVTDoSetI+0x104>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 800c0f2:	9a05      	ldr	r2, [sp, #20]
 800c0f4:	9b02      	ldr	r3, [sp, #8]
 800c0f6:	441a      	add	r2, r3
 800c0f8:	4b21      	ldr	r3, [pc, #132]	; (800c180 <chVTDoSetI+0x110>)
 800c0fa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800c0fc:	1ad3      	subs	r3, r2, r3
 800c0fe:	9306      	str	r3, [sp, #24]
    if (delta < ch.vtlist.vt_next->vt_delta) {
 800c100:	4b1f      	ldr	r3, [pc, #124]	; (800c180 <chVTDoSetI+0x110>)
 800c102:	69db      	ldr	r3, [r3, #28]
 800c104:	689a      	ldr	r2, [r3, #8]
 800c106:	9b06      	ldr	r3, [sp, #24]
 800c108:	429a      	cmp	r2, r3
 800c10a:	d906      	bls.n	800c11a <chVTDoSetI+0xaa>

      /* New alarm deadline.*/
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
 800c10c:	4b1c      	ldr	r3, [pc, #112]	; (800c180 <chVTDoSetI+0x110>)
 800c10e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800c110:	9b06      	ldr	r3, [sp, #24]
 800c112:	4413      	add	r3, r2
 800c114:	4618      	mov	r0, r3
 800c116:	f7ff ff73 	bl	800c000 <port_timer_set_alarm.lto_priv.456>
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 800c11a:	4b19      	ldr	r3, [pc, #100]	; (800c180 <chVTDoSetI+0x110>)
 800c11c:	69db      	ldr	r3, [r3, #28]
 800c11e:	9307      	str	r3, [sp, #28]
 800c120:	e007      	b.n	800c132 <chVTDoSetI+0xc2>
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 800c122:	9b07      	ldr	r3, [sp, #28]
 800c124:	689b      	ldr	r3, [r3, #8]
 800c126:	9a06      	ldr	r2, [sp, #24]
 800c128:	1ad3      	subs	r3, r2, r3
 800c12a:	9306      	str	r3, [sp, #24]
    p = p->vt_next;
 800c12c:	9b07      	ldr	r3, [sp, #28]
 800c12e:	681b      	ldr	r3, [r3, #0]
 800c130:	9307      	str	r3, [sp, #28]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 800c132:	9b07      	ldr	r3, [sp, #28]
 800c134:	689a      	ldr	r2, [r3, #8]
 800c136:	9b06      	ldr	r3, [sp, #24]
 800c138:	429a      	cmp	r2, r3
 800c13a:	d3f2      	bcc.n	800c122 <chVTDoSetI+0xb2>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 800c13c:	9b03      	ldr	r3, [sp, #12]
 800c13e:	9a07      	ldr	r2, [sp, #28]
 800c140:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 800c142:	9b03      	ldr	r3, [sp, #12]
 800c144:	681b      	ldr	r3, [r3, #0]
 800c146:	685a      	ldr	r2, [r3, #4]
 800c148:	9b03      	ldr	r3, [sp, #12]
 800c14a:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
 800c14c:	9b03      	ldr	r3, [sp, #12]
 800c14e:	685b      	ldr	r3, [r3, #4]
 800c150:	9a03      	ldr	r2, [sp, #12]
 800c152:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
 800c154:	9b07      	ldr	r3, [sp, #28]
 800c156:	9a03      	ldr	r2, [sp, #12]
 800c158:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
 800c15a:	9b03      	ldr	r3, [sp, #12]
 800c15c:	9a06      	ldr	r2, [sp, #24]
 800c15e:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 800c160:	9b07      	ldr	r3, [sp, #28]
 800c162:	689a      	ldr	r2, [r3, #8]
 800c164:	9b06      	ldr	r3, [sp, #24]
 800c166:	1ad2      	subs	r2, r2, r3
 800c168:	9b07      	ldr	r3, [sp, #28]
 800c16a:	609a      	str	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 800c16c:	4b04      	ldr	r3, [pc, #16]	; (800c180 <chVTDoSetI+0x110>)
 800c16e:	f04f 32ff 	mov.w	r2, #4294967295
 800c172:	625a      	str	r2, [r3, #36]	; 0x24
}
 800c174:	b009      	add	sp, #36	; 0x24
 800c176:	f85d fb04 	ldr.w	pc, [sp], #4
 800c17a:	bf00      	nop
 800c17c:	0800dbf0 	.word	0x0800dbf0
 800c180:	20000d30 	.word	0x20000d30
 800c184:	20000d4c 	.word	0x20000d4c
	...

0800c190 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 800c190:	b500      	push	{lr}
 800c192:	b085      	sub	sp, #20
 800c194:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800c196:	f7ff fea3 	bl	800bee0 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 800c19a:	9b01      	ldr	r3, [sp, #4]
 800c19c:	2b00      	cmp	r3, #0
 800c19e:	d102      	bne.n	800c1a6 <chVTDoResetI+0x16>
 800c1a0:	4835      	ldr	r0, [pc, #212]	; (800c278 <chVTDoResetI+0xe8>)
 800c1a2:	f7ff fca5 	bl	800baf0 <chSysHalt>
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");
 800c1a6:	9b01      	ldr	r3, [sp, #4]
 800c1a8:	68db      	ldr	r3, [r3, #12]
 800c1aa:	2b00      	cmp	r3, #0
 800c1ac:	d102      	bne.n	800c1b4 <chVTDoResetI+0x24>
 800c1ae:	4832      	ldr	r0, [pc, #200]	; (800c278 <chVTDoResetI+0xe8>)
 800c1b0:	f7ff fc9e 	bl	800baf0 <chSysHalt>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 800c1b4:	4b31      	ldr	r3, [pc, #196]	; (800c27c <chVTDoResetI+0xec>)
 800c1b6:	69da      	ldr	r2, [r3, #28]
 800c1b8:	9b01      	ldr	r3, [sp, #4]
 800c1ba:	429a      	cmp	r2, r3
 800c1bc:	d01b      	beq.n	800c1f6 <chVTDoResetI+0x66>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 800c1be:	9b01      	ldr	r3, [sp, #4]
 800c1c0:	685b      	ldr	r3, [r3, #4]
 800c1c2:	9a01      	ldr	r2, [sp, #4]
 800c1c4:	6812      	ldr	r2, [r2, #0]
 800c1c6:	601a      	str	r2, [r3, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 800c1c8:	9b01      	ldr	r3, [sp, #4]
 800c1ca:	681b      	ldr	r3, [r3, #0]
 800c1cc:	9a01      	ldr	r2, [sp, #4]
 800c1ce:	6852      	ldr	r2, [r2, #4]
 800c1d0:	605a      	str	r2, [r3, #4]
    vtp->vt_func = NULL;
 800c1d2:	9b01      	ldr	r3, [sp, #4]
 800c1d4:	2200      	movs	r2, #0
 800c1d6:	60da      	str	r2, [r3, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 800c1d8:	9b01      	ldr	r3, [sp, #4]
 800c1da:	681b      	ldr	r3, [r3, #0]
 800c1dc:	4a28      	ldr	r2, [pc, #160]	; (800c280 <chVTDoResetI+0xf0>)
 800c1de:	4293      	cmp	r3, r2
 800c1e0:	d046      	beq.n	800c270 <chVTDoResetI+0xe0>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 800c1e2:	9b01      	ldr	r3, [sp, #4]
 800c1e4:	681b      	ldr	r3, [r3, #0]
 800c1e6:	9a01      	ldr	r2, [sp, #4]
 800c1e8:	6812      	ldr	r2, [r2, #0]
 800c1ea:	6891      	ldr	r1, [r2, #8]
 800c1ec:	9a01      	ldr	r2, [sp, #4]
 800c1ee:	6892      	ldr	r2, [r2, #8]
 800c1f0:	440a      	add	r2, r1
 800c1f2:	609a      	str	r2, [r3, #8]
 800c1f4:	e03c      	b.n	800c270 <chVTDoResetI+0xe0>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 800c1f6:	9b01      	ldr	r3, [sp, #4]
 800c1f8:	681b      	ldr	r3, [r3, #0]
 800c1fa:	4a20      	ldr	r2, [pc, #128]	; (800c27c <chVTDoResetI+0xec>)
 800c1fc:	61d3      	str	r3, [r2, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800c1fe:	4b1f      	ldr	r3, [pc, #124]	; (800c27c <chVTDoResetI+0xec>)
 800c200:	69db      	ldr	r3, [r3, #28]
 800c202:	4a1f      	ldr	r2, [pc, #124]	; (800c280 <chVTDoResetI+0xf0>)
 800c204:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
 800c206:	9b01      	ldr	r3, [sp, #4]
 800c208:	2200      	movs	r2, #0
 800c20a:	60da      	str	r2, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800c20c:	4b1b      	ldr	r3, [pc, #108]	; (800c27c <chVTDoResetI+0xec>)
 800c20e:	69db      	ldr	r3, [r3, #28]
 800c210:	4a1b      	ldr	r2, [pc, #108]	; (800c280 <chVTDoResetI+0xf0>)
 800c212:	4293      	cmp	r3, r2
 800c214:	d102      	bne.n	800c21c <chVTDoResetI+0x8c>
    port_timer_stop_alarm();
 800c216:	f7ff feeb 	bl	800bff0 <port_timer_stop_alarm.lto_priv.458>
 800c21a:	e029      	b.n	800c270 <chVTDoResetI+0xe0>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 800c21c:	4b17      	ldr	r3, [pc, #92]	; (800c27c <chVTDoResetI+0xec>)
 800c21e:	69db      	ldr	r3, [r3, #28]
 800c220:	4a16      	ldr	r2, [pc, #88]	; (800c27c <chVTDoResetI+0xec>)
 800c222:	69d2      	ldr	r2, [r2, #28]
 800c224:	6891      	ldr	r1, [r2, #8]
 800c226:	9a01      	ldr	r2, [sp, #4]
 800c228:	6892      	ldr	r2, [r2, #8]
 800c22a:	440a      	add	r2, r1
 800c22c:	609a      	str	r2, [r3, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 800c22e:	f7ff feff 	bl	800c030 <chVTGetSystemTimeX.lto_priv.419>
 800c232:	4602      	mov	r2, r0
 800c234:	4b11      	ldr	r3, [pc, #68]	; (800c27c <chVTDoResetI+0xec>)
 800c236:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800c238:	1ad3      	subs	r3, r2, r3
 800c23a:	9302      	str	r3, [sp, #8]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 800c23c:	4b0f      	ldr	r3, [pc, #60]	; (800c27c <chVTDoResetI+0xec>)
 800c23e:	69db      	ldr	r3, [r3, #28]
 800c240:	689a      	ldr	r2, [r3, #8]
 800c242:	9b02      	ldr	r3, [sp, #8]
 800c244:	429a      	cmp	r2, r3
 800c246:	d913      	bls.n	800c270 <chVTDoResetI+0xe0>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 800c248:	4b0c      	ldr	r3, [pc, #48]	; (800c27c <chVTDoResetI+0xec>)
 800c24a:	69db      	ldr	r3, [r3, #28]
 800c24c:	689a      	ldr	r2, [r3, #8]
 800c24e:	9b02      	ldr	r3, [sp, #8]
 800c250:	1ad3      	subs	r3, r2, r3
 800c252:	9303      	str	r3, [sp, #12]

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 800c254:	9b03      	ldr	r3, [sp, #12]
 800c256:	2b01      	cmp	r3, #1
 800c258:	d801      	bhi.n	800c25e <chVTDoResetI+0xce>
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800c25a:	2302      	movs	r3, #2
 800c25c:	9303      	str	r3, [sp, #12]
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 800c25e:	4b07      	ldr	r3, [pc, #28]	; (800c27c <chVTDoResetI+0xec>)
 800c260:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800c262:	9b02      	ldr	r3, [sp, #8]
 800c264:	441a      	add	r2, r3
 800c266:	9b03      	ldr	r3, [sp, #12]
 800c268:	4413      	add	r3, r2
 800c26a:	4618      	mov	r0, r3
 800c26c:	f7ff fec8 	bl	800c000 <port_timer_set_alarm.lto_priv.456>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800c270:	b005      	add	sp, #20
 800c272:	f85d fb04 	ldr.w	pc, [sp], #4
 800c276:	bf00      	nop
 800c278:	0800dc00 	.word	0x0800dc00
 800c27c:	20000d30 	.word	0x20000d30
 800c280:	20000d4c 	.word	0x20000d4c
	...

0800c290 <port_lock.lto_priv.443>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800c290:	b082      	sub	sp, #8
 800c292:	2320      	movs	r3, #32
 800c294:	9301      	str	r3, [sp, #4]
 800c296:	9b01      	ldr	r3, [sp, #4]
 800c298:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c29c:	b002      	add	sp, #8
 800c29e:	4770      	bx	lr

0800c2a0 <port_unlock.lto_priv.439>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800c2a0:	b082      	sub	sp, #8
 800c2a2:	2300      	movs	r3, #0
 800c2a4:	9301      	str	r3, [sp, #4]
 800c2a6:	9b01      	ldr	r3, [sp, #4]
 800c2a8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c2ac:	b002      	add	sp, #8
 800c2ae:	4770      	bx	lr

0800c2b0 <port_lock_from_isr.lto_priv.454>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800c2b0:	b508      	push	{r3, lr}

  port_lock();
 800c2b2:	f7ff ffed 	bl	800c290 <port_lock.lto_priv.443>
}
 800c2b6:	bd08      	pop	{r3, pc}
	...

0800c2c0 <port_unlock_from_isr.lto_priv.451>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800c2c0:	b508      	push	{r3, lr}

  port_unlock();
 800c2c2:	f7ff ffed 	bl	800c2a0 <port_unlock.lto_priv.439>
}
 800c2c6:	bd08      	pop	{r3, pc}
	...

0800c2d0 <queue_init.lto_priv.427>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 800c2d0:	b082      	sub	sp, #8
 800c2d2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 800c2d4:	9b01      	ldr	r3, [sp, #4]
 800c2d6:	9a01      	ldr	r2, [sp, #4]
 800c2d8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800c2da:	9b01      	ldr	r3, [sp, #4]
 800c2dc:	9a01      	ldr	r2, [sp, #4]
 800c2de:	605a      	str	r2, [r3, #4]
}
 800c2e0:	b002      	add	sp, #8
 800c2e2:	4770      	bx	lr
	...

0800c2f0 <queue_fifo_remove.lto_priv.425>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 800c2f0:	b084      	sub	sp, #16
 800c2f2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 800c2f4:	9b01      	ldr	r3, [sp, #4]
 800c2f6:	681b      	ldr	r3, [r3, #0]
 800c2f8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 800c2fa:	9b03      	ldr	r3, [sp, #12]
 800c2fc:	681a      	ldr	r2, [r3, #0]
 800c2fe:	9b01      	ldr	r3, [sp, #4]
 800c300:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800c302:	9b01      	ldr	r3, [sp, #4]
 800c304:	681b      	ldr	r3, [r3, #0]
 800c306:	9a01      	ldr	r2, [sp, #4]
 800c308:	605a      	str	r2, [r3, #4]

  return tp;
 800c30a:	9b03      	ldr	r3, [sp, #12]
}
 800c30c:	4618      	mov	r0, r3
 800c30e:	b004      	add	sp, #16
 800c310:	4770      	bx	lr
 800c312:	bf00      	nop
	...

0800c320 <queue_dequeue>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 800c320:	b082      	sub	sp, #8
 800c322:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 800c324:	9b01      	ldr	r3, [sp, #4]
 800c326:	685b      	ldr	r3, [r3, #4]
 800c328:	9a01      	ldr	r2, [sp, #4]
 800c32a:	6812      	ldr	r2, [r2, #0]
 800c32c:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 800c32e:	9b01      	ldr	r3, [sp, #4]
 800c330:	681b      	ldr	r3, [r3, #0]
 800c332:	9a01      	ldr	r2, [sp, #4]
 800c334:	6852      	ldr	r2, [r2, #4]
 800c336:	605a      	str	r2, [r3, #4]

  return tp;
 800c338:	9b01      	ldr	r3, [sp, #4]
}
 800c33a:	4618      	mov	r0, r3
 800c33c:	b002      	add	sp, #8
 800c33e:	4770      	bx	lr

0800c340 <chSchIsRescRequiredI>:
 * @retval false        if rescheduling is not necessary.
 * @retval true         if there is a ready thread at higher priority.
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {
 800c340:	b508      	push	{r3, lr}

  chDbgCheckClassI();
 800c342:	f7ff fdcd 	bl	800bee0 <chDbgCheckClassI>

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 800c346:	4b06      	ldr	r3, [pc, #24]	; (800c360 <chSchIsRescRequiredI+0x20>)
 800c348:	681b      	ldr	r3, [r3, #0]
 800c34a:	689a      	ldr	r2, [r3, #8]
 800c34c:	4b04      	ldr	r3, [pc, #16]	; (800c360 <chSchIsRescRequiredI+0x20>)
 800c34e:	699b      	ldr	r3, [r3, #24]
 800c350:	689b      	ldr	r3, [r3, #8]
 800c352:	429a      	cmp	r2, r3
 800c354:	bf8c      	ite	hi
 800c356:	2301      	movhi	r3, #1
 800c358:	2300      	movls	r3, #0
 800c35a:	b2db      	uxtb	r3, r3
}
 800c35c:	4618      	mov	r0, r3
 800c35e:	bd08      	pop	{r3, pc}
 800c360:	20000d30 	.word	0x20000d30
	...

0800c370 <chSysLockFromISR.lto_priv.448>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800c370:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800c372:	f7ff ff9d 	bl	800c2b0 <port_lock_from_isr.lto_priv.454>
  _stats_start_measure_crit_isr();
 800c376:	f7fe f873 	bl	800a460 <_stats_start_measure_crit_isr>
  _dbg_check_lock_from_isr();
 800c37a:	f7ff fd41 	bl	800be00 <_dbg_check_lock_from_isr>
}
 800c37e:	bd08      	pop	{r3, pc}

0800c380 <chSysUnlockFromISR.lto_priv.446>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800c380:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
 800c382:	f7ff fd55 	bl	800be30 <_dbg_check_unlock_from_isr>
  _stats_stop_measure_crit_isr();
 800c386:	f7fe f873 	bl	800a470 <_stats_stop_measure_crit_isr>
  port_unlock_from_isr();
 800c38a:	f7ff ff99 	bl	800c2c0 <port_unlock_from_isr.lto_priv.451>
}
 800c38e:	bd08      	pop	{r3, pc}

0800c390 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 800c390:	b500      	push	{lr}
 800c392:	b083      	sub	sp, #12
 800c394:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800c396:	f7ff fda3 	bl	800bee0 <chDbgCheckClassI>

  return (bool)(vtp->vt_func != NULL);
 800c39a:	9b01      	ldr	r3, [sp, #4]
 800c39c:	68db      	ldr	r3, [r3, #12]
 800c39e:	2b00      	cmp	r3, #0
 800c3a0:	bf14      	ite	ne
 800c3a2:	2301      	movne	r3, #1
 800c3a4:	2300      	moveq	r3, #0
 800c3a6:	b2db      	uxtb	r3, r3
}
 800c3a8:	4618      	mov	r0, r3
 800c3aa:	b003      	add	sp, #12
 800c3ac:	f85d fb04 	ldr.w	pc, [sp], #4

0800c3b0 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 800c3b0:	b500      	push	{lr}
 800c3b2:	b083      	sub	sp, #12
 800c3b4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 800c3b6:	f7ff fd93 	bl	800bee0 <chDbgCheckClassI>

  sp->s_cnt++;
 800c3ba:	9b01      	ldr	r3, [sp, #4]
 800c3bc:	689b      	ldr	r3, [r3, #8]
 800c3be:	1c5a      	adds	r2, r3, #1
 800c3c0:	9b01      	ldr	r3, [sp, #4]
 800c3c2:	609a      	str	r2, [r3, #8]
}
 800c3c4:	b003      	add	sp, #12
 800c3c6:	f85d fb04 	ldr.w	pc, [sp], #4
 800c3ca:	bf00      	nop
 800c3cc:	0000      	movs	r0, r0
	...

0800c3d0 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 800c3d0:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
 800c3d2:	4806      	ldr	r0, [pc, #24]	; (800c3ec <_scheduler_init+0x1c>)
 800c3d4:	f7ff ff7c 	bl	800c2d0 <queue_init.lto_priv.427>
  ch.rlist.r_prio = NOPRIO;
 800c3d8:	4b04      	ldr	r3, [pc, #16]	; (800c3ec <_scheduler_init+0x1c>)
 800c3da:	2200      	movs	r2, #0
 800c3dc:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 800c3de:	4b03      	ldr	r3, [pc, #12]	; (800c3ec <_scheduler_init+0x1c>)
 800c3e0:	4a02      	ldr	r2, [pc, #8]	; (800c3ec <_scheduler_init+0x1c>)
 800c3e2:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 800c3e4:	4b01      	ldr	r3, [pc, #4]	; (800c3ec <_scheduler_init+0x1c>)
 800c3e6:	4a01      	ldr	r2, [pc, #4]	; (800c3ec <_scheduler_init+0x1c>)
 800c3e8:	615a      	str	r2, [r3, #20]
#endif
}
 800c3ea:	bd08      	pop	{r3, pc}
 800c3ec:	20000d30 	.word	0x20000d30

0800c3f0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 800c3f0:	b500      	push	{lr}
 800c3f2:	b085      	sub	sp, #20
 800c3f4:	9001      	str	r0, [sp, #4]
  thread_t *cp;

  chDbgCheckClassI();
 800c3f6:	f7ff fd73 	bl	800bee0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800c3fa:	9b01      	ldr	r3, [sp, #4]
 800c3fc:	2b00      	cmp	r3, #0
 800c3fe:	d102      	bne.n	800c406 <chSchReadyI+0x16>
 800c400:	4818      	ldr	r0, [pc, #96]	; (800c464 <chSchReadyI+0x74>)
 800c402:	f7ff fb75 	bl	800baf0 <chSysHalt>
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
 800c406:	9b01      	ldr	r3, [sp, #4]
 800c408:	f893 3020 	ldrb.w	r3, [r3, #32]
 800c40c:	2b00      	cmp	r3, #0
 800c40e:	d004      	beq.n	800c41a <chSchReadyI+0x2a>
 800c410:	9b01      	ldr	r3, [sp, #4]
 800c412:	f893 3020 	ldrb.w	r3, [r3, #32]
 800c416:	2b0f      	cmp	r3, #15
 800c418:	d102      	bne.n	800c420 <chSchReadyI+0x30>
 800c41a:	4812      	ldr	r0, [pc, #72]	; (800c464 <chSchReadyI+0x74>)
 800c41c:	f7ff fb68 	bl	800baf0 <chSysHalt>
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800c420:	9b01      	ldr	r3, [sp, #4]
 800c422:	2200      	movs	r2, #0
 800c424:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
 800c428:	4b0f      	ldr	r3, [pc, #60]	; (800c468 <chSchReadyI+0x78>)
 800c42a:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 800c42c:	9b03      	ldr	r3, [sp, #12]
 800c42e:	681b      	ldr	r3, [r3, #0]
 800c430:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
 800c432:	9b03      	ldr	r3, [sp, #12]
 800c434:	689a      	ldr	r2, [r3, #8]
 800c436:	9b01      	ldr	r3, [sp, #4]
 800c438:	689b      	ldr	r3, [r3, #8]
 800c43a:	429a      	cmp	r2, r3
 800c43c:	d2f6      	bcs.n	800c42c <chSchReadyI+0x3c>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 800c43e:	9b01      	ldr	r3, [sp, #4]
 800c440:	9a03      	ldr	r2, [sp, #12]
 800c442:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 800c444:	9b03      	ldr	r3, [sp, #12]
 800c446:	685a      	ldr	r2, [r3, #4]
 800c448:	9b01      	ldr	r3, [sp, #4]
 800c44a:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 800c44c:	9b01      	ldr	r3, [sp, #4]
 800c44e:	685b      	ldr	r3, [r3, #4]
 800c450:	9a01      	ldr	r2, [sp, #4]
 800c452:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 800c454:	9b03      	ldr	r3, [sp, #12]
 800c456:	9a01      	ldr	r2, [sp, #4]
 800c458:	605a      	str	r2, [r3, #4]

  return tp;
 800c45a:	9b01      	ldr	r3, [sp, #4]
}
 800c45c:	4618      	mov	r0, r3
 800c45e:	b005      	add	sp, #20
 800c460:	f85d fb04 	ldr.w	pc, [sp], #4
 800c464:	0800dc10 	.word	0x0800dc10
 800c468:	20000d30 	.word	0x20000d30
 800c46c:	00000000 	.word	0x00000000

0800c470 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 800c470:	b510      	push	{r4, lr}
 800c472:	b084      	sub	sp, #16
 800c474:	4603      	mov	r3, r0
 800c476:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp;

  chDbgCheckClassS();
 800c47a:	f7ff fd49 	bl	800bf10 <chDbgCheckClassS>

  otp = currp;
 800c47e:	4b19      	ldr	r3, [pc, #100]	; (800c4e4 <chSchGoSleepS+0x74>)
 800c480:	699b      	ldr	r3, [r3, #24]
 800c482:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
 800c484:	9b03      	ldr	r3, [sp, #12]
 800c486:	f89d 2007 	ldrb.w	r2, [sp, #7]
 800c48a:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 800c48e:	4815      	ldr	r0, [pc, #84]	; (800c4e4 <chSchGoSleepS+0x74>)
 800c490:	f7ff ff2e 	bl	800c2f0 <queue_fifo_remove.lto_priv.425>
 800c494:	4602      	mov	r2, r0
 800c496:	4b13      	ldr	r3, [pc, #76]	; (800c4e4 <chSchGoSleepS+0x74>)
 800c498:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800c49a:	4b12      	ldr	r3, [pc, #72]	; (800c4e4 <chSchGoSleepS+0x74>)
 800c49c:	699b      	ldr	r3, [r3, #24]
 800c49e:	2201      	movs	r2, #1
 800c4a0:	f883 2020 	strb.w	r2, [r3, #32]
  chSysSwitch(currp, otp);
 800c4a4:	9803      	ldr	r0, [sp, #12]
 800c4a6:	f7ff fd5b 	bl	800bf60 <_dbg_trace>
 800c4aa:	4b0e      	ldr	r3, [pc, #56]	; (800c4e4 <chSchGoSleepS+0x74>)
 800c4ac:	699b      	ldr	r3, [r3, #24]
 800c4ae:	4618      	mov	r0, r3
 800c4b0:	9903      	ldr	r1, [sp, #12]
 800c4b2:	f7fd ffa5 	bl	800a400 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800c4b6:	f3ef 8309 	mrs	r3, PSP
 800c4ba:	461c      	mov	r4, r3
  return(result);
 800c4bc:	4623      	mov	r3, r4
 800c4be:	9302      	str	r3, [sp, #8]
 800c4c0:	9b02      	ldr	r3, [sp, #8]
 800c4c2:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800c4c6:	9b03      	ldr	r3, [sp, #12]
 800c4c8:	69db      	ldr	r3, [r3, #28]
 800c4ca:	429a      	cmp	r2, r3
 800c4cc:	d202      	bcs.n	800c4d4 <chSchGoSleepS+0x64>
 800c4ce:	4806      	ldr	r0, [pc, #24]	; (800c4e8 <chSchGoSleepS+0x78>)
 800c4d0:	f7ff fb0e 	bl	800baf0 <chSysHalt>
 800c4d4:	4b03      	ldr	r3, [pc, #12]	; (800c4e4 <chSchGoSleepS+0x74>)
 800c4d6:	699b      	ldr	r3, [r3, #24]
 800c4d8:	4618      	mov	r0, r3
 800c4da:	9903      	ldr	r1, [sp, #12]
 800c4dc:	f7f3 fed8 	bl	8000290 <_port_switch>
}
 800c4e0:	b004      	add	sp, #16
 800c4e2:	bd10      	pop	{r4, pc}
 800c4e4:	20000d30 	.word	0x20000d30
 800c4e8:	0800db40 	.word	0x0800db40
 800c4ec:	00000000 	.word	0x00000000

0800c4f0 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 800c4f0:	b500      	push	{lr}
 800c4f2:	b085      	sub	sp, #20
 800c4f4:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 800c4f6:	9b01      	ldr	r3, [sp, #4]
 800c4f8:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 800c4fa:	f7ff ff39 	bl	800c370 <chSysLockFromISR.lto_priv.448>
  switch (tp->p_state) {
 800c4fe:	9b03      	ldr	r3, [sp, #12]
 800c500:	f893 3020 	ldrb.w	r3, [r3, #32]
 800c504:	2b07      	cmp	r3, #7
 800c506:	d823      	bhi.n	800c550 <wakeup+0x60>
 800c508:	a201      	add	r2, pc, #4	; (adr r2, 800c510 <wakeup+0x20>)
 800c50a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c50e:	bf00      	nop
 800c510:	0800c531 	.word	0x0800c531
 800c514:	0800c551 	.word	0x0800c551
 800c518:	0800c551 	.word	0x0800c551
 800c51c:	0800c537 	.word	0x0800c537
 800c520:	0800c54b 	.word	0x0800c54b
 800c524:	0800c541 	.word	0x0800c541
 800c528:	0800c551 	.word	0x0800c551
 800c52c:	0800c54b 	.word	0x0800c54b
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 800c530:	f7ff ff26 	bl	800c380 <chSysUnlockFromISR.lto_priv.446>
 800c534:	e015      	b.n	800c562 <wakeup+0x72>
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 800c536:	9b03      	ldr	r3, [sp, #12]
 800c538:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c53a:	2200      	movs	r2, #0
 800c53c:	601a      	str	r2, [r3, #0]
 800c53e:	e007      	b.n	800c550 <wakeup+0x60>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 800c540:	9b03      	ldr	r3, [sp, #12]
 800c542:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c544:	4618      	mov	r0, r3
 800c546:	f7ff ff33 	bl	800c3b0 <chSemFastSignalI>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 800c54a:	9803      	ldr	r0, [sp, #12]
 800c54c:	f7ff fee8 	bl	800c320 <queue_dequeue>
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 800c550:	9b03      	ldr	r3, [sp, #12]
 800c552:	f04f 32ff 	mov.w	r2, #4294967295
 800c556:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 800c558:	9803      	ldr	r0, [sp, #12]
 800c55a:	f7ff ff49 	bl	800c3f0 <chSchReadyI>
  chSysUnlockFromISR();
 800c55e:	f7ff ff0f 	bl	800c380 <chSysUnlockFromISR.lto_priv.446>
}
 800c562:	b005      	add	sp, #20
 800c564:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800c570 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 800c570:	b500      	push	{lr}
 800c572:	b089      	sub	sp, #36	; 0x24
 800c574:	4603      	mov	r3, r0
 800c576:	9100      	str	r1, [sp, #0]
 800c578:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();
 800c57c:	f7ff fcc8 	bl	800bf10 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
 800c580:	9b00      	ldr	r3, [sp, #0]
 800c582:	f1b3 3fff 	cmp.w	r3, #4294967295
 800c586:	d018      	beq.n	800c5ba <chSchGoSleepTimeoutS+0x4a>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 800c588:	4b12      	ldr	r3, [pc, #72]	; (800c5d4 <chSchGoSleepTimeoutS+0x64>)
 800c58a:	699b      	ldr	r3, [r3, #24]
 800c58c:	aa03      	add	r2, sp, #12
 800c58e:	4610      	mov	r0, r2
 800c590:	9900      	ldr	r1, [sp, #0]
 800c592:	4a11      	ldr	r2, [pc, #68]	; (800c5d8 <chSchGoSleepTimeoutS+0x68>)
 800c594:	f7ff fd6c 	bl	800c070 <chVTDoSetI>
    chSchGoSleepS(newstate);
 800c598:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800c59c:	4618      	mov	r0, r3
 800c59e:	f7ff ff67 	bl	800c470 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 800c5a2:	ab03      	add	r3, sp, #12
 800c5a4:	4618      	mov	r0, r3
 800c5a6:	f7ff fef3 	bl	800c390 <chVTIsArmedI>
 800c5aa:	4603      	mov	r3, r0
 800c5ac:	2b00      	cmp	r3, #0
 800c5ae:	d009      	beq.n	800c5c4 <chSchGoSleepTimeoutS+0x54>
      chVTDoResetI(&vt);
 800c5b0:	ab03      	add	r3, sp, #12
 800c5b2:	4618      	mov	r0, r3
 800c5b4:	f7ff fdec 	bl	800c190 <chVTDoResetI>
 800c5b8:	e004      	b.n	800c5c4 <chSchGoSleepTimeoutS+0x54>
    }
  }
  else {
    chSchGoSleepS(newstate);
 800c5ba:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800c5be:	4618      	mov	r0, r3
 800c5c0:	f7ff ff56 	bl	800c470 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 800c5c4:	4b03      	ldr	r3, [pc, #12]	; (800c5d4 <chSchGoSleepTimeoutS+0x64>)
 800c5c6:	699b      	ldr	r3, [r3, #24]
 800c5c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800c5ca:	4618      	mov	r0, r3
 800c5cc:	b009      	add	sp, #36	; 0x24
 800c5ce:	f85d fb04 	ldr.w	pc, [sp], #4
 800c5d2:	bf00      	nop
 800c5d4:	20000d30 	.word	0x20000d30
 800c5d8:	0800c4f1 	.word	0x0800c4f1
 800c5dc:	00000000 	.word	0x00000000

0800c5e0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 800c5e0:	b510      	push	{r4, lr}
 800c5e2:	b084      	sub	sp, #16
 800c5e4:	9001      	str	r0, [sp, #4]
 800c5e6:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();
 800c5e8:	f7ff fc92 	bl	800bf10 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800c5ec:	4b23      	ldr	r3, [pc, #140]	; (800c67c <chSchWakeupS+0x9c>)
 800c5ee:	681b      	ldr	r3, [r3, #0]
 800c5f0:	4a22      	ldr	r2, [pc, #136]	; (800c67c <chSchWakeupS+0x9c>)
 800c5f2:	4293      	cmp	r3, r2
 800c5f4:	d00a      	beq.n	800c60c <chSchWakeupS+0x2c>
 800c5f6:	4b21      	ldr	r3, [pc, #132]	; (800c67c <chSchWakeupS+0x9c>)
 800c5f8:	699b      	ldr	r3, [r3, #24]
 800c5fa:	689a      	ldr	r2, [r3, #8]
 800c5fc:	4b1f      	ldr	r3, [pc, #124]	; (800c67c <chSchWakeupS+0x9c>)
 800c5fe:	681b      	ldr	r3, [r3, #0]
 800c600:	689b      	ldr	r3, [r3, #8]
 800c602:	429a      	cmp	r2, r3
 800c604:	d202      	bcs.n	800c60c <chSchWakeupS+0x2c>
 800c606:	481e      	ldr	r0, [pc, #120]	; (800c680 <chSchWakeupS+0xa0>)
 800c608:	f7ff fa72 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 800c60c:	9b01      	ldr	r3, [sp, #4]
 800c60e:	9a00      	ldr	r2, [sp, #0]
 800c610:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800c612:	9b01      	ldr	r3, [sp, #4]
 800c614:	689a      	ldr	r2, [r3, #8]
 800c616:	4b19      	ldr	r3, [pc, #100]	; (800c67c <chSchWakeupS+0x9c>)
 800c618:	699b      	ldr	r3, [r3, #24]
 800c61a:	689b      	ldr	r3, [r3, #8]
 800c61c:	429a      	cmp	r2, r3
 800c61e:	d803      	bhi.n	800c628 <chSchWakeupS+0x48>
    (void) chSchReadyI(ntp);
 800c620:	9801      	ldr	r0, [sp, #4]
 800c622:	f7ff fee5 	bl	800c3f0 <chSchReadyI>
 800c626:	e026      	b.n	800c676 <chSchWakeupS+0x96>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 800c628:	4b14      	ldr	r3, [pc, #80]	; (800c67c <chSchWakeupS+0x9c>)
 800c62a:	699b      	ldr	r3, [r3, #24]
 800c62c:	4618      	mov	r0, r3
 800c62e:	f7ff fedf 	bl	800c3f0 <chSchReadyI>
 800c632:	9003      	str	r0, [sp, #12]
    setcurrp(ntp);
 800c634:	4a11      	ldr	r2, [pc, #68]	; (800c67c <chSchWakeupS+0x9c>)
 800c636:	9b01      	ldr	r3, [sp, #4]
 800c638:	6193      	str	r3, [r2, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 800c63a:	9b01      	ldr	r3, [sp, #4]
 800c63c:	2201      	movs	r2, #1
 800c63e:	f883 2020 	strb.w	r2, [r3, #32]
    chSysSwitch(ntp, otp);
 800c642:	9803      	ldr	r0, [sp, #12]
 800c644:	f7ff fc8c 	bl	800bf60 <_dbg_trace>
 800c648:	9801      	ldr	r0, [sp, #4]
 800c64a:	9903      	ldr	r1, [sp, #12]
 800c64c:	f7fd fed8 	bl	800a400 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800c650:	f3ef 8309 	mrs	r3, PSP
 800c654:	461c      	mov	r4, r3
  return(result);
 800c656:	4623      	mov	r3, r4
 800c658:	9302      	str	r3, [sp, #8]
 800c65a:	9b02      	ldr	r3, [sp, #8]
 800c65c:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800c660:	9b03      	ldr	r3, [sp, #12]
 800c662:	69db      	ldr	r3, [r3, #28]
 800c664:	429a      	cmp	r2, r3
 800c666:	d202      	bcs.n	800c66e <chSchWakeupS+0x8e>
 800c668:	4806      	ldr	r0, [pc, #24]	; (800c684 <chSchWakeupS+0xa4>)
 800c66a:	f7ff fa41 	bl	800baf0 <chSysHalt>
 800c66e:	9801      	ldr	r0, [sp, #4]
 800c670:	9903      	ldr	r1, [sp, #12]
 800c672:	f7f3 fe0d 	bl	8000290 <_port_switch>
  }
}
 800c676:	b004      	add	sp, #16
 800c678:	bd10      	pop	{r4, pc}
 800c67a:	bf00      	nop
 800c67c:	20000d30 	.word	0x20000d30
 800c680:	0800dc20 	.word	0x0800dc20
 800c684:	0800db40 	.word	0x0800db40
	...

0800c690 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 800c690:	b508      	push	{r3, lr}

  chDbgCheckClassS();
 800c692:	f7ff fc3d 	bl	800bf10 <chDbgCheckClassS>

  if (chSchIsRescRequiredI()) {
 800c696:	f7ff fe53 	bl	800c340 <chSchIsRescRequiredI>
 800c69a:	4603      	mov	r3, r0
 800c69c:	2b00      	cmp	r3, #0
 800c69e:	d001      	beq.n	800c6a4 <chSchRescheduleS+0x14>
    chSchDoRescheduleAhead();
 800c6a0:	f000 f856 	bl	800c750 <chSchDoRescheduleAhead>
  }
}
 800c6a4:	bd08      	pop	{r3, pc}
 800c6a6:	bf00      	nop
	...

0800c6b0 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 800c6b0:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 800c6b2:	4b09      	ldr	r3, [pc, #36]	; (800c6d8 <chSchIsPreemptionRequired+0x28>)
 800c6b4:	681b      	ldr	r3, [r3, #0]
 800c6b6:	689b      	ldr	r3, [r3, #8]
 800c6b8:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
 800c6ba:	4b07      	ldr	r3, [pc, #28]	; (800c6d8 <chSchIsPreemptionRequired+0x28>)
 800c6bc:	699b      	ldr	r3, [r3, #24]
 800c6be:	689b      	ldr	r3, [r3, #8]
 800c6c0:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 800c6c2:	9a01      	ldr	r2, [sp, #4]
 800c6c4:	9b00      	ldr	r3, [sp, #0]
 800c6c6:	429a      	cmp	r2, r3
 800c6c8:	bf8c      	ite	hi
 800c6ca:	2301      	movhi	r3, #1
 800c6cc:	2300      	movls	r3, #0
 800c6ce:	b2db      	uxtb	r3, r3
#endif
}
 800c6d0:	4618      	mov	r0, r3
 800c6d2:	b002      	add	sp, #8
 800c6d4:	4770      	bx	lr
 800c6d6:	bf00      	nop
 800c6d8:	20000d30 	.word	0x20000d30
 800c6dc:	00000000 	.word	0x00000000

0800c6e0 <chSchDoRescheduleBehind>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleBehind(void) {
 800c6e0:	b510      	push	{r4, lr}
 800c6e2:	b082      	sub	sp, #8
  thread_t *otp;

  otp = currp;
 800c6e4:	4b18      	ldr	r3, [pc, #96]	; (800c748 <chSchDoRescheduleBehind+0x68>)
 800c6e6:	699b      	ldr	r3, [r3, #24]
 800c6e8:	9301      	str	r3, [sp, #4]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 800c6ea:	4817      	ldr	r0, [pc, #92]	; (800c748 <chSchDoRescheduleBehind+0x68>)
 800c6ec:	f7ff fe00 	bl	800c2f0 <queue_fifo_remove.lto_priv.425>
 800c6f0:	4602      	mov	r2, r0
 800c6f2:	4b15      	ldr	r3, [pc, #84]	; (800c748 <chSchDoRescheduleBehind+0x68>)
 800c6f4:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800c6f6:	4b14      	ldr	r3, [pc, #80]	; (800c748 <chSchDoRescheduleBehind+0x68>)
 800c6f8:	699b      	ldr	r3, [r3, #24]
 800c6fa:	2201      	movs	r2, #1
 800c6fc:	f883 2020 	strb.w	r2, [r3, #32]
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
 800c700:	9801      	ldr	r0, [sp, #4]
 800c702:	f7ff fe75 	bl	800c3f0 <chSchReadyI>
  chSysSwitch(currp, otp);
 800c706:	9801      	ldr	r0, [sp, #4]
 800c708:	f7ff fc2a 	bl	800bf60 <_dbg_trace>
 800c70c:	4b0e      	ldr	r3, [pc, #56]	; (800c748 <chSchDoRescheduleBehind+0x68>)
 800c70e:	699b      	ldr	r3, [r3, #24]
 800c710:	4618      	mov	r0, r3
 800c712:	9901      	ldr	r1, [sp, #4]
 800c714:	f7fd fe74 	bl	800a400 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800c718:	f3ef 8309 	mrs	r3, PSP
 800c71c:	461c      	mov	r4, r3
  return(result);
 800c71e:	4623      	mov	r3, r4
 800c720:	9300      	str	r3, [sp, #0]
 800c722:	9b00      	ldr	r3, [sp, #0]
 800c724:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800c728:	9b01      	ldr	r3, [sp, #4]
 800c72a:	69db      	ldr	r3, [r3, #28]
 800c72c:	429a      	cmp	r2, r3
 800c72e:	d202      	bcs.n	800c736 <chSchDoRescheduleBehind+0x56>
 800c730:	4806      	ldr	r0, [pc, #24]	; (800c74c <chSchDoRescheduleBehind+0x6c>)
 800c732:	f7ff f9dd 	bl	800baf0 <chSysHalt>
 800c736:	4b04      	ldr	r3, [pc, #16]	; (800c748 <chSchDoRescheduleBehind+0x68>)
 800c738:	699b      	ldr	r3, [r3, #24]
 800c73a:	4618      	mov	r0, r3
 800c73c:	9901      	ldr	r1, [sp, #4]
 800c73e:	f7f3 fda7 	bl	8000290 <_port_switch>
}
 800c742:	b002      	add	sp, #8
 800c744:	bd10      	pop	{r4, pc}
 800c746:	bf00      	nop
 800c748:	20000d30 	.word	0x20000d30
 800c74c:	0800db40 	.word	0x0800db40

0800c750 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 800c750:	b510      	push	{r4, lr}
 800c752:	b084      	sub	sp, #16
  thread_t *otp, *cp;

  otp = currp;
 800c754:	4b25      	ldr	r3, [pc, #148]	; (800c7ec <chSchDoRescheduleAhead+0x9c>)
 800c756:	699b      	ldr	r3, [r3, #24]
 800c758:	9302      	str	r3, [sp, #8]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 800c75a:	4824      	ldr	r0, [pc, #144]	; (800c7ec <chSchDoRescheduleAhead+0x9c>)
 800c75c:	f7ff fdc8 	bl	800c2f0 <queue_fifo_remove.lto_priv.425>
 800c760:	4602      	mov	r2, r0
 800c762:	4b22      	ldr	r3, [pc, #136]	; (800c7ec <chSchDoRescheduleAhead+0x9c>)
 800c764:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800c766:	4b21      	ldr	r3, [pc, #132]	; (800c7ec <chSchDoRescheduleAhead+0x9c>)
 800c768:	699b      	ldr	r3, [r3, #24]
 800c76a:	2201      	movs	r2, #1
 800c76c:	f883 2020 	strb.w	r2, [r3, #32]

  otp->p_state = CH_STATE_READY;
 800c770:	9b02      	ldr	r3, [sp, #8]
 800c772:	2200      	movs	r2, #0
 800c774:	f883 2020 	strb.w	r2, [r3, #32]
  cp = (thread_t *)&ch.rlist.r_queue;
 800c778:	4b1c      	ldr	r3, [pc, #112]	; (800c7ec <chSchDoRescheduleAhead+0x9c>)
 800c77a:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 800c77c:	9b03      	ldr	r3, [sp, #12]
 800c77e:	681b      	ldr	r3, [r3, #0]
 800c780:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio > otp->p_prio);
 800c782:	9b03      	ldr	r3, [sp, #12]
 800c784:	689a      	ldr	r2, [r3, #8]
 800c786:	9b02      	ldr	r3, [sp, #8]
 800c788:	689b      	ldr	r3, [r3, #8]
 800c78a:	429a      	cmp	r2, r3
 800c78c:	d8f6      	bhi.n	800c77c <chSchDoRescheduleAhead+0x2c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 800c78e:	9b02      	ldr	r3, [sp, #8]
 800c790:	9a03      	ldr	r2, [sp, #12]
 800c792:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
 800c794:	9b03      	ldr	r3, [sp, #12]
 800c796:	685a      	ldr	r2, [r3, #4]
 800c798:	9b02      	ldr	r3, [sp, #8]
 800c79a:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
 800c79c:	9b02      	ldr	r3, [sp, #8]
 800c79e:	685b      	ldr	r3, [r3, #4]
 800c7a0:	9a02      	ldr	r2, [sp, #8]
 800c7a2:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
 800c7a4:	9b03      	ldr	r3, [sp, #12]
 800c7a6:	9a02      	ldr	r2, [sp, #8]
 800c7a8:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
 800c7aa:	9802      	ldr	r0, [sp, #8]
 800c7ac:	f7ff fbd8 	bl	800bf60 <_dbg_trace>
 800c7b0:	4b0e      	ldr	r3, [pc, #56]	; (800c7ec <chSchDoRescheduleAhead+0x9c>)
 800c7b2:	699b      	ldr	r3, [r3, #24]
 800c7b4:	4618      	mov	r0, r3
 800c7b6:	9902      	ldr	r1, [sp, #8]
 800c7b8:	f7fd fe22 	bl	800a400 <_stats_ctxswc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800c7bc:	f3ef 8309 	mrs	r3, PSP
 800c7c0:	461c      	mov	r4, r3
  return(result);
 800c7c2:	4623      	mov	r3, r4
 800c7c4:	9301      	str	r3, [sp, #4]
 800c7c6:	9b01      	ldr	r3, [sp, #4]
 800c7c8:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 800c7cc:	9b02      	ldr	r3, [sp, #8]
 800c7ce:	69db      	ldr	r3, [r3, #28]
 800c7d0:	429a      	cmp	r2, r3
 800c7d2:	d202      	bcs.n	800c7da <chSchDoRescheduleAhead+0x8a>
 800c7d4:	4806      	ldr	r0, [pc, #24]	; (800c7f0 <chSchDoRescheduleAhead+0xa0>)
 800c7d6:	f7ff f98b 	bl	800baf0 <chSysHalt>
 800c7da:	4b04      	ldr	r3, [pc, #16]	; (800c7ec <chSchDoRescheduleAhead+0x9c>)
 800c7dc:	699b      	ldr	r3, [r3, #24]
 800c7de:	4618      	mov	r0, r3
 800c7e0:	9902      	ldr	r1, [sp, #8]
 800c7e2:	f7f3 fd55 	bl	8000290 <_port_switch>
}
 800c7e6:	b004      	add	sp, #16
 800c7e8:	bd10      	pop	{r4, pc}
 800c7ea:	bf00      	nop
 800c7ec:	20000d30 	.word	0x20000d30
 800c7f0:	0800db40 	.word	0x0800db40
	...

0800c800 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 800c800:	b508      	push	{r3, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 800c802:	f7ff ffa5 	bl	800c750 <chSchDoRescheduleAhead>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 800c806:	bd08      	pop	{r3, pc}
	...

0800c810 <port_lock.lto_priv.444>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800c810:	b082      	sub	sp, #8
 800c812:	2320      	movs	r3, #32
 800c814:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800c816:	9b01      	ldr	r3, [sp, #4]
 800c818:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c81c:	b002      	add	sp, #8
 800c81e:	4770      	bx	lr

0800c820 <port_unlock.lto_priv.440>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800c820:	b082      	sub	sp, #8
 800c822:	2300      	movs	r3, #0
 800c824:	9301      	str	r3, [sp, #4]
 800c826:	9b01      	ldr	r3, [sp, #4]
 800c828:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c82c:	b002      	add	sp, #8
 800c82e:	4770      	bx	lr

0800c830 <st_lld_get_counter.lto_priv.436>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800c830:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800c834:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800c836:	4618      	mov	r0, r3
 800c838:	4770      	bx	lr
 800c83a:	bf00      	nop
 800c83c:	0000      	movs	r0, r0
	...

0800c840 <port_timer_get_time.lto_priv.432>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 800c840:	b508      	push	{r3, lr}

  return stGetCounter();
 800c842:	f7ff fff5 	bl	800c830 <st_lld_get_counter.lto_priv.436>
 800c846:	4603      	mov	r3, r0
}
 800c848:	4618      	mov	r0, r3
 800c84a:	bd08      	pop	{r3, pc}
 800c84c:	0000      	movs	r0, r0
	...

0800c850 <list_init>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
 800c850:	b082      	sub	sp, #8
 800c852:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
 800c854:	9b01      	ldr	r3, [sp, #4]
 800c856:	9a01      	ldr	r2, [sp, #4]
 800c858:	601a      	str	r2, [r3, #0]
}
 800c85a:	b002      	add	sp, #8
 800c85c:	4770      	bx	lr
 800c85e:	bf00      	nop

0800c860 <list_notempty>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
 800c860:	b082      	sub	sp, #8
 800c862:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
 800c864:	9b01      	ldr	r3, [sp, #4]
 800c866:	681a      	ldr	r2, [r3, #0]
 800c868:	9b01      	ldr	r3, [sp, #4]
 800c86a:	429a      	cmp	r2, r3
 800c86c:	bf14      	ite	ne
 800c86e:	2301      	movne	r3, #1
 800c870:	2300      	moveq	r3, #0
 800c872:	b2db      	uxtb	r3, r3
}
 800c874:	4618      	mov	r0, r3
 800c876:	b002      	add	sp, #8
 800c878:	4770      	bx	lr
 800c87a:	bf00      	nop
 800c87c:	0000      	movs	r0, r0
	...

0800c880 <queue_init.lto_priv.428>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 800c880:	b082      	sub	sp, #8
 800c882:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 800c884:	9b01      	ldr	r3, [sp, #4]
 800c886:	9a01      	ldr	r2, [sp, #4]
 800c888:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800c88a:	9b01      	ldr	r3, [sp, #4]
 800c88c:	9a01      	ldr	r2, [sp, #4]
 800c88e:	605a      	str	r2, [r3, #4]
}
 800c890:	b002      	add	sp, #8
 800c892:	4770      	bx	lr
	...

0800c8a0 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 800c8a0:	b082      	sub	sp, #8
 800c8a2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800c8a4:	9b01      	ldr	r3, [sp, #4]
 800c8a6:	681a      	ldr	r2, [r3, #0]
 800c8a8:	9b01      	ldr	r3, [sp, #4]
 800c8aa:	429a      	cmp	r2, r3
 800c8ac:	bf14      	ite	ne
 800c8ae:	2301      	movne	r3, #1
 800c8b0:	2300      	moveq	r3, #0
 800c8b2:	b2db      	uxtb	r3, r3
}
 800c8b4:	4618      	mov	r0, r3
 800c8b6:	b002      	add	sp, #8
 800c8b8:	4770      	bx	lr
 800c8ba:	bf00      	nop
 800c8bc:	0000      	movs	r0, r0
	...

0800c8c0 <list_insert>:

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {
 800c8c0:	b082      	sub	sp, #8
 800c8c2:	9001      	str	r0, [sp, #4]
 800c8c4:	9100      	str	r1, [sp, #0]

  tp->p_next = tlp->p_next;
 800c8c6:	9b00      	ldr	r3, [sp, #0]
 800c8c8:	681a      	ldr	r2, [r3, #0]
 800c8ca:	9b01      	ldr	r3, [sp, #4]
 800c8cc:	601a      	str	r2, [r3, #0]
  tlp->p_next = tp;
 800c8ce:	9b00      	ldr	r3, [sp, #0]
 800c8d0:	9a01      	ldr	r2, [sp, #4]
 800c8d2:	601a      	str	r2, [r3, #0]
}
 800c8d4:	b002      	add	sp, #8
 800c8d6:	4770      	bx	lr
	...

0800c8e0 <list_remove>:

static inline thread_t *list_remove(threads_list_t *tlp) {
 800c8e0:	b084      	sub	sp, #16
 800c8e2:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
 800c8e4:	9b01      	ldr	r3, [sp, #4]
 800c8e6:	681b      	ldr	r3, [r3, #0]
 800c8e8:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
 800c8ea:	9b03      	ldr	r3, [sp, #12]
 800c8ec:	681a      	ldr	r2, [r3, #0]
 800c8ee:	9b01      	ldr	r3, [sp, #4]
 800c8f0:	601a      	str	r2, [r3, #0]

  return tp;
 800c8f2:	9b03      	ldr	r3, [sp, #12]
}
 800c8f4:	4618      	mov	r0, r3
 800c8f6:	b004      	add	sp, #16
 800c8f8:	4770      	bx	lr
 800c8fa:	bf00      	nop
 800c8fc:	0000      	movs	r0, r0
	...

0800c900 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 800c900:	b082      	sub	sp, #8
 800c902:	9001      	str	r0, [sp, #4]
 800c904:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 800c906:	9b01      	ldr	r3, [sp, #4]
 800c908:	9a00      	ldr	r2, [sp, #0]
 800c90a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 800c90c:	9b00      	ldr	r3, [sp, #0]
 800c90e:	685a      	ldr	r2, [r3, #4]
 800c910:	9b01      	ldr	r3, [sp, #4]
 800c912:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 800c914:	9b01      	ldr	r3, [sp, #4]
 800c916:	685b      	ldr	r3, [r3, #4]
 800c918:	9a01      	ldr	r2, [sp, #4]
 800c91a:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 800c91c:	9b00      	ldr	r3, [sp, #0]
 800c91e:	9a01      	ldr	r2, [sp, #4]
 800c920:	605a      	str	r2, [r3, #4]
}
 800c922:	b002      	add	sp, #8
 800c924:	4770      	bx	lr
 800c926:	bf00      	nop
	...

0800c930 <queue_fifo_remove.lto_priv.426>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 800c930:	b084      	sub	sp, #16
 800c932:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 800c934:	9b01      	ldr	r3, [sp, #4]
 800c936:	681b      	ldr	r3, [r3, #0]
 800c938:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 800c93a:	9b03      	ldr	r3, [sp, #12]
 800c93c:	681a      	ldr	r2, [r3, #0]
 800c93e:	9b01      	ldr	r3, [sp, #4]
 800c940:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800c942:	9b01      	ldr	r3, [sp, #4]
 800c944:	681b      	ldr	r3, [r3, #0]
 800c946:	9a01      	ldr	r2, [sp, #4]
 800c948:	605a      	str	r2, [r3, #4]

  return tp;
 800c94a:	9b03      	ldr	r3, [sp, #12]
}
 800c94c:	4618      	mov	r0, r3
 800c94e:	b004      	add	sp, #16
 800c950:	4770      	bx	lr
 800c952:	bf00      	nop
	...

0800c960 <chSchCanYieldS>:
 * @retval false        if yielding is not possible.
 * @retval true         if there is a ready thread at equal or higher priority.
 *
 * @sclass
 */
static inline bool chSchCanYieldS(void) {
 800c960:	b508      	push	{r3, lr}

  chDbgCheckClassS();
 800c962:	f7ff fad5 	bl	800bf10 <chDbgCheckClassS>

  return firstprio(&ch.rlist.r_queue) >= currp->p_prio;
 800c966:	4b06      	ldr	r3, [pc, #24]	; (800c980 <chSchCanYieldS+0x20>)
 800c968:	681b      	ldr	r3, [r3, #0]
 800c96a:	689a      	ldr	r2, [r3, #8]
 800c96c:	4b04      	ldr	r3, [pc, #16]	; (800c980 <chSchCanYieldS+0x20>)
 800c96e:	699b      	ldr	r3, [r3, #24]
 800c970:	689b      	ldr	r3, [r3, #8]
 800c972:	429a      	cmp	r2, r3
 800c974:	bf2c      	ite	cs
 800c976:	2301      	movcs	r3, #1
 800c978:	2300      	movcc	r3, #0
 800c97a:	b2db      	uxtb	r3, r3
}
 800c97c:	4618      	mov	r0, r3
 800c97e:	bd08      	pop	{r3, pc}
 800c980:	20000d30 	.word	0x20000d30
	...

0800c990 <chSchDoYieldS>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal or higher priority, if any.
 *
 * @sclass
 */
static inline void chSchDoYieldS(void) {
 800c990:	b508      	push	{r3, lr}

  chDbgCheckClassS();
 800c992:	f7ff fabd 	bl	800bf10 <chDbgCheckClassS>

  if (chSchCanYieldS()) {
 800c996:	f7ff ffe3 	bl	800c960 <chSchCanYieldS>
 800c99a:	4603      	mov	r3, r0
 800c99c:	2b00      	cmp	r3, #0
 800c99e:	d001      	beq.n	800c9a4 <chSchDoYieldS+0x14>
    chSchDoRescheduleBehind();
 800c9a0:	f7ff fe9e 	bl	800c6e0 <chSchDoRescheduleBehind>
  }
}
 800c9a4:	bd08      	pop	{r3, pc}
 800c9a6:	bf00      	nop
	...

0800c9b0 <chSysLock.lto_priv.424>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800c9b0:	b508      	push	{r3, lr}

  port_lock();
 800c9b2:	f7ff ff2d 	bl	800c810 <port_lock.lto_priv.444>
  _stats_start_measure_crit_thd();
 800c9b6:	f7fd fd43 	bl	800a440 <_stats_start_measure_crit_thd>
  _dbg_check_lock();
 800c9ba:	f7ff f9f1 	bl	800bda0 <_dbg_check_lock>
}
 800c9be:	bd08      	pop	{r3, pc}

0800c9c0 <chSysUnlock.lto_priv.422>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800c9c0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 800c9c2:	f7ff fa05 	bl	800bdd0 <_dbg_check_unlock>
  _stats_stop_measure_crit_thd();
 800c9c6:	f7fd fd43 	bl	800a450 <_stats_stop_measure_crit_thd>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
 800c9ca:	4b09      	ldr	r3, [pc, #36]	; (800c9f0 <chSysUnlock.lto_priv.422+0x30>)
 800c9cc:	681b      	ldr	r3, [r3, #0]
 800c9ce:	4a08      	ldr	r2, [pc, #32]	; (800c9f0 <chSysUnlock.lto_priv.422+0x30>)
 800c9d0:	4293      	cmp	r3, r2
 800c9d2:	d00a      	beq.n	800c9ea <chSysUnlock.lto_priv.422+0x2a>
 800c9d4:	4b06      	ldr	r3, [pc, #24]	; (800c9f0 <chSysUnlock.lto_priv.422+0x30>)
 800c9d6:	699b      	ldr	r3, [r3, #24]
 800c9d8:	689a      	ldr	r2, [r3, #8]
 800c9da:	4b05      	ldr	r3, [pc, #20]	; (800c9f0 <chSysUnlock.lto_priv.422+0x30>)
 800c9dc:	681b      	ldr	r3, [r3, #0]
 800c9de:	689b      	ldr	r3, [r3, #8]
 800c9e0:	429a      	cmp	r2, r3
 800c9e2:	d202      	bcs.n	800c9ea <chSysUnlock.lto_priv.422+0x2a>
 800c9e4:	4803      	ldr	r0, [pc, #12]	; (800c9f4 <chSysUnlock.lto_priv.422+0x34>)
 800c9e6:	f7ff f883 	bl	800baf0 <chSysHalt>
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800c9ea:	f7ff ff19 	bl	800c820 <port_unlock.lto_priv.440>
}
 800c9ee:	bd08      	pop	{r3, pc}
 800c9f0:	20000d30 	.word	0x20000d30
 800c9f4:	0800dc40 	.word	0x0800dc40
	...

0800ca00 <chVTGetSystemTimeX.lto_priv.420>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 800ca00:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 800ca02:	f7ff ff1d 	bl	800c840 <port_timer_get_time.lto_priv.432>
 800ca06:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800ca08:	4618      	mov	r0, r3
 800ca0a:	bd08      	pop	{r3, pc}
 800ca0c:	0000      	movs	r0, r0
	...

0800ca10 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800ca10:	4b01      	ldr	r3, [pc, #4]	; (800ca18 <chThdGetSelfX+0x8>)
 800ca12:	699b      	ldr	r3, [r3, #24]
}
 800ca14:	4618      	mov	r0, r3
 800ca16:	4770      	bx	lr
 800ca18:	20000d30 	.word	0x20000d30
 800ca1c:	00000000 	.word	0x00000000

0800ca20 <chThdStartI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
static inline thread_t *chThdStartI(thread_t *tp) {
 800ca20:	b500      	push	{lr}
 800ca22:	b083      	sub	sp, #12
 800ca24:	9001      	str	r0, [sp, #4]

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");
 800ca26:	9b01      	ldr	r3, [sp, #4]
 800ca28:	f893 3020 	ldrb.w	r3, [r3, #32]
 800ca2c:	2b02      	cmp	r3, #2
 800ca2e:	d002      	beq.n	800ca36 <chThdStartI+0x16>
 800ca30:	4805      	ldr	r0, [pc, #20]	; (800ca48 <chThdStartI+0x28>)
 800ca32:	f7ff f85d 	bl	800baf0 <chSysHalt>

  return chSchReadyI(tp);
 800ca36:	9801      	ldr	r0, [sp, #4]
 800ca38:	f7ff fcda 	bl	800c3f0 <chSchReadyI>
 800ca3c:	4603      	mov	r3, r0
}
 800ca3e:	4618      	mov	r0, r3
 800ca40:	b003      	add	sp, #12
 800ca42:	f85d fb04 	ldr.w	pc, [sp], #4
 800ca46:	bf00      	nop
 800ca48:	0800dc50 	.word	0x0800dc50
 800ca4c:	00000000 	.word	0x00000000

0800ca50 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
 800ca50:	b500      	push	{lr}
 800ca52:	b083      	sub	sp, #12
 800ca54:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);
 800ca56:	9b01      	ldr	r3, [sp, #4]
 800ca58:	2b00      	cmp	r3, #0
 800ca5a:	d102      	bne.n	800ca62 <chThdSleepS+0x12>
 800ca5c:	4804      	ldr	r0, [pc, #16]	; (800ca70 <chThdSleepS+0x20>)
 800ca5e:	f7ff f847 	bl	800baf0 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 800ca62:	2008      	movs	r0, #8
 800ca64:	9901      	ldr	r1, [sp, #4]
 800ca66:	f7ff fd83 	bl	800c570 <chSchGoSleepTimeoutS>
}
 800ca6a:	b003      	add	sp, #12
 800ca6c:	f85d fb04 	ldr.w	pc, [sp], #4
 800ca70:	0800dc80 	.word	0x0800dc80
	...

0800ca80 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 800ca80:	b500      	push	{lr}
 800ca82:	b085      	sub	sp, #20
 800ca84:	9001      	str	r0, [sp, #4]
 800ca86:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");
 800ca88:	9801      	ldr	r0, [sp, #4]
 800ca8a:	f7ff ff09 	bl	800c8a0 <queue_notempty>
 800ca8e:	4603      	mov	r3, r0
 800ca90:	f083 0301 	eor.w	r3, r3, #1
 800ca94:	b2db      	uxtb	r3, r3
 800ca96:	2b00      	cmp	r3, #0
 800ca98:	d002      	beq.n	800caa0 <chThdDoDequeueNextI+0x20>
 800ca9a:	480c      	ldr	r0, [pc, #48]	; (800cacc <chThdDoDequeueNextI+0x4c>)
 800ca9c:	f7ff f828 	bl	800baf0 <chSysHalt>

  tp = queue_fifo_remove(tqp);
 800caa0:	9801      	ldr	r0, [sp, #4]
 800caa2:	f7ff ff45 	bl	800c930 <queue_fifo_remove.lto_priv.426>
 800caa6:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");
 800caa8:	9b03      	ldr	r3, [sp, #12]
 800caaa:	f893 3020 	ldrb.w	r3, [r3, #32]
 800caae:	2b04      	cmp	r3, #4
 800cab0:	d002      	beq.n	800cab8 <chThdDoDequeueNextI+0x38>
 800cab2:	4806      	ldr	r0, [pc, #24]	; (800cacc <chThdDoDequeueNextI+0x4c>)
 800cab4:	f7ff f81c 	bl	800baf0 <chSysHalt>

  tp->p_u.rdymsg = msg;
 800cab8:	9b03      	ldr	r3, [sp, #12]
 800caba:	9a00      	ldr	r2, [sp, #0]
 800cabc:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 800cabe:	9803      	ldr	r0, [sp, #12]
 800cac0:	f7ff fc96 	bl	800c3f0 <chSchReadyI>
}
 800cac4:	b005      	add	sp, #20
 800cac6:	f85d fb04 	ldr.w	pc, [sp], #4
 800caca:	bf00      	nop
 800cacc:	0800dce0 	.word	0x0800dce0

0800cad0 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 800cad0:	b500      	push	{lr}
 800cad2:	b083      	sub	sp, #12
 800cad4:	9001      	str	r0, [sp, #4]
 800cad6:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
 800cad8:	9b01      	ldr	r3, [sp, #4]
 800cada:	9a00      	ldr	r2, [sp, #0]
 800cadc:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
 800cade:	9b01      	ldr	r3, [sp, #4]
 800cae0:	2202      	movs	r2, #2
 800cae2:	f883 2020 	strb.w	r2, [r3, #32]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800cae6:	9b01      	ldr	r3, [sp, #4]
 800cae8:	2200      	movs	r2, #0
 800caea:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 800caee:	9b01      	ldr	r3, [sp, #4]
 800caf0:	9a00      	ldr	r2, [sp, #0]
 800caf2:	641a      	str	r2, [r3, #64]	; 0x40
  tp->p_mtxlist = NULL;
 800caf4:	9b01      	ldr	r3, [sp, #4]
 800caf6:	2200      	movs	r2, #0
 800caf8:	63da      	str	r2, [r3, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800cafa:	9b01      	ldr	r3, [sp, #4]
 800cafc:	2200      	movs	r2, #0
 800cafe:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800cb00:	9b01      	ldr	r3, [sp, #4]
 800cb02:	2201      	movs	r2, #1
 800cb04:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 800cb08:	9b01      	ldr	r3, [sp, #4]
 800cb0a:	2200      	movs	r2, #0
 800cb0c:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 800cb0e:	9b01      	ldr	r3, [sp, #4]
 800cb10:	4a12      	ldr	r2, [pc, #72]	; (800cb5c <_thread_init+0x8c>)
 800cb12:	611a      	str	r2, [r3, #16]
 800cb14:	4b11      	ldr	r3, [pc, #68]	; (800cb5c <_thread_init+0x8c>)
 800cb16:	695a      	ldr	r2, [r3, #20]
 800cb18:	9b01      	ldr	r3, [sp, #4]
 800cb1a:	615a      	str	r2, [r3, #20]
 800cb1c:	9b01      	ldr	r3, [sp, #4]
 800cb1e:	695b      	ldr	r3, [r3, #20]
 800cb20:	9a01      	ldr	r2, [sp, #4]
 800cb22:	611a      	str	r2, [r3, #16]
 800cb24:	4a0d      	ldr	r2, [pc, #52]	; (800cb5c <_thread_init+0x8c>)
 800cb26:	9b01      	ldr	r3, [sp, #4]
 800cb28:	6153      	str	r3, [r2, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 800cb2a:	9b01      	ldr	r3, [sp, #4]
 800cb2c:	3328      	adds	r3, #40	; 0x28
 800cb2e:	4618      	mov	r0, r3
 800cb30:	f7ff fe8e 	bl	800c850 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 800cb34:	9b01      	ldr	r3, [sp, #4]
 800cb36:	332c      	adds	r3, #44	; 0x2c
 800cb38:	4618      	mov	r0, r3
 800cb3a:	f7ff fea1 	bl	800c880 <queue_init.lto_priv.428>
#endif
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  tp->p_stklimit = (stkalign_t *)(tp + 1);
 800cb3e:	9b01      	ldr	r3, [sp, #4]
 800cb40:	f103 0260 	add.w	r2, r3, #96	; 0x60
 800cb44:	9b01      	ldr	r3, [sp, #4]
 800cb46:	61da      	str	r2, [r3, #28]
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->p_stats);
 800cb48:	9b01      	ldr	r3, [sp, #4]
 800cb4a:	3348      	adds	r3, #72	; 0x48
 800cb4c:	4618      	mov	r0, r3
 800cb4e:	f000 faa7 	bl	800d0a0 <chTMObjectInit>
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
 800cb52:	9b01      	ldr	r3, [sp, #4]
}
 800cb54:	4618      	mov	r0, r3
 800cb56:	b003      	add	sp, #12
 800cb58:	f85d fb04 	ldr.w	pc, [sp], #4
 800cb5c:	20000d30 	.word	0x20000d30

0800cb60 <_thread_memfill>:
 * @param[in] endp      last address to fill +1
 * @param[in] v         filler value
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {
 800cb60:	b084      	sub	sp, #16
 800cb62:	9003      	str	r0, [sp, #12]
 800cb64:	9102      	str	r1, [sp, #8]
 800cb66:	4613      	mov	r3, r2
 800cb68:	f88d 3007 	strb.w	r3, [sp, #7]
 800cb6c:	e005      	b.n	800cb7a <_thread_memfill+0x1a>

  while (startp < endp) {
    *startp++ = v;
 800cb6e:	9b03      	ldr	r3, [sp, #12]
 800cb70:	1c5a      	adds	r2, r3, #1
 800cb72:	9203      	str	r2, [sp, #12]
 800cb74:	f89d 2007 	ldrb.w	r2, [sp, #7]
 800cb78:	701a      	strb	r2, [r3, #0]
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 800cb7a:	9a03      	ldr	r2, [sp, #12]
 800cb7c:	9b02      	ldr	r3, [sp, #8]
 800cb7e:	429a      	cmp	r2, r3
 800cb80:	d3f5      	bcc.n	800cb6e <_thread_memfill+0xe>
    *startp++ = v;
  }
}
 800cb82:	b004      	add	sp, #16
 800cb84:	4770      	bx	lr
 800cb86:	bf00      	nop
	...

0800cb90 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 800cb90:	b500      	push	{lr}
 800cb92:	b087      	sub	sp, #28
 800cb94:	9003      	str	r0, [sp, #12]
 800cb96:	9102      	str	r1, [sp, #8]
 800cb98:	9201      	str	r2, [sp, #4]
 800cb9a:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
 800cb9c:	9b03      	ldr	r3, [sp, #12]
 800cb9e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 800cba0:	f7ff f99e 	bl	800bee0 <chDbgCheckClassI>
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
 800cba4:	9b03      	ldr	r3, [sp, #12]
 800cba6:	2b00      	cmp	r3, #0
 800cba8:	d008      	beq.n	800cbbc <chThdCreateI+0x2c>
 800cbaa:	9b02      	ldr	r3, [sp, #8]
 800cbac:	2be7      	cmp	r3, #231	; 0xe7
 800cbae:	d905      	bls.n	800cbbc <chThdCreateI+0x2c>
 800cbb0:	9b01      	ldr	r3, [sp, #4]
 800cbb2:	2b7f      	cmp	r3, #127	; 0x7f
 800cbb4:	d802      	bhi.n	800cbbc <chThdCreateI+0x2c>
 800cbb6:	9b00      	ldr	r3, [sp, #0]
 800cbb8:	2b00      	cmp	r3, #0
 800cbba:	d102      	bne.n	800cbc2 <chThdCreateI+0x32>
 800cbbc:	480e      	ldr	r0, [pc, #56]	; (800cbf8 <chThdCreateI+0x68>)
 800cbbe:	f7fe ff97 	bl	800baf0 <chSysHalt>
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800cbc2:	9b02      	ldr	r3, [sp, #8]
 800cbc4:	3b24      	subs	r3, #36	; 0x24
 800cbc6:	9a03      	ldr	r2, [sp, #12]
 800cbc8:	441a      	add	r2, r3
 800cbca:	9b05      	ldr	r3, [sp, #20]
 800cbcc:	60da      	str	r2, [r3, #12]
 800cbce:	9b05      	ldr	r3, [sp, #20]
 800cbd0:	68db      	ldr	r3, [r3, #12]
 800cbd2:	9a00      	ldr	r2, [sp, #0]
 800cbd4:	601a      	str	r2, [r3, #0]
 800cbd6:	9b05      	ldr	r3, [sp, #20]
 800cbd8:	68db      	ldr	r3, [r3, #12]
 800cbda:	9a08      	ldr	r2, [sp, #32]
 800cbdc:	605a      	str	r2, [r3, #4]
 800cbde:	9b05      	ldr	r3, [sp, #20]
 800cbe0:	68db      	ldr	r3, [r3, #12]
 800cbe2:	4a06      	ldr	r2, [pc, #24]	; (800cbfc <chThdCreateI+0x6c>)
 800cbe4:	621a      	str	r2, [r3, #32]

  return _thread_init(tp, prio);
 800cbe6:	9805      	ldr	r0, [sp, #20]
 800cbe8:	9901      	ldr	r1, [sp, #4]
 800cbea:	f7ff ff71 	bl	800cad0 <_thread_init>
 800cbee:	4603      	mov	r3, r0
}
 800cbf0:	4618      	mov	r0, r3
 800cbf2:	b007      	add	sp, #28
 800cbf4:	f85d fb04 	ldr.w	pc, [sp], #4
 800cbf8:	0800dc30 	.word	0x0800dc30
 800cbfc:	080002a1 	.word	0x080002a1

0800cc00 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 800cc00:	b500      	push	{lr}
 800cc02:	b089      	sub	sp, #36	; 0x24
 800cc04:	9005      	str	r0, [sp, #20]
 800cc06:	9104      	str	r1, [sp, #16]
 800cc08:	9203      	str	r2, [sp, #12]
 800cc0a:	9302      	str	r3, [sp, #8]
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 800cc0c:	9b05      	ldr	r3, [sp, #20]
 800cc0e:	3360      	adds	r3, #96	; 0x60
 800cc10:	9805      	ldr	r0, [sp, #20]
 800cc12:	4619      	mov	r1, r3
 800cc14:	22ff      	movs	r2, #255	; 0xff
 800cc16:	f7ff ffa3 	bl	800cb60 <_thread_memfill>
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 800cc1a:	9b05      	ldr	r3, [sp, #20]
 800cc1c:	f103 0160 	add.w	r1, r3, #96	; 0x60
 800cc20:	9a05      	ldr	r2, [sp, #20]
 800cc22:	9b04      	ldr	r3, [sp, #16]
 800cc24:	4413      	add	r3, r2
 800cc26:	4608      	mov	r0, r1
 800cc28:	4619      	mov	r1, r3
 800cc2a:	2255      	movs	r2, #85	; 0x55
 800cc2c:	f7ff ff98 	bl	800cb60 <_thread_memfill>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 800cc30:	f7ff febe 	bl	800c9b0 <chSysLock.lto_priv.424>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 800cc34:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800cc36:	9300      	str	r3, [sp, #0]
 800cc38:	9805      	ldr	r0, [sp, #20]
 800cc3a:	9904      	ldr	r1, [sp, #16]
 800cc3c:	9a03      	ldr	r2, [sp, #12]
 800cc3e:	9b02      	ldr	r3, [sp, #8]
 800cc40:	f7ff ffa6 	bl	800cb90 <chThdCreateI>
 800cc44:	9007      	str	r0, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
 800cc46:	9807      	ldr	r0, [sp, #28]
 800cc48:	2100      	movs	r1, #0
 800cc4a:	f7ff fcc9 	bl	800c5e0 <chSchWakeupS>
  chSysUnlock();
 800cc4e:	f7ff feb7 	bl	800c9c0 <chSysUnlock.lto_priv.422>

  return tp;
 800cc52:	9b07      	ldr	r3, [sp, #28]
}
 800cc54:	4618      	mov	r0, r3
 800cc56:	b009      	add	sp, #36	; 0x24
 800cc58:	f85d fb04 	ldr.w	pc, [sp], #4
 800cc5c:	0000      	movs	r0, r0
	...

0800cc60 <chThdStart>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdStart(thread_t *tp) {
 800cc60:	b500      	push	{lr}
 800cc62:	b083      	sub	sp, #12
 800cc64:	9001      	str	r0, [sp, #4]

  chSysLock();
 800cc66:	f7ff fea3 	bl	800c9b0 <chSysLock.lto_priv.424>
  tp = chThdStartI(tp);
 800cc6a:	9801      	ldr	r0, [sp, #4]
 800cc6c:	f7ff fed8 	bl	800ca20 <chThdStartI>
 800cc70:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800cc72:	f7ff fea5 	bl	800c9c0 <chSysUnlock.lto_priv.422>

  return tp;
 800cc76:	9b01      	ldr	r3, [sp, #4]
}
 800cc78:	4618      	mov	r0, r3
 800cc7a:	b003      	add	sp, #12
 800cc7c:	f85d fb04 	ldr.w	pc, [sp], #4

0800cc80 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 800cc80:	b500      	push	{lr}
 800cc82:	b085      	sub	sp, #20
 800cc84:	9001      	str	r0, [sp, #4]
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO);
 800cc86:	9b01      	ldr	r3, [sp, #4]
 800cc88:	2b7f      	cmp	r3, #127	; 0x7f
 800cc8a:	d902      	bls.n	800cc92 <chThdSetPriority+0x12>
 800cc8c:	4813      	ldr	r0, [pc, #76]	; (800ccdc <chThdSetPriority+0x5c>)
 800cc8e:	f7fe ff2f 	bl	800baf0 <chSysHalt>

  chSysLock();
 800cc92:	f7ff fe8d 	bl	800c9b0 <chSysLock.lto_priv.424>
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->p_realprio;
 800cc96:	4b12      	ldr	r3, [pc, #72]	; (800cce0 <chThdSetPriority+0x60>)
 800cc98:	699b      	ldr	r3, [r3, #24]
 800cc9a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800cc9c:	9303      	str	r3, [sp, #12]
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
 800cc9e:	4b10      	ldr	r3, [pc, #64]	; (800cce0 <chThdSetPriority+0x60>)
 800cca0:	699b      	ldr	r3, [r3, #24]
 800cca2:	689a      	ldr	r2, [r3, #8]
 800cca4:	4b0e      	ldr	r3, [pc, #56]	; (800cce0 <chThdSetPriority+0x60>)
 800cca6:	699b      	ldr	r3, [r3, #24]
 800cca8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ccaa:	429a      	cmp	r2, r3
 800ccac:	d005      	beq.n	800ccba <chThdSetPriority+0x3a>
 800ccae:	4b0c      	ldr	r3, [pc, #48]	; (800cce0 <chThdSetPriority+0x60>)
 800ccb0:	699b      	ldr	r3, [r3, #24]
 800ccb2:	689a      	ldr	r2, [r3, #8]
 800ccb4:	9b01      	ldr	r3, [sp, #4]
 800ccb6:	429a      	cmp	r2, r3
 800ccb8:	d203      	bcs.n	800ccc2 <chThdSetPriority+0x42>
    currp->p_prio = newprio;
 800ccba:	4b09      	ldr	r3, [pc, #36]	; (800cce0 <chThdSetPriority+0x60>)
 800ccbc:	699b      	ldr	r3, [r3, #24]
 800ccbe:	9a01      	ldr	r2, [sp, #4]
 800ccc0:	609a      	str	r2, [r3, #8]
  }
  currp->p_realprio = newprio;
 800ccc2:	4b07      	ldr	r3, [pc, #28]	; (800cce0 <chThdSetPriority+0x60>)
 800ccc4:	699b      	ldr	r3, [r3, #24]
 800ccc6:	9a01      	ldr	r2, [sp, #4]
 800ccc8:	641a      	str	r2, [r3, #64]	; 0x40
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
 800ccca:	f7ff fce1 	bl	800c690 <chSchRescheduleS>
  chSysUnlock();
 800ccce:	f7ff fe77 	bl	800c9c0 <chSysUnlock.lto_priv.422>

  return oldprio;
 800ccd2:	9b03      	ldr	r3, [sp, #12]
}
 800ccd4:	4618      	mov	r0, r3
 800ccd6:	b005      	add	sp, #20
 800ccd8:	f85d fb04 	ldr.w	pc, [sp], #4
 800ccdc:	0800dc60 	.word	0x0800dc60
 800cce0:	20000d30 	.word	0x20000d30
	...

0800ccf0 <chThdTerminate>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdTerminate(thread_t *tp) {
 800ccf0:	b500      	push	{lr}
 800ccf2:	b083      	sub	sp, #12
 800ccf4:	9001      	str	r0, [sp, #4]

  chSysLock();
 800ccf6:	f7ff fe5b 	bl	800c9b0 <chSysLock.lto_priv.424>
  tp->p_flags |= CH_FLAG_TERMINATE;
 800ccfa:	9b01      	ldr	r3, [sp, #4]
 800ccfc:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800cd00:	f043 0304 	orr.w	r3, r3, #4
 800cd04:	b2da      	uxtb	r2, r3
 800cd06:	9b01      	ldr	r3, [sp, #4]
 800cd08:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  chSysUnlock();
 800cd0c:	f7ff fe58 	bl	800c9c0 <chSysUnlock.lto_priv.422>
}
 800cd10:	b003      	add	sp, #12
 800cd12:	f85d fb04 	ldr.w	pc, [sp], #4
 800cd16:	bf00      	nop
	...

0800cd20 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 800cd20:	b500      	push	{lr}
 800cd22:	b083      	sub	sp, #12
 800cd24:	9001      	str	r0, [sp, #4]

  chSysLock();
 800cd26:	f7ff fe43 	bl	800c9b0 <chSysLock.lto_priv.424>
  chThdSleepS(time);
 800cd2a:	9801      	ldr	r0, [sp, #4]
 800cd2c:	f7ff fe90 	bl	800ca50 <chThdSleepS>
  chSysUnlock();
 800cd30:	f7ff fe46 	bl	800c9c0 <chSysUnlock.lto_priv.422>
}
 800cd34:	b003      	add	sp, #12
 800cd36:	f85d fb04 	ldr.w	pc, [sp], #4
 800cd3a:	bf00      	nop
 800cd3c:	0000      	movs	r0, r0
	...

0800cd40 <chThdSleepUntil>:
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
 800cd40:	b500      	push	{lr}
 800cd42:	b083      	sub	sp, #12
 800cd44:	9001      	str	r0, [sp, #4]

  chSysLock();
 800cd46:	f7ff fe33 	bl	800c9b0 <chSysLock.lto_priv.424>
  time -= chVTGetSystemTimeX();
 800cd4a:	f7ff fe59 	bl	800ca00 <chVTGetSystemTimeX.lto_priv.420>
 800cd4e:	4602      	mov	r2, r0
 800cd50:	9b01      	ldr	r3, [sp, #4]
 800cd52:	1a9b      	subs	r3, r3, r2
 800cd54:	9301      	str	r3, [sp, #4]
  if (time > (systime_t)0) {
 800cd56:	9b01      	ldr	r3, [sp, #4]
 800cd58:	2b00      	cmp	r3, #0
 800cd5a:	d002      	beq.n	800cd62 <chThdSleepUntil+0x22>
    chThdSleepS(time);
 800cd5c:	9801      	ldr	r0, [sp, #4]
 800cd5e:	f7ff fe77 	bl	800ca50 <chThdSleepS>
  }
  chSysUnlock();
 800cd62:	f7ff fe2d 	bl	800c9c0 <chSysUnlock.lto_priv.422>
}
 800cd66:	b003      	add	sp, #12
 800cd68:	f85d fb04 	ldr.w	pc, [sp], #4
 800cd6c:	0000      	movs	r0, r0
	...

0800cd70 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 800cd70:	b508      	push	{r3, lr}

  chSysLock();
 800cd72:	f7ff fe1d 	bl	800c9b0 <chSysLock.lto_priv.424>
  chSchDoYieldS();
 800cd76:	f7ff fe0b 	bl	800c990 <chSchDoYieldS>
  chSysUnlock();
 800cd7a:	f7ff fe21 	bl	800c9c0 <chSysUnlock.lto_priv.422>
}
 800cd7e:	bd08      	pop	{r3, pc}

0800cd80 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 800cd80:	b500      	push	{lr}
 800cd82:	b083      	sub	sp, #12
 800cd84:	9001      	str	r0, [sp, #4]

  chSysLock();
 800cd86:	f7ff fe13 	bl	800c9b0 <chSysLock.lto_priv.424>
  chThdExitS(msg);
 800cd8a:	9801      	ldr	r0, [sp, #4]
 800cd8c:	f000 f808 	bl	800cda0 <chThdExitS>
  /* The thread never returns here.*/
}
 800cd90:	b003      	add	sp, #12
 800cd92:	f85d fb04 	ldr.w	pc, [sp], #4
 800cd96:	bf00      	nop
	...

0800cda0 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 800cda0:	b500      	push	{lr}
 800cda2:	b085      	sub	sp, #20
 800cda4:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 800cda6:	4b19      	ldr	r3, [pc, #100]	; (800ce0c <chThdExitS+0x6c>)
 800cda8:	699b      	ldr	r3, [r3, #24]
 800cdaa:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
 800cdac:	9b03      	ldr	r3, [sp, #12]
 800cdae:	9a01      	ldr	r2, [sp, #4]
 800cdb0:	625a      	str	r2, [r3, #36]	; 0x24
 800cdb2:	e008      	b.n	800cdc6 <chThdExitS+0x26>
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 800cdb4:	9b03      	ldr	r3, [sp, #12]
 800cdb6:	3328      	adds	r3, #40	; 0x28
 800cdb8:	4618      	mov	r0, r3
 800cdba:	f7ff fd91 	bl	800c8e0 <list_remove>
 800cdbe:	4603      	mov	r3, r0
 800cdc0:	4618      	mov	r0, r3
 800cdc2:	f7ff fb15 	bl	800c3f0 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 800cdc6:	9b03      	ldr	r3, [sp, #12]
 800cdc8:	3328      	adds	r3, #40	; 0x28
 800cdca:	4618      	mov	r0, r3
 800cdcc:	f7ff fd48 	bl	800c860 <list_notempty>
 800cdd0:	4603      	mov	r3, r0
 800cdd2:	2b00      	cmp	r3, #0
 800cdd4:	d1ee      	bne.n	800cdb4 <chThdExitS+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 800cdd6:	9b03      	ldr	r3, [sp, #12]
 800cdd8:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800cddc:	f003 0303 	and.w	r3, r3, #3
 800cde0:	2b00      	cmp	r3, #0
 800cde2:	d109      	bne.n	800cdf8 <chThdExitS+0x58>
    REG_REMOVE(tp);
 800cde4:	9b03      	ldr	r3, [sp, #12]
 800cde6:	695b      	ldr	r3, [r3, #20]
 800cde8:	9a03      	ldr	r2, [sp, #12]
 800cdea:	6912      	ldr	r2, [r2, #16]
 800cdec:	611a      	str	r2, [r3, #16]
 800cdee:	9b03      	ldr	r3, [sp, #12]
 800cdf0:	691b      	ldr	r3, [r3, #16]
 800cdf2:	9a03      	ldr	r2, [sp, #12]
 800cdf4:	6952      	ldr	r2, [r2, #20]
 800cdf6:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 800cdf8:	200f      	movs	r0, #15
 800cdfa:	f7ff fb39 	bl	800c470 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 800cdfe:	4804      	ldr	r0, [pc, #16]	; (800ce10 <chThdExitS+0x70>)
 800ce00:	f7fe fe76 	bl	800baf0 <chSysHalt>
}
 800ce04:	b005      	add	sp, #20
 800ce06:	f85d fb04 	ldr.w	pc, [sp], #4
 800ce0a:	bf00      	nop
 800ce0c:	20000d30 	.word	0x20000d30
 800ce10:	0800dc90 	.word	0x0800dc90
	...

0800ce20 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 800ce20:	b500      	push	{lr}
 800ce22:	b085      	sub	sp, #20
 800ce24:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chDbgCheck(tp != NULL);
 800ce26:	9b01      	ldr	r3, [sp, #4]
 800ce28:	2b00      	cmp	r3, #0
 800ce2a:	d102      	bne.n	800ce32 <chThdWait+0x12>
 800ce2c:	4818      	ldr	r0, [pc, #96]	; (800ce90 <chThdWait+0x70>)
 800ce2e:	f7fe fe5f 	bl	800baf0 <chSysHalt>

  chSysLock();
 800ce32:	f7ff fdbd 	bl	800c9b0 <chSysLock.lto_priv.424>
  chDbgAssert(tp != currp, "waiting self");
 800ce36:	4b17      	ldr	r3, [pc, #92]	; (800ce94 <chThdWait+0x74>)
 800ce38:	699a      	ldr	r2, [r3, #24]
 800ce3a:	9b01      	ldr	r3, [sp, #4]
 800ce3c:	429a      	cmp	r2, r3
 800ce3e:	d102      	bne.n	800ce46 <chThdWait+0x26>
 800ce40:	4813      	ldr	r0, [pc, #76]	; (800ce90 <chThdWait+0x70>)
 800ce42:	f7fe fe55 	bl	800baf0 <chSysHalt>
#if CH_CFG_USE_DYNAMIC == TRUE
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
 800ce46:	9b01      	ldr	r3, [sp, #4]
 800ce48:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 800ce4c:	2b00      	cmp	r3, #0
 800ce4e:	d102      	bne.n	800ce56 <chThdWait+0x36>
 800ce50:	480f      	ldr	r0, [pc, #60]	; (800ce90 <chThdWait+0x70>)
 800ce52:	f7fe fe4d 	bl	800baf0 <chSysHalt>
#endif
  if (tp->p_state != CH_STATE_FINAL) {
 800ce56:	9b01      	ldr	r3, [sp, #4]
 800ce58:	f893 3020 	ldrb.w	r3, [r3, #32]
 800ce5c:	2b0f      	cmp	r3, #15
 800ce5e:	d00a      	beq.n	800ce76 <chThdWait+0x56>
    list_insert(currp, &tp->p_waiting);
 800ce60:	4b0c      	ldr	r3, [pc, #48]	; (800ce94 <chThdWait+0x74>)
 800ce62:	699a      	ldr	r2, [r3, #24]
 800ce64:	9b01      	ldr	r3, [sp, #4]
 800ce66:	3328      	adds	r3, #40	; 0x28
 800ce68:	4610      	mov	r0, r2
 800ce6a:	4619      	mov	r1, r3
 800ce6c:	f7ff fd28 	bl	800c8c0 <list_insert>
    chSchGoSleepS(CH_STATE_WTEXIT);
 800ce70:	2009      	movs	r0, #9
 800ce72:	f7ff fafd 	bl	800c470 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
 800ce76:	9b01      	ldr	r3, [sp, #4]
 800ce78:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ce7a:	9303      	str	r3, [sp, #12]
  chSysUnlock();
 800ce7c:	f7ff fda0 	bl	800c9c0 <chSysUnlock.lto_priv.422>

#if CH_CFG_USE_DYNAMIC == TRUE
  /* Releasing a lock if it is a dynamic thread.*/
  chThdRelease(tp);
 800ce80:	9801      	ldr	r0, [sp, #4]
 800ce82:	f7fd fb55 	bl	800a530 <chThdRelease>
#endif

  return msg;
 800ce86:	9b03      	ldr	r3, [sp, #12]
}
 800ce88:	4618      	mov	r0, r3
 800ce8a:	b005      	add	sp, #20
 800ce8c:	f85d fb04 	ldr.w	pc, [sp], #4
 800ce90:	0800dca0 	.word	0x0800dca0
 800ce94:	20000d30 	.word	0x20000d30
	...

0800cea0 <chThdSuspendTimeoutS>:
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
 800cea0:	b500      	push	{lr}
 800cea2:	b085      	sub	sp, #20
 800cea4:	9001      	str	r0, [sp, #4]
 800cea6:	9100      	str	r1, [sp, #0]
  thread_t *tp = chThdGetSelfX();
 800cea8:	f7ff fdb2 	bl	800ca10 <chThdGetSelfX>
 800ceac:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");
 800ceae:	9b01      	ldr	r3, [sp, #4]
 800ceb0:	681b      	ldr	r3, [r3, #0]
 800ceb2:	2b00      	cmp	r3, #0
 800ceb4:	d002      	beq.n	800cebc <chThdSuspendTimeoutS+0x1c>
 800ceb6:	480c      	ldr	r0, [pc, #48]	; (800cee8 <chThdSuspendTimeoutS+0x48>)
 800ceb8:	f7fe fe1a 	bl	800baf0 <chSysHalt>

  if (TIME_IMMEDIATE == timeout) {
 800cebc:	9b00      	ldr	r3, [sp, #0]
 800cebe:	2b00      	cmp	r3, #0
 800cec0:	d102      	bne.n	800cec8 <chThdSuspendTimeoutS+0x28>
    return MSG_TIMEOUT;
 800cec2:	f04f 33ff 	mov.w	r3, #4294967295
 800cec6:	e00a      	b.n	800cede <chThdSuspendTimeoutS+0x3e>
  }

  *trp = tp;
 800cec8:	9b01      	ldr	r3, [sp, #4]
 800ceca:	9a03      	ldr	r2, [sp, #12]
 800cecc:	601a      	str	r2, [r3, #0]
  tp->p_u.wttrp = trp;
 800cece:	9b03      	ldr	r3, [sp, #12]
 800ced0:	9a01      	ldr	r2, [sp, #4]
 800ced2:	625a      	str	r2, [r3, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800ced4:	2003      	movs	r0, #3
 800ced6:	9900      	ldr	r1, [sp, #0]
 800ced8:	f7ff fb4a 	bl	800c570 <chSchGoSleepTimeoutS>
 800cedc:	4603      	mov	r3, r0
}
 800cede:	4618      	mov	r0, r3
 800cee0:	b005      	add	sp, #20
 800cee2:	f85d fb04 	ldr.w	pc, [sp], #4
 800cee6:	bf00      	nop
 800cee8:	0800dcb0 	.word	0x0800dcb0
 800ceec:	00000000 	.word	0x00000000

0800cef0 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 800cef0:	b500      	push	{lr}
 800cef2:	b085      	sub	sp, #20
 800cef4:	9001      	str	r0, [sp, #4]
 800cef6:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 800cef8:	9b01      	ldr	r3, [sp, #4]
 800cefa:	681b      	ldr	r3, [r3, #0]
 800cefc:	2b00      	cmp	r3, #0
 800cefe:	d013      	beq.n	800cf28 <chThdResumeI+0x38>
    thread_t *tp = *trp;
 800cf00:	9b01      	ldr	r3, [sp, #4]
 800cf02:	681b      	ldr	r3, [r3, #0]
 800cf04:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
 800cf06:	9b03      	ldr	r3, [sp, #12]
 800cf08:	f893 3020 	ldrb.w	r3, [r3, #32]
 800cf0c:	2b03      	cmp	r3, #3
 800cf0e:	d002      	beq.n	800cf16 <chThdResumeI+0x26>
 800cf10:	4807      	ldr	r0, [pc, #28]	; (800cf30 <chThdResumeI+0x40>)
 800cf12:	f7fe fded 	bl	800baf0 <chSysHalt>
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 800cf16:	9b01      	ldr	r3, [sp, #4]
 800cf18:	2200      	movs	r2, #0
 800cf1a:	601a      	str	r2, [r3, #0]
    tp->p_u.rdymsg = msg;
 800cf1c:	9b03      	ldr	r3, [sp, #12]
 800cf1e:	9a00      	ldr	r2, [sp, #0]
 800cf20:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800cf22:	9803      	ldr	r0, [sp, #12]
 800cf24:	f7ff fa64 	bl	800c3f0 <chSchReadyI>
  }
}
 800cf28:	b005      	add	sp, #20
 800cf2a:	f85d fb04 	ldr.w	pc, [sp], #4
 800cf2e:	bf00      	nop
 800cf30:	0800dcd0 	.word	0x0800dcd0
	...

0800cf40 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 800cf40:	b500      	push	{lr}
 800cf42:	b083      	sub	sp, #12
 800cf44:	9001      	str	r0, [sp, #4]
 800cf46:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
 800cf48:	9b00      	ldr	r3, [sp, #0]
 800cf4a:	2b00      	cmp	r3, #0
 800cf4c:	d102      	bne.n	800cf54 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
 800cf4e:	f04f 33ff 	mov.w	r3, #4294967295
 800cf52:	e00a      	b.n	800cf6a <chThdEnqueueTimeoutS+0x2a>
  }

  queue_insert(currp, tqp);
 800cf54:	4b07      	ldr	r3, [pc, #28]	; (800cf74 <chThdEnqueueTimeoutS+0x34>)
 800cf56:	699b      	ldr	r3, [r3, #24]
 800cf58:	4618      	mov	r0, r3
 800cf5a:	9901      	ldr	r1, [sp, #4]
 800cf5c:	f7ff fcd0 	bl	800c900 <queue_insert>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800cf60:	2004      	movs	r0, #4
 800cf62:	9900      	ldr	r1, [sp, #0]
 800cf64:	f7ff fb04 	bl	800c570 <chSchGoSleepTimeoutS>
 800cf68:	4603      	mov	r3, r0
}
 800cf6a:	4618      	mov	r0, r3
 800cf6c:	b003      	add	sp, #12
 800cf6e:	f85d fb04 	ldr.w	pc, [sp], #4
 800cf72:	bf00      	nop
 800cf74:	20000d30 	.word	0x20000d30
	...

0800cf80 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 800cf80:	b500      	push	{lr}
 800cf82:	b083      	sub	sp, #12
 800cf84:	9001      	str	r0, [sp, #4]
 800cf86:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 800cf88:	9801      	ldr	r0, [sp, #4]
 800cf8a:	f7ff fc89 	bl	800c8a0 <queue_notempty>
 800cf8e:	4603      	mov	r3, r0
 800cf90:	2b00      	cmp	r3, #0
 800cf92:	d003      	beq.n	800cf9c <chThdDequeueNextI+0x1c>
    chThdDoDequeueNextI(tqp, msg);
 800cf94:	9801      	ldr	r0, [sp, #4]
 800cf96:	9900      	ldr	r1, [sp, #0]
 800cf98:	f7ff fd72 	bl	800ca80 <chThdDoDequeueNextI>
  }
}
 800cf9c:	b003      	add	sp, #12
 800cf9e:	f85d fb04 	ldr.w	pc, [sp], #4
 800cfa2:	bf00      	nop
	...

0800cfb0 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 800cfb0:	b500      	push	{lr}
 800cfb2:	b083      	sub	sp, #12
 800cfb4:	9001      	str	r0, [sp, #4]
 800cfb6:	9100      	str	r1, [sp, #0]
 800cfb8:	e003      	b.n	800cfc2 <chThdDequeueAllI+0x12>

  while (queue_notempty(tqp)) {
    chThdDoDequeueNextI(tqp, msg);
 800cfba:	9801      	ldr	r0, [sp, #4]
 800cfbc:	9900      	ldr	r1, [sp, #0]
 800cfbe:	f7ff fd5f 	bl	800ca80 <chThdDoDequeueNextI>
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  while (queue_notempty(tqp)) {
 800cfc2:	9801      	ldr	r0, [sp, #4]
 800cfc4:	f7ff fc6c 	bl	800c8a0 <queue_notempty>
 800cfc8:	4603      	mov	r3, r0
 800cfca:	2b00      	cmp	r3, #0
 800cfcc:	d1f5      	bne.n	800cfba <chThdDequeueAllI+0xa>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 800cfce:	b003      	add	sp, #12
 800cfd0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800cfe0 <port_rt_get_counter_value.lto_priv.406>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 800cfe0:	4b01      	ldr	r3, [pc, #4]	; (800cfe8 <port_rt_get_counter_value.lto_priv.406+0x8>)
 800cfe2:	685b      	ldr	r3, [r3, #4]
}
 800cfe4:	4618      	mov	r0, r3
 800cfe6:	4770      	bx	lr
 800cfe8:	e0001000 	.word	0xe0001000
 800cfec:	00000000 	.word	0x00000000

0800cff0 <tm_stop.lto_priv.405>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 800cff0:	b084      	sub	sp, #16
 800cff2:	9003      	str	r0, [sp, #12]
 800cff4:	9102      	str	r1, [sp, #8]
 800cff6:	9201      	str	r2, [sp, #4]

  tmp->n++;
 800cff8:	9b03      	ldr	r3, [sp, #12]
 800cffa:	68db      	ldr	r3, [r3, #12]
 800cffc:	1c5a      	adds	r2, r3, #1
 800cffe:	9b03      	ldr	r3, [sp, #12]
 800d000:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 800d002:	9b03      	ldr	r3, [sp, #12]
 800d004:	689b      	ldr	r3, [r3, #8]
 800d006:	9a02      	ldr	r2, [sp, #8]
 800d008:	1ad2      	subs	r2, r2, r3
 800d00a:	9b01      	ldr	r3, [sp, #4]
 800d00c:	1ad2      	subs	r2, r2, r3
 800d00e:	9b03      	ldr	r3, [sp, #12]
 800d010:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 800d012:	9b03      	ldr	r3, [sp, #12]
 800d014:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 800d018:	9b03      	ldr	r3, [sp, #12]
 800d01a:	689b      	ldr	r3, [r3, #8]
 800d01c:	461a      	mov	r2, r3
 800d01e:	f04f 0300 	mov.w	r3, #0
 800d022:	1812      	adds	r2, r2, r0
 800d024:	eb43 0301 	adc.w	r3, r3, r1
 800d028:	9903      	ldr	r1, [sp, #12]
 800d02a:	e9c1 2304 	strd	r2, r3, [r1, #16]
  if (tmp->last > tmp->worst) {
 800d02e:	9b03      	ldr	r3, [sp, #12]
 800d030:	689a      	ldr	r2, [r3, #8]
 800d032:	9b03      	ldr	r3, [sp, #12]
 800d034:	685b      	ldr	r3, [r3, #4]
 800d036:	429a      	cmp	r2, r3
 800d038:	d903      	bls.n	800d042 <tm_stop.lto_priv.405+0x52>
    tmp->worst = tmp->last;
 800d03a:	9b03      	ldr	r3, [sp, #12]
 800d03c:	689a      	ldr	r2, [r3, #8]
 800d03e:	9b03      	ldr	r3, [sp, #12]
 800d040:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 800d042:	9b03      	ldr	r3, [sp, #12]
 800d044:	689a      	ldr	r2, [r3, #8]
 800d046:	9b03      	ldr	r3, [sp, #12]
 800d048:	681b      	ldr	r3, [r3, #0]
 800d04a:	429a      	cmp	r2, r3
 800d04c:	d203      	bcs.n	800d056 <tm_stop.lto_priv.405+0x66>
    tmp->best = tmp->last;
 800d04e:	9b03      	ldr	r3, [sp, #12]
 800d050:	689a      	ldr	r2, [r3, #8]
 800d052:	9b03      	ldr	r3, [sp, #12]
 800d054:	601a      	str	r2, [r3, #0]
  }
}
 800d056:	b004      	add	sp, #16
 800d058:	4770      	bx	lr
 800d05a:	bf00      	nop
 800d05c:	0000      	movs	r0, r0
	...

0800d060 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 800d060:	b500      	push	{lr}
 800d062:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 800d064:	4b0b      	ldr	r3, [pc, #44]	; (800d094 <_tm_init+0x34>)
 800d066:	2200      	movs	r2, #0
 800d068:	f8c3 24a0 	str.w	r2, [r3, #1184]	; 0x4a0
  chTMObjectInit(&tm);
 800d06c:	466b      	mov	r3, sp
 800d06e:	4618      	mov	r0, r3
 800d070:	f000 f816 	bl	800d0a0 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
 800d074:	466b      	mov	r3, sp
 800d076:	4618      	mov	r0, r3
 800d078:	f7fd f93a 	bl	800a2f0 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 800d07c:	466b      	mov	r3, sp
 800d07e:	4618      	mov	r0, r3
 800d080:	f7fd f946 	bl	800a310 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 800d084:	9b02      	ldr	r3, [sp, #8]
 800d086:	4a03      	ldr	r2, [pc, #12]	; (800d094 <_tm_init+0x34>)
 800d088:	f8c2 34a0 	str.w	r3, [r2, #1184]	; 0x4a0
}
 800d08c:	b007      	add	sp, #28
 800d08e:	f85d fb04 	ldr.w	pc, [sp], #4
 800d092:	bf00      	nop
 800d094:	20000d30 	.word	0x20000d30
	...

0800d0a0 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 800d0a0:	b082      	sub	sp, #8
 800d0a2:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 800d0a4:	9b01      	ldr	r3, [sp, #4]
 800d0a6:	f04f 32ff 	mov.w	r2, #4294967295
 800d0aa:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 800d0ac:	9b01      	ldr	r3, [sp, #4]
 800d0ae:	2200      	movs	r2, #0
 800d0b0:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 800d0b2:	9b01      	ldr	r3, [sp, #4]
 800d0b4:	2200      	movs	r2, #0
 800d0b6:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 800d0b8:	9b01      	ldr	r3, [sp, #4]
 800d0ba:	2200      	movs	r2, #0
 800d0bc:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 800d0be:	9901      	ldr	r1, [sp, #4]
 800d0c0:	f04f 0200 	mov.w	r2, #0
 800d0c4:	f04f 0300 	mov.w	r3, #0
 800d0c8:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 800d0cc:	b002      	add	sp, #8
 800d0ce:	4770      	bx	lr

0800d0d0 <atoi>:
 800d0d0:	2100      	movs	r1, #0
 800d0d2:	220a      	movs	r2, #10
 800d0d4:	f000 b894 	b.w	800d200 <strtol>
	...

0800d0e0 <_strtol_r>:
 800d0e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d0e4:	4c44      	ldr	r4, [pc, #272]	; (800d1f8 <_strtol_r+0x118>)
 800d0e6:	4683      	mov	fp, r0
 800d0e8:	460e      	mov	r6, r1
 800d0ea:	f8d4 e000 	ldr.w	lr, [r4]
 800d0ee:	e000      	b.n	800d0f2 <_strtol_r+0x12>
 800d0f0:	4626      	mov	r6, r4
 800d0f2:	4634      	mov	r4, r6
 800d0f4:	f814 5b01 	ldrb.w	r5, [r4], #1
 800d0f8:	eb0e 0005 	add.w	r0, lr, r5
 800d0fc:	7840      	ldrb	r0, [r0, #1]
 800d0fe:	f000 0008 	and.w	r0, r0, #8
 800d102:	f000 08ff 	and.w	r8, r0, #255	; 0xff
 800d106:	2800      	cmp	r0, #0
 800d108:	d1f2      	bne.n	800d0f0 <_strtol_r+0x10>
 800d10a:	2d2d      	cmp	r5, #45	; 0x2d
 800d10c:	d04b      	beq.n	800d1a6 <_strtol_r+0xc6>
 800d10e:	2d2b      	cmp	r5, #43	; 0x2b
 800d110:	bf04      	itt	eq
 800d112:	7875      	ldrbeq	r5, [r6, #1]
 800d114:	1cb4      	addeq	r4, r6, #2
 800d116:	b11b      	cbz	r3, 800d120 <_strtol_r+0x40>
 800d118:	2b10      	cmp	r3, #16
 800d11a:	d060      	beq.n	800d1de <_strtol_r+0xfe>
 800d11c:	469a      	mov	sl, r3
 800d11e:	e003      	b.n	800d128 <_strtol_r+0x48>
 800d120:	2d30      	cmp	r5, #48	; 0x30
 800d122:	d054      	beq.n	800d1ce <_strtol_r+0xee>
 800d124:	230a      	movs	r3, #10
 800d126:	469a      	mov	sl, r3
 800d128:	f1b8 0f00 	cmp.w	r8, #0
 800d12c:	bf14      	ite	ne
 800d12e:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 800d132:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 800d136:	2700      	movs	r7, #0
 800d138:	fbb0 f9fa 	udiv	r9, r0, sl
 800d13c:	46bc      	mov	ip, r7
 800d13e:	fb0a 0019 	mls	r0, sl, r9, r0
 800d142:	e00c      	b.n	800d15e <_strtol_r+0x7e>
 800d144:	3d30      	subs	r5, #48	; 0x30
 800d146:	42ab      	cmp	r3, r5
 800d148:	dd19      	ble.n	800d17e <_strtol_r+0x9e>
 800d14a:	1c7e      	adds	r6, r7, #1
 800d14c:	d005      	beq.n	800d15a <_strtol_r+0x7a>
 800d14e:	45cc      	cmp	ip, r9
 800d150:	d824      	bhi.n	800d19c <_strtol_r+0xbc>
 800d152:	d021      	beq.n	800d198 <_strtol_r+0xb8>
 800d154:	fb0a 5c0c 	mla	ip, sl, ip, r5
 800d158:	2701      	movs	r7, #1
 800d15a:	f814 5b01 	ldrb.w	r5, [r4], #1
 800d15e:	eb0e 0605 	add.w	r6, lr, r5
 800d162:	7876      	ldrb	r6, [r6, #1]
 800d164:	f016 0f04 	tst.w	r6, #4
 800d168:	d1ec      	bne.n	800d144 <_strtol_r+0x64>
 800d16a:	f016 0603 	ands.w	r6, r6, #3
 800d16e:	d006      	beq.n	800d17e <_strtol_r+0x9e>
 800d170:	2e01      	cmp	r6, #1
 800d172:	bf0c      	ite	eq
 800d174:	2637      	moveq	r6, #55	; 0x37
 800d176:	2657      	movne	r6, #87	; 0x57
 800d178:	1bad      	subs	r5, r5, r6
 800d17a:	42ab      	cmp	r3, r5
 800d17c:	dce5      	bgt.n	800d14a <_strtol_r+0x6a>
 800d17e:	1c7b      	adds	r3, r7, #1
 800d180:	d016      	beq.n	800d1b0 <_strtol_r+0xd0>
 800d182:	f1c8 0000 	rsb	r0, r8, #0
 800d186:	ea8c 0000 	eor.w	r0, ip, r0
 800d18a:	4440      	add	r0, r8
 800d18c:	b14a      	cbz	r2, 800d1a2 <_strtol_r+0xc2>
 800d18e:	b107      	cbz	r7, 800d192 <_strtol_r+0xb2>
 800d190:	1e61      	subs	r1, r4, #1
 800d192:	6011      	str	r1, [r2, #0]
 800d194:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d198:	4285      	cmp	r5, r0
 800d19a:	dddb      	ble.n	800d154 <_strtol_r+0x74>
 800d19c:	f04f 37ff 	mov.w	r7, #4294967295
 800d1a0:	e7db      	b.n	800d15a <_strtol_r+0x7a>
 800d1a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d1a6:	1cb4      	adds	r4, r6, #2
 800d1a8:	7875      	ldrb	r5, [r6, #1]
 800d1aa:	f04f 0801 	mov.w	r8, #1
 800d1ae:	e7b2      	b.n	800d116 <_strtol_r+0x36>
 800d1b0:	f1b8 0f00 	cmp.w	r8, #0
 800d1b4:	f04f 0322 	mov.w	r3, #34	; 0x22
 800d1b8:	bf14      	ite	ne
 800d1ba:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 800d1be:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 800d1c2:	f8cb 3000 	str.w	r3, [fp]
 800d1c6:	2a00      	cmp	r2, #0
 800d1c8:	d1e2      	bne.n	800d190 <_strtol_r+0xb0>
 800d1ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d1ce:	7823      	ldrb	r3, [r4, #0]
 800d1d0:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 800d1d4:	2b58      	cmp	r3, #88	; 0x58
 800d1d6:	d009      	beq.n	800d1ec <_strtol_r+0x10c>
 800d1d8:	2308      	movs	r3, #8
 800d1da:	469a      	mov	sl, r3
 800d1dc:	e7a4      	b.n	800d128 <_strtol_r+0x48>
 800d1de:	2d30      	cmp	r5, #48	; 0x30
 800d1e0:	d19c      	bne.n	800d11c <_strtol_r+0x3c>
 800d1e2:	7820      	ldrb	r0, [r4, #0]
 800d1e4:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 800d1e8:	2858      	cmp	r0, #88	; 0x58
 800d1ea:	d197      	bne.n	800d11c <_strtol_r+0x3c>
 800d1ec:	f04f 0a10 	mov.w	sl, #16
 800d1f0:	7865      	ldrb	r5, [r4, #1]
 800d1f2:	4653      	mov	r3, sl
 800d1f4:	3402      	adds	r4, #2
 800d1f6:	e797      	b.n	800d128 <_strtol_r+0x48>
 800d1f8:	200008f8 	.word	0x200008f8
 800d1fc:	00000000 	.word	0x00000000

0800d200 <strtol>:
 800d200:	b430      	push	{r4, r5}
 800d202:	4c04      	ldr	r4, [pc, #16]	; (800d214 <strtol+0x14>)
 800d204:	460d      	mov	r5, r1
 800d206:	4613      	mov	r3, r2
 800d208:	4601      	mov	r1, r0
 800d20a:	462a      	mov	r2, r5
 800d20c:	6820      	ldr	r0, [r4, #0]
 800d20e:	bc30      	pop	{r4, r5}
 800d210:	f7ff bf66 	b.w	800d0e0 <_strtol_r>
 800d214:	20000d28 	.word	0x20000d28
	...
 800d220:	65726854 	.word	0x65726854
 800d224:	2c736461 	.word	0x2c736461
 800d228:	716e6520 	.word	0x716e6520
 800d22c:	69756575 	.word	0x69756575
 800d230:	7420676e 	.word	0x7420676e
 800d234:	20747365 	.word	0x20747365
 800d238:	00003123 	.word	0x00003123
 800d23c:	65726854 	.word	0x65726854
 800d240:	2c736461 	.word	0x2c736461
 800d244:	716e6520 	.word	0x716e6520
 800d248:	69756575 	.word	0x69756575
 800d24c:	7420676e 	.word	0x7420676e
 800d250:	20747365 	.word	0x20747365
 800d254:	00003223 	.word	0x00003223
 800d258:	65726854 	.word	0x65726854
 800d25c:	2c736461 	.word	0x2c736461
 800d260:	69727020 	.word	0x69727020
 800d264:	7469726f 	.word	0x7469726f
 800d268:	68632079 	.word	0x68632079
 800d26c:	65676e61 	.word	0x65676e61
 800d270:	00000000 	.word	0x00000000
 800d274:	65726854 	.word	0x65726854
 800d278:	2c736461 	.word	0x2c736461
 800d27c:	6c656420 	.word	0x6c656420
 800d280:	00737961 	.word	0x00737961
 800d284:	616d6553 	.word	0x616d6553
 800d288:	726f6870 	.word	0x726f6870
 800d28c:	202c7365 	.word	0x202c7365
 800d290:	75716e65 	.word	0x75716e65
 800d294:	6e697565 	.word	0x6e697565
 800d298:	00000067 	.word	0x00000067
 800d29c:	616d6553 	.word	0x616d6553
 800d2a0:	726f6870 	.word	0x726f6870
 800d2a4:	202c7365 	.word	0x202c7365
 800d2a8:	656d6974 	.word	0x656d6974
 800d2ac:	0074756f 	.word	0x0074756f
 800d2b0:	616d6553 	.word	0x616d6553
 800d2b4:	726f6870 	.word	0x726f6870
 800d2b8:	202c7365 	.word	0x202c7365
 800d2bc:	6d6f7461 	.word	0x6d6f7461
 800d2c0:	73206369 	.word	0x73206369
 800d2c4:	616e6769 	.word	0x616e6769
 800d2c8:	61772d6c 	.word	0x61772d6c
 800d2cc:	00007469 	.word	0x00007469
 800d2d0:	616e6942 	.word	0x616e6942
 800d2d4:	53207972 	.word	0x53207972
 800d2d8:	70616d65 	.word	0x70616d65
 800d2dc:	65726f68 	.word	0x65726f68
 800d2e0:	66202c73 	.word	0x66202c73
 800d2e4:	74636e75 	.word	0x74636e75
 800d2e8:	616e6f69 	.word	0x616e6f69
 800d2ec:	7974696c 	.word	0x7974696c
 800d2f0:	00000000 	.word	0x00000000
 800d2f4:	6574754d 	.word	0x6574754d
 800d2f8:	2c736578 	.word	0x2c736578
 800d2fc:	69727020 	.word	0x69727020
 800d300:	7469726f 	.word	0x7469726f
 800d304:	6e652079 	.word	0x6e652079
 800d308:	75657571 	.word	0x75657571
 800d30c:	20676e69 	.word	0x20676e69
 800d310:	74736574 	.word	0x74736574
 800d314:	00000000 	.word	0x00000000
 800d318:	6574754d 	.word	0x6574754d
 800d31c:	2c736578 	.word	0x2c736578
 800d320:	69727020 	.word	0x69727020
 800d324:	7469726f 	.word	0x7469726f
 800d328:	65722079 	.word	0x65722079
 800d32c:	6e727574 	.word	0x6e727574
 800d330:	00000000 	.word	0x00000000
 800d334:	6574754d 	.word	0x6574754d
 800d338:	2c736578 	.word	0x2c736578
 800d33c:	61747320 	.word	0x61747320
 800d340:	00737574 	.word	0x00737574
 800d344:	646e6f43 	.word	0x646e6f43
 800d348:	2c726156 	.word	0x2c726156
 800d34c:	67697320 	.word	0x67697320
 800d350:	206c616e 	.word	0x206c616e
 800d354:	74736574 	.word	0x74736574
 800d358:	00000000 	.word	0x00000000
 800d35c:	646e6f43 	.word	0x646e6f43
 800d360:	2c726156 	.word	0x2c726156
 800d364:	6f726220 	.word	0x6f726220
 800d368:	61636461 	.word	0x61636461
 800d36c:	74207473 	.word	0x74207473
 800d370:	00747365 	.word	0x00747365
 800d374:	646e6f43 	.word	0x646e6f43
 800d378:	2c726156 	.word	0x2c726156
 800d37c:	6f6f6220 	.word	0x6f6f6220
 800d380:	74207473 	.word	0x74207473
 800d384:	00747365 	.word	0x00747365
 800d388:	7373654d 	.word	0x7373654d
 800d38c:	73656761 	.word	0x73656761
 800d390:	6f6c202c 	.word	0x6f6c202c
 800d394:	0000706f 	.word	0x0000706f
 800d398:	6c69614d 	.word	0x6c69614d
 800d39c:	65786f62 	.word	0x65786f62
 800d3a0:	71202c73 	.word	0x71202c73
 800d3a4:	69756575 	.word	0x69756575
 800d3a8:	6120676e 	.word	0x6120676e
 800d3ac:	7420646e 	.word	0x7420646e
 800d3b0:	6f656d69 	.word	0x6f656d69
 800d3b4:	00737475 	.word	0x00737475
 800d3b8:	6e657645 	.word	0x6e657645
 800d3bc:	202c7374 	.word	0x202c7374
 800d3c0:	69676572 	.word	0x69676572
 800d3c4:	61727473 	.word	0x61727473
 800d3c8:	6e6f6974 	.word	0x6e6f6974
 800d3cc:	646e6120 	.word	0x646e6120
 800d3d0:	73696420 	.word	0x73696420
 800d3d4:	63746170 	.word	0x63746170
 800d3d8:	00000068 	.word	0x00000068
 800d3dc:	6e657645 	.word	0x6e657645
 800d3e0:	202c7374 	.word	0x202c7374
 800d3e4:	74696177 	.word	0x74696177
 800d3e8:	646e6120 	.word	0x646e6120
 800d3ec:	6f726220 	.word	0x6f726220
 800d3f0:	61636461 	.word	0x61636461
 800d3f4:	00007473 	.word	0x00007473
 800d3f8:	6e657645 	.word	0x6e657645
 800d3fc:	202c7374 	.word	0x202c7374
 800d400:	656d6974 	.word	0x656d6974
 800d404:	7374756f 	.word	0x7374756f
 800d408:	00000000 	.word	0x00000000
 800d40c:	70616548 	.word	0x70616548
 800d410:	6c61202c 	.word	0x6c61202c
 800d414:	61636f6c 	.word	0x61636f6c
 800d418:	6e6f6974 	.word	0x6e6f6974
 800d41c:	646e6120 	.word	0x646e6120
 800d420:	61726620 	.word	0x61726620
 800d424:	6e656d67 	.word	0x6e656d67
 800d428:	69746174 	.word	0x69746174
 800d42c:	74206e6f 	.word	0x74206e6f
 800d430:	00747365 	.word	0x00747365
 800d434:	6f6d654d 	.word	0x6f6d654d
 800d438:	50207972 	.word	0x50207972
 800d43c:	736c6f6f 	.word	0x736c6f6f
 800d440:	7571202c 	.word	0x7571202c
 800d444:	2f657565 	.word	0x2f657565
 800d448:	75716564 	.word	0x75716564
 800d44c:	00657565 	.word	0x00657565
 800d450:	616e7944 	.word	0x616e7944
 800d454:	2063696d 	.word	0x2063696d
 800d458:	73495041 	.word	0x73495041
 800d45c:	6874202c 	.word	0x6874202c
 800d460:	64616572 	.word	0x64616572
 800d464:	72632073 	.word	0x72632073
 800d468:	69746165 	.word	0x69746165
 800d46c:	66206e6f 	.word	0x66206e6f
 800d470:	206d6f72 	.word	0x206d6f72
 800d474:	70616568 	.word	0x70616568
 800d478:	00000000 	.word	0x00000000
 800d47c:	616e7944 	.word	0x616e7944
 800d480:	2063696d 	.word	0x2063696d
 800d484:	73495041 	.word	0x73495041
 800d488:	6874202c 	.word	0x6874202c
 800d48c:	64616572 	.word	0x64616572
 800d490:	72632073 	.word	0x72632073
 800d494:	69746165 	.word	0x69746165
 800d498:	66206e6f 	.word	0x66206e6f
 800d49c:	206d6f72 	.word	0x206d6f72
 800d4a0:	6f6d656d 	.word	0x6f6d656d
 800d4a4:	70207972 	.word	0x70207972
 800d4a8:	006c6f6f 	.word	0x006c6f6f
 800d4ac:	616e7944 	.word	0x616e7944
 800d4b0:	2063696d 	.word	0x2063696d
 800d4b4:	73495041 	.word	0x73495041
 800d4b8:	6572202c 	.word	0x6572202c
 800d4bc:	74736967 	.word	0x74736967
 800d4c0:	61207972 	.word	0x61207972
 800d4c4:	7220646e 	.word	0x7220646e
 800d4c8:	72656665 	.word	0x72656665
 800d4cc:	65636e65 	.word	0x65636e65
 800d4d0:	00000073 	.word	0x00000073
 800d4d4:	75657551 	.word	0x75657551
 800d4d8:	202c7365 	.word	0x202c7365
 800d4dc:	75706e69 	.word	0x75706e69
 800d4e0:	75712074 	.word	0x75712074
 800d4e4:	73657565 	.word	0x73657565
 800d4e8:	00000000 	.word	0x00000000
 800d4ec:	75657551 	.word	0x75657551
 800d4f0:	202c7365 	.word	0x202c7365
 800d4f4:	7074756f 	.word	0x7074756f
 800d4f8:	71207475 	.word	0x71207475
 800d4fc:	65756575 	.word	0x65756575
 800d500:	00000073 	.word	0x00000073
 800d504:	74737953 	.word	0x74737953
 800d508:	202c6d65 	.word	0x202c6d65
 800d50c:	74697263 	.word	0x74697263
 800d510:	6c616369 	.word	0x6c616369
 800d514:	6e6f7a20 	.word	0x6e6f7a20
 800d518:	00007365 	.word	0x00007365
 800d51c:	74737953 	.word	0x74737953
 800d520:	202c6d65 	.word	0x202c6d65
 800d524:	65746e69 	.word	0x65746e69
 800d528:	70757272 	.word	0x70757272
 800d52c:	68207374 	.word	0x68207374
 800d530:	6c646e61 	.word	0x6c646e61
 800d534:	00676e69 	.word	0x00676e69
 800d538:	74737953 	.word	0x74737953
 800d53c:	202c6d65 	.word	0x202c6d65
 800d540:	65746e69 	.word	0x65746e69
 800d544:	74697267 	.word	0x74697267
 800d548:	00000079 	.word	0x00000079
 800d54c:	636e6542 	.word	0x636e6542
 800d550:	72616d68 	.word	0x72616d68
 800d554:	6d202c6b 	.word	0x6d202c6b
 800d558:	61737365 	.word	0x61737365
 800d55c:	20736567 	.word	0x20736567
 800d560:	00003123 	.word	0x00003123
 800d564:	636e6542 	.word	0x636e6542
 800d568:	72616d68 	.word	0x72616d68
 800d56c:	6d202c6b 	.word	0x6d202c6b
 800d570:	61737365 	.word	0x61737365
 800d574:	20736567 	.word	0x20736567
 800d578:	00003223 	.word	0x00003223
 800d57c:	636e6542 	.word	0x636e6542
 800d580:	72616d68 	.word	0x72616d68
 800d584:	6d202c6b 	.word	0x6d202c6b
 800d588:	61737365 	.word	0x61737365
 800d58c:	20736567 	.word	0x20736567
 800d590:	00003323 	.word	0x00003323
 800d594:	636e6542 	.word	0x636e6542
 800d598:	72616d68 	.word	0x72616d68
 800d59c:	63202c6b 	.word	0x63202c6b
 800d5a0:	65746e6f 	.word	0x65746e6f
 800d5a4:	73207478 	.word	0x73207478
 800d5a8:	63746977 	.word	0x63746977
 800d5ac:	00000068 	.word	0x00000068
 800d5b0:	636e6542 	.word	0x636e6542
 800d5b4:	72616d68 	.word	0x72616d68
 800d5b8:	74202c6b 	.word	0x74202c6b
 800d5bc:	61657268 	.word	0x61657268
 800d5c0:	202c7364 	.word	0x202c7364
 800d5c4:	6c6c7566 	.word	0x6c6c7566
 800d5c8:	63796320 	.word	0x63796320
 800d5cc:	0000656c 	.word	0x0000656c
 800d5d0:	636e6542 	.word	0x636e6542
 800d5d4:	72616d68 	.word	0x72616d68
 800d5d8:	74202c6b 	.word	0x74202c6b
 800d5dc:	61657268 	.word	0x61657268
 800d5e0:	202c7364 	.word	0x202c7364
 800d5e4:	61657263 	.word	0x61657263
 800d5e8:	6f206574 	.word	0x6f206574
 800d5ec:	00796c6e 	.word	0x00796c6e
 800d5f0:	636e6542 	.word	0x636e6542
 800d5f4:	72616d68 	.word	0x72616d68
 800d5f8:	6d202c6b 	.word	0x6d202c6b
 800d5fc:	20737361 	.word	0x20737361
 800d600:	63736572 	.word	0x63736572
 800d604:	75646568 	.word	0x75646568
 800d608:	202c656c 	.word	0x202c656c
 800d60c:	68742035 	.word	0x68742035
 800d610:	64616572 	.word	0x64616572
 800d614:	00000073 	.word	0x00000073
 800d618:	636e6542 	.word	0x636e6542
 800d61c:	72616d68 	.word	0x72616d68
 800d620:	72202c6b 	.word	0x72202c6b
 800d624:	646e756f 	.word	0x646e756f
 800d628:	626f7220 	.word	0x626f7220
 800d62c:	63206e69 	.word	0x63206e69
 800d630:	65746e6f 	.word	0x65746e6f
 800d634:	73207478 	.word	0x73207478
 800d638:	63746977 	.word	0x63746977
 800d63c:	676e6968 	.word	0x676e6968
 800d640:	00000000 	.word	0x00000000
 800d644:	636e6542 	.word	0x636e6542
 800d648:	72616d68 	.word	0x72616d68
 800d64c:	49202c6b 	.word	0x49202c6b
 800d650:	51204f2f 	.word	0x51204f2f
 800d654:	65756575 	.word	0x65756575
 800d658:	68742073 	.word	0x68742073
 800d65c:	67756f72 	.word	0x67756f72
 800d660:	74757068 	.word	0x74757068
 800d664:	00000000 	.word	0x00000000
 800d668:	636e6542 	.word	0x636e6542
 800d66c:	72616d68 	.word	0x72616d68
 800d670:	76202c6b 	.word	0x76202c6b
 800d674:	75747269 	.word	0x75747269
 800d678:	74206c61 	.word	0x74206c61
 800d67c:	72656d69 	.word	0x72656d69
 800d680:	65732073 	.word	0x65732073
 800d684:	65722f74 	.word	0x65722f74
 800d688:	00746573 	.word	0x00746573
 800d68c:	636e6542 	.word	0x636e6542
 800d690:	72616d68 	.word	0x72616d68
 800d694:	73202c6b 	.word	0x73202c6b
 800d698:	70616d65 	.word	0x70616d65
 800d69c:	65726f68 	.word	0x65726f68
 800d6a0:	61772073 	.word	0x61772073
 800d6a4:	732f7469 	.word	0x732f7469
 800d6a8:	616e6769 	.word	0x616e6769
 800d6ac:	0000006c 	.word	0x0000006c
 800d6b0:	636e6542 	.word	0x636e6542
 800d6b4:	72616d68 	.word	0x72616d68
 800d6b8:	6d202c6b 	.word	0x6d202c6b
 800d6bc:	78657475 	.word	0x78657475
 800d6c0:	6c207365 	.word	0x6c207365
 800d6c4:	2f6b636f 	.word	0x2f6b636f
 800d6c8:	6f6c6e75 	.word	0x6f6c6e75
 800d6cc:	00006b63 	.word	0x00006b63
 800d6d0:	202d2d2d 	.word	0x202d2d2d
 800d6d4:	74737953 	.word	0x74737953
 800d6d8:	203a6d65 	.word	0x203a6d65
 800d6dc:	00000000 	.word	0x00000000
 800d6e0:	74796220 	.word	0x74796220
 800d6e4:	00007365 	.word	0x00007365
 800d6e8:	202d2d2d 	.word	0x202d2d2d
 800d6ec:	65726854 	.word	0x65726854
 800d6f0:	203a6461 	.word	0x203a6461
 800d6f4:	00000000 	.word	0x00000000
 800d6f8:	202d2d2d 	.word	0x202d2d2d
 800d6fc:	656d6954 	.word	0x656d6954
 800d700:	203a2072 	.word	0x203a2072
 800d704:	00000000 	.word	0x00000000
 800d708:	202d2d2d 	.word	0x202d2d2d
 800d70c:	616d6553 	.word	0x616d6553
 800d710:	203a6870 	.word	0x203a6870
 800d714:	00000000 	.word	0x00000000
 800d718:	202d2d2d 	.word	0x202d2d2d
 800d71c:	6e657645 	.word	0x6e657645
 800d720:	203a5374 	.word	0x203a5374
 800d724:	00000000 	.word	0x00000000
 800d728:	202d2d2d 	.word	0x202d2d2d
 800d72c:	6e657645 	.word	0x6e657645
 800d730:	203a4c74 	.word	0x203a4c74
 800d734:	00000000 	.word	0x00000000
 800d738:	202d2d2d 	.word	0x202d2d2d
 800d73c:	6574754d 	.word	0x6574754d
 800d740:	203a2078 	.word	0x203a2078
 800d744:	00000000 	.word	0x00000000
 800d748:	202d2d2d 	.word	0x202d2d2d
 800d74c:	646e6f43 	.word	0x646e6f43
 800d750:	203a2e56 	.word	0x203a2e56
 800d754:	00000000 	.word	0x00000000
 800d758:	202d2d2d 	.word	0x202d2d2d
 800d75c:	75657551 	.word	0x75657551
 800d760:	203a2065 	.word	0x203a2065
 800d764:	00000000 	.word	0x00000000
 800d768:	202d2d2d 	.word	0x202d2d2d
 800d76c:	6c69614d 	.word	0x6c69614d
 800d770:	203a2e42 	.word	0x203a2e42
 800d774:	00000000 	.word	0x00000000
 800d778:	636e6542 	.word	0x636e6542
 800d77c:	72616d68 	.word	0x72616d68
 800d780:	52202c6b 	.word	0x52202c6b
 800d784:	66204d41 	.word	0x66204d41
 800d788:	70746f6f 	.word	0x70746f6f
 800d78c:	746e6972 	.word	0x746e6972
 800d790:	00000000 	.word	0x00000000
 800d794:	6c756e28 	.word	0x6c756e28
 800d798:	0000296c 	.word	0x0000296c
 800d79c:	252c6425 	.word	0x252c6425
 800d7a0:	64252c64 	.word	0x64252c64
 800d7a4:	2c64252c 	.word	0x2c64252c
 800d7a8:	252c6425 	.word	0x252c6425
 800d7ac:	00000a64 	.word	0x00000a64
 800d7b0:	44434241 	.word	0x44434241
 800d7b4:	00000000 	.word	0x00000000
 800d7b8:	202d2d2d 	.word	0x202d2d2d
 800d7bc:	726f6353 	.word	0x726f6353
 800d7c0:	203a2065 	.word	0x203a2065
 800d7c4:	00000000 	.word	0x00000000
 800d7c8:	67736d20 	.word	0x67736d20
 800d7cc:	2c532f73 	.word	0x2c532f73
 800d7d0:	00000020 	.word	0x00000020
 800d7d4:	78746320 	.word	0x78746320
 800d7d8:	2f637773 	.word	0x2f637773
 800d7dc:	00000053 	.word	0x00000053
 800d7e0:	72687420 	.word	0x72687420
 800d7e4:	73646165 	.word	0x73646165
 800d7e8:	0000532f 	.word	0x0000532f
 800d7ec:	73657220 	.word	0x73657220
 800d7f0:	64656863 	.word	0x64656863
 800d7f4:	73656c75 	.word	0x73656c75
 800d7f8:	202c532f 	.word	0x202c532f
 800d7fc:	00000000 	.word	0x00000000
 800d800:	74796220 	.word	0x74796220
 800d804:	532f7365 	.word	0x532f7365
 800d808:	00000000 	.word	0x00000000
 800d80c:	6d697420 	.word	0x6d697420
 800d810:	2f737265 	.word	0x2f737265
 800d814:	00000053 	.word	0x00000053
 800d818:	69617720 	.word	0x69617720
 800d81c:	69732b74 	.word	0x69732b74
 800d820:	6c616e67 	.word	0x6c616e67
 800d824:	0000532f 	.word	0x0000532f
 800d828:	636f6c20 	.word	0x636f6c20
 800d82c:	6e752b6b 	.word	0x6e752b6b
 800d830:	6b636f6c 	.word	0x6b636f6c
 800d834:	0000532f 	.word	0x0000532f
	...
 800d840:	00000041 	.word	0x00000041
 800d844:	00000042 	.word	0x00000042
 800d848:	00000043 	.word	0x00000043
 800d84c:	00004241 	.word	0x00004241
 800d850:	00000044 	.word	0x00000044
 800d854:	00000045 	.word	0x00000045
 800d858:	44434241 	.word	0x44434241
 800d85c:	00000000 	.word	0x00000000
 800d860:	44434241 	.word	0x44434241
 800d864:	00000045 	.word	0x00000045
 800d868:	00434241 	.word	0x00434241
 800d86c:	00000041 	.word	0x00000041
 800d870:	00000041 	.word	0x00000041
 800d874:	00000042 	.word	0x00000042
 800d878:	00000043 	.word	0x00000043
 800d87c:	00000044 	.word	0x00000044
 800d880:	00000045 	.word	0x00000045
 800d884:	44434241 	.word	0x44434241
 800d888:	00000045 	.word	0x00000045
 800d88c:	00434241 	.word	0x00434241
 800d890:	00000a0d 	.word	0x00000a0d
 800d894:	00000000 	.word	0x00000000
 800d898:	202a2a2a 	.word	0x202a2a2a
 800d89c:	62696843 	.word	0x62696843
 800d8a0:	2f534f69 	.word	0x2f534f69
 800d8a4:	74205452 	.word	0x74205452
 800d8a8:	20747365 	.word	0x20747365
 800d8ac:	74697573 	.word	0x74697573
 800d8b0:	00000065 	.word	0x00000065
 800d8b4:	002a2a2a 	.word	0x002a2a2a
 800d8b8:	202a2a2a 	.word	0x202a2a2a
 800d8bc:	6e72654b 	.word	0x6e72654b
 800d8c0:	203a6c65 	.word	0x203a6c65
 800d8c4:	20202020 	.word	0x20202020
 800d8c8:	00002020 	.word	0x00002020
 800d8cc:	2e312e33 	.word	0x2e312e33
 800d8d0:	00000033 	.word	0x00000033
 800d8d4:	202a2a2a 	.word	0x202a2a2a
 800d8d8:	706d6f43 	.word	0x706d6f43
 800d8dc:	64656c69 	.word	0x64656c69
 800d8e0:	2020203a 	.word	0x2020203a
 800d8e4:	00002020 	.word	0x00002020
 800d8e8:	20626546 	.word	0x20626546
 800d8ec:	32203031 	.word	0x32203031
 800d8f0:	20373130 	.word	0x20373130
 800d8f4:	3031202d 	.word	0x3031202d
 800d8f8:	3a31333a 	.word	0x3a31333a
 800d8fc:	00003332 	.word	0x00003332
 800d900:	202a2a2a 	.word	0x202a2a2a
 800d904:	706d6f43 	.word	0x706d6f43
 800d908:	72656c69 	.word	0x72656c69
 800d90c:	2020203a 	.word	0x2020203a
 800d910:	00002020 	.word	0x00002020
 800d914:	20434347 	.word	0x20434347
 800d918:	2e392e34 	.word	0x2e392e34
 800d91c:	30322033 	.word	0x30322033
 800d920:	35303531 	.word	0x35303531
 800d924:	28203932 	.word	0x28203932
 800d928:	656c6572 	.word	0x656c6572
 800d92c:	29657361 	.word	0x29657361
 800d930:	52415b20 	.word	0x52415b20
 800d934:	6d652f4d 	.word	0x6d652f4d
 800d938:	64646562 	.word	0x64646562
 800d93c:	342d6465 	.word	0x342d6465
 800d940:	622d395f 	.word	0x622d395f
 800d944:	636e6172 	.word	0x636e6172
 800d948:	65722068 	.word	0x65722068
 800d94c:	69736976 	.word	0x69736976
 800d950:	32206e6f 	.word	0x32206e6f
 800d954:	37393732 	.word	0x37393732
 800d958:	00005d37 	.word	0x00005d37
 800d95c:	202a2a2a 	.word	0x202a2a2a
 800d960:	68637241 	.word	0x68637241
 800d964:	63657469 	.word	0x63657469
 800d968:	65727574 	.word	0x65727574
 800d96c:	0000203a 	.word	0x0000203a
 800d970:	764d5241 	.word	0x764d5241
 800d974:	4d2d4537 	.word	0x4d2d4537
 800d978:	00000000 	.word	0x00000000
 800d97c:	202a2a2a 	.word	0x202a2a2a
 800d980:	65726f43 	.word	0x65726f43
 800d984:	72615620 	.word	0x72615620
 800d988:	746e6169 	.word	0x746e6169
 800d98c:	0000203a 	.word	0x0000203a
 800d990:	74726f43 	.word	0x74726f43
 800d994:	4d2d7865 	.word	0x4d2d7865
 800d998:	00000034 	.word	0x00000034
 800d99c:	202a2a2a 	.word	0x202a2a2a
 800d9a0:	74726f50 	.word	0x74726f50
 800d9a4:	666e4920 	.word	0x666e4920
 800d9a8:	20203a6f 	.word	0x20203a6f
 800d9ac:	00002020 	.word	0x00002020
 800d9b0:	61766441 	.word	0x61766441
 800d9b4:	6465636e 	.word	0x6465636e
 800d9b8:	72656b20 	.word	0x72656b20
 800d9bc:	206c656e 	.word	0x206c656e
 800d9c0:	65646f6d 	.word	0x65646f6d
 800d9c4:	00000000 	.word	0x00000000
 800d9c8:	202a2a2a 	.word	0x202a2a2a
 800d9cc:	74616c50 	.word	0x74616c50
 800d9d0:	6d726f66 	.word	0x6d726f66
 800d9d4:	2020203a 	.word	0x2020203a
 800d9d8:	00002020 	.word	0x00002020
 800d9dc:	334d5453 	.word	0x334d5453
 800d9e0:	30344632 	.word	0x30344632
 800d9e4:	20457831 	.word	0x20457831
 800d9e8:	68676948 	.word	0x68676948
 800d9ec:	72655020 	.word	0x72655020
 800d9f0:	6d726f66 	.word	0x6d726f66
 800d9f4:	65636e61 	.word	0x65636e61
 800d9f8:	74697720 	.word	0x74697720
 800d9fc:	53442068 	.word	0x53442068
 800da00:	6e612050 	.word	0x6e612050
 800da04:	50462064 	.word	0x50462064
 800da08:	00000055 	.word	0x00000055
 800da0c:	202a2a2a 	.word	0x202a2a2a
 800da10:	74736554 	.word	0x74736554
 800da14:	616f4220 	.word	0x616f4220
 800da18:	203a6472 	.word	0x203a6472
 800da1c:	00002020 	.word	0x00002020
 800da20:	694d5453 	.word	0x694d5453
 800da24:	656f7263 	.word	0x656f7263
 800da28:	7463656c 	.word	0x7463656c
 800da2c:	696e6f72 	.word	0x696e6f72
 800da30:	4e207363 	.word	0x4e207363
 800da34:	454c4355 	.word	0x454c4355
 800da38:	34462d4f 	.word	0x34462d4f
 800da3c:	45523130 	.word	0x45523130
 800da40:	00000000 	.word	0x00000000
 800da44:	202d2d2d 	.word	0x202d2d2d
 800da48:	74736554 	.word	0x74736554
 800da4c:	73614320 	.word	0x73614320
 800da50:	00002065 	.word	0x00002065
 800da54:	0000002e 	.word	0x0000002e
 800da58:	00002820 	.word	0x00002820
 800da5c:	00000029 	.word	0x00000029
 800da60:	202d2d2d 	.word	0x202d2d2d
 800da64:	75736552 	.word	0x75736552
 800da68:	203a746c 	.word	0x203a746c
 800da6c:	4c494146 	.word	0x4c494146
 800da70:	20455255 	.word	0x20455255
 800da74:	00002328 	.word	0x00002328
 800da78:	00005b20 	.word	0x00005b20
 800da7c:	0000295d 	.word	0x0000295d
 800da80:	202d2d2d 	.word	0x202d2d2d
 800da84:	75736552 	.word	0x75736552
 800da88:	203a746c 	.word	0x203a746c
 800da8c:	43435553 	.word	0x43435553
 800da90:	00535345 	.word	0x00535345
 800da94:	616e6946 	.word	0x616e6946
 800da98:	6572206c 	.word	0x6572206c
 800da9c:	746c7573 	.word	0x746c7573
 800daa0:	0000203a 	.word	0x0000203a
 800daa4:	4c494146 	.word	0x4c494146
 800daa8:	00455255 	.word	0x00455255
 800daac:	43435553 	.word	0x43435553
 800dab0:	00535345 	.word	0x00535345
 800dab4:	00000045 	.word	0x00000045
 800dab8:	00000044 	.word	0x00000044
 800dabc:	00000043 	.word	0x00000043
 800dac0:	00000042 	.word	0x00000042
 800dac4:	00000041 	.word	0x00000041
 800dac8:	44434241 	.word	0x44434241
 800dacc:	00000045 	.word	0x00000045
 800dad0:	20414d44 	.word	0x20414d44
 800dad4:	6c696166 	.word	0x6c696166
 800dad8:	00657275 	.word	0x00657275
 800dadc:	00000000 	.word	0x00000000
 800dae0:	656c6469 	.word	0x656c6469
 800dae4:	00000000 	.word	0x00000000
 800dae8:	31235653 	.word	0x31235653
 800daec:	00000000 	.word	0x00000000
 800daf0:	32235653 	.word	0x32235653
 800daf4:	00000000 	.word	0x00000000
 800daf8:	33235653 	.word	0x33235653
 800dafc:	00000000 	.word	0x00000000
 800db00:	34235653 	.word	0x34235653
 800db04:	00000000 	.word	0x00000000
 800db08:	35235653 	.word	0x35235653
 800db0c:	00000000 	.word	0x00000000
 800db10:	36235653 	.word	0x36235653
 800db14:	00000000 	.word	0x00000000
 800db18:	37235653 	.word	0x37235653
 800db1c:	00000000 	.word	0x00000000
 800db20:	38235653 	.word	0x38235653
 800db24:	00000000 	.word	0x00000000
 800db28:	39235653 	.word	0x39235653
 800db2c:	00000000 	.word	0x00000000
 800db30:	31235653 	.word	0x31235653
 800db34:	00000030 	.word	0x00000030
 800db38:	31235653 	.word	0x31235653
 800db3c:	00000031 	.word	0x00000031
 800db40:	63617473 	.word	0x63617473
 800db44:	766f206b 	.word	0x766f206b
 800db48:	6c667265 	.word	0x6c667265
 800db4c:	0000776f 	.word	0x0000776f

0800db50 <ram_areas.lto_priv.460>:
 800db50:	0800eef4 200025d8 200025d8 200025d8     .....%. .%. .%. 
 800db60:	0800eef4 00000000 00000000 00000000     ................
 800db70:	0800eef4 00000000 00000000 00000000     ................
 800db80:	0800eef4 00000000 00000000 00000000     ................
 800db90:	0800eef4 00000000 00000000 00000000     ................
 800dba0:	0800eef4 00000000 00000000 00000000     ................
 800dbb0:	0800eef4 00000000 00000000 00000000     ................
 800dbc0:	0800eef4 00000000 00000000 00000000     ................

0800dbd0 <__func__.5826.lto_priv.459>:
 800dbd0:	54566863 69546f44 00496b63 00000000     chVTDoTickI.....

0800dbe0 <__func__.5737.lto_priv.6>:
 800dbe0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800dbf0 <__func__.6443.lto_priv.114>:
 800dbf0:	54566863 65536f44 00004974 00000000     chVTDoSetI......

0800dc00 <__func__.6451.lto_priv.111>:
 800dc00:	54566863 65526f44 49746573 00000000     chVTDoResetI....

0800dc10 <__func__.6440.lto_priv.139>:
 800dc10:	63536863 61655268 00497964 00000000     chSchReadyI.....

0800dc20 <__func__.6468.lto_priv.141>:
 800dc20:	63536863 6b615768 53707565 00000000     chSchWakeupS....

0800dc30 <__func__.6452.lto_priv.413>:
 800dc30:	68546863 65724364 49657461 00000000     chThdCreateI....

0800dc40 <__func__.5737.lto_priv.7>:
 800dc40:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800dc50 <__func__.5907.lto_priv.416>:
 800dc50:	68546863 61745364 00497472 00000000     chThdStartI.....

0800dc60 <__func__.6468.lto_priv.142>:
 800dc60:	68546863 74655364 6f697250 79746972     chThdSetPriority
	...

0800dc80 <__func__.5911.lto_priv.415>:
 800dc80:	68546863 656c5364 00537065 00000000     chThdSleepS.....

0800dc90 <__func__.6496.lto_priv.412>:
 800dc90:	68546863 69784564 00005374 00000000     chThdExitS......

0800dca0 <__func__.6501.lto_priv.411>:
 800dca0:	68546863 69615764 00000074 00000000     chThdWait.......

0800dcb0 <__func__.6512.lto_priv.409>:
 800dcb0:	68546863 73755364 646e6570 656d6954     chThdSuspendTime
 800dcc0:	5374756f 00000000 00000000 00000000     outS............

0800dcd0 <__func__.6518.lto_priv.408>:
 800dcd0:	68546863 73655264 49656d75 00000000     chThdResumeI....

0800dce0 <__func__.5923.lto_priv.414>:
 800dce0:	68546863 446f4464 65757165 654e6575     chThdDoDequeueNe
 800dcf0:	00497478 00000000 00000000 00000000     xtI.............

0800dd00 <__func__.6435.lto_priv.136>:
 800dd00:	68546863 64644164 00666552 00000000     chThdAddRef.....

0800dd10 <__func__.5737.lto_priv.8>:
 800dd10:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800dd20 <__func__.6440.lto_priv.140>:
 800dd20:	68546863 6c655264 65736165 00000000     chThdRelease....

0800dd30 <__func__.6462.lto_priv.123>:
 800dd30:	68546863 65724364 46657461 4d6d6f72     chThdCreateFromM
 800dd40:	726f6d65 6f6f5079 0000006c 00000000     emoryPool.......

0800dd50 <ch_debug>:
 800dd50:	6e69616d 18431600 08600404 1814100c     main..C...`.....
 800dd60:	2221201c 00000000 00000000 00000000     . !"............

0800dd70 <__func__.5737.lto_priv.9>:
 800dd70:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800dd80 <__func__.6441.lto_priv.404>:
 800dd80:	65526863 78654e67 72685474 00646165     chRegNextThread.

0800dd90 <__func__.6436.lto_priv.403>:
 800dd90:	65536863 6a624f6d 49746365 0074696e     chSemObjectInit.

0800dda0 <__func__.5737.lto_priv.10>:
 800dda0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800ddb0 <__func__.6446.lto_priv.129>:
 800ddb0:	65536863 7365526d 00497465 00000000     chSemResetI.....

0800ddc0 <__func__.6457.lto_priv.125>:
 800ddc0:	65536863 6961576d 00005374 00000000     chSemWaitS......

0800ddd0 <__func__.6467.lto_priv.402>:
 800ddd0:	65536863 6961576d 6d695474 74756f65     chSemWaitTimeout
 800dde0:	00000053 00000000 00000000 00000000     S...............

0800ddf0 <__func__.6471.lto_priv.401>:
 800ddf0:	65536863 6769536d 006c616e 00000000     chSemSignal.....

0800de00 <__func__.6475.lto_priv.121>:
 800de00:	65536863 6769536d 496c616e 00000000     chSemSignalI....

0800de10 <__func__.6481.lto_priv.400>:
 800de10:	65536863 6464416d 6e756f43 49726574     chSemAddCounterI
	...

0800de30 <__func__.6490.lto_priv.399>:
 800de30:	65536863 6769536d 576c616e 00746961     chSemSignalWait.

0800de40 <__func__.6435.lto_priv.137>:
 800de40:	744d6863 6a624f78 49746365 0074696e     chMtxObjectInit.

0800de50 <__func__.5737.lto_priv.11>:
 800de50:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800de60 <__func__.6443.lto_priv.115>:
 800de60:	744d6863 636f4c78 0000536b 00000000     chMtxLockS......

0800de70 <__func__.6460.lto_priv.134>:
 800de70:	744d6863 79725478 6b636f4c 00000053     chMtxTryLockS...

0800de80 <__func__.6466.lto_priv.384>:
 800de80:	744d6863 6c6e5578 006b636f 00000000     chMtxUnlock.....

0800de90 <__func__.6477.lto_priv.131>:
 800de90:	744d6863 6c6e5578 536b636f 00000000     chMtxUnlockS....

0800dea0 <__func__.6435.lto_priv.138>:
 800dea0:	6f436863 624f646e 7463656a 74696e49     chCondObjectInit
	...

0800dec0 <__func__.6439.lto_priv.368>:
 800dec0:	6f436863 6953646e 6c616e67 00000000     chCondSignal....

0800ded0 <__func__.5737.lto_priv.12>:
 800ded0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800dee0 <__func__.6443.lto_priv.116>:
 800dee0:	6f436863 6953646e 6c616e67 00000049     chCondSignalI...

0800def0 <__func__.6451.lto_priv.112>:
 800def0:	6f436863 7242646e 6364616f 49747361     chCondBroadcastI
	...

0800df10 <__func__.6465.lto_priv.367>:
 800df10:	6f436863 6157646e 00537469 00000000     chCondWaitS.....

0800df20 <__func__.6477.lto_priv.132>:
 800df20:	6f436863 6157646e 69547469 756f656d     chCondWaitTimeou
 800df30:	00005374 00000000 00000000 00000000     tS..............

0800df40 <__func__.6438.lto_priv.366>:
 800df40:	76456863 67655274 65747369 73614d72     chEvtRegisterMas
 800df50:	7469576b 616c4668 00007367 00000000     kWithFlags......

0800df60 <__func__.5737.lto_priv.13>:
 800df60:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800df70 <__func__.6444.lto_priv.127>:
 800df70:	76456863 726e5574 73696765 00726574     chEvtUnregister.

0800df80 <__func__.6460.lto_priv.135>:
 800df80:	76456863 6f724274 61636461 6c467473     chEvtBroadcastFl
 800df90:	49736761 00000000 00000000 00000000     agsI............

0800dfa0 <__func__.6472.lto_priv.365>:
 800dfa0:	76456863 67695374 006c616e 00000000     chEvtSignal.....

0800dfb0 <__func__.6477.lto_priv.133>:
 800dfb0:	76456863 67695374 496c616e 00000000     chEvtSignalI....

0800dfc0 <__func__.6491.lto_priv.364>:
 800dfc0:	76456863 73694474 63746170 00000068     chEvtDispatch...

0800dfd0 <__func__.6437.lto_priv.118>:
 800dfd0:	734d6863 6e655367 00000064 00000000     chMsgSend.......

0800dfe0 <__func__.5737.lto_priv.14>:
 800dfe0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800dff0 <__func__.6446.lto_priv.130>:
 800dff0:	734d6863 6c655267 65736165 00000000     chMsgRelease....

0800e000 <__func__.6437.lto_priv.119>:
 800e000:	424d6863 656a624f 6e497463 00007469     chMBObjectInit..

0800e010 <__func__.5737.lto_priv.15>:
 800e010:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800e020 <__func__.6444.lto_priv.128>:
 800e020:	424d6863 65736552 00004974 00000000     chMBResetI......

0800e030 <__func__.6457.lto_priv.126>:
 800e030:	424d6863 74736f50 00000053 00000000     chMBPostS.......

0800e040 <__func__.6462.lto_priv.124>:
 800e040:	424d6863 74736f50 00000049 00000000     chMBPostI.......

0800e050 <__func__.6475.lto_priv.122>:
 800e050:	424d6863 74736f50 61656841 00005364     chMBPostAheadS..

0800e060 <__func__.6480.lto_priv.353>:
 800e060:	424d6863 74736f50 61656841 00004964     chMBPostAheadI..

0800e070 <__func__.6493.lto_priv.352>:
 800e070:	424d6863 63746546 00005368 00000000     chMBFetchS......

0800e080 <__func__.6498.lto_priv.351>:
 800e080:	424d6863 63746546 00004968 00000000     chMBFetchI......

0800e090 <__func__.5737.lto_priv.16>:
 800e090:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800e0a0 <__func__.6463.lto_priv.340>:
 800e0a0:	51496863 64616552 656d6954 0074756f     chIQReadTimeout.

0800e0b0 <__func__.6499.lto_priv.337>:
 800e0b0:	514f6863 74697257 6d695465 74756f65     chOQWriteTimeout
	...

0800e0d0 <__func__.5737.lto_priv.17>:
 800e0d0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800e0e0 <__func__.6442.lto_priv.334>:
 800e0e0:	65486863 624f7061 7463656a 74696e49     chHeapObjectInit
	...

0800e100 <__func__.6459.lto_priv.333>:
 800e100:	65486863 72467061 00006565 00000000     chHeapFree......

0800e110 <__func__.6437.lto_priv.120>:
 800e110:	6f506863 624f6c6f 7463656a 74696e49     chPoolObjectInit
	...

0800e130 <__func__.6443.lto_priv.117>:
 800e130:	6f506863 6f4c6c6f 72416461 00796172     chPoolLoadArray.

0800e140 <__func__.6451.lto_priv.113>:
 800e140:	6f506863 6c416c6f 49636f6c 00000000     chPoolAllocI....

0800e150 <__func__.5737.lto_priv.18>:
 800e150:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800e160 <__func__.6461.lto_priv.331>:
 800e160:	6f506863 72466c6f 00496565 00000000     chPoolFreeI.....

0800e170 <__func__.7037.lto_priv.330>:
 800e170:	74537473 41747261 6d72616c 00000000     stStartAlarm....

0800e180 <__func__.7044.lto_priv.109>:
 800e180:	65537473 616c4174 00006d72 00000000     stSetAlarm......

0800e190 <__func__.7041.lto_priv.303>:
 800e190:	53633269 74726174 00000000 00000000     i2cStart........

0800e1a0 <__func__.5737.lto_priv.19>:
 800e1a0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800e1b0 <__func__.7060.lto_priv.300>:
 800e1b0:	4d633269 65747361 61725472 696d736e     i2cMasterTransmi
 800e1c0:	6d695474 74756f65 00000000 00000000     tTimeout........

0800e1d0 <__func__.7073.lto_priv.298>:
 800e1d0:	41633269 69757163 75426572 00000073     i2cAcquireBus...

0800e1e0 <__func__.7077.lto_priv.297>:
 800e1e0:	52633269 61656c65 75426573 00000073     i2cReleaseBus...

0800e1f0 <vmt.lto_priv.0>:
 800e1f0:	080079c1 080079f1 08007a21 08007a51     .y...y..!z..Qz..
 800e200:	08007a71 08007aa1 08007ac1 08007af1     qz...z...z...z..

0800e210 <__func__.7082.lto_priv.284>:
 800e210:	74536473 00747261 00000000 00000000     sdStart.........

0800e220 <__func__.5737.lto_priv.20>:
 800e220:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800e230 <__func__.7091.lto_priv.282>:
 800e230:	6e496473 696d6f63 6144676e 00496174     sdIncomingDataI.

0800e240 <_stm32_dma_streams>:
 800e240:	40026010 40026008 000b0000 40026028     .`.@.`.@....(`.@
 800e250:	40026008 000c0106 40026040 40026008     .`.@....@`.@.`.@
 800e260:	000d0210 40026058 40026008 000e0316     ....X`.@.`.@....
 800e270:	40026070 4002600c 000f0400 40026088     p`.@.`.@.....`.@
 800e280:	4002600c 00100506 400260a0 4002600c     .`.@.....`.@.`.@
 800e290:	00110610 400260b8 4002600c 002f0716     .....`.@.`.@../.
 800e2a0:	40026410 40026408 00380800 40026428     .d.@.d.@..8.(d.@
 800e2b0:	40026408 00390906 40026440 40026408     .d.@..9.@d.@.d.@
 800e2c0:	003a0a10 40026458 40026408 003b0b16     ..:.Xd.@.d.@..;.
 800e2d0:	40026470 4002640c 003c0c00 40026488     pd.@.d.@..<..d.@
 800e2e0:	4002640c 00440d06 400264a0 4002640c     .d.@..D..d.@.d.@
 800e2f0:	00450e10 400264b8 4002640c 00460f16     ..E..d.@.d.@..F.

0800e300 <__func__.7115.lto_priv.278>:
 800e300:	53616d64 61657274 6c6c416d 7461636f     dmaStreamAllocat
 800e310:	00000065 00000000 00000000 00000000     e...............

0800e320 <__func__.7052.lto_priv.265>:
 800e320:	5f633269 5f646c6c 5f746573 636f6c63     i2c_lld_set_cloc
 800e330:	0000006b 00000000 00000000 00000000     k...............

0800e340 <__func__.7131.lto_priv.264>:
 800e340:	5f633269 5f646c6c 72617473 00000074     i2c_lld_start...

0800e350 <__func__.5737.lto_priv.21>:
 800e350:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800e360 <default_config.lto_priv.240>:
 800e360:	00009600 40000000 00000000 00000000     .......@........

0800e370 <pal_default_config>:
 800e370:	2a8004a0 00000000 fffffbaf 64155105     ...*.........Q.d
 800e380:	0000ffdf 00007700 000aa000 00000080     .....w..........
 800e390:	00000000 ffffffff 55555555 0000ffff     ........UUUU....
	...
 800e3b0:	ffffffff 51555555 0000ffff 00000000     ....UUUQ........
	...
 800e3cc:	ffffffff 55555555 0000ffff 00000000     ....UUUU........
	...
 800e3e8:	ffffffff 55555555 0000ffff 00000000     ....UUUU........
	...
 800e404:	ffffffff 55555550 0000ffff 00000000     ....PUUU........
	...

0800e420 <wa>:
 800e420:	200014f0 20001658 200017c0 20001928     ... X.. ... (.. 
 800e430:	20001a90 00000000 00000000 00000000     ... ............

0800e440 <__func__.5737.lto_priv.22>:
 800e440:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800e450 <testthd1>:
 800e450:	0800d220 00000000 00000000 08005cb1      ............\..

0800e460 <testthd2>:
 800e460:	0800d23c 00000000 00000000 08005da1     <............]..

0800e470 <testthd3>:
 800e470:	0800d258 00000000 00000000 08005ea1     X............^..

0800e480 <testthd4>:
 800e480:	0800d274 00000000 00000000 08006081     t............`..

0800e490 <patternthd>:
 800e490:	0800e450 0800e460 0800e470 0800e480     P...`...p.......
	...

0800e4b0 <__func__.5737.lto_priv.23>:
 800e4b0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800e4c0 <testsem1>:
 800e4c0:	0800d284 08006331 00000000 08003f61     ....1c......a?..

0800e4d0 <testsem2>:
 800e4d0:	0800d29c 080040e1 00000000 08004121     .....@......!A..

0800e4e0 <testsem3>:
 800e4e0:	0800d2b0 080042c1 00000000 080042f1     .....B.......B..

0800e4f0 <testsem4>:
 800e4f0:	0800d2d0 00000000 00000000 080043c1     .............C..

0800e500 <patternsem>:
 800e500:	0800e4c0 0800e4d0 0800e4e0 0800e4f0     ................
	...

0800e520 <__func__.5737.lto_priv.24>:
 800e520:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800e530 <testmtx1>:
 800e530:	0800d2f4 08004611 00000000 08004651     .....F......QF..

0800e540 <testmtx4>:
 800e540:	0800d318 08004761 00000000 080047e1     ....aG.......G..

0800e550 <testmtx5>:
 800e550:	0800d334 08004ae1 00000000 08004af1     4....J.......J..

0800e560 <testmtx6>:
 800e560:	0800d344 08004bf1 00000000 08004c41     D....K......AL..

0800e570 <testmtx7>:
 800e570:	0800d35c 08004d51 00000000 08004d71     \...QM......qM..

0800e580 <testmtx8>:
 800e580:	0800d374 08004e51 00000000 08004f01     t...QN.......O..

0800e590 <patternmtx>:
 800e590:	0800e530 0800e540 0800e550 0800e560     0...@...P...`...
 800e5a0:	0800e570 0800e580 00000000 00000000     p...............

0800e5b0 <__func__.5737.lto_priv.25>:
 800e5b0:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800e5c0 <testmsg1>:
 800e5c0:	0800d388 00000000 00000000 08005011     .............P..

0800e5d0 <patternmsg>:
 800e5d0:	0800e5c0 00000000 00000000 00000000     ................

0800e5e0 <testmbox1>:
 800e5e0:	0800d398 080030e1 00000000 08003101     .....0.......1..

0800e5f0 <patternmbox>:
 800e5f0:	0800e5e0 00000000 00000000 00000000     ................

0800e600 <__func__.5737.lto_priv.26>:
 800e600:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800e610 <evhndl.lto_priv.174>:
 800e610:	08003a81 08003aa1 08003ac1 00000000     .:...:...:......

0800e620 <testevt1>:
 800e620:	0800d3b8 08003a71 00000000 08003ae1     ....q:.......:..

0800e630 <testevt2>:
 800e630:	0800d3dc 08003ba1 00000000 08003c01     .....;.......<..

0800e640 <testevt3>:
 800e640:	0800d3f8 08002121 00000000 08002131     ....!!......1!..

0800e650 <patternevt>:
 800e650:	0800e620 0800e630 0800e640 00000000      ...0...@.......

0800e660 <__func__.5737.lto_priv.27>:
 800e660:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800e670 <testheap1>:
 800e670:	0800d40c 08002221 00000000 08002241     ....!"......A"..

0800e680 <patternheap>:
 800e680:	0800e670 00000000 00000000 00000000     p...............

0800e690 <testpools1>:
 800e690:	0800d434 08002531 00000000 08002551     4...1%......Q%..

0800e6a0 <patternpools>:
 800e6a0:	0800e690 00000000 00000000 00000000     ................

0800e6b0 <testdyn1>:
 800e6b0:	0800d450 080026a1 00000000 080026c1     P....&.......&..

0800e6c0 <testdyn2>:
 800e6c0:	0800d47c 08002801 00000000 08002821     |....(......!(..

0800e6d0 <testdyn3>:
 800e6d0:	0800d4ac 080029e1 00000000 08002a01     .....).......*..

0800e6e0 <patterndyn>:
 800e6e0:	0800e6b0 0800e6c0 0800e6d0 00000000     ................

0800e6f0 <testqueues1>:
 800e6f0:	0800d4d4 08002da1 00000000 08002df1     .....-.......-..

0800e700 <testqueues2>:
 800e700:	0800d4ec 08000f01 00000000 08000f51     ............Q...

0800e710 <patternqueues>:
 800e710:	0800e6f0 0800e700 00000000 00000000     ................

0800e720 <__func__.5737.lto_priv.28>:
 800e720:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800e730 <testsys1>:
 800e730:	0800d504 00000000 00000000 080014b1     ................

0800e740 <testsys2>:
 800e740:	0800d51c 00000000 00000000 08001541     ............A...

0800e750 <testsys3>:
 800e750:	0800d538 00000000 00000000 08001561     8...........a...

0800e760 <patternsys>:
 800e760:	0800e730 0800e740 0800e750 00000000     0...@...P.......

0800e770 <__func__.5737.lto_priv.29>:
 800e770:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800e780 <testbmk1>:
 800e780:	0800d54c 00000000 00000000 080017e1     L...............

0800e790 <testbmk2>:
 800e790:	0800d564 00000000 00000000 08001861     d...........a...

0800e7a0 <testbmk3>:
 800e7a0:	0800d57c 00000000 00000000 080018e1     |...............

0800e7b0 <testbmk4>:
 800e7b0:	0800d594 00000000 00000000 08001a11     ................

0800e7c0 <testbmk5>:
 800e7c0:	0800d5b0 00000000 00000000 08001ad1     ................

0800e7d0 <testbmk6>:
 800e7d0:	0800d5d0 00000000 00000000 08001b51     ............Q...

0800e7e0 <testbmk7>:
 800e7e0:	0800d5f0 08001c01 00000000 08001c11     ................

0800e7f0 <testbmk8>:
 800e7f0:	0800d618 00000000 00000000 08001d91     ................

0800e800 <testbmk9>:
 800e800:	0800d644 00000000 00000000 08001e91     D...............

0800e810 <testbmk10>:
 800e810:	0800d668 00000000 00000000 08001f51     h...........Q...

0800e820 <testbmk11>:
 800e820:	0800d68c 08001fe1 00000000 08001ff1     ................

0800e830 <testbmk12>:
 800e830:	0800d6b0 08002081 00000000 08002091     ..... ....... ..

0800e840 <testbmk13>:
 800e840:	0800d778 00000000 00000000 080002d1     x...............

0800e850 <patternbmk>:
 800e850:	0800e780 0800e790 0800e7a0 0800e7b0     ................
 800e860:	0800e7c0 0800e7d0 0800e7e0 0800e7f0     ................
 800e870:	0800e800 0800e810 0800e820 0800e830     ........ ...0...
 800e880:	0800e840 00000000 00000000 00000000     @...............

0800e890 <__func__.5737.lto_priv.30>:
 800e890:	79536863 6c6e5573 006b636f 00000000     chSysUnlock.....

0800e8a0 <PCA9685_I2C_CONFIG>:
 800e8a0:	00000001 00061a80 00000002 00000000     ................

0800e8b0 <_ctype_>:
 800e8b0:	20202000 20202020 28282020 20282828     .         ((((( 
 800e8c0:	20202020 20202020 20202020 20202020                     
 800e8d0:	10108820 10101010 10101010 10101010      ...............
 800e8e0:	04040410 04040404 10040404 10101010     ................
 800e8f0:	41411010 41414141 01010101 01010101     ..AAAAAA........
 800e900:	01010101 01010101 01010101 10101010     ................
 800e910:	42421010 42424242 02020202 02020202     ..BBBBBB........
 800e920:	02020202 02020202 02020202 10101010     ................
 800e930:	00000020 00000000 00000000 00000000      ...............
	...
 800e9c0:	00000043                                C...
